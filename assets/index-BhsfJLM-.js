(function () {
  const e = document.createElement("link").relList;
  if (e && e.supports && e.supports("modulepreload")) return;
  for (const r of document.querySelectorAll('link[rel="modulepreload"]')) n(r);
  new MutationObserver((r) => {
    for (const s of r)
      if (s.type === "childList")
        for (const o of s.addedNodes)
          o.tagName === "LINK" && o.rel === "modulepreload" && n(o);
  }).observe(document, { childList: !0, subtree: !0 });
  function t(r) {
    const s = {};
    return (
      r.integrity && (s.integrity = r.integrity),
      r.referrerPolicy && (s.referrerPolicy = r.referrerPolicy),
      r.crossOrigin === "use-credentials"
        ? (s.credentials = "include")
        : r.crossOrigin === "anonymous"
          ? (s.credentials = "omit")
          : (s.credentials = "same-origin"),
      s
    );
  }
  function n(r) {
    if (r.ep) return;
    r.ep = !0;
    const s = t(r);
    fetch(r.href, s);
  }
})();
function qM(i) {
  return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default")
    ? i.default
    : i;
}
var p_ = { exports: {} },
  ug = {};
/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var uw;
function MP() {
  if (uw) return ug;
  uw = 1;
  var i = Symbol.for("react.transitional.element"),
    e = Symbol.for("react.fragment");
  function t(n, r, s) {
    var o = null;
    if (
      (s !== void 0 && (o = "" + s),
      r.key !== void 0 && (o = "" + r.key),
      "key" in r)
    ) {
      s = {};
      for (var u in r) u !== "key" && (s[u] = r[u]);
    } else s = r;
    return (
      (r = s.ref),
      { $$typeof: i, type: n, key: o, ref: r !== void 0 ? r : null, props: s }
    );
  }
  return ((ug.Fragment = e), (ug.jsx = t), (ug.jsxs = t), ug);
}
var fw;
function TP() {
  return (fw || ((fw = 1), (p_.exports = MP())), p_.exports);
}
var P = TP(),
  m_ = { exports: {} },
  en = {};
/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var hw;
function EP() {
  if (hw) return en;
  hw = 1;
  var i = Symbol.for("react.transitional.element"),
    e = Symbol.for("react.portal"),
    t = Symbol.for("react.fragment"),
    n = Symbol.for("react.strict_mode"),
    r = Symbol.for("react.profiler"),
    s = Symbol.for("react.consumer"),
    o = Symbol.for("react.context"),
    u = Symbol.for("react.forward_ref"),
    h = Symbol.for("react.suspense"),
    d = Symbol.for("react.memo"),
    m = Symbol.for("react.lazy"),
    v = Symbol.for("react.activity"),
    y = Symbol.iterator;
  function b(V) {
    return V === null || typeof V != "object"
      ? null
      : ((V = (y && V[y]) || V["@@iterator"]),
        typeof V == "function" ? V : null);
  }
  var _ = {
      isMounted: function () {
        return !1;
      },
      enqueueForceUpdate: function () {},
      enqueueReplaceState: function () {},
      enqueueSetState: function () {},
    },
    w = Object.assign,
    E = {};
  function T(V, Z, se) {
    ((this.props = V),
      (this.context = Z),
      (this.refs = E),
      (this.updater = se || _));
  }
  ((T.prototype.isReactComponent = {}),
    (T.prototype.setState = function (V, Z) {
      if (typeof V != "object" && typeof V != "function" && V != null)
        throw Error(
          "takes an object of state variables to update or a function which returns an object of state variables.",
        );
      this.updater.enqueueSetState(this, V, Z, "setState");
    }),
    (T.prototype.forceUpdate = function (V) {
      this.updater.enqueueForceUpdate(this, V, "forceUpdate");
    }));
  function C() {}
  C.prototype = T.prototype;
  function R(V, Z, se) {
    ((this.props = V),
      (this.context = Z),
      (this.refs = E),
      (this.updater = se || _));
  }
  var L = (R.prototype = new C());
  ((L.constructor = R), w(L, T.prototype), (L.isPureReactComponent = !0));
  var I = Array.isArray;
  function O() {}
  var B = { H: null, A: null, T: null, S: null },
    N = Object.prototype.hasOwnProperty;
  function F(V, Z, se) {
    var ue = se.ref;
    return {
      $$typeof: i,
      type: V,
      key: Z,
      ref: ue !== void 0 ? ue : null,
      props: se,
    };
  }
  function j(V, Z) {
    return F(V.type, Z, V.props);
  }
  function q(V) {
    return typeof V == "object" && V !== null && V.$$typeof === i;
  }
  function X(V) {
    var Z = { "=": "=0", ":": "=2" };
    return (
      "$" +
      V.replace(/[=:]/g, function (se) {
        return Z[se];
      })
    );
  }
  var J = /\/+/g;
  function ee(V, Z) {
    return typeof V == "object" && V !== null && V.key != null
      ? X("" + V.key)
      : Z.toString(36);
  }
  function ne(V) {
    switch (V.status) {
      case "fulfilled":
        return V.value;
      case "rejected":
        throw V.reason;
      default:
        switch (
          (typeof V.status == "string"
            ? V.then(O, O)
            : ((V.status = "pending"),
              V.then(
                function (Z) {
                  V.status === "pending" &&
                    ((V.status = "fulfilled"), (V.value = Z));
                },
                function (Z) {
                  V.status === "pending" &&
                    ((V.status = "rejected"), (V.reason = Z));
                },
              )),
          V.status)
        ) {
          case "fulfilled":
            return V.value;
          case "rejected":
            throw V.reason;
        }
    }
    throw V;
  }
  function W(V, Z, se, ue, ge) {
    var ae = typeof V;
    (ae === "undefined" || ae === "boolean") && (V = null);
    var he = !1;
    if (V === null) he = !0;
    else
      switch (ae) {
        case "bigint":
        case "string":
        case "number":
          he = !0;
          break;
        case "object":
          switch (V.$$typeof) {
            case i:
            case e:
              he = !0;
              break;
            case m:
              return ((he = V._init), W(he(V._payload), Z, se, ue, ge));
          }
      }
    if (he)
      return (
        (ge = ge(V)),
        (he = ue === "" ? "." + ee(V, 0) : ue),
        I(ge)
          ? ((se = ""),
            he != null && (se = he.replace(J, "$&/") + "/"),
            W(ge, Z, se, "", function (it) {
              return it;
            }))
          : ge != null &&
            (q(ge) &&
              (ge = j(
                ge,
                se +
                  (ge.key == null || (V && V.key === ge.key)
                    ? ""
                    : ("" + ge.key).replace(J, "$&/") + "/") +
                  he,
              )),
            Z.push(ge)),
        1
      );
    he = 0;
    var ye = ue === "" ? "." : ue + ":";
    if (I(V))
      for (var ze = 0; ze < V.length; ze++)
        ((ue = V[ze]), (ae = ye + ee(ue, ze)), (he += W(ue, Z, se, ae, ge)));
    else if (((ze = b(V)), typeof ze == "function"))
      for (V = ze.call(V), ze = 0; !(ue = V.next()).done; )
        ((ue = ue.value),
          (ae = ye + ee(ue, ze++)),
          (he += W(ue, Z, se, ae, ge)));
    else if (ae === "object") {
      if (typeof V.then == "function") return W(ne(V), Z, se, ue, ge);
      throw (
        (Z = String(V)),
        Error(
          "Objects are not valid as a React child (found: " +
            (Z === "[object Object]"
              ? "object with keys {" + Object.keys(V).join(", ") + "}"
              : Z) +
            "). If you meant to render a collection of children, use an array instead.",
        )
      );
    }
    return he;
  }
  function $(V, Z, se) {
    if (V == null) return V;
    var ue = [],
      ge = 0;
    return (
      W(V, ue, "", "", function (ae) {
        return Z.call(se, ae, ge++);
      }),
      ue
    );
  }
  function de(V) {
    if (V._status === -1) {
      var Z = V._result;
      ((Z = Z()),
        Z.then(
          function (se) {
            (V._status === 0 || V._status === -1) &&
              ((V._status = 1), (V._result = se));
          },
          function (se) {
            (V._status === 0 || V._status === -1) &&
              ((V._status = 2), (V._result = se));
          },
        ),
        V._status === -1 && ((V._status = 0), (V._result = Z)));
    }
    if (V._status === 1) return V._result.default;
    throw V._result;
  }
  var le =
      typeof reportError == "function"
        ? reportError
        : function (V) {
            if (
              typeof window == "object" &&
              typeof window.ErrorEvent == "function"
            ) {
              var Z = new window.ErrorEvent("error", {
                bubbles: !0,
                cancelable: !0,
                message:
                  typeof V == "object" &&
                  V !== null &&
                  typeof V.message == "string"
                    ? String(V.message)
                    : String(V),
                error: V,
              });
              if (!window.dispatchEvent(Z)) return;
            } else if (
              typeof process == "object" &&
              typeof process.emit == "function"
            ) {
              process.emit("uncaughtException", V);
              return;
            }
            console.error(V);
          },
    fe = {
      map: $,
      forEach: function (V, Z, se) {
        $(
          V,
          function () {
            Z.apply(this, arguments);
          },
          se,
        );
      },
      count: function (V) {
        var Z = 0;
        return (
          $(V, function () {
            Z++;
          }),
          Z
        );
      },
      toArray: function (V) {
        return (
          $(V, function (Z) {
            return Z;
          }) || []
        );
      },
      only: function (V) {
        if (!q(V))
          throw Error(
            "React.Children.only expected to receive a single React element child.",
          );
        return V;
      },
    };
  return (
    (en.Activity = v),
    (en.Children = fe),
    (en.Component = T),
    (en.Fragment = t),
    (en.Profiler = r),
    (en.PureComponent = R),
    (en.StrictMode = n),
    (en.Suspense = h),
    (en.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = B),
    (en.__COMPILER_RUNTIME = {
      __proto__: null,
      c: function (V) {
        return B.H.useMemoCache(V);
      },
    }),
    (en.cache = function (V) {
      return function () {
        return V.apply(null, arguments);
      };
    }),
    (en.cacheSignal = function () {
      return null;
    }),
    (en.cloneElement = function (V, Z, se) {
      if (V == null)
        throw Error(
          "The argument must be a React element, but you passed " + V + ".",
        );
      var ue = w({}, V.props),
        ge = V.key;
      if (Z != null)
        for (ae in (Z.key !== void 0 && (ge = "" + Z.key), Z))
          !N.call(Z, ae) ||
            ae === "key" ||
            ae === "__self" ||
            ae === "__source" ||
            (ae === "ref" && Z.ref === void 0) ||
            (ue[ae] = Z[ae]);
      var ae = arguments.length - 2;
      if (ae === 1) ue.children = se;
      else if (1 < ae) {
        for (var he = Array(ae), ye = 0; ye < ae; ye++)
          he[ye] = arguments[ye + 2];
        ue.children = he;
      }
      return F(V.type, ge, ue);
    }),
    (en.createContext = function (V) {
      return (
        (V = {
          $$typeof: o,
          _currentValue: V,
          _currentValue2: V,
          _threadCount: 0,
          Provider: null,
          Consumer: null,
        }),
        (V.Provider = V),
        (V.Consumer = { $$typeof: s, _context: V }),
        V
      );
    }),
    (en.createElement = function (V, Z, se) {
      var ue,
        ge = {},
        ae = null;
      if (Z != null)
        for (ue in (Z.key !== void 0 && (ae = "" + Z.key), Z))
          N.call(Z, ue) &&
            ue !== "key" &&
            ue !== "__self" &&
            ue !== "__source" &&
            (ge[ue] = Z[ue]);
      var he = arguments.length - 2;
      if (he === 1) ge.children = se;
      else if (1 < he) {
        for (var ye = Array(he), ze = 0; ze < he; ze++)
          ye[ze] = arguments[ze + 2];
        ge.children = ye;
      }
      if (V && V.defaultProps)
        for (ue in ((he = V.defaultProps), he))
          ge[ue] === void 0 && (ge[ue] = he[ue]);
      return F(V, ae, ge);
    }),
    (en.createRef = function () {
      return { current: null };
    }),
    (en.forwardRef = function (V) {
      return { $$typeof: u, render: V };
    }),
    (en.isValidElement = q),
    (en.lazy = function (V) {
      return { $$typeof: m, _payload: { _status: -1, _result: V }, _init: de };
    }),
    (en.memo = function (V, Z) {
      return { $$typeof: d, type: V, compare: Z === void 0 ? null : Z };
    }),
    (en.startTransition = function (V) {
      var Z = B.T,
        se = {};
      B.T = se;
      try {
        var ue = V(),
          ge = B.S;
        (ge !== null && ge(se, ue),
          typeof ue == "object" &&
            ue !== null &&
            typeof ue.then == "function" &&
            ue.then(O, le));
      } catch (ae) {
        le(ae);
      } finally {
        (Z !== null && se.types !== null && (Z.types = se.types), (B.T = Z));
      }
    }),
    (en.unstable_useCacheRefresh = function () {
      return B.H.useCacheRefresh();
    }),
    (en.use = function (V) {
      return B.H.use(V);
    }),
    (en.useActionState = function (V, Z, se) {
      return B.H.useActionState(V, Z, se);
    }),
    (en.useCallback = function (V, Z) {
      return B.H.useCallback(V, Z);
    }),
    (en.useContext = function (V) {
      return B.H.useContext(V);
    }),
    (en.useDebugValue = function () {}),
    (en.useDeferredValue = function (V, Z) {
      return B.H.useDeferredValue(V, Z);
    }),
    (en.useEffect = function (V, Z) {
      return B.H.useEffect(V, Z);
    }),
    (en.useEffectEvent = function (V) {
      return B.H.useEffectEvent(V);
    }),
    (en.useId = function () {
      return B.H.useId();
    }),
    (en.useImperativeHandle = function (V, Z, se) {
      return B.H.useImperativeHandle(V, Z, se);
    }),
    (en.useInsertionEffect = function (V, Z) {
      return B.H.useInsertionEffect(V, Z);
    }),
    (en.useLayoutEffect = function (V, Z) {
      return B.H.useLayoutEffect(V, Z);
    }),
    (en.useMemo = function (V, Z) {
      return B.H.useMemo(V, Z);
    }),
    (en.useOptimistic = function (V, Z) {
      return B.H.useOptimistic(V, Z);
    }),
    (en.useReducer = function (V, Z, se) {
      return B.H.useReducer(V, Z, se);
    }),
    (en.useRef = function (V) {
      return B.H.useRef(V);
    }),
    (en.useState = function (V) {
      return B.H.useState(V);
    }),
    (en.useSyncExternalStore = function (V, Z, se) {
      return B.H.useSyncExternalStore(V, Z, se);
    }),
    (en.useTransition = function () {
      return B.H.useTransition();
    }),
    (en.version = "19.2.4"),
    en
  );
}
var dw;
function S0() {
  return (dw || ((dw = 1), (m_.exports = EP())), m_.exports);
}
var ie = S0();
const M0 = qM(ie);
var g_ = { exports: {} },
  fg = {},
  v_ = { exports: {} },
  y_ = {};
/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var pw;
function wP() {
  return (
    pw ||
      ((pw = 1),
      (function (i) {
        function e(W, $) {
          var de = W.length;
          W.push($);
          e: for (; 0 < de; ) {
            var le = (de - 1) >>> 1,
              fe = W[le];
            if (0 < r(fe, $)) ((W[le] = $), (W[de] = fe), (de = le));
            else break e;
          }
        }
        function t(W) {
          return W.length === 0 ? null : W[0];
        }
        function n(W) {
          if (W.length === 0) return null;
          var $ = W[0],
            de = W.pop();
          if (de !== $) {
            W[0] = de;
            e: for (var le = 0, fe = W.length, V = fe >>> 1; le < V; ) {
              var Z = 2 * (le + 1) - 1,
                se = W[Z],
                ue = Z + 1,
                ge = W[ue];
              if (0 > r(se, de))
                ue < fe && 0 > r(ge, se)
                  ? ((W[le] = ge), (W[ue] = de), (le = ue))
                  : ((W[le] = se), (W[Z] = de), (le = Z));
              else if (ue < fe && 0 > r(ge, de))
                ((W[le] = ge), (W[ue] = de), (le = ue));
              else break e;
            }
          }
          return $;
        }
        function r(W, $) {
          var de = W.sortIndex - $.sortIndex;
          return de !== 0 ? de : W.id - $.id;
        }
        if (
          ((i.unstable_now = void 0),
          typeof performance == "object" &&
            typeof performance.now == "function")
        ) {
          var s = performance;
          i.unstable_now = function () {
            return s.now();
          };
        } else {
          var o = Date,
            u = o.now();
          i.unstable_now = function () {
            return o.now() - u;
          };
        }
        var h = [],
          d = [],
          m = 1,
          v = null,
          y = 3,
          b = !1,
          _ = !1,
          w = !1,
          E = !1,
          T = typeof setTimeout == "function" ? setTimeout : null,
          C = typeof clearTimeout == "function" ? clearTimeout : null,
          R = typeof setImmediate < "u" ? setImmediate : null;
        function L(W) {
          for (var $ = t(d); $ !== null; ) {
            if ($.callback === null) n(d);
            else if ($.startTime <= W)
              (n(d), ($.sortIndex = $.expirationTime), e(h, $));
            else break;
            $ = t(d);
          }
        }
        function I(W) {
          if (((w = !1), L(W), !_))
            if (t(h) !== null) ((_ = !0), O || ((O = !0), X()));
            else {
              var $ = t(d);
              $ !== null && ne(I, $.startTime - W);
            }
        }
        var O = !1,
          B = -1,
          N = 5,
          F = -1;
        function j() {
          return E ? !0 : !(i.unstable_now() - F < N);
        }
        function q() {
          if (((E = !1), O)) {
            var W = i.unstable_now();
            F = W;
            var $ = !0;
            try {
              e: {
                ((_ = !1), w && ((w = !1), C(B), (B = -1)), (b = !0));
                var de = y;
                try {
                  t: {
                    for (
                      L(W), v = t(h);
                      v !== null && !(v.expirationTime > W && j());
                    ) {
                      var le = v.callback;
                      if (typeof le == "function") {
                        ((v.callback = null), (y = v.priorityLevel));
                        var fe = le(v.expirationTime <= W);
                        if (((W = i.unstable_now()), typeof fe == "function")) {
                          ((v.callback = fe), L(W), ($ = !0));
                          break t;
                        }
                        (v === t(h) && n(h), L(W));
                      } else n(h);
                      v = t(h);
                    }
                    if (v !== null) $ = !0;
                    else {
                      var V = t(d);
                      (V !== null && ne(I, V.startTime - W), ($ = !1));
                    }
                  }
                  break e;
                } finally {
                  ((v = null), (y = de), (b = !1));
                }
                $ = void 0;
              }
            } finally {
              $ ? X() : (O = !1);
            }
          }
        }
        var X;
        if (typeof R == "function")
          X = function () {
            R(q);
          };
        else if (typeof MessageChannel < "u") {
          var J = new MessageChannel(),
            ee = J.port2;
          ((J.port1.onmessage = q),
            (X = function () {
              ee.postMessage(null);
            }));
        } else
          X = function () {
            T(q, 0);
          };
        function ne(W, $) {
          B = T(function () {
            W(i.unstable_now());
          }, $);
        }
        ((i.unstable_IdlePriority = 5),
          (i.unstable_ImmediatePriority = 1),
          (i.unstable_LowPriority = 4),
          (i.unstable_NormalPriority = 3),
          (i.unstable_Profiling = null),
          (i.unstable_UserBlockingPriority = 2),
          (i.unstable_cancelCallback = function (W) {
            W.callback = null;
          }),
          (i.unstable_forceFrameRate = function (W) {
            0 > W || 125 < W
              ? console.error(
                  "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported",
                )
              : (N = 0 < W ? Math.floor(1e3 / W) : 5);
          }),
          (i.unstable_getCurrentPriorityLevel = function () {
            return y;
          }),
          (i.unstable_next = function (W) {
            switch (y) {
              case 1:
              case 2:
              case 3:
                var $ = 3;
                break;
              default:
                $ = y;
            }
            var de = y;
            y = $;
            try {
              return W();
            } finally {
              y = de;
            }
          }),
          (i.unstable_requestPaint = function () {
            E = !0;
          }),
          (i.unstable_runWithPriority = function (W, $) {
            switch (W) {
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
                break;
              default:
                W = 3;
            }
            var de = y;
            y = W;
            try {
              return $();
            } finally {
              y = de;
            }
          }),
          (i.unstable_scheduleCallback = function (W, $, de) {
            var le = i.unstable_now();
            switch (
              (typeof de == "object" && de !== null
                ? ((de = de.delay),
                  (de = typeof de == "number" && 0 < de ? le + de : le))
                : (de = le),
              W)
            ) {
              case 1:
                var fe = -1;
                break;
              case 2:
                fe = 250;
                break;
              case 5:
                fe = 1073741823;
                break;
              case 4:
                fe = 1e4;
                break;
              default:
                fe = 5e3;
            }
            return (
              (fe = de + fe),
              (W = {
                id: m++,
                callback: $,
                priorityLevel: W,
                startTime: de,
                expirationTime: fe,
                sortIndex: -1,
              }),
              de > le
                ? ((W.sortIndex = de),
                  e(d, W),
                  t(h) === null &&
                    W === t(d) &&
                    (w ? (C(B), (B = -1)) : (w = !0), ne(I, de - le)))
                : ((W.sortIndex = fe),
                  e(h, W),
                  _ || b || ((_ = !0), O || ((O = !0), X()))),
              W
            );
          }),
          (i.unstable_shouldYield = j),
          (i.unstable_wrapCallback = function (W) {
            var $ = y;
            return function () {
              var de = y;
              y = $;
              try {
                return W.apply(this, arguments);
              } finally {
                y = de;
              }
            };
          }));
      })(y_)),
    y_
  );
}
var mw;
function nR() {
  return (mw || ((mw = 1), (v_.exports = wP())), v_.exports);
}
var x_ = { exports: {} },
  ds = {};
/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var gw;
function AP() {
  if (gw) return ds;
  gw = 1;
  var i = S0();
  function e(h) {
    var d = "https://react.dev/errors/" + h;
    if (1 < arguments.length) {
      d += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var m = 2; m < arguments.length; m++)
        d += "&args[]=" + encodeURIComponent(arguments[m]);
    }
    return (
      "Minified React error #" +
      h +
      "; visit " +
      d +
      " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    );
  }
  function t() {}
  var n = {
      d: {
        f: t,
        r: function () {
          throw Error(e(522));
        },
        D: t,
        C: t,
        L: t,
        m: t,
        X: t,
        S: t,
        M: t,
      },
      p: 0,
      findDOMNode: null,
    },
    r = Symbol.for("react.portal");
  function s(h, d, m) {
    var v =
      3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
      $$typeof: r,
      key: v == null ? null : "" + v,
      children: h,
      containerInfo: d,
      implementation: m,
    };
  }
  var o = i.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
  function u(h, d) {
    if (h === "font") return "";
    if (typeof d == "string") return d === "use-credentials" ? d : "";
  }
  return (
    (ds.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = n),
    (ds.createPortal = function (h, d) {
      var m =
        2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
      if (!d || (d.nodeType !== 1 && d.nodeType !== 9 && d.nodeType !== 11))
        throw Error(e(299));
      return s(h, d, null, m);
    }),
    (ds.flushSync = function (h) {
      var d = o.T,
        m = n.p;
      try {
        if (((o.T = null), (n.p = 2), h)) return h();
      } finally {
        ((o.T = d), (n.p = m), n.d.f());
      }
    }),
    (ds.preconnect = function (h, d) {
      typeof h == "string" &&
        (d
          ? ((d = d.crossOrigin),
            (d =
              typeof d == "string"
                ? d === "use-credentials"
                  ? d
                  : ""
                : void 0))
          : (d = null),
        n.d.C(h, d));
    }),
    (ds.prefetchDNS = function (h) {
      typeof h == "string" && n.d.D(h);
    }),
    (ds.preinit = function (h, d) {
      if (typeof h == "string" && d && typeof d.as == "string") {
        var m = d.as,
          v = u(m, d.crossOrigin),
          y = typeof d.integrity == "string" ? d.integrity : void 0,
          b = typeof d.fetchPriority == "string" ? d.fetchPriority : void 0;
        m === "style"
          ? n.d.S(h, typeof d.precedence == "string" ? d.precedence : void 0, {
              crossOrigin: v,
              integrity: y,
              fetchPriority: b,
            })
          : m === "script" &&
            n.d.X(h, {
              crossOrigin: v,
              integrity: y,
              fetchPriority: b,
              nonce: typeof d.nonce == "string" ? d.nonce : void 0,
            });
      }
    }),
    (ds.preinitModule = function (h, d) {
      if (typeof h == "string")
        if (typeof d == "object" && d !== null) {
          if (d.as == null || d.as === "script") {
            var m = u(d.as, d.crossOrigin);
            n.d.M(h, {
              crossOrigin: m,
              integrity: typeof d.integrity == "string" ? d.integrity : void 0,
              nonce: typeof d.nonce == "string" ? d.nonce : void 0,
            });
          }
        } else d == null && n.d.M(h);
    }),
    (ds.preload = function (h, d) {
      if (
        typeof h == "string" &&
        typeof d == "object" &&
        d !== null &&
        typeof d.as == "string"
      ) {
        var m = d.as,
          v = u(m, d.crossOrigin);
        n.d.L(h, m, {
          crossOrigin: v,
          integrity: typeof d.integrity == "string" ? d.integrity : void 0,
          nonce: typeof d.nonce == "string" ? d.nonce : void 0,
          type: typeof d.type == "string" ? d.type : void 0,
          fetchPriority:
            typeof d.fetchPriority == "string" ? d.fetchPriority : void 0,
          referrerPolicy:
            typeof d.referrerPolicy == "string" ? d.referrerPolicy : void 0,
          imageSrcSet:
            typeof d.imageSrcSet == "string" ? d.imageSrcSet : void 0,
          imageSizes: typeof d.imageSizes == "string" ? d.imageSizes : void 0,
          media: typeof d.media == "string" ? d.media : void 0,
        });
      }
    }),
    (ds.preloadModule = function (h, d) {
      if (typeof h == "string")
        if (d) {
          var m = u(d.as, d.crossOrigin);
          n.d.m(h, {
            as: typeof d.as == "string" && d.as !== "script" ? d.as : void 0,
            crossOrigin: m,
            integrity: typeof d.integrity == "string" ? d.integrity : void 0,
          });
        } else n.d.m(h);
    }),
    (ds.requestFormReset = function (h) {
      n.d.r(h);
    }),
    (ds.unstable_batchedUpdates = function (h, d) {
      return h(d);
    }),
    (ds.useFormState = function (h, d, m) {
      return o.H.useFormState(h, d, m);
    }),
    (ds.useFormStatus = function () {
      return o.H.useHostTransitionStatus();
    }),
    (ds.version = "19.2.4"),
    ds
  );
}
var vw;
function CP() {
  if (vw) return x_.exports;
  vw = 1;
  function i() {
    if (
      !(
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" ||
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"
      )
    )
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(i);
      } catch (e) {
        console.error(e);
      }
  }
  return (i(), (x_.exports = AP()), x_.exports);
}
/**
 * @license React
 * react-dom-client.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var yw;
function RP() {
  if (yw) return fg;
  yw = 1;
  var i = nR(),
    e = S0(),
    t = CP();
  function n(a) {
    var l = "https://react.dev/errors/" + a;
    if (1 < arguments.length) {
      l += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var p = 2; p < arguments.length; p++)
        l += "&args[]=" + encodeURIComponent(arguments[p]);
    }
    return (
      "Minified React error #" +
      a +
      "; visit " +
      l +
      " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    );
  }
  function r(a) {
    return !(!a || (a.nodeType !== 1 && a.nodeType !== 9 && a.nodeType !== 11));
  }
  function s(a) {
    var l = a,
      p = a;
    if (a.alternate) for (; l.return; ) l = l.return;
    else {
      a = l;
      do ((l = a), (l.flags & 4098) !== 0 && (p = l.return), (a = l.return));
      while (a);
    }
    return l.tag === 3 ? p : null;
  }
  function o(a) {
    if (a.tag === 13) {
      var l = a.memoizedState;
      if (
        (l === null && ((a = a.alternate), a !== null && (l = a.memoizedState)),
        l !== null)
      )
        return l.dehydrated;
    }
    return null;
  }
  function u(a) {
    if (a.tag === 31) {
      var l = a.memoizedState;
      if (
        (l === null && ((a = a.alternate), a !== null && (l = a.memoizedState)),
        l !== null)
      )
        return l.dehydrated;
    }
    return null;
  }
  function h(a) {
    if (s(a) !== a) throw Error(n(188));
  }
  function d(a) {
    var l = a.alternate;
    if (!l) {
      if (((l = s(a)), l === null)) throw Error(n(188));
      return l !== a ? null : a;
    }
    for (var p = a, g = l; ; ) {
      var M = p.return;
      if (M === null) break;
      var A = M.alternate;
      if (A === null) {
        if (((g = M.return), g !== null)) {
          p = g;
          continue;
        }
        break;
      }
      if (M.child === A.child) {
        for (A = M.child; A; ) {
          if (A === p) return (h(M), a);
          if (A === g) return (h(M), l);
          A = A.sibling;
        }
        throw Error(n(188));
      }
      if (p.return !== g.return) ((p = M), (g = A));
      else {
        for (var z = !1, Q = M.child; Q; ) {
          if (Q === p) {
            ((z = !0), (p = M), (g = A));
            break;
          }
          if (Q === g) {
            ((z = !0), (g = M), (p = A));
            break;
          }
          Q = Q.sibling;
        }
        if (!z) {
          for (Q = A.child; Q; ) {
            if (Q === p) {
              ((z = !0), (p = A), (g = M));
              break;
            }
            if (Q === g) {
              ((z = !0), (g = A), (p = M));
              break;
            }
            Q = Q.sibling;
          }
          if (!z) throw Error(n(189));
        }
      }
      if (p.alternate !== g) throw Error(n(190));
    }
    if (p.tag !== 3) throw Error(n(188));
    return p.stateNode.current === p ? a : l;
  }
  function m(a) {
    var l = a.tag;
    if (l === 5 || l === 26 || l === 27 || l === 6) return a;
    for (a = a.child; a !== null; ) {
      if (((l = m(a)), l !== null)) return l;
      a = a.sibling;
    }
    return null;
  }
  var v = Object.assign,
    y = Symbol.for("react.element"),
    b = Symbol.for("react.transitional.element"),
    _ = Symbol.for("react.portal"),
    w = Symbol.for("react.fragment"),
    E = Symbol.for("react.strict_mode"),
    T = Symbol.for("react.profiler"),
    C = Symbol.for("react.consumer"),
    R = Symbol.for("react.context"),
    L = Symbol.for("react.forward_ref"),
    I = Symbol.for("react.suspense"),
    O = Symbol.for("react.suspense_list"),
    B = Symbol.for("react.memo"),
    N = Symbol.for("react.lazy"),
    F = Symbol.for("react.activity"),
    j = Symbol.for("react.memo_cache_sentinel"),
    q = Symbol.iterator;
  function X(a) {
    return a === null || typeof a != "object"
      ? null
      : ((a = (q && a[q]) || a["@@iterator"]),
        typeof a == "function" ? a : null);
  }
  var J = Symbol.for("react.client.reference");
  function ee(a) {
    if (a == null) return null;
    if (typeof a == "function")
      return a.$$typeof === J ? null : a.displayName || a.name || null;
    if (typeof a == "string") return a;
    switch (a) {
      case w:
        return "Fragment";
      case T:
        return "Profiler";
      case E:
        return "StrictMode";
      case I:
        return "Suspense";
      case O:
        return "SuspenseList";
      case F:
        return "Activity";
    }
    if (typeof a == "object")
      switch (a.$$typeof) {
        case _:
          return "Portal";
        case R:
          return a.displayName || "Context";
        case C:
          return (a._context.displayName || "Context") + ".Consumer";
        case L:
          var l = a.render;
          return (
            (a = a.displayName),
            a ||
              ((a = l.displayName || l.name || ""),
              (a = a !== "" ? "ForwardRef(" + a + ")" : "ForwardRef")),
            a
          );
        case B:
          return (
            (l = a.displayName || null),
            l !== null ? l : ee(a.type) || "Memo"
          );
        case N:
          ((l = a._payload), (a = a._init));
          try {
            return ee(a(l));
          } catch {}
      }
    return null;
  }
  var ne = Array.isArray,
    W = e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
    $ = t.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
    de = { pending: !1, data: null, method: null, action: null },
    le = [],
    fe = -1;
  function V(a) {
    return { current: a };
  }
  function Z(a) {
    0 > fe || ((a.current = le[fe]), (le[fe] = null), fe--);
  }
  function se(a, l) {
    (fe++, (le[fe] = a.current), (a.current = l));
  }
  var ue = V(null),
    ge = V(null),
    ae = V(null),
    he = V(null);
  function ye(a, l) {
    switch ((se(ae, l), se(ge, a), se(ue, null), l.nodeType)) {
      case 9:
      case 11:
        a = (a = l.documentElement) && (a = a.namespaceURI) ? UE(a) : 0;
        break;
      default:
        if (((a = l.tagName), (l = l.namespaceURI)))
          ((l = UE(l)), (a = PE(l, a)));
        else
          switch (a) {
            case "svg":
              a = 1;
              break;
            case "math":
              a = 2;
              break;
            default:
              a = 0;
          }
    }
    (Z(ue), se(ue, a));
  }
  function ze() {
    (Z(ue), Z(ge), Z(ae));
  }
  function it(a) {
    a.memoizedState !== null && se(he, a);
    var l = ue.current,
      p = PE(l, a.type);
    l !== p && (se(ge, a), se(ue, p));
  }
  function qe(a) {
    (ge.current === a && (Z(ue), Z(ge)),
      he.current === a && (Z(he), (ag._currentValue = de)));
  }
  var Ye, ft;
  function Re(a) {
    if (Ye === void 0)
      try {
        throw Error();
      } catch (p) {
        var l = p.stack.trim().match(/\n( *(at )?)/);
        ((Ye = (l && l[1]) || ""),
          (ft =
            -1 <
            p.stack.indexOf(`
    at`)
              ? " (<anonymous>)"
              : -1 < p.stack.indexOf("@")
                ? "@unknown:0:0"
                : ""));
      }
    return (
      `
` +
      Ye +
      a +
      ft
    );
  }
  var Ie = !1;
  function De(a, l) {
    if (!a || Ie) return "";
    Ie = !0;
    var p = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      var g = {
        DetermineComponentFrameRoot: function () {
          try {
            if (l) {
              var at = function () {
                throw Error();
              };
              if (
                (Object.defineProperty(at.prototype, "props", {
                  set: function () {
                    throw Error();
                  },
                }),
                typeof Reflect == "object" && Reflect.construct)
              ) {
                try {
                  Reflect.construct(at, []);
                } catch (Xe) {
                  var Be = Xe;
                }
                Reflect.construct(a, [], at);
              } else {
                try {
                  at.call();
                } catch (Xe) {
                  Be = Xe;
                }
                a.call(at.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (Xe) {
                Be = Xe;
              }
              (at = a()) &&
                typeof at.catch == "function" &&
                at.catch(function () {});
            }
          } catch (Xe) {
            if (Xe && Be && typeof Xe.stack == "string")
              return [Xe.stack, Be.stack];
          }
          return [null, null];
        },
      };
      g.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
      var M = Object.getOwnPropertyDescriptor(
        g.DetermineComponentFrameRoot,
        "name",
      );
      M &&
        M.configurable &&
        Object.defineProperty(g.DetermineComponentFrameRoot, "name", {
          value: "DetermineComponentFrameRoot",
        });
      var A = g.DetermineComponentFrameRoot(),
        z = A[0],
        Q = A[1];
      if (z && Q) {
        var pe = z.split(`
`),
          Ue = Q.split(`
`);
        for (
          M = g = 0;
          g < pe.length && !pe[g].includes("DetermineComponentFrameRoot");
        )
          g++;
        for (
          ;
          M < Ue.length && !Ue[M].includes("DetermineComponentFrameRoot");
        )
          M++;
        if (g === pe.length || M === Ue.length)
          for (
            g = pe.length - 1, M = Ue.length - 1;
            1 <= g && 0 <= M && pe[g] !== Ue[M];
          )
            M--;
        for (; 1 <= g && 0 <= M; g--, M--)
          if (pe[g] !== Ue[M]) {
            if (g !== 1 || M !== 1)
              do
                if ((g--, M--, 0 > M || pe[g] !== Ue[M])) {
                  var tt =
                    `
` + pe[g].replace(" at new ", " at ");
                  return (
                    a.displayName &&
                      tt.includes("<anonymous>") &&
                      (tt = tt.replace("<anonymous>", a.displayName)),
                    tt
                  );
                }
              while (1 <= g && 0 <= M);
            break;
          }
      }
    } finally {
      ((Ie = !1), (Error.prepareStackTrace = p));
    }
    return (p = a ? a.displayName || a.name : "") ? Re(p) : "";
  }
  function Qe(a, l) {
    switch (a.tag) {
      case 26:
      case 27:
      case 5:
        return Re(a.type);
      case 16:
        return Re("Lazy");
      case 13:
        return a.child !== l && l !== null
          ? Re("Suspense Fallback")
          : Re("Suspense");
      case 19:
        return Re("SuspenseList");
      case 0:
      case 15:
        return De(a.type, !1);
      case 11:
        return De(a.type.render, !1);
      case 1:
        return De(a.type, !0);
      case 31:
        return Re("Activity");
      default:
        return "";
    }
  }
  function K(a) {
    try {
      var l = "",
        p = null;
      do ((l += Qe(a, p)), (p = a), (a = a.return));
      while (a);
      return l;
    } catch (g) {
      return (
        `
Error generating stack: ` +
        g.message +
        `
` +
        g.stack
      );
    }
  }
  var rt = Object.prototype.hasOwnProperty,
    je = i.unstable_scheduleCallback,
    Te = i.unstable_cancelCallback,
    ke = i.unstable_shouldYield,
    H = i.unstable_requestPaint,
    k = i.unstable_now,
    oe = i.unstable_getCurrentPriorityLevel,
    Ae = i.unstable_ImmediatePriority,
    _e = i.unstable_UserBlockingPriority,
    be = i.unstable_NormalPriority,
    et = i.unstable_LowPriority,
    $e = i.unstable_IdlePriority,
    ht = i.log,
    yt = i.unstable_setDisableYieldValue,
    Ge = null,
    Ve = null;
  function Ze(a) {
    if (
      (typeof ht == "function" && yt(a),
      Ve && typeof Ve.setStrictMode == "function")
    )
      try {
        Ve.setStrictMode(Ge, a);
      } catch {}
  }
  var re = Math.clz32 ? Math.clz32 : ce,
    Se = Math.log,
    lt = Math.LN2;
  function ce(a) {
    return ((a >>>= 0), a === 0 ? 32 : (31 - ((Se(a) / lt) | 0)) | 0);
  }
  var Oe = 256,
    Ke = 262144,
    dt = 4194304;
  function Je(a) {
    var l = a & 42;
    if (l !== 0) return l;
    switch (a & -a) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
        return 64;
      case 128:
        return 128;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
        return a & 261888;
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return a & 3932160;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return a & 62914560;
      case 67108864:
        return 67108864;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 0;
      default:
        return a;
    }
  }
  function Ee(a, l, p) {
    var g = a.pendingLanes;
    if (g === 0) return 0;
    var M = 0,
      A = a.suspendedLanes,
      z = a.pingedLanes;
    a = a.warmLanes;
    var Q = g & 134217727;
    return (
      Q !== 0
        ? ((g = Q & ~A),
          g !== 0
            ? (M = Je(g))
            : ((z &= Q),
              z !== 0
                ? (M = Je(z))
                : p || ((p = Q & ~a), p !== 0 && (M = Je(p)))))
        : ((Q = g & ~A),
          Q !== 0
            ? (M = Je(Q))
            : z !== 0
              ? (M = Je(z))
              : p || ((p = g & ~a), p !== 0 && (M = Je(p)))),
      M === 0
        ? 0
        : l !== 0 &&
            l !== M &&
            (l & A) === 0 &&
            ((A = M & -M),
            (p = l & -l),
            A >= p || (A === 32 && (p & 4194048) !== 0))
          ? l
          : M
    );
  }
  function ct(a, l) {
    return (a.pendingLanes & ~(a.suspendedLanes & ~a.pingedLanes) & l) === 0;
  }
  function Mt(a, l) {
    switch (a) {
      case 1:
      case 2:
      case 4:
      case 8:
      case 64:
        return l + 250;
      case 16:
      case 32:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return l + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return -1;
      case 67108864:
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function St() {
    var a = dt;
    return ((dt <<= 1), (dt & 62914560) === 0 && (dt = 4194304), a);
  }
  function Dt(a) {
    for (var l = [], p = 0; 31 > p; p++) l.push(a);
    return l;
  }
  function hn(a, l) {
    ((a.pendingLanes |= l),
      l !== 268435456 &&
        ((a.suspendedLanes = 0), (a.pingedLanes = 0), (a.warmLanes = 0)));
  }
  function bn(a, l, p, g, M, A) {
    var z = a.pendingLanes;
    ((a.pendingLanes = p),
      (a.suspendedLanes = 0),
      (a.pingedLanes = 0),
      (a.warmLanes = 0),
      (a.expiredLanes &= p),
      (a.entangledLanes &= p),
      (a.errorRecoveryDisabledLanes &= p),
      (a.shellSuspendCounter = 0));
    var Q = a.entanglements,
      pe = a.expirationTimes,
      Ue = a.hiddenUpdates;
    for (p = z & ~p; 0 < p; ) {
      var tt = 31 - re(p),
        at = 1 << tt;
      ((Q[tt] = 0), (pe[tt] = -1));
      var Be = Ue[tt];
      if (Be !== null)
        for (Ue[tt] = null, tt = 0; tt < Be.length; tt++) {
          var Xe = Be[tt];
          Xe !== null && (Xe.lane &= -536870913);
        }
      p &= ~at;
    }
    (g !== 0 && Bn(a, g, 0),
      A !== 0 && M === 0 && a.tag !== 0 && (a.suspendedLanes |= A & ~(z & ~l)));
  }
  function Bn(a, l, p) {
    ((a.pendingLanes |= l), (a.suspendedLanes &= ~l));
    var g = 31 - re(l);
    ((a.entangledLanes |= l),
      (a.entanglements[g] = a.entanglements[g] | 1073741824 | (p & 261930)));
  }
  function Ai(a, l) {
    var p = (a.entangledLanes |= l);
    for (a = a.entanglements; p; ) {
      var g = 31 - re(p),
        M = 1 << g;
      ((M & l) | (a[g] & l) && (a[g] |= l), (p &= ~M));
    }
  }
  function $r(a, l) {
    var p = l & -l;
    return (
      (p = (p & 42) !== 0 ? 1 : Zi(p)),
      (p & (a.suspendedLanes | l)) !== 0 ? 0 : p
    );
  }
  function Zi(a) {
    switch (a) {
      case 2:
        a = 1;
        break;
      case 8:
        a = 4;
        break;
      case 32:
        a = 16;
        break;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        a = 128;
        break;
      case 268435456:
        a = 134217728;
        break;
      default:
        a = 0;
    }
    return a;
  }
  function ar(a) {
    return (
      (a &= -a),
      2 < a ? (8 < a ? ((a & 134217727) !== 0 ? 32 : 268435456) : 8) : 2
    );
  }
  function zi() {
    var a = $.p;
    return a !== 0 ? a : ((a = window.event), a === void 0 ? 32 : iw(a.type));
  }
  function xi(a, l) {
    var p = $.p;
    try {
      return (($.p = a), l());
    } finally {
      $.p = p;
    }
  }
  var Hn = Math.random().toString(36).slice(2),
    Un = "__reactFiber$" + Hn,
    ii = "__reactProps$" + Hn,
    Ir = "__reactContainer$" + Hn,
    gr = "__reactEvents$" + Hn,
    es = "__reactListeners$" + Hn,
    _s = "__reactHandles$" + Hn,
    Ba = "__reactResources$" + Hn,
    Ss = "__reactMarker$" + Hn;
  function Xs(a) {
    (delete a[Un], delete a[ii], delete a[gr], delete a[es], delete a[_s]);
  }
  function ts(a) {
    var l = a[Un];
    if (l) return l;
    for (var p = a.parentNode; p; ) {
      if ((l = p[Ir] || p[Un])) {
        if (
          ((p = l.alternate),
          l.child !== null || (p !== null && p.child !== null))
        )
          for (a = VE(a); a !== null; ) {
            if ((p = a[Un])) return p;
            a = VE(a);
          }
        return l;
      }
      ((a = p), (p = a.parentNode));
    }
    return null;
  }
  function Ms(a) {
    if ((a = a[Un] || a[Ir])) {
      var l = a.tag;
      if (
        l === 5 ||
        l === 6 ||
        l === 13 ||
        l === 31 ||
        l === 26 ||
        l === 27 ||
        l === 3
      )
        return a;
    }
    return null;
  }
  function qs(a) {
    var l = a.tag;
    if (l === 5 || l === 26 || l === 27 || l === 6) return a.stateNode;
    throw Error(n(33));
  }
  function G(a) {
    var l = a[Ba];
    return (
      l ||
        (l = a[Ba] =
          { hoistableStyles: new Map(), hoistableScripts: new Map() }),
      l
    );
  }
  function ve(a) {
    a[Ss] = !0;
  }
  var Fe = new Set(),
    Le = {};
  function Ce(a, l) {
    (pt(a, l), pt(a + "Capture", l));
  }
  function pt(a, l) {
    for (Le[a] = l, a = 0; a < l.length; a++) Fe.add(l[a]);
  }
  var bt = RegExp(
      "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$",
    ),
    _t = {},
    gt = {};
  function Lt(a) {
    return rt.call(gt, a)
      ? !0
      : rt.call(_t, a)
        ? !1
        : bt.test(a)
          ? (gt[a] = !0)
          : ((_t[a] = !0), !1);
  }
  function zt(a, l, p) {
    if (Lt(l))
      if (p === null) a.removeAttribute(l);
      else {
        switch (typeof p) {
          case "undefined":
          case "function":
          case "symbol":
            a.removeAttribute(l);
            return;
          case "boolean":
            var g = l.toLowerCase().slice(0, 5);
            if (g !== "data-" && g !== "aria-") {
              a.removeAttribute(l);
              return;
            }
        }
        a.setAttribute(l, "" + p);
      }
  }
  function Wt(a, l, p) {
    if (p === null) a.removeAttribute(l);
    else {
      switch (typeof p) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          a.removeAttribute(l);
          return;
      }
      a.setAttribute(l, "" + p);
    }
  }
  function At(a, l, p, g) {
    if (g === null) a.removeAttribute(p);
    else {
      switch (typeof g) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          a.removeAttribute(p);
          return;
      }
      a.setAttributeNS(l, p, "" + g);
    }
  }
  function Kt(a) {
    switch (typeof a) {
      case "bigint":
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return a;
      case "object":
        return a;
      default:
        return "";
    }
  }
  function Ln(a) {
    var l = a.type;
    return (
      (a = a.nodeName) &&
      a.toLowerCase() === "input" &&
      (l === "checkbox" || l === "radio")
    );
  }
  function On(a, l, p) {
    var g = Object.getOwnPropertyDescriptor(a.constructor.prototype, l);
    if (
      !a.hasOwnProperty(l) &&
      typeof g < "u" &&
      typeof g.get == "function" &&
      typeof g.set == "function"
    ) {
      var M = g.get,
        A = g.set;
      return (
        Object.defineProperty(a, l, {
          configurable: !0,
          get: function () {
            return M.call(this);
          },
          set: function (z) {
            ((p = "" + z), A.call(this, z));
          },
        }),
        Object.defineProperty(a, l, { enumerable: g.enumerable }),
        {
          getValue: function () {
            return p;
          },
          setValue: function (z) {
            p = "" + z;
          },
          stopTracking: function () {
            ((a._valueTracker = null), delete a[l]);
          },
        }
      );
    }
  }
  function rn(a) {
    if (!a._valueTracker) {
      var l = Ln(a) ? "checked" : "value";
      a._valueTracker = On(a, l, "" + a[l]);
    }
  }
  function mn(a) {
    if (!a) return !1;
    var l = a._valueTracker;
    if (!l) return !0;
    var p = l.getValue(),
      g = "";
    return (
      a && (g = Ln(a) ? (a.checked ? "true" : "false") : a.value),
      (a = g),
      a !== p ? (l.setValue(a), !0) : !1
    );
  }
  function vt(a) {
    if (
      ((a = a || (typeof document < "u" ? document : void 0)), typeof a > "u")
    )
      return null;
    try {
      return a.activeElement || a.body;
    } catch {
      return a.body;
    }
  }
  var bi = /[\n"\\]/g;
  function Pt(a) {
    return a.replace(bi, function (l) {
      return "\\" + l.charCodeAt(0).toString(16) + " ";
    });
  }
  function Bi(a, l, p, g, M, A, z, Q) {
    ((a.name = ""),
      z != null &&
      typeof z != "function" &&
      typeof z != "symbol" &&
      typeof z != "boolean"
        ? (a.type = z)
        : a.removeAttribute("type"),
      l != null
        ? z === "number"
          ? ((l === 0 && a.value === "") || a.value != l) &&
            (a.value = "" + Kt(l))
          : a.value !== "" + Kt(l) && (a.value = "" + Kt(l))
        : (z !== "submit" && z !== "reset") || a.removeAttribute("value"),
      l != null
        ? ei(a, z, Kt(l))
        : p != null
          ? ei(a, z, Kt(p))
          : g != null && a.removeAttribute("value"),
      M == null && A != null && (a.defaultChecked = !!A),
      M != null &&
        (a.checked = M && typeof M != "function" && typeof M != "symbol"),
      Q != null &&
      typeof Q != "function" &&
      typeof Q != "symbol" &&
      typeof Q != "boolean"
        ? (a.name = "" + Kt(Q))
        : a.removeAttribute("name"));
  }
  function ki(a, l, p, g, M, A, z, Q) {
    if (
      (A != null &&
        typeof A != "function" &&
        typeof A != "symbol" &&
        typeof A != "boolean" &&
        (a.type = A),
      l != null || p != null)
    ) {
      if (!((A !== "submit" && A !== "reset") || l != null)) {
        rn(a);
        return;
      }
      ((p = p != null ? "" + Kt(p) : ""),
        (l = l != null ? "" + Kt(l) : p),
        Q || l === a.value || (a.value = l),
        (a.defaultValue = l));
    }
    ((g = g ?? M),
      (g = typeof g != "function" && typeof g != "symbol" && !!g),
      (a.checked = Q ? a.checked : !!g),
      (a.defaultChecked = !!g),
      z != null &&
        typeof z != "function" &&
        typeof z != "symbol" &&
        typeof z != "boolean" &&
        (a.name = z),
      rn(a));
  }
  function ei(a, l, p) {
    (l === "number" && vt(a.ownerDocument) === a) ||
      a.defaultValue === "" + p ||
      (a.defaultValue = "" + p);
  }
  function Ki(a, l, p, g) {
    if (((a = a.options), l)) {
      l = {};
      for (var M = 0; M < p.length; M++) l["$" + p[M]] = !0;
      for (p = 0; p < a.length; p++)
        ((M = l.hasOwnProperty("$" + a[p].value)),
          a[p].selected !== M && (a[p].selected = M),
          M && g && (a[p].defaultSelected = !0));
    } else {
      for (p = "" + Kt(p), l = null, M = 0; M < a.length; M++) {
        if (a[M].value === p) {
          ((a[M].selected = !0), g && (a[M].defaultSelected = !0));
          return;
        }
        l !== null || a[M].disabled || (l = a[M]);
      }
      l !== null && (l.selected = !0);
    }
  }
  function gn(a, l, p) {
    if (
      l != null &&
      ((l = "" + Kt(l)), l !== a.value && (a.value = l), p == null)
    ) {
      a.defaultValue !== l && (a.defaultValue = l);
      return;
    }
    a.defaultValue = p != null ? "" + Kt(p) : "";
  }
  function qn(a, l, p, g) {
    if (l == null) {
      if (g != null) {
        if (p != null) throw Error(n(92));
        if (ne(g)) {
          if (1 < g.length) throw Error(n(93));
          g = g[0];
        }
        p = g;
      }
      (p == null && (p = ""), (l = p));
    }
    ((p = Kt(l)),
      (a.defaultValue = p),
      (g = a.textContent),
      g === p && g !== "" && g !== null && (a.value = g),
      rn(a));
  }
  function Vi(a, l) {
    if (l) {
      var p = a.firstChild;
      if (p && p === a.lastChild && p.nodeType === 3) {
        p.nodeValue = l;
        return;
      }
    }
    a.textContent = l;
  }
  var ri = new Set(
    "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
      " ",
    ),
  );
  function Or(a, l, p) {
    var g = l.indexOf("--") === 0;
    p == null || typeof p == "boolean" || p === ""
      ? g
        ? a.setProperty(l, "")
        : l === "float"
          ? (a.cssFloat = "")
          : (a[l] = "")
      : g
        ? a.setProperty(l, p)
        : typeof p != "number" || p === 0 || ri.has(l)
          ? l === "float"
            ? (a.cssFloat = p)
            : (a[l] = ("" + p).trim())
          : (a[l] = p + "px");
  }
  function ns(a, l, p) {
    if (l != null && typeof l != "object") throw Error(n(62));
    if (((a = a.style), p != null)) {
      for (var g in p)
        !p.hasOwnProperty(g) ||
          (l != null && l.hasOwnProperty(g)) ||
          (g.indexOf("--") === 0
            ? a.setProperty(g, "")
            : g === "float"
              ? (a.cssFloat = "")
              : (a[g] = ""));
      for (var M in l)
        ((g = l[M]), l.hasOwnProperty(M) && p[M] !== g && Or(a, M, g));
    } else for (var A in l) l.hasOwnProperty(A) && Or(a, A, l[A]);
  }
  function Ts(a) {
    if (a.indexOf("-") === -1) return !1;
    switch (a) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var gf = new Map([
      ["acceptCharset", "accept-charset"],
      ["htmlFor", "for"],
      ["httpEquiv", "http-equiv"],
      ["crossOrigin", "crossorigin"],
      ["accentHeight", "accent-height"],
      ["alignmentBaseline", "alignment-baseline"],
      ["arabicForm", "arabic-form"],
      ["baselineShift", "baseline-shift"],
      ["capHeight", "cap-height"],
      ["clipPath", "clip-path"],
      ["clipRule", "clip-rule"],
      ["colorInterpolation", "color-interpolation"],
      ["colorInterpolationFilters", "color-interpolation-filters"],
      ["colorProfile", "color-profile"],
      ["colorRendering", "color-rendering"],
      ["dominantBaseline", "dominant-baseline"],
      ["enableBackground", "enable-background"],
      ["fillOpacity", "fill-opacity"],
      ["fillRule", "fill-rule"],
      ["floodColor", "flood-color"],
      ["floodOpacity", "flood-opacity"],
      ["fontFamily", "font-family"],
      ["fontSize", "font-size"],
      ["fontSizeAdjust", "font-size-adjust"],
      ["fontStretch", "font-stretch"],
      ["fontStyle", "font-style"],
      ["fontVariant", "font-variant"],
      ["fontWeight", "font-weight"],
      ["glyphName", "glyph-name"],
      ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
      ["glyphOrientationVertical", "glyph-orientation-vertical"],
      ["horizAdvX", "horiz-adv-x"],
      ["horizOriginX", "horiz-origin-x"],
      ["imageRendering", "image-rendering"],
      ["letterSpacing", "letter-spacing"],
      ["lightingColor", "lighting-color"],
      ["markerEnd", "marker-end"],
      ["markerMid", "marker-mid"],
      ["markerStart", "marker-start"],
      ["overlinePosition", "overline-position"],
      ["overlineThickness", "overline-thickness"],
      ["paintOrder", "paint-order"],
      ["panose-1", "panose-1"],
      ["pointerEvents", "pointer-events"],
      ["renderingIntent", "rendering-intent"],
      ["shapeRendering", "shape-rendering"],
      ["stopColor", "stop-color"],
      ["stopOpacity", "stop-opacity"],
      ["strikethroughPosition", "strikethrough-position"],
      ["strikethroughThickness", "strikethrough-thickness"],
      ["strokeDasharray", "stroke-dasharray"],
      ["strokeDashoffset", "stroke-dashoffset"],
      ["strokeLinecap", "stroke-linecap"],
      ["strokeLinejoin", "stroke-linejoin"],
      ["strokeMiterlimit", "stroke-miterlimit"],
      ["strokeOpacity", "stroke-opacity"],
      ["strokeWidth", "stroke-width"],
      ["textAnchor", "text-anchor"],
      ["textDecoration", "text-decoration"],
      ["textRendering", "text-rendering"],
      ["transformOrigin", "transform-origin"],
      ["underlinePosition", "underline-position"],
      ["underlineThickness", "underline-thickness"],
      ["unicodeBidi", "unicode-bidi"],
      ["unicodeRange", "unicode-range"],
      ["unitsPerEm", "units-per-em"],
      ["vAlphabetic", "v-alphabetic"],
      ["vHanging", "v-hanging"],
      ["vIdeographic", "v-ideographic"],
      ["vMathematical", "v-mathematical"],
      ["vectorEffect", "vector-effect"],
      ["vertAdvY", "vert-adv-y"],
      ["vertOriginX", "vert-origin-x"],
      ["vertOriginY", "vert-origin-y"],
      ["wordSpacing", "word-spacing"],
      ["writingMode", "writing-mode"],
      ["xmlnsXlink", "xmlns:xlink"],
      ["xHeight", "x-height"],
    ]),
    el =
      /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
  function Ys(a) {
    return el.test("" + a)
      ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')"
      : a;
  }
  function wr() {}
  var ka = null;
  function nc(a) {
    return (
      (a = a.target || a.srcElement || window),
      a.correspondingUseElement && (a = a.correspondingUseElement),
      a.nodeType === 3 ? a.parentNode : a
    );
  }
  var Es = null,
    Zs = null;
  function ic(a) {
    var l = Ms(a);
    if (l && (a = l.stateNode)) {
      var p = a[ii] || null;
      e: switch (((a = l.stateNode), l.type)) {
        case "input":
          if (
            (Bi(
              a,
              p.value,
              p.defaultValue,
              p.defaultValue,
              p.checked,
              p.defaultChecked,
              p.type,
              p.name,
            ),
            (l = p.name),
            p.type === "radio" && l != null)
          ) {
            for (p = a; p.parentNode; ) p = p.parentNode;
            for (
              p = p.querySelectorAll(
                'input[name="' + Pt("" + l) + '"][type="radio"]',
              ),
                l = 0;
              l < p.length;
              l++
            ) {
              var g = p[l];
              if (g !== a && g.form === a.form) {
                var M = g[ii] || null;
                if (!M) throw Error(n(90));
                Bi(
                  g,
                  M.value,
                  M.defaultValue,
                  M.defaultValue,
                  M.checked,
                  M.defaultChecked,
                  M.type,
                  M.name,
                );
              }
            }
            for (l = 0; l < p.length; l++)
              ((g = p[l]), g.form === a.form && mn(g));
          }
          break e;
        case "textarea":
          gn(a, p.value, p.defaultValue);
          break e;
        case "select":
          ((l = p.value), l != null && Ki(a, !!p.multiple, l, !1));
      }
    }
  }
  var rc = !1;
  function tl(a, l, p) {
    if (rc) return a(l, p);
    rc = !0;
    try {
      var g = a(l);
      return g;
    } finally {
      if (
        ((rc = !1),
        (Es !== null || Zs !== null) &&
          (Ra(), Es && ((l = Es), (a = Zs), (Zs = Es = null), ic(l), a)))
      )
        for (l = 0; l < a.length; l++) ic(a[l]);
    }
  }
  function Va(a, l) {
    var p = a.stateNode;
    if (p === null) return null;
    var g = p[ii] || null;
    if (g === null) return null;
    p = g[l];
    e: switch (l) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        ((g = !g.disabled) ||
          ((a = a.type),
          (g = !(
            a === "button" ||
            a === "input" ||
            a === "select" ||
            a === "textarea"
          ))),
          (a = !g));
        break e;
      default:
        a = !1;
    }
    if (a) return null;
    if (p && typeof p != "function") throw Error(n(231, l, typeof p));
    return p;
  }
  var ws = !(
      typeof window > "u" ||
      typeof window.document > "u" ||
      typeof window.document.createElement > "u"
    ),
    Fr = !1;
  if (ws)
    try {
      var Ga = {};
      (Object.defineProperty(Ga, "passive", {
        get: function () {
          Fr = !0;
        },
      }),
        window.addEventListener("test", Ga, Ga),
        window.removeEventListener("test", Ga, Ga));
    } catch {
      Fr = !1;
    }
  var Ar = null,
    sc = null,
    Sa = null;
  function nl() {
    if (Sa) return Sa;
    var a,
      l = sc,
      p = l.length,
      g,
      M = "value" in Ar ? Ar.value : Ar.textContent,
      A = M.length;
    for (a = 0; a < p && l[a] === M[a]; a++);
    var z = p - a;
    for (g = 1; g <= z && l[p - g] === M[A - g]; g++);
    return (Sa = M.slice(a, 1 < g ? 1 - g : void 0));
  }
  function il(a) {
    var l = a.keyCode;
    return (
      "charCode" in a
        ? ((a = a.charCode), a === 0 && l === 13 && (a = 13))
        : (a = l),
      a === 10 && (a = 13),
      32 <= a || a === 13 ? a : 0
    );
  }
  function Ks() {
    return !0;
  }
  function rl() {
    return !1;
  }
  function si(a) {
    function l(p, g, M, A, z) {
      ((this._reactName = p),
        (this._targetInst = M),
        (this.type = g),
        (this.nativeEvent = A),
        (this.target = z),
        (this.currentTarget = null));
      for (var Q in a)
        a.hasOwnProperty(Q) && ((p = a[Q]), (this[Q] = p ? p(A) : A[Q]));
      return (
        (this.isDefaultPrevented = (
          A.defaultPrevented != null ? A.defaultPrevented : A.returnValue === !1
        )
          ? Ks
          : rl),
        (this.isPropagationStopped = rl),
        this
      );
    }
    return (
      v(l.prototype, {
        preventDefault: function () {
          this.defaultPrevented = !0;
          var p = this.nativeEvent;
          p &&
            (p.preventDefault
              ? p.preventDefault()
              : typeof p.returnValue != "unknown" && (p.returnValue = !1),
            (this.isDefaultPrevented = Ks));
        },
        stopPropagation: function () {
          var p = this.nativeEvent;
          p &&
            (p.stopPropagation
              ? p.stopPropagation()
              : typeof p.cancelBubble != "unknown" && (p.cancelBubble = !0),
            (this.isPropagationStopped = Ks));
        },
        persist: function () {},
        isPersistent: Ks,
      }),
      l
    );
  }
  var Ma = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function (a) {
        return a.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0,
    },
    So = si(Ma),
    Ha = v({}, Ma, { view: 0, detail: 0 }),
    sl = si(Ha),
    al,
    ja,
    Wa,
    Gi = v({}, Ha, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: Gh,
      button: 0,
      buttons: 0,
      relatedTarget: function (a) {
        return a.relatedTarget === void 0
          ? a.fromElement === a.srcElement
            ? a.toElement
            : a.fromElement
          : a.relatedTarget;
      },
      movementX: function (a) {
        return "movementX" in a
          ? a.movementX
          : (a !== Wa &&
              (Wa && a.type === "mousemove"
                ? ((al = a.screenX - Wa.screenX), (ja = a.screenY - Wa.screenY))
                : (ja = al = 0),
              (Wa = a)),
            al);
      },
      movementY: function (a) {
        return "movementY" in a ? a.movementY : ja;
      },
    }),
    vf = si(Gi),
    ac = v({}, Gi, { dataTransfer: 0 }),
    oc = si(ac),
    nu = v({}, Ha, { relatedTarget: 0 }),
    iu = si(nu),
    vr = v({}, Ma, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }),
    As = si(vr),
    Cr = v({}, Ma, {
      clipboardData: function (a) {
        return "clipboardData" in a ? a.clipboardData : window.clipboardData;
      },
    }),
    Ta = si(Cr),
    ol = v({}, Ma, { data: 0 }),
    kh = si(ol),
    Vh = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified",
    },
    B0 = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta",
    },
    k0 = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey",
    };
  function Xp(a) {
    var l = this.nativeEvent;
    return l.getModifierState
      ? l.getModifierState(a)
      : (a = k0[a])
        ? !!l[a]
        : !1;
  }
  function Gh() {
    return Xp;
  }
  var V0 = v({}, Ha, {
      key: function (a) {
        if (a.key) {
          var l = Vh[a.key] || a.key;
          if (l !== "Unidentified") return l;
        }
        return a.type === "keypress"
          ? ((a = il(a)), a === 13 ? "Enter" : String.fromCharCode(a))
          : a.type === "keydown" || a.type === "keyup"
            ? B0[a.keyCode] || "Unidentified"
            : "";
      },
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: Gh,
      charCode: function (a) {
        return a.type === "keypress" ? il(a) : 0;
      },
      keyCode: function (a) {
        return a.type === "keydown" || a.type === "keyup" ? a.keyCode : 0;
      },
      which: function (a) {
        return a.type === "keypress"
          ? il(a)
          : a.type === "keydown" || a.type === "keyup"
            ? a.keyCode
            : 0;
      },
    }),
    lc = si(V0),
    Hh = v({}, Gi, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0,
    }),
    qp = si(Hh),
    Yp = v({}, Ha, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: Gh,
    }),
    G0 = si(Yp),
    H0 = v({}, Ma, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }),
    Ob = si(H0),
    yr = v({}, Gi, {
      deltaX: function (a) {
        return "deltaX" in a
          ? a.deltaX
          : "wheelDeltaX" in a
            ? -a.wheelDeltaX
            : 0;
      },
      deltaY: function (a) {
        return "deltaY" in a
          ? a.deltaY
          : "wheelDeltaY" in a
            ? -a.wheelDeltaY
            : "wheelDelta" in a
              ? -a.wheelDelta
              : 0;
      },
      deltaZ: 0,
      deltaMode: 0,
    }),
    j0 = si(yr),
    W0 = v({}, Ma, { newState: 0, oldState: 0 }),
    X0 = si(W0),
    q0 = [9, 13, 27, 32],
    cc = ws && "CompositionEvent" in window,
    ru = null;
  ws && "documentMode" in document && (ru = document.documentMode);
  var jh = ws && "TextEvent" in window && !ru,
    Zp = ws && (!cc || (ru && 8 < ru && 11 >= ru)),
    Y0 = " ",
    yf = !1;
  function Wh(a, l) {
    switch (a) {
      case "keyup":
        return q0.indexOf(l.keyCode) !== -1;
      case "keydown":
        return l.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function Kp(a) {
    return (
      (a = a.detail),
      typeof a == "object" && "data" in a ? a.data : null
    );
  }
  var uc = !1;
  function Z0(a, l) {
    switch (a) {
      case "compositionend":
        return Kp(l);
      case "keypress":
        return l.which !== 32 ? null : ((yf = !0), Y0);
      case "textInput":
        return ((a = l.data), a === Y0 && yf ? null : a);
      default:
        return null;
    }
  }
  function Qp(a, l) {
    if (uc)
      return a === "compositionend" || (!cc && Wh(a, l))
        ? ((a = nl()), (Sa = sc = Ar = null), (uc = !1), a)
        : null;
    switch (a) {
      case "paste":
        return null;
      case "keypress":
        if (!(l.ctrlKey || l.altKey || l.metaKey) || (l.ctrlKey && l.altKey)) {
          if (l.char && 1 < l.char.length) return l.char;
          if (l.which) return String.fromCharCode(l.which);
        }
        return null;
      case "compositionend":
        return Zp && l.locale !== "ko" ? null : l.data;
      default:
        return null;
    }
  }
  var Jp = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0,
  };
  function $p(a) {
    var l = a && a.nodeName && a.nodeName.toLowerCase();
    return l === "input" ? !!Jp[a.type] : l === "textarea";
  }
  function Xh(a, l, p, g) {
    (Es ? (Zs ? Zs.push(g) : (Zs = [g])) : (Es = g),
      (l = ey(l, "onChange")),
      0 < l.length &&
        ((p = new So("onChange", "change", null, p, g)),
        a.push({ event: p, listeners: l })));
  }
  var ll = null,
    fc = null;
  function K0(a) {
    AE(a, 0);
  }
  function su(a) {
    var l = qs(a);
    if (mn(l)) return a;
  }
  function em(a, l) {
    if (a === "change") return l;
  }
  var Xa = !1;
  if (ws) {
    var xf;
    if (ws) {
      var tm = "oninput" in document;
      if (!tm) {
        var nm = document.createElement("div");
        (nm.setAttribute("oninput", "return;"),
          (tm = typeof nm.oninput == "function"));
      }
      xf = tm;
    } else xf = !1;
    Xa = xf && (!document.documentMode || 9 < document.documentMode);
  }
  function Qs() {
    ll && (ll.detachEvent("onpropertychange", bf), (fc = ll = null));
  }
  function bf(a) {
    if (a.propertyName === "value" && su(fc)) {
      var l = [];
      (Xh(l, fc, a, nc(a)), tl(K0, l));
    }
  }
  function Q0(a, l, p) {
    a === "focusin"
      ? (Qs(), (ll = l), (fc = p), ll.attachEvent("onpropertychange", bf))
      : a === "focusout" && Qs();
  }
  function im(a) {
    if (a === "selectionchange" || a === "keyup" || a === "keydown")
      return su(fc);
  }
  function J0(a, l) {
    if (a === "click") return su(l);
  }
  function $0(a, l) {
    if (a === "input" || a === "change") return su(l);
  }
  function rm(a, l) {
    return (a === l && (a !== 0 || 1 / a === 1 / l)) || (a !== a && l !== l);
  }
  var zr = typeof Object.is == "function" ? Object.is : rm;
  function au(a, l) {
    if (zr(a, l)) return !0;
    if (
      typeof a != "object" ||
      a === null ||
      typeof l != "object" ||
      l === null
    )
      return !1;
    var p = Object.keys(a),
      g = Object.keys(l);
    if (p.length !== g.length) return !1;
    for (g = 0; g < p.length; g++) {
      var M = p[g];
      if (!rt.call(l, M) || !zr(a[M], l[M])) return !1;
    }
    return !0;
  }
  function _f(a) {
    for (; a && a.firstChild; ) a = a.firstChild;
    return a;
  }
  function ou(a, l) {
    var p = _f(a);
    a = 0;
    for (var g; p; ) {
      if (p.nodeType === 3) {
        if (((g = a + p.textContent.length), a <= l && g >= l))
          return { node: p, offset: l - a };
        a = g;
      }
      e: {
        for (; p; ) {
          if (p.nextSibling) {
            p = p.nextSibling;
            break e;
          }
          p = p.parentNode;
        }
        p = void 0;
      }
      p = _f(p);
    }
  }
  function Yn(a, l) {
    return a && l
      ? a === l
        ? !0
        : a && a.nodeType === 3
          ? !1
          : l && l.nodeType === 3
            ? Yn(a, l.parentNode)
            : "contains" in a
              ? a.contains(l)
              : a.compareDocumentPosition
                ? !!(a.compareDocumentPosition(l) & 16)
                : !1
      : !1;
  }
  function ev(a) {
    a =
      a != null &&
      a.ownerDocument != null &&
      a.ownerDocument.defaultView != null
        ? a.ownerDocument.defaultView
        : window;
    for (var l = vt(a.document); l instanceof a.HTMLIFrameElement; ) {
      try {
        var p = typeof l.contentWindow.location.href == "string";
      } catch {
        p = !1;
      }
      if (p) a = l.contentWindow;
      else break;
      l = vt(a.document);
    }
    return l;
  }
  function sm(a) {
    var l = a && a.nodeName && a.nodeName.toLowerCase();
    return (
      l &&
      ((l === "input" &&
        (a.type === "text" ||
          a.type === "search" ||
          a.type === "tel" ||
          a.type === "url" ||
          a.type === "password")) ||
        l === "textarea" ||
        a.contentEditable === "true")
    );
  }
  var tv = ws && "documentMode" in document && 11 >= document.documentMode,
    qa = null,
    Ya = null,
    lu = null,
    qh = !1;
  function cu(a, l, p) {
    var g =
      p.window === p ? p.document : p.nodeType === 9 ? p : p.ownerDocument;
    qh ||
      qa == null ||
      qa !== vt(g) ||
      ((g = qa),
      "selectionStart" in g && sm(g)
        ? (g = { start: g.selectionStart, end: g.selectionEnd })
        : ((g = (
            (g.ownerDocument && g.ownerDocument.defaultView) ||
            window
          ).getSelection()),
          (g = {
            anchorNode: g.anchorNode,
            anchorOffset: g.anchorOffset,
            focusNode: g.focusNode,
            focusOffset: g.focusOffset,
          })),
      (lu && au(lu, g)) ||
        ((lu = g),
        (g = ey(Ya, "onSelect")),
        0 < g.length &&
          ((l = new So("onSelect", "select", null, l, p)),
          a.push({ event: l, listeners: g }),
          (l.target = qa))));
  }
  function Rr(a, l) {
    var p = {};
    return (
      (p[a.toLowerCase()] = l.toLowerCase()),
      (p["Webkit" + a] = "webkit" + l),
      (p["Moz" + a] = "moz" + l),
      p
    );
  }
  var hc = {
      animationend: Rr("Animation", "AnimationEnd"),
      animationiteration: Rr("Animation", "AnimationIteration"),
      animationstart: Rr("Animation", "AnimationStart"),
      transitionrun: Rr("Transition", "TransitionRun"),
      transitionstart: Rr("Transition", "TransitionStart"),
      transitioncancel: Rr("Transition", "TransitionCancel"),
      transitionend: Rr("Transition", "TransitionEnd"),
    },
    Sf = {},
    am = {};
  ws &&
    ((am = document.createElement("div").style),
    "AnimationEvent" in window ||
      (delete hc.animationend.animation,
      delete hc.animationiteration.animation,
      delete hc.animationstart.animation),
    "TransitionEvent" in window || delete hc.transitionend.transition);
  function Mo(a) {
    if (Sf[a]) return Sf[a];
    if (!hc[a]) return a;
    var l = hc[a],
      p;
    for (p in l) if (l.hasOwnProperty(p) && p in am) return (Sf[a] = l[p]);
    return a;
  }
  var Yh = Mo("animationend"),
    Mf = Mo("animationiteration"),
    om = Mo("animationstart"),
    nv = Mo("transitionrun"),
    Fb = Mo("transitionstart"),
    iv = Mo("transitioncancel"),
    lm = Mo("transitionend"),
    Js = new Map(),
    Tf =
      "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
        " ",
      );
  Tf.push("scrollEnd");
  function $s(a, l) {
    (Js.set(a, l), Ce(l, [a]));
  }
  var Ef =
      typeof reportError == "function"
        ? reportError
        : function (a) {
            if (
              typeof window == "object" &&
              typeof window.ErrorEvent == "function"
            ) {
              var l = new window.ErrorEvent("error", {
                bubbles: !0,
                cancelable: !0,
                message:
                  typeof a == "object" &&
                  a !== null &&
                  typeof a.message == "string"
                    ? String(a.message)
                    : String(a),
                error: a,
              });
              if (!window.dispatchEvent(l)) return;
            } else if (
              typeof process == "object" &&
              typeof process.emit == "function"
            ) {
              process.emit("uncaughtException", a);
              return;
            }
            console.error(a);
          },
    ea = [],
    To = 0,
    or = 0;
  function wf() {
    for (var a = To, l = (or = To = 0); l < a; ) {
      var p = ea[l];
      ea[l++] = null;
      var g = ea[l];
      ea[l++] = null;
      var M = ea[l];
      ea[l++] = null;
      var A = ea[l];
      if (((ea[l++] = null), g !== null && M !== null)) {
        var z = g.pending;
        (z === null ? (M.next = M) : ((M.next = z.next), (z.next = M)),
          (g.pending = M));
      }
      A !== 0 && cl(p, M, A);
    }
  }
  function lr(a, l, p, g) {
    ((ea[To++] = a),
      (ea[To++] = l),
      (ea[To++] = p),
      (ea[To++] = g),
      (or |= g),
      (a.lanes |= g),
      (a = a.alternate),
      a !== null && (a.lanes |= g));
  }
  function Zh(a, l, p, g) {
    return (lr(a, l, p, g), ta(a));
  }
  function Br(a, l) {
    return (lr(a, null, null, l), ta(a));
  }
  function cl(a, l, p) {
    a.lanes |= p;
    var g = a.alternate;
    g !== null && (g.lanes |= p);
    for (var M = !1, A = a.return; A !== null; )
      ((A.childLanes |= p),
        (g = A.alternate),
        g !== null && (g.childLanes |= p),
        A.tag === 22 &&
          ((a = A.stateNode), a === null || a._visibility & 1 || (M = !0)),
        (a = A),
        (A = A.return));
    return a.tag === 3
      ? ((A = a.stateNode),
        M &&
          l !== null &&
          ((M = 31 - re(p)),
          (a = A.hiddenUpdates),
          (g = a[M]),
          g === null ? (a[M] = [l]) : g.push(l),
          (l.lane = p | 536870912)),
        A)
      : null;
  }
  function ta(a) {
    if (50 < Cl) throw ((Cl = 0), (Lc = null), Error(n(185)));
    for (var l = a.return; l !== null; ) ((a = l), (l = a.return));
    return a.tag === 3 ? a.stateNode : null;
  }
  var ul = {};
  function cm(a, l, p, g) {
    ((this.tag = a),
      (this.key = p),
      (this.sibling =
        this.child =
        this.return =
        this.stateNode =
        this.type =
        this.elementType =
          null),
      (this.index = 0),
      (this.refCleanup = this.ref = null),
      (this.pendingProps = l),
      (this.dependencies =
        this.memoizedState =
        this.updateQueue =
        this.memoizedProps =
          null),
      (this.mode = g),
      (this.subtreeFlags = this.flags = 0),
      (this.deletions = null),
      (this.childLanes = this.lanes = 0),
      (this.alternate = null));
  }
  function fi(a, l, p, g) {
    return new cm(a, l, p, g);
  }
  function Kh(a) {
    return ((a = a.prototype), !(!a || !a.isReactComponent));
  }
  function is(a, l) {
    var p = a.alternate;
    return (
      p === null
        ? ((p = fi(a.tag, l, a.key, a.mode)),
          (p.elementType = a.elementType),
          (p.type = a.type),
          (p.stateNode = a.stateNode),
          (p.alternate = a),
          (a.alternate = p))
        : ((p.pendingProps = l),
          (p.type = a.type),
          (p.flags = 0),
          (p.subtreeFlags = 0),
          (p.deletions = null)),
      (p.flags = a.flags & 65011712),
      (p.childLanes = a.childLanes),
      (p.lanes = a.lanes),
      (p.child = a.child),
      (p.memoizedProps = a.memoizedProps),
      (p.memoizedState = a.memoizedState),
      (p.updateQueue = a.updateQueue),
      (l = a.dependencies),
      (p.dependencies =
        l === null ? null : { lanes: l.lanes, firstContext: l.firstContext }),
      (p.sibling = a.sibling),
      (p.index = a.index),
      (p.ref = a.ref),
      (p.refCleanup = a.refCleanup),
      p
    );
  }
  function uu(a, l) {
    a.flags &= 65011714;
    var p = a.alternate;
    return (
      p === null
        ? ((a.childLanes = 0),
          (a.lanes = l),
          (a.child = null),
          (a.subtreeFlags = 0),
          (a.memoizedProps = null),
          (a.memoizedState = null),
          (a.updateQueue = null),
          (a.dependencies = null),
          (a.stateNode = null))
        : ((a.childLanes = p.childLanes),
          (a.lanes = p.lanes),
          (a.child = p.child),
          (a.subtreeFlags = 0),
          (a.deletions = null),
          (a.memoizedProps = p.memoizedProps),
          (a.memoizedState = p.memoizedState),
          (a.updateQueue = p.updateQueue),
          (a.type = p.type),
          (l = p.dependencies),
          (a.dependencies =
            l === null
              ? null
              : { lanes: l.lanes, firstContext: l.firstContext })),
      a
    );
  }
  function Za(a, l, p, g, M, A) {
    var z = 0;
    if (((g = a), typeof a == "function")) Kh(a) && (z = 1);
    else if (typeof a == "string")
      z = fP(a, p, ue.current)
        ? 26
        : a === "html" || a === "head" || a === "body"
          ? 27
          : 5;
    else
      e: switch (a) {
        case F:
          return ((a = fi(31, p, l, M)), (a.elementType = F), (a.lanes = A), a);
        case w:
          return fl(p.children, M, A, l);
        case E:
          ((z = 8), (M |= 24));
          break;
        case T:
          return (
            (a = fi(12, p, l, M | 2)),
            (a.elementType = T),
            (a.lanes = A),
            a
          );
        case I:
          return ((a = fi(13, p, l, M)), (a.elementType = I), (a.lanes = A), a);
        case O:
          return ((a = fi(19, p, l, M)), (a.elementType = O), (a.lanes = A), a);
        default:
          if (typeof a == "object" && a !== null)
            switch (a.$$typeof) {
              case R:
                z = 10;
                break e;
              case C:
                z = 9;
                break e;
              case L:
                z = 11;
                break e;
              case B:
                z = 14;
                break e;
              case N:
                ((z = 16), (g = null));
                break e;
            }
          ((z = 29),
            (p = Error(n(130, a === null ? "null" : typeof a, ""))),
            (g = null));
      }
    return (
      (l = fi(z, p, l, M)),
      (l.elementType = a),
      (l.type = g),
      (l.lanes = A),
      l
    );
  }
  function fl(a, l, p, g) {
    return ((a = fi(7, a, g, l)), (a.lanes = p), a);
  }
  function Qh(a, l, p) {
    return ((a = fi(6, a, null, l)), (a.lanes = p), a);
  }
  function fu(a) {
    var l = fi(18, null, null, 0);
    return ((l.stateNode = a), l);
  }
  function Jh(a, l, p) {
    return (
      (l = fi(4, a.children !== null ? a.children : [], a.key, l)),
      (l.lanes = p),
      (l.stateNode = {
        containerInfo: a.containerInfo,
        pendingChildren: null,
        implementation: a.implementation,
      }),
      l
    );
  }
  var Af = new WeakMap();
  function Cs(a, l) {
    if (typeof a == "object" && a !== null) {
      var p = Af.get(a);
      return p !== void 0
        ? p
        : ((l = { value: a, source: l, stack: K(l) }), Af.set(a, l), l);
    }
    return { value: a, source: l, stack: K(l) };
  }
  var hl = [],
    dl = 0,
    hu = null,
    du = 0,
    rs = [],
    ai = 0,
    Eo = null,
    hi = 1,
    Ea = "";
  function Ka(a, l) {
    ((hl[dl++] = du), (hl[dl++] = hu), (hu = a), (du = l));
  }
  function rv(a, l, p) {
    ((rs[ai++] = hi), (rs[ai++] = Ea), (rs[ai++] = Eo), (Eo = a));
    var g = hi;
    a = Ea;
    var M = 32 - re(g) - 1;
    ((g &= ~(1 << M)), (p += 1));
    var A = 32 - re(l) + M;
    if (30 < A) {
      var z = M - (M % 5);
      ((A = (g & ((1 << z) - 1)).toString(32)),
        (g >>= z),
        (M -= z),
        (hi = (1 << (32 - re(l) + M)) | (p << M) | g),
        (Ea = A + a));
    } else ((hi = (1 << A) | (p << M) | g), (Ea = a));
  }
  function Qa(a) {
    a.return !== null && (Ka(a, 1), rv(a, 1, 0));
  }
  function $h(a) {
    for (; a === hu; )
      ((hu = hl[--dl]), (hl[dl] = null), (du = hl[--dl]), (hl[dl] = null));
    for (; a === Eo; )
      ((Eo = rs[--ai]),
        (rs[ai] = null),
        (Ea = rs[--ai]),
        (rs[ai] = null),
        (hi = rs[--ai]),
        (rs[ai] = null));
  }
  function ed(a, l) {
    ((rs[ai++] = hi),
      (rs[ai++] = Ea),
      (rs[ai++] = Eo),
      (hi = l.id),
      (Ea = l.overflow),
      (Eo = a));
  }
  var _i = null,
    Zn = null,
    _n = !1,
    wo = null,
    Rs = !1,
    pu = Error(n(519));
  function Ja(a) {
    var l = Error(
      n(
        418,
        1 < arguments.length && arguments[1] !== void 0 && arguments[1]
          ? "text"
          : "HTML",
        "",
      ),
    );
    throw ($a(Cs(l, a)), pu);
  }
  function sv(a) {
    var l = a.stateNode,
      p = a.type,
      g = a.memoizedProps;
    switch (((l[Un] = a), (l[ii] = g), p)) {
      case "dialog":
        (Tn("cancel", l), Tn("close", l));
        break;
      case "iframe":
      case "object":
      case "embed":
        Tn("load", l);
        break;
      case "video":
      case "audio":
        for (p = 0; p < pa.length; p++) Tn(pa[p], l);
        break;
      case "source":
        Tn("error", l);
        break;
      case "img":
      case "image":
      case "link":
        (Tn("error", l), Tn("load", l));
        break;
      case "details":
        Tn("toggle", l);
        break;
      case "input":
        (Tn("invalid", l),
          ki(
            l,
            g.value,
            g.defaultValue,
            g.checked,
            g.defaultChecked,
            g.type,
            g.name,
            !0,
          ));
        break;
      case "select":
        Tn("invalid", l);
        break;
      case "textarea":
        (Tn("invalid", l), qn(l, g.value, g.defaultValue, g.children));
    }
    ((p = g.children),
      (typeof p != "string" && typeof p != "number" && typeof p != "bigint") ||
      l.textContent === "" + p ||
      g.suppressHydrationWarning === !0 ||
      LE(l.textContent, p)
        ? (g.popover != null && (Tn("beforetoggle", l), Tn("toggle", l)),
          g.onScroll != null && Tn("scroll", l),
          g.onScrollEnd != null && Tn("scrollend", l),
          g.onClick != null && (l.onclick = wr),
          (l = !0))
        : (l = !1),
      l || Ja(a, !0));
  }
  function av(a) {
    for (_i = a.return; _i; )
      switch (_i.tag) {
        case 5:
        case 31:
        case 13:
          Rs = !1;
          return;
        case 27:
        case 3:
          Rs = !0;
          return;
        default:
          _i = _i.return;
      }
  }
  function mu(a) {
    if (a !== _i) return !1;
    if (!_n) return (av(a), (_n = !0), !1);
    var l = a.tag,
      p;
    if (
      ((p = l !== 3 && l !== 27) &&
        ((p = l === 5) &&
          ((p = a.type),
          (p =
            !(p !== "form" && p !== "button") || $b(a.type, a.memoizedProps))),
        (p = !p)),
      p && Zn && Ja(a),
      av(a),
      l === 13)
    ) {
      if (((a = a.memoizedState), (a = a !== null ? a.dehydrated : null), !a))
        throw Error(n(317));
      Zn = kE(a);
    } else if (l === 31) {
      if (((a = a.memoizedState), (a = a !== null ? a.dehydrated : null), !a))
        throw Error(n(317));
      Zn = kE(a);
    } else
      l === 27
        ? ((l = Zn), Iu(a.type) ? ((a = r_), (r_ = null), (Zn = a)) : (Zn = l))
        : (Zn = _i ? po(a.stateNode.nextSibling) : null);
    return !0;
  }
  function pl() {
    ((Zn = _i = null), (_n = !1));
  }
  function td() {
    var a = wo;
    return (
      a !== null &&
        (Mi === null ? (Mi = a) : Mi.push.apply(Mi, a), (wo = null)),
      a
    );
  }
  function $a(a) {
    wo === null ? (wo = [a]) : wo.push(a);
  }
  var gu = V(null),
    ml = null,
    eo = null;
  function Ao(a, l, p) {
    (se(gu, l._currentValue), (l._currentValue = p));
  }
  function to(a) {
    ((a._currentValue = gu.current), Z(gu));
  }
  function nd(a, l, p) {
    for (; a !== null; ) {
      var g = a.alternate;
      if (
        ((a.childLanes & l) !== l
          ? ((a.childLanes |= l), g !== null && (g.childLanes |= l))
          : g !== null && (g.childLanes & l) !== l && (g.childLanes |= l),
        a === p)
      )
        break;
      a = a.return;
    }
  }
  function id(a, l, p, g) {
    var M = a.child;
    for (M !== null && (M.return = a); M !== null; ) {
      var A = M.dependencies;
      if (A !== null) {
        var z = M.child;
        A = A.firstContext;
        e: for (; A !== null; ) {
          var Q = A;
          A = M;
          for (var pe = 0; pe < l.length; pe++)
            if (Q.context === l[pe]) {
              ((A.lanes |= p),
                (Q = A.alternate),
                Q !== null && (Q.lanes |= p),
                nd(A.return, p, a),
                g || (z = null));
              break e;
            }
          A = Q.next;
        }
      } else if (M.tag === 18) {
        if (((z = M.return), z === null)) throw Error(n(341));
        ((z.lanes |= p),
          (A = z.alternate),
          A !== null && (A.lanes |= p),
          nd(z, p, a),
          (z = null));
      } else z = M.child;
      if (z !== null) z.return = M;
      else
        for (z = M; z !== null; ) {
          if (z === a) {
            z = null;
            break;
          }
          if (((M = z.sibling), M !== null)) {
            ((M.return = z.return), (z = M));
            break;
          }
          z = z.return;
        }
      M = z;
    }
  }
  function no(a, l, p, g) {
    a = null;
    for (var M = l, A = !1; M !== null; ) {
      if (!A) {
        if ((M.flags & 524288) !== 0) A = !0;
        else if ((M.flags & 262144) !== 0) break;
      }
      if (M.tag === 10) {
        var z = M.alternate;
        if (z === null) throw Error(n(387));
        if (((z = z.memoizedProps), z !== null)) {
          var Q = M.type;
          zr(M.pendingProps.value, z.value) ||
            (a !== null ? a.push(Q) : (a = [Q]));
        }
      } else if (M === he.current) {
        if (((z = M.alternate), z === null)) throw Error(n(387));
        z.memoizedState.memoizedState !== M.memoizedState.memoizedState &&
          (a !== null ? a.push(ag) : (a = [ag]));
      }
      M = M.return;
    }
    (a !== null && id(l, a, p, g), (l.flags |= 262144));
  }
  function Cf(a) {
    for (a = a.firstContext; a !== null; ) {
      if (!zr(a.context._currentValue, a.memoizedValue)) return !0;
      a = a.next;
    }
    return !1;
  }
  function gl(a) {
    ((ml = a),
      (eo = null),
      (a = a.dependencies),
      a !== null && (a.firstContext = null));
  }
  function Xt(a) {
    return ov(ml, a);
  }
  function vu(a, l) {
    return (ml === null && gl(a), ov(a, l));
  }
  function ov(a, l) {
    var p = l._currentValue;
    if (((l = { context: l, memoizedValue: p, next: null }), eo === null)) {
      if (a === null) throw Error(n(308));
      ((eo = l),
        (a.dependencies = { lanes: 0, firstContext: l }),
        (a.flags |= 524288));
    } else eo = eo.next = l;
    return p;
  }
  var lv =
      typeof AbortController < "u"
        ? AbortController
        : function () {
            var a = [],
              l = (this.signal = {
                aborted: !1,
                addEventListener: function (p, g) {
                  a.push(g);
                },
              });
            this.abort = function () {
              ((l.aborted = !0),
                a.forEach(function (p) {
                  return p();
                }));
            };
          },
    zb = i.unstable_scheduleCallback,
    Bb = i.unstable_NormalPriority,
    Hi = {
      $$typeof: R,
      Consumer: null,
      Provider: null,
      _currentValue: null,
      _currentValue2: null,
      _threadCount: 0,
    };
  function um() {
    return { controller: new lv(), data: new Map(), refCount: 0 };
  }
  function dc(a) {
    (a.refCount--,
      a.refCount === 0 &&
        zb(Bb, function () {
          a.controller.abort();
        }));
  }
  var Ds = null,
    rd = 0,
    Co = 0,
    na = null;
  function fm(a, l) {
    if (Ds === null) {
      var p = (Ds = []);
      ((rd = 0),
        (Co = He()),
        (na = {
          status: "pending",
          value: void 0,
          then: function (g) {
            p.push(g);
          },
        }));
    }
    return (rd++, l.then(hm, hm), l);
  }
  function hm() {
    if (--rd === 0 && Ds !== null) {
      na !== null && (na.status = "fulfilled");
      var a = Ds;
      ((Ds = null), (Co = 0), (na = null));
      for (var l = 0; l < a.length; l++) (0, a[l])();
    }
  }
  function dm(a, l) {
    var p = [],
      g = {
        status: "pending",
        value: null,
        reason: null,
        then: function (M) {
          p.push(M);
        },
      };
    return (
      a.then(
        function () {
          ((g.status = "fulfilled"), (g.value = l));
          for (var M = 0; M < p.length; M++) (0, p[M])(l);
        },
        function (M) {
          for (g.status = "rejected", g.reason = M, M = 0; M < p.length; M++)
            (0, p[M])(void 0);
        },
      ),
      g
    );
  }
  var cv = W.S;
  W.S = function (a, l) {
    ((eg = k()),
      typeof l == "object" &&
        l !== null &&
        typeof l.then == "function" &&
        fm(a, l),
      cv !== null && cv(a, l));
  };
  var vl = V(null);
  function sd() {
    var a = vl.current;
    return a !== null ? a : Zt.pooledCache;
  }
  function Rf(a, l) {
    l === null ? se(vl, vl.current) : se(vl, l.pool);
  }
  function pm() {
    var a = sd();
    return a === null ? null : { parent: Hi._currentValue, pool: a };
  }
  var pc = Error(n(460)),
    Df = Error(n(474)),
    an = Error(n(542)),
    ad = { then: function () {} };
  function ss(a) {
    return ((a = a.status), a === "fulfilled" || a === "rejected");
  }
  function od(a, l, p) {
    switch (
      ((p = a[p]),
      p === void 0 ? a.push(l) : p !== l && (l.then(wr, wr), (l = p)),
      l.status)
    ) {
      case "fulfilled":
        return l.value;
      case "rejected":
        throw ((a = l.reason), vc(a), a);
      default:
        if (typeof l.status == "string") l.then(wr, wr);
        else {
          if (((a = Zt), a !== null && 100 < a.shellSuspendCounter))
            throw Error(n(482));
          ((a = l),
            (a.status = "pending"),
            a.then(
              function (g) {
                if (l.status === "pending") {
                  var M = l;
                  ((M.status = "fulfilled"), (M.value = g));
                }
              },
              function (g) {
                if (l.status === "pending") {
                  var M = l;
                  ((M.status = "rejected"), (M.reason = g));
                }
              },
            ));
        }
        switch (l.status) {
          case "fulfilled":
            return l.value;
          case "rejected":
            throw ((a = l.reason), vc(a), a);
        }
        throw ((io = l), pc);
    }
  }
  function mc(a) {
    try {
      var l = a._init;
      return l(a._payload);
    } catch (p) {
      throw p !== null && typeof p == "object" && typeof p.then == "function"
        ? ((io = p), pc)
        : p;
    }
  }
  var io = null;
  function gc() {
    if (io === null) throw Error(n(459));
    var a = io;
    return ((io = null), a);
  }
  function vc(a) {
    if (a === pc || a === an) throw Error(n(483));
  }
  var yc = null,
    xc = 0;
  function Lf(a) {
    var l = xc;
    return ((xc += 1), yc === null && (yc = []), od(yc, a, l));
  }
  function ia(a, l) {
    ((l = l.props.ref), (a.ref = l !== void 0 ? l : null));
  }
  function yu(a, l) {
    throw l.$$typeof === y
      ? Error(n(525))
      : ((a = Object.prototype.toString.call(l)),
        Error(
          n(
            31,
            a === "[object Object]"
              ? "object with keys {" + Object.keys(l).join(", ") + "}"
              : a,
          ),
        ));
  }
  function ld(a) {
    function l(Me, xe) {
      if (a) {
        var Ne = Me.deletions;
        Ne === null ? ((Me.deletions = [xe]), (Me.flags |= 16)) : Ne.push(xe);
      }
    }
    function p(Me, xe) {
      if (!a) return null;
      for (; xe !== null; ) (l(Me, xe), (xe = xe.sibling));
      return null;
    }
    function g(Me) {
      for (var xe = new Map(); Me !== null; )
        (Me.key !== null ? xe.set(Me.key, Me) : xe.set(Me.index, Me),
          (Me = Me.sibling));
      return xe;
    }
    function M(Me, xe) {
      return ((Me = is(Me, xe)), (Me.index = 0), (Me.sibling = null), Me);
    }
    function A(Me, xe, Ne) {
      return (
        (Me.index = Ne),
        a
          ? ((Ne = Me.alternate),
            Ne !== null
              ? ((Ne = Ne.index), Ne < xe ? ((Me.flags |= 67108866), xe) : Ne)
              : ((Me.flags |= 67108866), xe))
          : ((Me.flags |= 1048576), xe)
      );
    }
    function z(Me) {
      return (a && Me.alternate === null && (Me.flags |= 67108866), Me);
    }
    function Q(Me, xe, Ne, st) {
      return xe === null || xe.tag !== 6
        ? ((xe = Qh(Ne, Me.mode, st)), (xe.return = Me), xe)
        : ((xe = M(xe, Ne)), (xe.return = Me), xe);
    }
    function pe(Me, xe, Ne, st) {
      var kt = Ne.type;
      return kt === w
        ? tt(Me, xe, Ne.props.children, st, Ne.key)
        : xe !== null &&
            (xe.elementType === kt ||
              (typeof kt == "object" &&
                kt !== null &&
                kt.$$typeof === N &&
                mc(kt) === xe.type))
          ? ((xe = M(xe, Ne.props)), ia(xe, Ne), (xe.return = Me), xe)
          : ((xe = Za(Ne.type, Ne.key, Ne.props, null, Me.mode, st)),
            ia(xe, Ne),
            (xe.return = Me),
            xe);
    }
    function Ue(Me, xe, Ne, st) {
      return xe === null ||
        xe.tag !== 4 ||
        xe.stateNode.containerInfo !== Ne.containerInfo ||
        xe.stateNode.implementation !== Ne.implementation
        ? ((xe = Jh(Ne, Me.mode, st)), (xe.return = Me), xe)
        : ((xe = M(xe, Ne.children || [])), (xe.return = Me), xe);
    }
    function tt(Me, xe, Ne, st, kt) {
      return xe === null || xe.tag !== 7
        ? ((xe = fl(Ne, Me.mode, st, kt)), (xe.return = Me), xe)
        : ((xe = M(xe, Ne)), (xe.return = Me), xe);
    }
    function at(Me, xe, Ne) {
      if (
        (typeof xe == "string" && xe !== "") ||
        typeof xe == "number" ||
        typeof xe == "bigint"
      )
        return ((xe = Qh("" + xe, Me.mode, Ne)), (xe.return = Me), xe);
      if (typeof xe == "object" && xe !== null) {
        switch (xe.$$typeof) {
          case b:
            return (
              (Ne = Za(xe.type, xe.key, xe.props, null, Me.mode, Ne)),
              ia(Ne, xe),
              (Ne.return = Me),
              Ne
            );
          case _:
            return ((xe = Jh(xe, Me.mode, Ne)), (xe.return = Me), xe);
          case N:
            return ((xe = mc(xe)), at(Me, xe, Ne));
        }
        if (ne(xe) || X(xe))
          return ((xe = fl(xe, Me.mode, Ne, null)), (xe.return = Me), xe);
        if (typeof xe.then == "function") return at(Me, Lf(xe), Ne);
        if (xe.$$typeof === R) return at(Me, vu(Me, xe), Ne);
        yu(Me, xe);
      }
      return null;
    }
    function Be(Me, xe, Ne, st) {
      var kt = xe !== null ? xe.key : null;
      if (
        (typeof Ne == "string" && Ne !== "") ||
        typeof Ne == "number" ||
        typeof Ne == "bigint"
      )
        return kt !== null ? null : Q(Me, xe, "" + Ne, st);
      if (typeof Ne == "object" && Ne !== null) {
        switch (Ne.$$typeof) {
          case b:
            return Ne.key === kt ? pe(Me, xe, Ne, st) : null;
          case _:
            return Ne.key === kt ? Ue(Me, xe, Ne, st) : null;
          case N:
            return ((Ne = mc(Ne)), Be(Me, xe, Ne, st));
        }
        if (ne(Ne) || X(Ne))
          return kt !== null ? null : tt(Me, xe, Ne, st, null);
        if (typeof Ne.then == "function") return Be(Me, xe, Lf(Ne), st);
        if (Ne.$$typeof === R) return Be(Me, xe, vu(Me, Ne), st);
        yu(Me, Ne);
      }
      return null;
    }
    function Xe(Me, xe, Ne, st, kt) {
      if (
        (typeof st == "string" && st !== "") ||
        typeof st == "number" ||
        typeof st == "bigint"
      )
        return ((Me = Me.get(Ne) || null), Q(xe, Me, "" + st, kt));
      if (typeof st == "object" && st !== null) {
        switch (st.$$typeof) {
          case b:
            return (
              (Me = Me.get(st.key === null ? Ne : st.key) || null),
              pe(xe, Me, st, kt)
            );
          case _:
            return (
              (Me = Me.get(st.key === null ? Ne : st.key) || null),
              Ue(xe, Me, st, kt)
            );
          case N:
            return ((st = mc(st)), Xe(Me, xe, Ne, st, kt));
        }
        if (ne(st) || X(st))
          return ((Me = Me.get(Ne) || null), tt(xe, Me, st, kt, null));
        if (typeof st.then == "function") return Xe(Me, xe, Ne, Lf(st), kt);
        if (st.$$typeof === R) return Xe(Me, xe, Ne, vu(xe, st), kt);
        yu(xe, st);
      }
      return null;
    }
    function Nt(Me, xe, Ne, st) {
      for (
        var kt = null, Fn = null, It = xe, fn = (xe = 0), An = null;
        It !== null && fn < Ne.length;
        fn++
      ) {
        It.index > fn ? ((An = It), (It = null)) : (An = It.sibling);
        var zn = Be(Me, It, Ne[fn], st);
        if (zn === null) {
          It === null && (It = An);
          break;
        }
        (a && It && zn.alternate === null && l(Me, It),
          (xe = A(zn, xe, fn)),
          Fn === null ? (kt = zn) : (Fn.sibling = zn),
          (Fn = zn),
          (It = An));
      }
      if (fn === Ne.length) return (p(Me, It), _n && Ka(Me, fn), kt);
      if (It === null) {
        for (; fn < Ne.length; fn++)
          ((It = at(Me, Ne[fn], st)),
            It !== null &&
              ((xe = A(It, xe, fn)),
              Fn === null ? (kt = It) : (Fn.sibling = It),
              (Fn = It)));
        return (_n && Ka(Me, fn), kt);
      }
      for (It = g(It); fn < Ne.length; fn++)
        ((An = Xe(It, Me, fn, Ne[fn], st)),
          An !== null &&
            (a &&
              An.alternate !== null &&
              It.delete(An.key === null ? fn : An.key),
            (xe = A(An, xe, fn)),
            Fn === null ? (kt = An) : (Fn.sibling = An),
            (Fn = An)));
      return (
        a &&
          It.forEach(function (ku) {
            return l(Me, ku);
          }),
        _n && Ka(Me, fn),
        kt
      );
    }
    function jt(Me, xe, Ne, st) {
      if (Ne == null) throw Error(n(151));
      for (
        var kt = null,
          Fn = null,
          It = xe,
          fn = (xe = 0),
          An = null,
          zn = Ne.next();
        It !== null && !zn.done;
        fn++, zn = Ne.next()
      ) {
        It.index > fn ? ((An = It), (It = null)) : (An = It.sibling);
        var ku = Be(Me, It, zn.value, st);
        if (ku === null) {
          It === null && (It = An);
          break;
        }
        (a && It && ku.alternate === null && l(Me, It),
          (xe = A(ku, xe, fn)),
          Fn === null ? (kt = ku) : (Fn.sibling = ku),
          (Fn = ku),
          (It = An));
      }
      if (zn.done) return (p(Me, It), _n && Ka(Me, fn), kt);
      if (It === null) {
        for (; !zn.done; fn++, zn = Ne.next())
          ((zn = at(Me, zn.value, st)),
            zn !== null &&
              ((xe = A(zn, xe, fn)),
              Fn === null ? (kt = zn) : (Fn.sibling = zn),
              (Fn = zn)));
        return (_n && Ka(Me, fn), kt);
      }
      for (It = g(It); !zn.done; fn++, zn = Ne.next())
        ((zn = Xe(It, Me, fn, zn.value, st)),
          zn !== null &&
            (a &&
              zn.alternate !== null &&
              It.delete(zn.key === null ? fn : zn.key),
            (xe = A(zn, xe, fn)),
            Fn === null ? (kt = zn) : (Fn.sibling = zn),
            (Fn = zn)));
      return (
        a &&
          It.forEach(function (SP) {
            return l(Me, SP);
          }),
        _n && Ka(Me, fn),
        kt
      );
    }
    function Jn(Me, xe, Ne, st) {
      if (
        (typeof Ne == "object" &&
          Ne !== null &&
          Ne.type === w &&
          Ne.key === null &&
          (Ne = Ne.props.children),
        typeof Ne == "object" && Ne !== null)
      ) {
        switch (Ne.$$typeof) {
          case b:
            e: {
              for (var kt = Ne.key; xe !== null; ) {
                if (xe.key === kt) {
                  if (((kt = Ne.type), kt === w)) {
                    if (xe.tag === 7) {
                      (p(Me, xe.sibling),
                        (st = M(xe, Ne.props.children)),
                        (st.return = Me),
                        (Me = st));
                      break e;
                    }
                  } else if (
                    xe.elementType === kt ||
                    (typeof kt == "object" &&
                      kt !== null &&
                      kt.$$typeof === N &&
                      mc(kt) === xe.type)
                  ) {
                    (p(Me, xe.sibling),
                      (st = M(xe, Ne.props)),
                      ia(st, Ne),
                      (st.return = Me),
                      (Me = st));
                    break e;
                  }
                  p(Me, xe);
                  break;
                } else l(Me, xe);
                xe = xe.sibling;
              }
              Ne.type === w
                ? ((st = fl(Ne.props.children, Me.mode, st, Ne.key)),
                  (st.return = Me),
                  (Me = st))
                : ((st = Za(Ne.type, Ne.key, Ne.props, null, Me.mode, st)),
                  ia(st, Ne),
                  (st.return = Me),
                  (Me = st));
            }
            return z(Me);
          case _:
            e: {
              for (kt = Ne.key; xe !== null; ) {
                if (xe.key === kt)
                  if (
                    xe.tag === 4 &&
                    xe.stateNode.containerInfo === Ne.containerInfo &&
                    xe.stateNode.implementation === Ne.implementation
                  ) {
                    (p(Me, xe.sibling),
                      (st = M(xe, Ne.children || [])),
                      (st.return = Me),
                      (Me = st));
                    break e;
                  } else {
                    p(Me, xe);
                    break;
                  }
                else l(Me, xe);
                xe = xe.sibling;
              }
              ((st = Jh(Ne, Me.mode, st)), (st.return = Me), (Me = st));
            }
            return z(Me);
          case N:
            return ((Ne = mc(Ne)), Jn(Me, xe, Ne, st));
        }
        if (ne(Ne)) return Nt(Me, xe, Ne, st);
        if (X(Ne)) {
          if (((kt = X(Ne)), typeof kt != "function")) throw Error(n(150));
          return ((Ne = kt.call(Ne)), jt(Me, xe, Ne, st));
        }
        if (typeof Ne.then == "function") return Jn(Me, xe, Lf(Ne), st);
        if (Ne.$$typeof === R) return Jn(Me, xe, vu(Me, Ne), st);
        yu(Me, Ne);
      }
      return (typeof Ne == "string" && Ne !== "") ||
        typeof Ne == "number" ||
        typeof Ne == "bigint"
        ? ((Ne = "" + Ne),
          xe !== null && xe.tag === 6
            ? (p(Me, xe.sibling), (st = M(xe, Ne)), (st.return = Me), (Me = st))
            : (p(Me, xe),
              (st = Qh(Ne, Me.mode, st)),
              (st.return = Me),
              (Me = st)),
          z(Me))
        : p(Me, xe);
    }
    return function (Me, xe, Ne, st) {
      try {
        xc = 0;
        var kt = Jn(Me, xe, Ne, st);
        return ((yc = null), kt);
      } catch (It) {
        if (It === pc || It === an) throw It;
        var Fn = fi(29, It, null, Me.mode);
        return ((Fn.lanes = st), (Fn.return = Me), Fn);
      } finally {
      }
    };
  }
  var Ro = ld(!0),
    cd = ld(!1),
    kr = !1;
  function Nf(a) {
    a.updateQueue = {
      baseState: a.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null, lanes: 0, hiddenCallbacks: null },
      callbacks: null,
    };
  }
  function mm(a, l) {
    ((a = a.updateQueue),
      l.updateQueue === a &&
        (l.updateQueue = {
          baseState: a.baseState,
          firstBaseUpdate: a.firstBaseUpdate,
          lastBaseUpdate: a.lastBaseUpdate,
          shared: a.shared,
          callbacks: null,
        }));
  }
  function Do(a) {
    return { lane: a, tag: 0, payload: null, callback: null, next: null };
  }
  function yl(a, l, p) {
    var g = a.updateQueue;
    if (g === null) return null;
    if (((g = g.shared), (Ot & 2) !== 0)) {
      var M = g.pending;
      return (
        M === null ? (l.next = l) : ((l.next = M.next), (M.next = l)),
        (g.pending = l),
        (l = ta(a)),
        cl(a, null, p),
        l
      );
    }
    return (lr(a, g, l, p), ta(a));
  }
  function xl(a, l, p) {
    if (
      ((l = l.updateQueue), l !== null && ((l = l.shared), (p & 4194048) !== 0))
    ) {
      var g = l.lanes;
      ((g &= a.pendingLanes), (p |= g), (l.lanes = p), Ai(a, p));
    }
  }
  function Bt(a, l) {
    var p = a.updateQueue,
      g = a.alternate;
    if (g !== null && ((g = g.updateQueue), p === g)) {
      var M = null,
        A = null;
      if (((p = p.firstBaseUpdate), p !== null)) {
        do {
          var z = {
            lane: p.lane,
            tag: p.tag,
            payload: p.payload,
            callback: null,
            next: null,
          };
          (A === null ? (M = A = z) : (A = A.next = z), (p = p.next));
        } while (p !== null);
        A === null ? (M = A = l) : (A = A.next = l);
      } else M = A = l;
      ((p = {
        baseState: g.baseState,
        firstBaseUpdate: M,
        lastBaseUpdate: A,
        shared: g.shared,
        callbacks: g.callbacks,
      }),
        (a.updateQueue = p));
      return;
    }
    ((a = p.lastBaseUpdate),
      a === null ? (p.firstBaseUpdate = l) : (a.next = l),
      (p.lastBaseUpdate = l));
  }
  var gm = !1;
  function Uf() {
    if (gm) {
      var a = na;
      if (a !== null) throw a;
    }
  }
  function xu(a, l, p, g) {
    gm = !1;
    var M = a.updateQueue;
    kr = !1;
    var A = M.firstBaseUpdate,
      z = M.lastBaseUpdate,
      Q = M.shared.pending;
    if (Q !== null) {
      M.shared.pending = null;
      var pe = Q,
        Ue = pe.next;
      ((pe.next = null), z === null ? (A = Ue) : (z.next = Ue), (z = pe));
      var tt = a.alternate;
      tt !== null &&
        ((tt = tt.updateQueue),
        (Q = tt.lastBaseUpdate),
        Q !== z &&
          (Q === null ? (tt.firstBaseUpdate = Ue) : (Q.next = Ue),
          (tt.lastBaseUpdate = pe)));
    }
    if (A !== null) {
      var at = M.baseState;
      ((z = 0), (tt = Ue = pe = null), (Q = A));
      do {
        var Be = Q.lane & -536870913,
          Xe = Be !== Q.lane;
        if (Xe ? (sn & Be) === Be : (g & Be) === Be) {
          (Be !== 0 && Be === Co && (gm = !0),
            tt !== null &&
              (tt = tt.next =
                {
                  lane: 0,
                  tag: Q.tag,
                  payload: Q.payload,
                  callback: null,
                  next: null,
                }));
          e: {
            var Nt = a,
              jt = Q;
            Be = l;
            var Jn = p;
            switch (jt.tag) {
              case 1:
                if (((Nt = jt.payload), typeof Nt == "function")) {
                  at = Nt.call(Jn, at, Be);
                  break e;
                }
                at = Nt;
                break e;
              case 3:
                Nt.flags = (Nt.flags & -65537) | 128;
              case 0:
                if (
                  ((Nt = jt.payload),
                  (Be = typeof Nt == "function" ? Nt.call(Jn, at, Be) : Nt),
                  Be == null)
                )
                  break e;
                at = v({}, at, Be);
                break e;
              case 2:
                kr = !0;
            }
          }
          ((Be = Q.callback),
            Be !== null &&
              ((a.flags |= 64),
              Xe && (a.flags |= 8192),
              (Xe = M.callbacks),
              Xe === null ? (M.callbacks = [Be]) : Xe.push(Be)));
        } else
          ((Xe = {
            lane: Be,
            tag: Q.tag,
            payload: Q.payload,
            callback: Q.callback,
            next: null,
          }),
            tt === null ? ((Ue = tt = Xe), (pe = at)) : (tt = tt.next = Xe),
            (z |= Be));
        if (((Q = Q.next), Q === null)) {
          if (((Q = M.shared.pending), Q === null)) break;
          ((Xe = Q),
            (Q = Xe.next),
            (Xe.next = null),
            (M.lastBaseUpdate = Xe),
            (M.shared.pending = null));
        }
      } while (!0);
      (tt === null && (pe = at),
        (M.baseState = pe),
        (M.firstBaseUpdate = Ue),
        (M.lastBaseUpdate = tt),
        A === null && (M.shared.lanes = 0),
        (uo |= z),
        (a.lanes = z),
        (a.memoizedState = at));
    }
  }
  function bu(a, l) {
    if (typeof a != "function") throw Error(n(191, a));
    a.call(l);
  }
  function uv(a, l) {
    var p = a.callbacks;
    if (p !== null)
      for (a.callbacks = null, a = 0; a < p.length; a++) bu(p[a], l);
  }
  var _u = V(null),
    ud = V(0);
  function fv(a, l) {
    ((a = Ps), se(ud, a), se(_u, l), (Ps = a | l.baseLanes));
  }
  function vm() {
    (se(ud, Ps), se(_u, _u.current));
  }
  function Pf() {
    ((Ps = ud.current), Z(_u), Z(ud));
  }
  var as = V(null),
    Vr = null;
  function Lo(a) {
    var l = a.alternate;
    (se(Sn, Sn.current & 1),
      se(as, a),
      Vr === null &&
        (l === null || _u.current !== null || l.memoizedState !== null) &&
        (Vr = a));
  }
  function ym(a) {
    (se(Sn, Sn.current), se(as, a), Vr === null && (Vr = a));
  }
  function hv(a) {
    a.tag === 22
      ? (se(Sn, Sn.current), se(as, a), Vr === null && (Vr = a))
      : os();
  }
  function os() {
    (se(Sn, Sn.current), se(as, as.current));
  }
  function Ci(a) {
    (Z(as), Vr === a && (Vr = null), Z(Sn));
  }
  var Sn = V(0);
  function Ls(a) {
    for (var l = a; l !== null; ) {
      if (l.tag === 13) {
        var p = l.memoizedState;
        if (p !== null && ((p = p.dehydrated), p === null || n_(p) || i_(p)))
          return l;
      } else if (
        l.tag === 19 &&
        (l.memoizedProps.revealOrder === "forwards" ||
          l.memoizedProps.revealOrder === "backwards" ||
          l.memoizedProps.revealOrder === "unstable_legacy-backwards" ||
          l.memoizedProps.revealOrder === "together")
      ) {
        if ((l.flags & 128) !== 0) return l;
      } else if (l.child !== null) {
        ((l.child.return = l), (l = l.child));
        continue;
      }
      if (l === a) break;
      for (; l.sibling === null; ) {
        if (l.return === null || l.return === a) return null;
        l = l.return;
      }
      ((l.sibling.return = l.return), (l = l.sibling));
    }
    return null;
  }
  var oi = 0,
    Jt = null,
    jn = null,
    vn = null,
    ra = !1,
    Su = !1,
    bc = !1,
    fd = 0,
    If = 0,
    Mu = null,
    xm = 0;
  function di() {
    throw Error(n(321));
  }
  function bm(a, l) {
    if (l === null) return !1;
    for (var p = 0; p < l.length && p < a.length; p++)
      if (!zr(a[p], l[p])) return !1;
    return !0;
  }
  function hd(a, l, p, g, M, A) {
    return (
      (oi = A),
      (Jt = l),
      (l.memoizedState = null),
      (l.updateQueue = null),
      (l.lanes = 0),
      (W.H = a === null || a.memoizedState === null ? jv : km),
      (bc = !1),
      (A = p(g, M)),
      (bc = !1),
      Su && (A = _c(l, p, g, M)),
      dv(a),
      A
    );
  }
  function dv(a) {
    W.H = Tu;
    var l = jn !== null && jn.next !== null;
    if (((oi = 0), (vn = jn = Jt = null), (ra = !1), (If = 0), (Mu = null), l))
      throw Error(n(300));
    a === null ||
      ji ||
      ((a = a.dependencies), a !== null && Cf(a) && (ji = !0));
  }
  function _c(a, l, p, g) {
    Jt = a;
    var M = 0;
    do {
      if ((Su && (Mu = null), (If = 0), (Su = !1), 25 <= M))
        throw Error(n(301));
      if (((M += 1), (vn = jn = null), a.updateQueue != null)) {
        var A = a.updateQueue;
        ((A.lastEffect = null),
          (A.events = null),
          (A.stores = null),
          A.memoCache != null && (A.memoCache.index = 0));
      }
      ((W.H = sa), (A = l(p, g)));
    } while (Su);
    return A;
  }
  function Sc() {
    var a = W.H,
      l = a.useState()[0];
    return (
      (l = typeof l.then == "function" ? Of(l) : l),
      (a = a.useState()[0]),
      (jn !== null ? jn.memoizedState : null) !== a && (Jt.flags |= 1024),
      l
    );
  }
  function _m() {
    var a = fd !== 0;
    return ((fd = 0), a);
  }
  function Sm(a, l, p) {
    ((l.updateQueue = a.updateQueue), (l.flags &= -2053), (a.lanes &= ~p));
  }
  function Mm(a) {
    if (ra) {
      for (a = a.memoizedState; a !== null; ) {
        var l = a.queue;
        (l !== null && (l.pending = null), (a = a.next));
      }
      ra = !1;
    }
    ((oi = 0), (vn = jn = Jt = null), (Su = !1), (If = fd = 0), (Mu = null));
  }
  function Qi() {
    var a = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null,
    };
    return (vn === null ? (Jt.memoizedState = vn = a) : (vn = vn.next = a), vn);
  }
  function Ri() {
    if (jn === null) {
      var a = Jt.alternate;
      a = a !== null ? a.memoizedState : null;
    } else a = jn.next;
    var l = vn === null ? Jt.memoizedState : vn.next;
    if (l !== null) ((vn = l), (jn = a));
    else {
      if (a === null)
        throw Jt.alternate === null ? Error(n(467)) : Error(n(310));
      ((jn = a),
        (a = {
          memoizedState: jn.memoizedState,
          baseState: jn.baseState,
          baseQueue: jn.baseQueue,
          queue: jn.queue,
          next: null,
        }),
        vn === null ? (Jt.memoizedState = vn = a) : (vn = vn.next = a));
    }
    return vn;
  }
  function dd() {
    return { lastEffect: null, events: null, stores: null, memoCache: null };
  }
  function Of(a) {
    var l = If;
    return (
      (If += 1),
      Mu === null && (Mu = []),
      (a = od(Mu, a, l)),
      (l = Jt),
      (vn === null ? l.memoizedState : vn.next) === null &&
        ((l = l.alternate),
        (W.H = l === null || l.memoizedState === null ? jv : km)),
      a
    );
  }
  function bl(a) {
    if (a !== null && typeof a == "object") {
      if (typeof a.then == "function") return Of(a);
      if (a.$$typeof === R) return Xt(a);
    }
    throw Error(n(438, String(a)));
  }
  function Tm(a) {
    var l = null,
      p = Jt.updateQueue;
    if ((p !== null && (l = p.memoCache), l == null)) {
      var g = Jt.alternate;
      g !== null &&
        ((g = g.updateQueue),
        g !== null &&
          ((g = g.memoCache),
          g != null &&
            (l = {
              data: g.data.map(function (M) {
                return M.slice();
              }),
              index: 0,
            })));
    }
    if (
      (l == null && (l = { data: [], index: 0 }),
      p === null && ((p = dd()), (Jt.updateQueue = p)),
      (p.memoCache = l),
      (p = l.data[l.index]),
      p === void 0)
    )
      for (p = l.data[l.index] = Array(a), g = 0; g < a; g++) p[g] = j;
    return (l.index++, p);
  }
  function No(a, l) {
    return typeof l == "function" ? l(a) : l;
  }
  function pd(a) {
    var l = Ri();
    return Em(l, jn, a);
  }
  function Em(a, l, p) {
    var g = a.queue;
    if (g === null) throw Error(n(311));
    g.lastRenderedReducer = p;
    var M = a.baseQueue,
      A = g.pending;
    if (A !== null) {
      if (M !== null) {
        var z = M.next;
        ((M.next = A.next), (A.next = z));
      }
      ((l.baseQueue = M = A), (g.pending = null));
    }
    if (((A = a.baseState), M === null)) a.memoizedState = A;
    else {
      l = M.next;
      var Q = (z = null),
        pe = null,
        Ue = l,
        tt = !1;
      do {
        var at = Ue.lane & -536870913;
        if (at !== Ue.lane ? (sn & at) === at : (oi & at) === at) {
          var Be = Ue.revertLane;
          if (Be === 0)
            (pe !== null &&
              (pe = pe.next =
                {
                  lane: 0,
                  revertLane: 0,
                  gesture: null,
                  action: Ue.action,
                  hasEagerState: Ue.hasEagerState,
                  eagerState: Ue.eagerState,
                  next: null,
                }),
              at === Co && (tt = !0));
          else if ((oi & Be) === Be) {
            ((Ue = Ue.next), Be === Co && (tt = !0));
            continue;
          } else
            ((at = {
              lane: 0,
              revertLane: Ue.revertLane,
              gesture: null,
              action: Ue.action,
              hasEagerState: Ue.hasEagerState,
              eagerState: Ue.eagerState,
              next: null,
            }),
              pe === null ? ((Q = pe = at), (z = A)) : (pe = pe.next = at),
              (Jt.lanes |= Be),
              (uo |= Be));
          ((at = Ue.action),
            bc && p(A, at),
            (A = Ue.hasEagerState ? Ue.eagerState : p(A, at)));
        } else
          ((Be = {
            lane: at,
            revertLane: Ue.revertLane,
            gesture: Ue.gesture,
            action: Ue.action,
            hasEagerState: Ue.hasEagerState,
            eagerState: Ue.eagerState,
            next: null,
          }),
            pe === null ? ((Q = pe = Be), (z = A)) : (pe = pe.next = Be),
            (Jt.lanes |= at),
            (uo |= at));
        Ue = Ue.next;
      } while (Ue !== null && Ue !== l);
      if (
        (pe === null ? (z = A) : (pe.next = Q),
        !zr(A, a.memoizedState) && ((ji = !0), tt && ((p = na), p !== null)))
      )
        throw p;
      ((a.memoizedState = A),
        (a.baseState = z),
        (a.baseQueue = pe),
        (g.lastRenderedState = A));
    }
    return (M === null && (g.lanes = 0), [a.memoizedState, g.dispatch]);
  }
  function wm(a) {
    var l = Ri(),
      p = l.queue;
    if (p === null) throw Error(n(311));
    p.lastRenderedReducer = a;
    var g = p.dispatch,
      M = p.pending,
      A = l.memoizedState;
    if (M !== null) {
      p.pending = null;
      var z = (M = M.next);
      do ((A = a(A, z.action)), (z = z.next));
      while (z !== M);
      (zr(A, l.memoizedState) || (ji = !0),
        (l.memoizedState = A),
        l.baseQueue === null && (l.baseState = A),
        (p.lastRenderedState = A));
    }
    return [A, g];
  }
  function pv(a, l, p) {
    var g = Jt,
      M = Ri(),
      A = _n;
    if (A) {
      if (p === void 0) throw Error(n(407));
      p = p();
    } else p = l();
    var z = !zr((jn || M).memoizedState, p);
    if (
      (z && ((M.memoizedState = p), (ji = !0)),
      (M = M.queue),
      Pm(vv.bind(null, g, M, a), [a]),
      M.getSnapshot !== l || z || (vn !== null && vn.memoizedState.tag & 1))
    ) {
      if (
        ((g.flags |= 2048),
        _l(9, { destroy: void 0 }, gv.bind(null, g, M, p, l), null),
        Zt === null)
      )
        throw Error(n(349));
      A || (oi & 127) !== 0 || mv(g, l, p);
    }
    return p;
  }
  function mv(a, l, p) {
    ((a.flags |= 16384),
      (a = { getSnapshot: l, value: p }),
      (l = Jt.updateQueue),
      l === null
        ? ((l = dd()), (Jt.updateQueue = l), (l.stores = [a]))
        : ((p = l.stores), p === null ? (l.stores = [a]) : p.push(a)));
  }
  function gv(a, l, p, g) {
    ((l.value = p), (l.getSnapshot = g), yv(l) && xv(a));
  }
  function vv(a, l, p) {
    return p(function () {
      yv(l) && xv(a);
    });
  }
  function yv(a) {
    var l = a.getSnapshot;
    a = a.value;
    try {
      var p = l();
      return !zr(a, p);
    } catch {
      return !0;
    }
  }
  function xv(a) {
    var l = Br(a, 2);
    l !== null && ln(l, a, 2);
  }
  function Am(a) {
    var l = Qi();
    if (typeof a == "function") {
      var p = a;
      if (((a = p()), bc)) {
        Ze(!0);
        try {
          p();
        } finally {
          Ze(!1);
        }
      }
    }
    return (
      (l.memoizedState = l.baseState = a),
      (l.queue = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: No,
        lastRenderedState: a,
      }),
      l
    );
  }
  function Cm(a, l, p, g) {
    return ((a.baseState = p), Em(a, jn, typeof g == "function" ? g : No));
  }
  function kb(a, l, p, g, M) {
    if (yd(a)) throw Error(n(485));
    if (((a = l.action), a !== null)) {
      var A = {
        payload: M,
        action: a,
        next: null,
        isTransition: !0,
        status: "pending",
        value: null,
        reason: null,
        listeners: [],
        then: function (z) {
          A.listeners.push(z);
        },
      };
      (W.T !== null ? p(!0) : (A.isTransition = !1),
        g(A),
        (p = l.pending),
        p === null
          ? ((A.next = l.pending = A), bv(l, A))
          : ((A.next = p.next), (l.pending = p.next = A)));
    }
  }
  function bv(a, l) {
    var p = l.action,
      g = l.payload,
      M = a.state;
    if (l.isTransition) {
      var A = W.T,
        z = {};
      W.T = z;
      try {
        var Q = p(M, g),
          pe = W.S;
        (pe !== null && pe(z, Q), _v(a, l, Q));
      } catch (Ue) {
        Rm(a, l, Ue);
      } finally {
        (A !== null && z.types !== null && (A.types = z.types), (W.T = A));
      }
    } else
      try {
        ((A = p(M, g)), _v(a, l, A));
      } catch (Ue) {
        Rm(a, l, Ue);
      }
  }
  function _v(a, l, p) {
    p !== null && typeof p == "object" && typeof p.then == "function"
      ? p.then(
          function (g) {
            Sv(a, l, g);
          },
          function (g) {
            return Rm(a, l, g);
          },
        )
      : Sv(a, l, p);
  }
  function Sv(a, l, p) {
    ((l.status = "fulfilled"),
      (l.value = p),
      Mv(l),
      (a.state = p),
      (l = a.pending),
      l !== null &&
        ((p = l.next),
        p === l ? (a.pending = null) : ((p = p.next), (l.next = p), bv(a, p))));
  }
  function Rm(a, l, p) {
    var g = a.pending;
    if (((a.pending = null), g !== null)) {
      g = g.next;
      do ((l.status = "rejected"), (l.reason = p), Mv(l), (l = l.next));
      while (l !== g);
    }
    a.action = null;
  }
  function Mv(a) {
    a = a.listeners;
    for (var l = 0; l < a.length; l++) (0, a[l])();
  }
  function Dm(a, l) {
    return l;
  }
  function Lm(a, l) {
    if (_n) {
      var p = Zt.formState;
      if (p !== null) {
        e: {
          var g = Jt;
          if (_n) {
            if (Zn) {
              t: {
                for (var M = Zn, A = Rs; M.nodeType !== 8; ) {
                  if (!A) {
                    M = null;
                    break t;
                  }
                  if (((M = po(M.nextSibling)), M === null)) {
                    M = null;
                    break t;
                  }
                }
                ((A = M.data), (M = A === "F!" || A === "F" ? M : null));
              }
              if (M) {
                ((Zn = po(M.nextSibling)), (g = M.data === "F!"));
                break e;
              }
            }
            Ja(g);
          }
          g = !1;
        }
        g && (l = p[0]);
      }
    }
    return (
      (p = Qi()),
      (p.memoizedState = p.baseState = l),
      (g = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Dm,
        lastRenderedState: l,
      }),
      (p.queue = g),
      (p = Vv.bind(null, Jt, g)),
      (g.dispatch = p),
      (g = Am(!1)),
      (A = Bm.bind(null, Jt, !1, g.queue)),
      (g = Qi()),
      (M = { state: l, dispatch: null, action: a, pending: null }),
      (g.queue = M),
      (p = kb.bind(null, Jt, M, A, p)),
      (M.dispatch = p),
      (g.memoizedState = a),
      [l, p, !1]
    );
  }
  function Tv(a) {
    var l = Ri();
    return Nm(l, jn, a);
  }
  function Nm(a, l, p) {
    if (
      ((l = Em(a, l, Dm)[0]),
      (a = pd(No)[0]),
      typeof l == "object" && l !== null && typeof l.then == "function")
    )
      try {
        var g = Of(l);
      } catch (z) {
        throw z === pc ? an : z;
      }
    else g = l;
    l = Ri();
    var M = l.queue,
      A = M.dispatch;
    return (
      p !== l.memoizedState &&
        ((Jt.flags |= 2048),
        _l(9, { destroy: void 0 }, Ev.bind(null, M, p), null)),
      [g, A, a]
    );
  }
  function Ev(a, l) {
    a.action = l;
  }
  function Um(a) {
    var l = Ri(),
      p = jn;
    if (p !== null) return Nm(l, p, a);
    (Ri(), (l = l.memoizedState), (p = Ri()));
    var g = p.queue.dispatch;
    return ((p.memoizedState = a), [l, g, !1]);
  }
  function _l(a, l, p, g) {
    return (
      (a = { tag: a, create: p, deps: g, inst: l, next: null }),
      (l = Jt.updateQueue),
      l === null && ((l = dd()), (Jt.updateQueue = l)),
      (p = l.lastEffect),
      p === null
        ? (l.lastEffect = a.next = a)
        : ((g = p.next), (p.next = a), (a.next = g), (l.lastEffect = a)),
      a
    );
  }
  function md() {
    return Ri().memoizedState;
  }
  function gd(a, l, p, g) {
    var M = Qi();
    ((Jt.flags |= a),
      (M.memoizedState = _l(
        1 | l,
        { destroy: void 0 },
        p,
        g === void 0 ? null : g,
      )));
  }
  function vd(a, l, p, g) {
    var M = Ri();
    g = g === void 0 ? null : g;
    var A = M.memoizedState.inst;
    jn !== null && g !== null && bm(g, jn.memoizedState.deps)
      ? (M.memoizedState = _l(l, A, p, g))
      : ((Jt.flags |= a), (M.memoizedState = _l(1 | l, A, p, g)));
  }
  function wv(a, l) {
    gd(8390656, 8, a, l);
  }
  function Pm(a, l) {
    vd(2048, 8, a, l);
  }
  function Av(a) {
    Jt.flags |= 4;
    var l = Jt.updateQueue;
    if (l === null) ((l = dd()), (Jt.updateQueue = l), (l.events = [a]));
    else {
      var p = l.events;
      p === null ? (l.events = [a]) : p.push(a);
    }
  }
  function Cv(a) {
    var l = Ri().memoizedState;
    return (
      Av({ ref: l, nextImpl: a }),
      function () {
        if ((Ot & 2) !== 0) throw Error(n(440));
        return l.impl.apply(void 0, arguments);
      }
    );
  }
  function Rv(a, l) {
    return vd(4, 2, a, l);
  }
  function Dv(a, l) {
    return vd(4, 4, a, l);
  }
  function Lv(a, l) {
    if (typeof l == "function") {
      a = a();
      var p = l(a);
      return function () {
        typeof p == "function" ? p() : l(null);
      };
    }
    if (l != null)
      return (
        (a = a()),
        (l.current = a),
        function () {
          l.current = null;
        }
      );
  }
  function Nv(a, l, p) {
    ((p = p != null ? p.concat([a]) : null), vd(4, 4, Lv.bind(null, l, a), p));
  }
  function Im() {}
  function Uv(a, l) {
    var p = Ri();
    l = l === void 0 ? null : l;
    var g = p.memoizedState;
    return l !== null && bm(l, g[1]) ? g[0] : ((p.memoizedState = [a, l]), a);
  }
  function Pv(a, l) {
    var p = Ri();
    l = l === void 0 ? null : l;
    var g = p.memoizedState;
    if (l !== null && bm(l, g[1])) return g[0];
    if (((g = a()), bc)) {
      Ze(!0);
      try {
        a();
      } finally {
        Ze(!1);
      }
    }
    return ((p.memoizedState = [g, l]), g);
  }
  function Om(a, l, p) {
    return p === void 0 || ((oi & 1073741824) !== 0 && (sn & 261930) === 0)
      ? (a.memoizedState = l)
      : ((a.memoizedState = p), (a = dn()), (Jt.lanes |= a), (uo |= a), p);
  }
  function Iv(a, l, p, g) {
    return zr(p, l)
      ? p
      : _u.current !== null
        ? ((a = Om(a, p, g)), zr(a, l) || (ji = !0), a)
        : (oi & 42) === 0 || ((oi & 1073741824) !== 0 && (sn & 261930) === 0)
          ? ((ji = !0), (a.memoizedState = p))
          : ((a = dn()), (Jt.lanes |= a), (uo |= a), l);
  }
  function Ov(a, l, p, g, M) {
    var A = $.p;
    $.p = A !== 0 && 8 > A ? A : 8;
    var z = W.T,
      Q = {};
    ((W.T = Q), Bm(a, !1, l, p));
    try {
      var pe = M(),
        Ue = W.S;
      if (
        (Ue !== null && Ue(Q, pe),
        pe !== null && typeof pe == "object" && typeof pe.then == "function")
      ) {
        var tt = dm(pe, g);
        Ff(a, l, tt, Os(a));
      } else Ff(a, l, g, Os(a));
    } catch (at) {
      Ff(a, l, { then: function () {}, status: "rejected", reason: at }, Os());
    } finally {
      (($.p = A),
        z !== null && Q.types !== null && (z.types = Q.types),
        (W.T = z));
    }
  }
  function Vb() {}
  function Fm(a, l, p, g) {
    if (a.tag !== 5) throw Error(n(476));
    var M = Fv(a).queue;
    Ov(
      a,
      M,
      l,
      de,
      p === null
        ? Vb
        : function () {
            return (zv(a), p(g));
          },
    );
  }
  function Fv(a) {
    var l = a.memoizedState;
    if (l !== null) return l;
    l = {
      memoizedState: de,
      baseState: de,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: No,
        lastRenderedState: de,
      },
      next: null,
    };
    var p = {};
    return (
      (l.next = {
        memoizedState: p,
        baseState: p,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: No,
          lastRenderedState: p,
        },
        next: null,
      }),
      (a.memoizedState = l),
      (a = a.alternate),
      a !== null && (a.memoizedState = l),
      l
    );
  }
  function zv(a) {
    var l = Fv(a);
    (l.next === null && (l = a.alternate.memoizedState),
      Ff(a, l.next.queue, {}, Os()));
  }
  function zm() {
    return Xt(ag);
  }
  function Bv() {
    return Ri().memoizedState;
  }
  function kv() {
    return Ri().memoizedState;
  }
  function Gb(a) {
    for (var l = a.return; l !== null; ) {
      switch (l.tag) {
        case 24:
        case 3:
          var p = Os();
          a = Do(p);
          var g = yl(l, a, p);
          (g !== null && (ln(g, l, p), xl(g, l, p)),
            (l = { cache: um() }),
            (a.payload = l));
          return;
      }
      l = l.return;
    }
  }
  function Hb(a, l, p) {
    var g = Os();
    ((p = {
      lane: g,
      revertLane: 0,
      gesture: null,
      action: p,
      hasEagerState: !1,
      eagerState: null,
      next: null,
    }),
      yd(a)
        ? Gv(l, p)
        : ((p = Zh(a, l, p, g)), p !== null && (ln(p, a, g), Hv(p, l, g))));
  }
  function Vv(a, l, p) {
    var g = Os();
    Ff(a, l, p, g);
  }
  function Ff(a, l, p, g) {
    var M = {
      lane: g,
      revertLane: 0,
      gesture: null,
      action: p,
      hasEagerState: !1,
      eagerState: null,
      next: null,
    };
    if (yd(a)) Gv(l, M);
    else {
      var A = a.alternate;
      if (
        a.lanes === 0 &&
        (A === null || A.lanes === 0) &&
        ((A = l.lastRenderedReducer), A !== null)
      )
        try {
          var z = l.lastRenderedState,
            Q = A(z, p);
          if (((M.hasEagerState = !0), (M.eagerState = Q), zr(Q, z)))
            return (lr(a, l, M, 0), Zt === null && wf(), !1);
        } catch {
        } finally {
        }
      if (((p = Zh(a, l, M, g)), p !== null))
        return (ln(p, a, g), Hv(p, l, g), !0);
    }
    return !1;
  }
  function Bm(a, l, p, g) {
    if (
      ((g = {
        lane: 2,
        revertLane: He(),
        gesture: null,
        action: g,
        hasEagerState: !1,
        eagerState: null,
        next: null,
      }),
      yd(a))
    ) {
      if (l) throw Error(n(479));
    } else ((l = Zh(a, p, g, 2)), l !== null && ln(l, a, 2));
  }
  function yd(a) {
    var l = a.alternate;
    return a === Jt || (l !== null && l === Jt);
  }
  function Gv(a, l) {
    Su = ra = !0;
    var p = a.pending;
    (p === null ? (l.next = l) : ((l.next = p.next), (p.next = l)),
      (a.pending = l));
  }
  function Hv(a, l, p) {
    if ((p & 4194048) !== 0) {
      var g = l.lanes;
      ((g &= a.pendingLanes), (p |= g), (l.lanes = p), Ai(a, p));
    }
  }
  var Tu = {
    readContext: Xt,
    use: bl,
    useCallback: di,
    useContext: di,
    useEffect: di,
    useImperativeHandle: di,
    useLayoutEffect: di,
    useInsertionEffect: di,
    useMemo: di,
    useReducer: di,
    useRef: di,
    useState: di,
    useDebugValue: di,
    useDeferredValue: di,
    useTransition: di,
    useSyncExternalStore: di,
    useId: di,
    useHostTransitionStatus: di,
    useFormState: di,
    useActionState: di,
    useOptimistic: di,
    useMemoCache: di,
    useCacheRefresh: di,
  };
  Tu.useEffectEvent = di;
  var jv = {
      readContext: Xt,
      use: bl,
      useCallback: function (a, l) {
        return ((Qi().memoizedState = [a, l === void 0 ? null : l]), a);
      },
      useContext: Xt,
      useEffect: wv,
      useImperativeHandle: function (a, l, p) {
        ((p = p != null ? p.concat([a]) : null),
          gd(4194308, 4, Lv.bind(null, l, a), p));
      },
      useLayoutEffect: function (a, l) {
        return gd(4194308, 4, a, l);
      },
      useInsertionEffect: function (a, l) {
        gd(4, 2, a, l);
      },
      useMemo: function (a, l) {
        var p = Qi();
        l = l === void 0 ? null : l;
        var g = a();
        if (bc) {
          Ze(!0);
          try {
            a();
          } finally {
            Ze(!1);
          }
        }
        return ((p.memoizedState = [g, l]), g);
      },
      useReducer: function (a, l, p) {
        var g = Qi();
        if (p !== void 0) {
          var M = p(l);
          if (bc) {
            Ze(!0);
            try {
              p(l);
            } finally {
              Ze(!1);
            }
          }
        } else M = l;
        return (
          (g.memoizedState = g.baseState = M),
          (a = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: a,
            lastRenderedState: M,
          }),
          (g.queue = a),
          (a = a.dispatch = Hb.bind(null, Jt, a)),
          [g.memoizedState, a]
        );
      },
      useRef: function (a) {
        var l = Qi();
        return ((a = { current: a }), (l.memoizedState = a));
      },
      useState: function (a) {
        a = Am(a);
        var l = a.queue,
          p = Vv.bind(null, Jt, l);
        return ((l.dispatch = p), [a.memoizedState, p]);
      },
      useDebugValue: Im,
      useDeferredValue: function (a, l) {
        var p = Qi();
        return Om(p, a, l);
      },
      useTransition: function () {
        var a = Am(!1);
        return (
          (a = Ov.bind(null, Jt, a.queue, !0, !1)),
          (Qi().memoizedState = a),
          [!1, a]
        );
      },
      useSyncExternalStore: function (a, l, p) {
        var g = Jt,
          M = Qi();
        if (_n) {
          if (p === void 0) throw Error(n(407));
          p = p();
        } else {
          if (((p = l()), Zt === null)) throw Error(n(349));
          (sn & 127) !== 0 || mv(g, l, p);
        }
        M.memoizedState = p;
        var A = { value: p, getSnapshot: l };
        return (
          (M.queue = A),
          wv(vv.bind(null, g, A, a), [a]),
          (g.flags |= 2048),
          _l(9, { destroy: void 0 }, gv.bind(null, g, A, p, l), null),
          p
        );
      },
      useId: function () {
        var a = Qi(),
          l = Zt.identifierPrefix;
        if (_n) {
          var p = Ea,
            g = hi;
          ((p = (g & ~(1 << (32 - re(g) - 1))).toString(32) + p),
            (l = "_" + l + "R_" + p),
            (p = fd++),
            0 < p && (l += "H" + p.toString(32)),
            (l += "_"));
        } else ((p = xm++), (l = "_" + l + "r_" + p.toString(32) + "_"));
        return (a.memoizedState = l);
      },
      useHostTransitionStatus: zm,
      useFormState: Lm,
      useActionState: Lm,
      useOptimistic: function (a) {
        var l = Qi();
        l.memoizedState = l.baseState = a;
        var p = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: null,
          lastRenderedState: null,
        };
        return (
          (l.queue = p),
          (l = Bm.bind(null, Jt, !0, p)),
          (p.dispatch = l),
          [a, l]
        );
      },
      useMemoCache: Tm,
      useCacheRefresh: function () {
        return (Qi().memoizedState = Gb.bind(null, Jt));
      },
      useEffectEvent: function (a) {
        var l = Qi(),
          p = { impl: a };
        return (
          (l.memoizedState = p),
          function () {
            if ((Ot & 2) !== 0) throw Error(n(440));
            return p.impl.apply(void 0, arguments);
          }
        );
      },
    },
    km = {
      readContext: Xt,
      use: bl,
      useCallback: Uv,
      useContext: Xt,
      useEffect: Pm,
      useImperativeHandle: Nv,
      useInsertionEffect: Rv,
      useLayoutEffect: Dv,
      useMemo: Pv,
      useReducer: pd,
      useRef: md,
      useState: function () {
        return pd(No);
      },
      useDebugValue: Im,
      useDeferredValue: function (a, l) {
        var p = Ri();
        return Iv(p, jn.memoizedState, a, l);
      },
      useTransition: function () {
        var a = pd(No)[0],
          l = Ri().memoizedState;
        return [typeof a == "boolean" ? a : Of(a), l];
      },
      useSyncExternalStore: pv,
      useId: Bv,
      useHostTransitionStatus: zm,
      useFormState: Tv,
      useActionState: Tv,
      useOptimistic: function (a, l) {
        var p = Ri();
        return Cm(p, jn, a, l);
      },
      useMemoCache: Tm,
      useCacheRefresh: kv,
    };
  km.useEffectEvent = Cv;
  var sa = {
    readContext: Xt,
    use: bl,
    useCallback: Uv,
    useContext: Xt,
    useEffect: Pm,
    useImperativeHandle: Nv,
    useInsertionEffect: Rv,
    useLayoutEffect: Dv,
    useMemo: Pv,
    useReducer: wm,
    useRef: md,
    useState: function () {
      return wm(No);
    },
    useDebugValue: Im,
    useDeferredValue: function (a, l) {
      var p = Ri();
      return jn === null ? Om(p, a, l) : Iv(p, jn.memoizedState, a, l);
    },
    useTransition: function () {
      var a = wm(No)[0],
        l = Ri().memoizedState;
      return [typeof a == "boolean" ? a : Of(a), l];
    },
    useSyncExternalStore: pv,
    useId: Bv,
    useHostTransitionStatus: zm,
    useFormState: Um,
    useActionState: Um,
    useOptimistic: function (a, l) {
      var p = Ri();
      return jn !== null
        ? Cm(p, jn, a, l)
        : ((p.baseState = a), [a, p.queue.dispatch]);
    },
    useMemoCache: Tm,
    useCacheRefresh: kv,
  };
  sa.useEffectEvent = Cv;
  function xd(a, l, p, g) {
    ((l = a.memoizedState),
      (p = p(g, l)),
      (p = p == null ? l : v({}, l, p)),
      (a.memoizedState = p),
      a.lanes === 0 && (a.updateQueue.baseState = p));
  }
  var zf = {
    enqueueSetState: function (a, l, p) {
      a = a._reactInternals;
      var g = Os(),
        M = Do(g);
      ((M.payload = l),
        p != null && (M.callback = p),
        (l = yl(a, M, g)),
        l !== null && (ln(l, a, g), xl(l, a, g)));
    },
    enqueueReplaceState: function (a, l, p) {
      a = a._reactInternals;
      var g = Os(),
        M = Do(g);
      ((M.tag = 1),
        (M.payload = l),
        p != null && (M.callback = p),
        (l = yl(a, M, g)),
        l !== null && (ln(l, a, g), xl(l, a, g)));
    },
    enqueueForceUpdate: function (a, l) {
      a = a._reactInternals;
      var p = Os(),
        g = Do(p);
      ((g.tag = 2),
        l != null && (g.callback = l),
        (l = yl(a, g, p)),
        l !== null && (ln(l, a, p), xl(l, a, p)));
    },
  };
  function Vm(a, l, p, g, M, A, z) {
    return (
      (a = a.stateNode),
      typeof a.shouldComponentUpdate == "function"
        ? a.shouldComponentUpdate(g, A, z)
        : l.prototype && l.prototype.isPureReactComponent
          ? !au(p, g) || !au(M, A)
          : !0
    );
  }
  function Gm(a, l, p, g) {
    ((a = l.state),
      typeof l.componentWillReceiveProps == "function" &&
        l.componentWillReceiveProps(p, g),
      typeof l.UNSAFE_componentWillReceiveProps == "function" &&
        l.UNSAFE_componentWillReceiveProps(p, g),
      l.state !== a && zf.enqueueReplaceState(l, l.state, null));
  }
  function Sl(a, l) {
    var p = l;
    if ("ref" in l) {
      p = {};
      for (var g in l) g !== "ref" && (p[g] = l[g]);
    }
    if ((a = a.defaultProps)) {
      p === l && (p = v({}, p));
      for (var M in a) p[M] === void 0 && (p[M] = a[M]);
    }
    return p;
  }
  function Wv(a) {
    Ef(a);
  }
  function Hm(a) {
    console.error(a);
  }
  function jm(a) {
    Ef(a);
  }
  function bd(a, l) {
    try {
      var p = a.onUncaughtError;
      p(l.value, { componentStack: l.stack });
    } catch (g) {
      setTimeout(function () {
        throw g;
      });
    }
  }
  function Xv(a, l, p) {
    try {
      var g = a.onCaughtError;
      g(p.value, {
        componentStack: p.stack,
        errorBoundary: l.tag === 1 ? l.stateNode : null,
      });
    } catch (M) {
      setTimeout(function () {
        throw M;
      });
    }
  }
  function Wm(a, l, p) {
    return (
      (p = Do(p)),
      (p.tag = 3),
      (p.payload = { element: null }),
      (p.callback = function () {
        bd(a, l);
      }),
      p
    );
  }
  function Xm(a) {
    return ((a = Do(a)), (a.tag = 3), a);
  }
  function qv(a, l, p, g) {
    var M = p.type.getDerivedStateFromError;
    if (typeof M == "function") {
      var A = g.value;
      ((a.payload = function () {
        return M(A);
      }),
        (a.callback = function () {
          Xv(l, p, g);
        }));
    }
    var z = p.stateNode;
    z !== null &&
      typeof z.componentDidCatch == "function" &&
      (a.callback = function () {
        (Xv(l, p, g),
          typeof M != "function" &&
            (Ni === null ? (Ni = new Set([this])) : Ni.add(this)));
        var Q = g.stack;
        this.componentDidCatch(g.value, {
          componentStack: Q !== null ? Q : "",
        });
      });
  }
  function Ji(a, l, p, g, M) {
    if (
      ((p.flags |= 32768),
      g !== null && typeof g == "object" && typeof g.then == "function")
    ) {
      if (
        ((l = p.alternate),
        l !== null && no(l, p, M, !0),
        (p = as.current),
        p !== null)
      ) {
        switch (p.tag) {
          case 31:
          case 13:
            return (
              Vr === null ? Lu() : p.alternate === null && pi === 0 && (pi = 3),
              (p.flags &= -257),
              (p.flags |= 65536),
              (p.lanes = M),
              g === ad
                ? (p.flags |= 16384)
                : ((l = p.updateQueue),
                  l === null ? (p.updateQueue = new Set([g])) : l.add(g),
                  Kf(a, g, M)),
              !1
            );
          case 22:
            return (
              (p.flags |= 65536),
              g === ad
                ? (p.flags |= 16384)
                : ((l = p.updateQueue),
                  l === null
                    ? ((l = {
                        transitions: null,
                        markerInstances: null,
                        retryQueue: new Set([g]),
                      }),
                      (p.updateQueue = l))
                    : ((p = l.retryQueue),
                      p === null ? (l.retryQueue = new Set([g])) : p.add(g)),
                  Kf(a, g, M)),
              !1
            );
        }
        throw Error(n(435, p.tag));
      }
      return (Kf(a, g, M), Lu(), !1);
    }
    if (_n)
      return (
        (l = as.current),
        l !== null
          ? ((l.flags & 65536) === 0 && (l.flags |= 256),
            (l.flags |= 65536),
            (l.lanes = M),
            g !== pu && ((a = Error(n(422), { cause: g })), $a(Cs(a, p))))
          : (g !== pu && ((l = Error(n(423), { cause: g })), $a(Cs(l, p))),
            (a = a.current.alternate),
            (a.flags |= 65536),
            (M &= -M),
            (a.lanes |= M),
            (g = Cs(g, p)),
            (M = Wm(a.stateNode, g, M)),
            Bt(a, M),
            pi !== 4 && (pi = 2)),
        !1
      );
    var A = Error(n(520), { cause: g });
    if (
      ((A = Cs(A, p)),
      Dc === null ? (Dc = [A]) : Dc.push(A),
      pi !== 4 && (pi = 2),
      l === null)
    )
      return !0;
    ((g = Cs(g, p)), (p = l));
    do {
      switch (p.tag) {
        case 3:
          return (
            (p.flags |= 65536),
            (a = M & -M),
            (p.lanes |= a),
            (a = Wm(p.stateNode, g, a)),
            Bt(p, a),
            !1
          );
        case 1:
          if (
            ((l = p.type),
            (A = p.stateNode),
            (p.flags & 128) === 0 &&
              (typeof l.getDerivedStateFromError == "function" ||
                (A !== null &&
                  typeof A.componentDidCatch == "function" &&
                  (Ni === null || !Ni.has(A)))))
          )
            return (
              (p.flags |= 65536),
              (M &= -M),
              (p.lanes |= M),
              (M = Xm(M)),
              qv(M, a, p, g),
              Bt(p, M),
              !1
            );
      }
      p = p.return;
    } while (p !== null);
    return !1;
  }
  var _d = Error(n(461)),
    ji = !1;
  function cr(a, l, p, g) {
    l.child = a === null ? cd(l, null, p, g) : Ro(l, a.child, p, g);
  }
  function qm(a, l, p, g, M) {
    p = p.render;
    var A = l.ref;
    if ("ref" in g) {
      var z = {};
      for (var Q in g) Q !== "ref" && (z[Q] = g[Q]);
    } else z = g;
    return (
      gl(l),
      (g = hd(a, l, p, z, A, M)),
      (Q = _m()),
      a !== null && !ji
        ? (Sm(a, l, M), Di(a, l, M))
        : (_n && Q && Qa(l), (l.flags |= 1), cr(a, l, g, M), l.child)
    );
  }
  function Mc(a, l, p, g, M) {
    if (a === null) {
      var A = p.type;
      return typeof A == "function" &&
        !Kh(A) &&
        A.defaultProps === void 0 &&
        p.compare === null
        ? ((l.tag = 15), (l.type = A), Sd(a, l, A, g, M))
        : ((a = Za(p.type, null, g, l, l.mode, M)),
          (a.ref = l.ref),
          (a.return = l),
          (l.child = a));
    }
    if (((A = a.child), !Cd(a, M))) {
      var z = A.memoizedProps;
      if (
        ((p = p.compare), (p = p !== null ? p : au), p(z, g) && a.ref === l.ref)
      )
        return Di(a, l, M);
    }
    return (
      (l.flags |= 1),
      (a = is(A, g)),
      (a.ref = l.ref),
      (a.return = l),
      (l.child = a)
    );
  }
  function Sd(a, l, p, g, M) {
    if (a !== null) {
      var A = a.memoizedProps;
      if (au(A, g) && a.ref === l.ref)
        if (((ji = !1), (l.pendingProps = g = A), Cd(a, M)))
          (a.flags & 131072) !== 0 && (ji = !0);
        else return ((l.lanes = a.lanes), Di(a, l, M));
    }
    return Eu(a, l, p, g, M);
  }
  function Tc(a, l, p, g) {
    var M = g.children,
      A = a !== null ? a.memoizedState : null;
    if (
      (a === null &&
        l.stateNode === null &&
        (l.stateNode = {
          _visibility: 1,
          _pendingMarkers: null,
          _retryCache: null,
          _transitions: null,
        }),
      g.mode === "hidden")
    ) {
      if ((l.flags & 128) !== 0) {
        if (((A = A !== null ? A.baseLanes | p : p), a !== null)) {
          for (g = l.child = a.child, M = 0; g !== null; )
            ((M = M | g.lanes | g.childLanes), (g = g.sibling));
          g = M & ~A;
        } else ((g = 0), (l.child = null));
        return ls(a, l, A, p, g);
      }
      if ((p & 536870912) !== 0)
        ((l.memoizedState = { baseLanes: 0, cachePool: null }),
          a !== null && Rf(l, A !== null ? A.cachePool : null),
          A !== null ? fv(l, A) : vm(),
          hv(l));
      else
        return (
          (g = l.lanes = 536870912),
          ls(a, l, A !== null ? A.baseLanes | p : p, p, g)
        );
    } else
      A !== null
        ? (Rf(l, A.cachePool), fv(l, A), os(), (l.memoizedState = null))
        : (a !== null && Rf(l, null), vm(), os());
    return (cr(a, l, M, p), l.child);
  }
  function ro(a, l) {
    return (
      (a !== null && a.tag === 22) ||
        l.stateNode !== null ||
        (l.stateNode = {
          _visibility: 1,
          _pendingMarkers: null,
          _retryCache: null,
          _transitions: null,
        }),
      l.sibling
    );
  }
  function ls(a, l, p, g, M) {
    var A = sd();
    return (
      (A = A === null ? null : { parent: Hi._currentValue, pool: A }),
      (l.memoizedState = { baseLanes: p, cachePool: A }),
      a !== null && Rf(l, null),
      vm(),
      hv(l),
      a !== null && no(a, l, g, !0),
      (l.childLanes = M),
      null
    );
  }
  function Md(a, l) {
    return (
      (l = Ad({ mode: l.mode, children: l.children }, a.mode)),
      (l.ref = a.ref),
      (a.child = l),
      (l.return = a),
      l
    );
  }
  function Yv(a, l, p) {
    return (
      Ro(l, a.child, null, p),
      (a = Md(l, l.pendingProps)),
      (a.flags |= 2),
      Ci(l),
      (l.memoizedState = null),
      a
    );
  }
  function Td(a, l, p) {
    var g = l.pendingProps,
      M = (l.flags & 128) !== 0;
    if (((l.flags &= -129), a === null)) {
      if (_n) {
        if (g.mode === "hidden")
          return ((a = Md(l, g)), (l.lanes = 536870912), ro(null, a));
        if (
          (ym(l),
          (a = Zn)
            ? ((a = BE(a, Rs)),
              (a = a !== null && a.data === "&" ? a : null),
              a !== null &&
                ((l.memoizedState = {
                  dehydrated: a,
                  treeContext: Eo !== null ? { id: hi, overflow: Ea } : null,
                  retryLane: 536870912,
                  hydrationErrors: null,
                }),
                (p = fu(a)),
                (p.return = l),
                (l.child = p),
                (_i = l),
                (Zn = null)))
            : (a = null),
          a === null)
        )
          throw Ja(l);
        return ((l.lanes = 536870912), null);
      }
      return Md(l, g);
    }
    var A = a.memoizedState;
    if (A !== null) {
      var z = A.dehydrated;
      if ((ym(l), M))
        if (l.flags & 256) ((l.flags &= -257), (l = Yv(a, l, p)));
        else if (l.memoizedState !== null)
          ((l.child = a.child), (l.flags |= 128), (l = null));
        else throw Error(n(558));
      else if (
        (ji || no(a, l, p, !1), (M = (p & a.childLanes) !== 0), ji || M)
      ) {
        if (
          ((g = Zt),
          g !== null && ((z = $r(g, p)), z !== 0 && z !== A.retryLane))
        )
          throw ((A.retryLane = z), Br(a, z), ln(g, a, z), _d);
        (Lu(), (l = Yv(a, l, p)));
      } else
        ((a = A.treeContext),
          (Zn = po(z.nextSibling)),
          (_i = l),
          (_n = !0),
          (wo = null),
          (Rs = !1),
          a !== null && ed(l, a),
          (l = Md(l, g)),
          (l.flags |= 4096));
      return l;
    }
    return (
      (a = is(a.child, { mode: g.mode, children: g.children })),
      (a.ref = l.ref),
      (l.child = a),
      (a.return = l),
      a
    );
  }
  function Ec(a, l) {
    var p = l.ref;
    if (p === null) a !== null && a.ref !== null && (l.flags |= 4194816);
    else {
      if (typeof p != "function" && typeof p != "object") throw Error(n(284));
      (a === null || a.ref !== p) && (l.flags |= 4194816);
    }
  }
  function Eu(a, l, p, g, M) {
    return (
      gl(l),
      (p = hd(a, l, p, g, void 0, M)),
      (g = _m()),
      a !== null && !ji
        ? (Sm(a, l, M), Di(a, l, M))
        : (_n && g && Qa(l), (l.flags |= 1), cr(a, l, p, M), l.child)
    );
  }
  function Bf(a, l, p, g, M, A) {
    return (
      gl(l),
      (l.updateQueue = null),
      (p = _c(l, g, p, M)),
      dv(a),
      (g = _m()),
      a !== null && !ji
        ? (Sm(a, l, A), Di(a, l, A))
        : (_n && g && Qa(l), (l.flags |= 1), cr(a, l, p, A), l.child)
    );
  }
  function Ed(a, l, p, g, M) {
    if ((gl(l), l.stateNode === null)) {
      var A = ul,
        z = p.contextType;
      (typeof z == "object" && z !== null && (A = Xt(z)),
        (A = new p(g, A)),
        (l.memoizedState =
          A.state !== null && A.state !== void 0 ? A.state : null),
        (A.updater = zf),
        (l.stateNode = A),
        (A._reactInternals = l),
        (A = l.stateNode),
        (A.props = g),
        (A.state = l.memoizedState),
        (A.refs = {}),
        Nf(l),
        (z = p.contextType),
        (A.context = typeof z == "object" && z !== null ? Xt(z) : ul),
        (A.state = l.memoizedState),
        (z = p.getDerivedStateFromProps),
        typeof z == "function" && (xd(l, p, z, g), (A.state = l.memoizedState)),
        typeof p.getDerivedStateFromProps == "function" ||
          typeof A.getSnapshotBeforeUpdate == "function" ||
          (typeof A.UNSAFE_componentWillMount != "function" &&
            typeof A.componentWillMount != "function") ||
          ((z = A.state),
          typeof A.componentWillMount == "function" && A.componentWillMount(),
          typeof A.UNSAFE_componentWillMount == "function" &&
            A.UNSAFE_componentWillMount(),
          z !== A.state && zf.enqueueReplaceState(A, A.state, null),
          xu(l, g, A, M),
          Uf(),
          (A.state = l.memoizedState)),
        typeof A.componentDidMount == "function" && (l.flags |= 4194308),
        (g = !0));
    } else if (a === null) {
      A = l.stateNode;
      var Q = l.memoizedProps,
        pe = Sl(p, Q);
      A.props = pe;
      var Ue = A.context,
        tt = p.contextType;
      ((z = ul), typeof tt == "object" && tt !== null && (z = Xt(tt)));
      var at = p.getDerivedStateFromProps;
      ((tt =
        typeof at == "function" ||
        typeof A.getSnapshotBeforeUpdate == "function"),
        (Q = l.pendingProps !== Q),
        tt ||
          (typeof A.UNSAFE_componentWillReceiveProps != "function" &&
            typeof A.componentWillReceiveProps != "function") ||
          ((Q || Ue !== z) && Gm(l, A, g, z)),
        (kr = !1));
      var Be = l.memoizedState;
      ((A.state = Be),
        xu(l, g, A, M),
        Uf(),
        (Ue = l.memoizedState),
        Q || Be !== Ue || kr
          ? (typeof at == "function" &&
              (xd(l, p, at, g), (Ue = l.memoizedState)),
            (pe = kr || Vm(l, p, pe, g, Be, Ue, z))
              ? (tt ||
                  (typeof A.UNSAFE_componentWillMount != "function" &&
                    typeof A.componentWillMount != "function") ||
                  (typeof A.componentWillMount == "function" &&
                    A.componentWillMount(),
                  typeof A.UNSAFE_componentWillMount == "function" &&
                    A.UNSAFE_componentWillMount()),
                typeof A.componentDidMount == "function" &&
                  (l.flags |= 4194308))
              : (typeof A.componentDidMount == "function" &&
                  (l.flags |= 4194308),
                (l.memoizedProps = g),
                (l.memoizedState = Ue)),
            (A.props = g),
            (A.state = Ue),
            (A.context = z),
            (g = pe))
          : (typeof A.componentDidMount == "function" && (l.flags |= 4194308),
            (g = !1)));
    } else {
      ((A = l.stateNode),
        mm(a, l),
        (z = l.memoizedProps),
        (tt = Sl(p, z)),
        (A.props = tt),
        (at = l.pendingProps),
        (Be = A.context),
        (Ue = p.contextType),
        (pe = ul),
        typeof Ue == "object" && Ue !== null && (pe = Xt(Ue)),
        (Q = p.getDerivedStateFromProps),
        (Ue =
          typeof Q == "function" ||
          typeof A.getSnapshotBeforeUpdate == "function") ||
          (typeof A.UNSAFE_componentWillReceiveProps != "function" &&
            typeof A.componentWillReceiveProps != "function") ||
          ((z !== at || Be !== pe) && Gm(l, A, g, pe)),
        (kr = !1),
        (Be = l.memoizedState),
        (A.state = Be),
        xu(l, g, A, M),
        Uf());
      var Xe = l.memoizedState;
      z !== at ||
      Be !== Xe ||
      kr ||
      (a !== null && a.dependencies !== null && Cf(a.dependencies))
        ? (typeof Q == "function" && (xd(l, p, Q, g), (Xe = l.memoizedState)),
          (tt =
            kr ||
            Vm(l, p, tt, g, Be, Xe, pe) ||
            (a !== null && a.dependencies !== null && Cf(a.dependencies)))
            ? (Ue ||
                (typeof A.UNSAFE_componentWillUpdate != "function" &&
                  typeof A.componentWillUpdate != "function") ||
                (typeof A.componentWillUpdate == "function" &&
                  A.componentWillUpdate(g, Xe, pe),
                typeof A.UNSAFE_componentWillUpdate == "function" &&
                  A.UNSAFE_componentWillUpdate(g, Xe, pe)),
              typeof A.componentDidUpdate == "function" && (l.flags |= 4),
              typeof A.getSnapshotBeforeUpdate == "function" &&
                (l.flags |= 1024))
            : (typeof A.componentDidUpdate != "function" ||
                (z === a.memoizedProps && Be === a.memoizedState) ||
                (l.flags |= 4),
              typeof A.getSnapshotBeforeUpdate != "function" ||
                (z === a.memoizedProps && Be === a.memoizedState) ||
                (l.flags |= 1024),
              (l.memoizedProps = g),
              (l.memoizedState = Xe)),
          (A.props = g),
          (A.state = Xe),
          (A.context = pe),
          (g = tt))
        : (typeof A.componentDidUpdate != "function" ||
            (z === a.memoizedProps && Be === a.memoizedState) ||
            (l.flags |= 4),
          typeof A.getSnapshotBeforeUpdate != "function" ||
            (z === a.memoizedProps && Be === a.memoizedState) ||
            (l.flags |= 1024),
          (g = !1));
    }
    return (
      (A = g),
      Ec(a, l),
      (g = (l.flags & 128) !== 0),
      A || g
        ? ((A = l.stateNode),
          (p =
            g && typeof p.getDerivedStateFromError != "function"
              ? null
              : A.render()),
          (l.flags |= 1),
          a !== null && g
            ? ((l.child = Ro(l, a.child, null, M)),
              (l.child = Ro(l, null, p, M)))
            : cr(a, l, p, M),
          (l.memoizedState = A.state),
          (a = l.child))
        : (a = Di(a, l, M)),
      a
    );
  }
  function Zv(a, l, p, g) {
    return (pl(), (l.flags |= 256), cr(a, l, p, g), l.child);
  }
  var Ym = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0,
    hydrationErrors: null,
  };
  function Dr(a) {
    return { baseLanes: a, cachePool: pm() };
  }
  function wd(a, l, p) {
    return ((a = a !== null ? a.childLanes & ~p : 0), l && (a |= jr), a);
  }
  function Kv(a, l, p) {
    var g = l.pendingProps,
      M = !1,
      A = (l.flags & 128) !== 0,
      z;
    if (
      ((z = A) ||
        (z =
          a !== null && a.memoizedState === null ? !1 : (Sn.current & 2) !== 0),
      z && ((M = !0), (l.flags &= -129)),
      (z = (l.flags & 32) !== 0),
      (l.flags &= -33),
      a === null)
    ) {
      if (_n) {
        if (
          (M ? Lo(l) : os(),
          (a = Zn)
            ? ((a = BE(a, Rs)),
              (a = a !== null && a.data !== "&" ? a : null),
              a !== null &&
                ((l.memoizedState = {
                  dehydrated: a,
                  treeContext: Eo !== null ? { id: hi, overflow: Ea } : null,
                  retryLane: 536870912,
                  hydrationErrors: null,
                }),
                (p = fu(a)),
                (p.return = l),
                (l.child = p),
                (_i = l),
                (Zn = null)))
            : (a = null),
          a === null)
        )
          throw Ja(l);
        return (i_(a) ? (l.lanes = 32) : (l.lanes = 536870912), null);
      }
      var Q = g.children;
      return (
        (g = g.fallback),
        M
          ? (os(),
            (M = l.mode),
            (Q = Ad({ mode: "hidden", children: Q }, M)),
            (g = fl(g, M, p, null)),
            (Q.return = l),
            (g.return = l),
            (Q.sibling = g),
            (l.child = Q),
            (g = l.child),
            (g.memoizedState = Dr(p)),
            (g.childLanes = wd(a, z, p)),
            (l.memoizedState = Ym),
            ro(null, g))
          : (Lo(l), kf(l, Q))
      );
    }
    var pe = a.memoizedState;
    if (pe !== null && ((Q = pe.dehydrated), Q !== null)) {
      if (A)
        l.flags & 256
          ? (Lo(l), (l.flags &= -257), (l = Zm(a, l, p)))
          : l.memoizedState !== null
            ? (os(), (l.child = a.child), (l.flags |= 128), (l = null))
            : (os(),
              (Q = g.fallback),
              (M = l.mode),
              (g = Ad({ mode: "visible", children: g.children }, M)),
              (Q = fl(Q, M, p, null)),
              (Q.flags |= 2),
              (g.return = l),
              (Q.return = l),
              (g.sibling = Q),
              (l.child = g),
              Ro(l, a.child, null, p),
              (g = l.child),
              (g.memoizedState = Dr(p)),
              (g.childLanes = wd(a, z, p)),
              (l.memoizedState = Ym),
              (l = ro(null, g)));
      else if ((Lo(l), i_(Q))) {
        if (((z = Q.nextSibling && Q.nextSibling.dataset), z)) var Ue = z.dgst;
        ((z = Ue),
          (g = Error(n(419))),
          (g.stack = ""),
          (g.digest = z),
          $a({ value: g, source: null, stack: null }),
          (l = Zm(a, l, p)));
      } else if (
        (ji || no(a, l, p, !1), (z = (p & a.childLanes) !== 0), ji || z)
      ) {
        if (
          ((z = Zt),
          z !== null && ((g = $r(z, p)), g !== 0 && g !== pe.retryLane))
        )
          throw ((pe.retryLane = g), Br(a, g), ln(z, a, g), _d);
        (n_(Q) || Lu(), (l = Zm(a, l, p)));
      } else
        n_(Q)
          ? ((l.flags |= 192), (l.child = a.child), (l = null))
          : ((a = pe.treeContext),
            (Zn = po(Q.nextSibling)),
            (_i = l),
            (_n = !0),
            (wo = null),
            (Rs = !1),
            a !== null && ed(l, a),
            (l = kf(l, g.children)),
            (l.flags |= 4096));
      return l;
    }
    return M
      ? (os(),
        (Q = g.fallback),
        (M = l.mode),
        (pe = a.child),
        (Ue = pe.sibling),
        (g = is(pe, { mode: "hidden", children: g.children })),
        (g.subtreeFlags = pe.subtreeFlags & 65011712),
        Ue !== null
          ? (Q = is(Ue, Q))
          : ((Q = fl(Q, M, p, null)), (Q.flags |= 2)),
        (Q.return = l),
        (g.return = l),
        (g.sibling = Q),
        (l.child = g),
        ro(null, g),
        (g = l.child),
        (Q = a.child.memoizedState),
        Q === null
          ? (Q = Dr(p))
          : ((M = Q.cachePool),
            M !== null
              ? ((pe = Hi._currentValue),
                (M = M.parent !== pe ? { parent: pe, pool: pe } : M))
              : (M = pm()),
            (Q = { baseLanes: Q.baseLanes | p, cachePool: M })),
        (g.memoizedState = Q),
        (g.childLanes = wd(a, z, p)),
        (l.memoizedState = Ym),
        ro(a.child, g))
      : (Lo(l),
        (p = a.child),
        (a = p.sibling),
        (p = is(p, { mode: "visible", children: g.children })),
        (p.return = l),
        (p.sibling = null),
        a !== null &&
          ((z = l.deletions),
          z === null ? ((l.deletions = [a]), (l.flags |= 16)) : z.push(a)),
        (l.child = p),
        (l.memoizedState = null),
        p);
  }
  function kf(a, l) {
    return (
      (l = Ad({ mode: "visible", children: l }, a.mode)),
      (l.return = a),
      (a.child = l)
    );
  }
  function Ad(a, l) {
    return ((a = fi(22, a, null, l)), (a.lanes = 0), a);
  }
  function Zm(a, l, p) {
    return (
      Ro(l, a.child, null, p),
      (a = kf(l, l.pendingProps.children)),
      (a.flags |= 2),
      (l.memoizedState = null),
      a
    );
  }
  function Qv(a, l, p) {
    a.lanes |= l;
    var g = a.alternate;
    (g !== null && (g.lanes |= l), nd(a.return, l, p));
  }
  function wc(a, l, p, g, M, A) {
    var z = a.memoizedState;
    z === null
      ? (a.memoizedState = {
          isBackwards: l,
          rendering: null,
          renderingStartTime: 0,
          last: g,
          tail: p,
          tailMode: M,
          treeForkCount: A,
        })
      : ((z.isBackwards = l),
        (z.rendering = null),
        (z.renderingStartTime = 0),
        (z.last = g),
        (z.tail = p),
        (z.tailMode = M),
        (z.treeForkCount = A));
  }
  function cs(a, l, p) {
    var g = l.pendingProps,
      M = g.revealOrder,
      A = g.tail;
    g = g.children;
    var z = Sn.current,
      Q = (z & 2) !== 0;
    if (
      (Q ? ((z = (z & 1) | 2), (l.flags |= 128)) : (z &= 1),
      se(Sn, z),
      cr(a, l, g, p),
      (g = _n ? du : 0),
      !Q && a !== null && (a.flags & 128) !== 0)
    )
      e: for (a = l.child; a !== null; ) {
        if (a.tag === 13) a.memoizedState !== null && Qv(a, p, l);
        else if (a.tag === 19) Qv(a, p, l);
        else if (a.child !== null) {
          ((a.child.return = a), (a = a.child));
          continue;
        }
        if (a === l) break e;
        for (; a.sibling === null; ) {
          if (a.return === null || a.return === l) break e;
          a = a.return;
        }
        ((a.sibling.return = a.return), (a = a.sibling));
      }
    switch (M) {
      case "forwards":
        for (p = l.child, M = null; p !== null; )
          ((a = p.alternate),
            a !== null && Ls(a) === null && (M = p),
            (p = p.sibling));
        ((p = M),
          p === null
            ? ((M = l.child), (l.child = null))
            : ((M = p.sibling), (p.sibling = null)),
          wc(l, !1, M, p, A, g));
        break;
      case "backwards":
      case "unstable_legacy-backwards":
        for (p = null, M = l.child, l.child = null; M !== null; ) {
          if (((a = M.alternate), a !== null && Ls(a) === null)) {
            l.child = M;
            break;
          }
          ((a = M.sibling), (M.sibling = p), (p = M), (M = a));
        }
        wc(l, !0, p, null, A, g);
        break;
      case "together":
        wc(l, !1, null, null, void 0, g);
        break;
      default:
        l.memoizedState = null;
    }
    return l.child;
  }
  function Di(a, l, p) {
    if (
      (a !== null && (l.dependencies = a.dependencies),
      (uo |= l.lanes),
      (p & l.childLanes) === 0)
    )
      if (a !== null) {
        if ((no(a, l, p, !1), (p & l.childLanes) === 0)) return null;
      } else return null;
    if (a !== null && l.child !== a.child) throw Error(n(153));
    if (l.child !== null) {
      for (
        a = l.child, p = is(a, a.pendingProps), l.child = p, p.return = l;
        a.sibling !== null;
      )
        ((a = a.sibling),
          (p = p.sibling = is(a, a.pendingProps)),
          (p.return = l));
      p.sibling = null;
    }
    return l.child;
  }
  function Cd(a, l) {
    return (a.lanes & l) !== 0
      ? !0
      : ((a = a.dependencies), !!(a !== null && Cf(a)));
  }
  function jb(a, l, p) {
    switch (l.tag) {
      case 3:
        (ye(l, l.stateNode.containerInfo),
          Ao(l, Hi, a.memoizedState.cache),
          pl());
        break;
      case 27:
      case 5:
        it(l);
        break;
      case 4:
        ye(l, l.stateNode.containerInfo);
        break;
      case 10:
        Ao(l, l.type, l.memoizedProps.value);
        break;
      case 31:
        if (l.memoizedState !== null) return ((l.flags |= 128), ym(l), null);
        break;
      case 13:
        var g = l.memoizedState;
        if (g !== null)
          return g.dehydrated !== null
            ? (Lo(l), (l.flags |= 128), null)
            : (p & l.child.childLanes) !== 0
              ? Kv(a, l, p)
              : (Lo(l), (a = Di(a, l, p)), a !== null ? a.sibling : null);
        Lo(l);
        break;
      case 19:
        var M = (a.flags & 128) !== 0;
        if (
          ((g = (p & l.childLanes) !== 0),
          g || (no(a, l, p, !1), (g = (p & l.childLanes) !== 0)),
          M)
        ) {
          if (g) return cs(a, l, p);
          l.flags |= 128;
        }
        if (
          ((M = l.memoizedState),
          M !== null &&
            ((M.rendering = null), (M.tail = null), (M.lastEffect = null)),
          se(Sn, Sn.current),
          g)
        )
          break;
        return null;
      case 22:
        return ((l.lanes = 0), Tc(a, l, p, l.pendingProps));
      case 24:
        Ao(l, Hi, a.memoizedState.cache);
    }
    return Di(a, l, p);
  }
  function Rd(a, l, p) {
    if (a !== null)
      if (a.memoizedProps !== l.pendingProps) ji = !0;
      else {
        if (!Cd(a, p) && (l.flags & 128) === 0) return ((ji = !1), jb(a, l, p));
        ji = (a.flags & 131072) !== 0;
      }
    else ((ji = !1), _n && (l.flags & 1048576) !== 0 && rv(l, du, l.index));
    switch (((l.lanes = 0), l.tag)) {
      case 16:
        e: {
          var g = l.pendingProps;
          if (((a = mc(l.elementType)), (l.type = a), typeof a == "function"))
            Kh(a)
              ? ((g = Sl(a, g)), (l.tag = 1), (l = Ed(null, l, a, g, p)))
              : ((l.tag = 0), (l = Eu(null, l, a, g, p)));
          else {
            if (a != null) {
              var M = a.$$typeof;
              if (M === L) {
                ((l.tag = 11), (l = qm(null, l, a, g, p)));
                break e;
              } else if (M === B) {
                ((l.tag = 14), (l = Mc(null, l, a, g, p)));
                break e;
              }
            }
            throw ((l = ee(a) || a), Error(n(306, l, "")));
          }
        }
        return l;
      case 0:
        return Eu(a, l, l.type, l.pendingProps, p);
      case 1:
        return ((g = l.type), (M = Sl(g, l.pendingProps)), Ed(a, l, g, M, p));
      case 3:
        e: {
          if ((ye(l, l.stateNode.containerInfo), a === null))
            throw Error(n(387));
          g = l.pendingProps;
          var A = l.memoizedState;
          ((M = A.element), mm(a, l), xu(l, g, null, p));
          var z = l.memoizedState;
          if (
            ((g = z.cache),
            Ao(l, Hi, g),
            g !== A.cache && id(l, [Hi], p, !0),
            Uf(),
            (g = z.element),
            A.isDehydrated)
          )
            if (
              ((A = { element: g, isDehydrated: !1, cache: z.cache }),
              (l.updateQueue.baseState = A),
              (l.memoizedState = A),
              l.flags & 256)
            ) {
              l = Zv(a, l, g, p);
              break e;
            } else if (g !== M) {
              ((M = Cs(Error(n(424)), l)), $a(M), (l = Zv(a, l, g, p)));
              break e;
            } else {
              switch (((a = l.stateNode.containerInfo), a.nodeType)) {
                case 9:
                  a = a.body;
                  break;
                default:
                  a = a.nodeName === "HTML" ? a.ownerDocument.body : a;
              }
              for (
                Zn = po(a.firstChild),
                  _i = l,
                  _n = !0,
                  wo = null,
                  Rs = !0,
                  p = cd(l, null, g, p),
                  l.child = p;
                p;
              )
                ((p.flags = (p.flags & -3) | 4096), (p = p.sibling));
            }
          else {
            if ((pl(), g === M)) {
              l = Di(a, l, p);
              break e;
            }
            cr(a, l, g, p);
          }
          l = l.child;
        }
        return l;
      case 26:
        return (
          Ec(a, l),
          a === null
            ? (p = WE(l.type, null, l.pendingProps, null))
              ? (l.memoizedState = p)
              : _n ||
                ((p = l.type),
                (a = l.pendingProps),
                (g = ty(ae.current).createElement(p)),
                (g[Un] = l),
                (g[ii] = a),
                Xr(g, p, a),
                ve(g),
                (l.stateNode = g))
            : (l.memoizedState = WE(
                l.type,
                a.memoizedProps,
                l.pendingProps,
                a.memoizedState,
              )),
          null
        );
      case 27:
        return (
          it(l),
          a === null &&
            _n &&
            ((g = l.stateNode = GE(l.type, l.pendingProps, ae.current)),
            (_i = l),
            (Rs = !0),
            (M = Zn),
            Iu(l.type) ? ((r_ = M), (Zn = po(g.firstChild))) : (Zn = M)),
          cr(a, l, l.pendingProps.children, p),
          Ec(a, l),
          a === null && (l.flags |= 4194304),
          l.child
        );
      case 5:
        return (
          a === null &&
            _n &&
            ((M = g = Zn) &&
              ((g = JU(g, l.type, l.pendingProps, Rs)),
              g !== null
                ? ((l.stateNode = g),
                  (_i = l),
                  (Zn = po(g.firstChild)),
                  (Rs = !1),
                  (M = !0))
                : (M = !1)),
            M || Ja(l)),
          it(l),
          (M = l.type),
          (A = l.pendingProps),
          (z = a !== null ? a.memoizedProps : null),
          (g = A.children),
          $b(M, A) ? (g = null) : z !== null && $b(M, z) && (l.flags |= 32),
          l.memoizedState !== null &&
            ((M = hd(a, l, Sc, null, null, p)), (ag._currentValue = M)),
          Ec(a, l),
          cr(a, l, g, p),
          l.child
        );
      case 6:
        return (
          a === null &&
            _n &&
            ((a = p = Zn) &&
              ((p = $U(p, l.pendingProps, Rs)),
              p !== null
                ? ((l.stateNode = p), (_i = l), (Zn = null), (a = !0))
                : (a = !1)),
            a || Ja(l)),
          null
        );
      case 13:
        return Kv(a, l, p);
      case 4:
        return (
          ye(l, l.stateNode.containerInfo),
          (g = l.pendingProps),
          a === null ? (l.child = Ro(l, null, g, p)) : cr(a, l, g, p),
          l.child
        );
      case 11:
        return qm(a, l, l.type, l.pendingProps, p);
      case 7:
        return (cr(a, l, l.pendingProps, p), l.child);
      case 8:
        return (cr(a, l, l.pendingProps.children, p), l.child);
      case 12:
        return (cr(a, l, l.pendingProps.children, p), l.child);
      case 10:
        return (
          (g = l.pendingProps),
          Ao(l, l.type, g.value),
          cr(a, l, g.children, p),
          l.child
        );
      case 9:
        return (
          (M = l.type._context),
          (g = l.pendingProps.children),
          gl(l),
          (M = Xt(M)),
          (g = g(M)),
          (l.flags |= 1),
          cr(a, l, g, p),
          l.child
        );
      case 14:
        return Mc(a, l, l.type, l.pendingProps, p);
      case 15:
        return Sd(a, l, l.type, l.pendingProps, p);
      case 19:
        return cs(a, l, p);
      case 31:
        return Td(a, l, p);
      case 22:
        return Tc(a, l, p, l.pendingProps);
      case 24:
        return (
          gl(l),
          (g = Xt(Hi)),
          a === null
            ? ((M = sd()),
              M === null &&
                ((M = Zt),
                (A = um()),
                (M.pooledCache = A),
                A.refCount++,
                A !== null && (M.pooledCacheLanes |= p),
                (M = A)),
              (l.memoizedState = { parent: g, cache: M }),
              Nf(l),
              Ao(l, Hi, M))
            : ((a.lanes & p) !== 0 && (mm(a, l), xu(l, null, null, p), Uf()),
              (M = a.memoizedState),
              (A = l.memoizedState),
              M.parent !== g
                ? ((M = { parent: g, cache: g }),
                  (l.memoizedState = M),
                  l.lanes === 0 &&
                    (l.memoizedState = l.updateQueue.baseState = M),
                  Ao(l, Hi, g))
                : ((g = A.cache),
                  Ao(l, Hi, g),
                  g !== M.cache && id(l, [Hi], p, !0))),
          cr(a, l, l.pendingProps.children, p),
          l.child
        );
      case 29:
        throw l.pendingProps;
    }
    throw Error(n(156, l.tag));
  }
  function so(a) {
    a.flags |= 4;
  }
  function Vf(a, l, p, g, M) {
    if (((l = (a.mode & 32) !== 0) && (l = !1), l)) {
      if (((a.flags |= 16777216), (M & 335544128) === M))
        if (a.stateNode.complete) a.flags |= 8192;
        else if (gi()) a.flags |= 8192;
        else throw ((io = ad), Df);
    } else a.flags &= -16777217;
  }
  function Km(a, l) {
    if (l.type !== "stylesheet" || (l.state.loading & 4) !== 0)
      a.flags &= -16777217;
    else if (((a.flags |= 16777216), !KE(l)))
      if (gi()) a.flags |= 8192;
      else throw ((io = ad), Df);
  }
  function Uo(a, l) {
    (l !== null && (a.flags |= 4),
      a.flags & 16384 &&
        ((l = a.tag !== 22 ? St() : 536870912), (a.lanes |= l), (ti |= l)));
  }
  function ao(a, l) {
    if (!_n)
      switch (a.tailMode) {
        case "hidden":
          l = a.tail;
          for (var p = null; l !== null; )
            (l.alternate !== null && (p = l), (l = l.sibling));
          p === null ? (a.tail = null) : (p.sibling = null);
          break;
        case "collapsed":
          p = a.tail;
          for (var g = null; p !== null; )
            (p.alternate !== null && (g = p), (p = p.sibling));
          g === null
            ? l || a.tail === null
              ? (a.tail = null)
              : (a.tail.sibling = null)
            : (g.sibling = null);
      }
  }
  function Wn(a) {
    var l = a.alternate !== null && a.alternate.child === a.child,
      p = 0,
      g = 0;
    if (l)
      for (var M = a.child; M !== null; )
        ((p |= M.lanes | M.childLanes),
          (g |= M.subtreeFlags & 65011712),
          (g |= M.flags & 65011712),
          (M.return = a),
          (M = M.sibling));
    else
      for (M = a.child; M !== null; )
        ((p |= M.lanes | M.childLanes),
          (g |= M.subtreeFlags),
          (g |= M.flags),
          (M.return = a),
          (M = M.sibling));
    return ((a.subtreeFlags |= g), (a.childLanes = p), l);
  }
  function Gf(a, l, p) {
    var g = l.pendingProps;
    switch (($h(l), l.tag)) {
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return (Wn(l), null);
      case 1:
        return (Wn(l), null);
      case 3:
        return (
          (p = l.stateNode),
          (g = null),
          a !== null && (g = a.memoizedState.cache),
          l.memoizedState.cache !== g && (l.flags |= 2048),
          to(Hi),
          ze(),
          p.pendingContext &&
            ((p.context = p.pendingContext), (p.pendingContext = null)),
          (a === null || a.child === null) &&
            (mu(l)
              ? so(l)
              : a === null ||
                (a.memoizedState.isDehydrated && (l.flags & 256) === 0) ||
                ((l.flags |= 1024), td())),
          Wn(l),
          null
        );
      case 26:
        var M = l.type,
          A = l.memoizedState;
        return (
          a === null
            ? (so(l),
              A !== null ? (Wn(l), Km(l, A)) : (Wn(l), Vf(l, M, null, g, p)))
            : A
              ? A !== a.memoizedState
                ? (so(l), Wn(l), Km(l, A))
                : (Wn(l), (l.flags &= -16777217))
              : ((a = a.memoizedProps),
                a !== g && so(l),
                Wn(l),
                Vf(l, M, a, g, p)),
          null
        );
      case 27:
        if (
          (qe(l),
          (p = ae.current),
          (M = l.type),
          a !== null && l.stateNode != null)
        )
          a.memoizedProps !== g && so(l);
        else {
          if (!g) {
            if (l.stateNode === null) throw Error(n(166));
            return (Wn(l), null);
          }
          ((a = ue.current),
            mu(l) ? sv(l) : ((a = GE(M, g, p)), (l.stateNode = a), so(l)));
        }
        return (Wn(l), null);
      case 5:
        if ((qe(l), (M = l.type), a !== null && l.stateNode != null))
          a.memoizedProps !== g && so(l);
        else {
          if (!g) {
            if (l.stateNode === null) throw Error(n(166));
            return (Wn(l), null);
          }
          if (((A = ue.current), mu(l))) sv(l);
          else {
            var z = ty(ae.current);
            switch (A) {
              case 1:
                A = z.createElementNS("http://www.w3.org/2000/svg", M);
                break;
              case 2:
                A = z.createElementNS("http://www.w3.org/1998/Math/MathML", M);
                break;
              default:
                switch (M) {
                  case "svg":
                    A = z.createElementNS("http://www.w3.org/2000/svg", M);
                    break;
                  case "math":
                    A = z.createElementNS(
                      "http://www.w3.org/1998/Math/MathML",
                      M,
                    );
                    break;
                  case "script":
                    ((A = z.createElement("div")),
                      (A.innerHTML = "<script><\/script>"),
                      (A = A.removeChild(A.firstChild)));
                    break;
                  case "select":
                    ((A =
                      typeof g.is == "string"
                        ? z.createElement("select", { is: g.is })
                        : z.createElement("select")),
                      g.multiple
                        ? (A.multiple = !0)
                        : g.size && (A.size = g.size));
                    break;
                  default:
                    A =
                      typeof g.is == "string"
                        ? z.createElement(M, { is: g.is })
                        : z.createElement(M);
                }
            }
            ((A[Un] = l), (A[ii] = g));
            e: for (z = l.child; z !== null; ) {
              if (z.tag === 5 || z.tag === 6) A.appendChild(z.stateNode);
              else if (z.tag !== 4 && z.tag !== 27 && z.child !== null) {
                ((z.child.return = z), (z = z.child));
                continue;
              }
              if (z === l) break e;
              for (; z.sibling === null; ) {
                if (z.return === null || z.return === l) break e;
                z = z.return;
              }
              ((z.sibling.return = z.return), (z = z.sibling));
            }
            l.stateNode = A;
            e: switch ((Xr(A, M, g), M)) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                g = !!g.autoFocus;
                break e;
              case "img":
                g = !0;
                break e;
              default:
                g = !1;
            }
            g && so(l);
          }
        }
        return (
          Wn(l),
          Vf(l, l.type, a === null ? null : a.memoizedProps, l.pendingProps, p),
          null
        );
      case 6:
        if (a && l.stateNode != null) a.memoizedProps !== g && so(l);
        else {
          if (typeof g != "string" && l.stateNode === null) throw Error(n(166));
          if (((a = ae.current), mu(l))) {
            if (
              ((a = l.stateNode),
              (p = l.memoizedProps),
              (g = null),
              (M = _i),
              M !== null)
            )
              switch (M.tag) {
                case 27:
                case 5:
                  g = M.memoizedProps;
              }
            ((a[Un] = l),
              (a = !!(
                a.nodeValue === p ||
                (g !== null && g.suppressHydrationWarning === !0) ||
                LE(a.nodeValue, p)
              )),
              a || Ja(l, !0));
          } else
            ((a = ty(a).createTextNode(g)), (a[Un] = l), (l.stateNode = a));
        }
        return (Wn(l), null);
      case 31:
        if (((p = l.memoizedState), a === null || a.memoizedState !== null)) {
          if (((g = mu(l)), p !== null)) {
            if (a === null) {
              if (!g) throw Error(n(318));
              if (
                ((a = l.memoizedState),
                (a = a !== null ? a.dehydrated : null),
                !a)
              )
                throw Error(n(557));
              a[Un] = l;
            } else
              (pl(),
                (l.flags & 128) === 0 && (l.memoizedState = null),
                (l.flags |= 4));
            (Wn(l), (a = !1));
          } else
            ((p = td()),
              a !== null &&
                a.memoizedState !== null &&
                (a.memoizedState.hydrationErrors = p),
              (a = !0));
          if (!a) return l.flags & 256 ? (Ci(l), l) : (Ci(l), null);
          if ((l.flags & 128) !== 0) throw Error(n(558));
        }
        return (Wn(l), null);
      case 13:
        if (
          ((g = l.memoizedState),
          a === null ||
            (a.memoizedState !== null && a.memoizedState.dehydrated !== null))
        ) {
          if (((M = mu(l)), g !== null && g.dehydrated !== null)) {
            if (a === null) {
              if (!M) throw Error(n(318));
              if (
                ((M = l.memoizedState),
                (M = M !== null ? M.dehydrated : null),
                !M)
              )
                throw Error(n(317));
              M[Un] = l;
            } else
              (pl(),
                (l.flags & 128) === 0 && (l.memoizedState = null),
                (l.flags |= 4));
            (Wn(l), (M = !1));
          } else
            ((M = td()),
              a !== null &&
                a.memoizedState !== null &&
                (a.memoizedState.hydrationErrors = M),
              (M = !0));
          if (!M) return l.flags & 256 ? (Ci(l), l) : (Ci(l), null);
        }
        return (
          Ci(l),
          (l.flags & 128) !== 0
            ? ((l.lanes = p), l)
            : ((p = g !== null),
              (a = a !== null && a.memoizedState !== null),
              p &&
                ((g = l.child),
                (M = null),
                g.alternate !== null &&
                  g.alternate.memoizedState !== null &&
                  g.alternate.memoizedState.cachePool !== null &&
                  (M = g.alternate.memoizedState.cachePool.pool),
                (A = null),
                g.memoizedState !== null &&
                  g.memoizedState.cachePool !== null &&
                  (A = g.memoizedState.cachePool.pool),
                A !== M && (g.flags |= 2048)),
              p !== a && p && (l.child.flags |= 8192),
              Uo(l, l.updateQueue),
              Wn(l),
              null)
        );
      case 4:
        return (ze(), a === null && Yb(l.stateNode.containerInfo), Wn(l), null);
      case 10:
        return (to(l.type), Wn(l), null);
      case 19:
        if ((Z(Sn), (g = l.memoizedState), g === null)) return (Wn(l), null);
        if (((M = (l.flags & 128) !== 0), (A = g.rendering), A === null))
          if (M) ao(g, !1);
          else {
            if (pi !== 0 || (a !== null && (a.flags & 128) !== 0))
              for (a = l.child; a !== null; ) {
                if (((A = Ls(a)), A !== null)) {
                  for (
                    l.flags |= 128,
                      ao(g, !1),
                      a = A.updateQueue,
                      l.updateQueue = a,
                      Uo(l, a),
                      l.subtreeFlags = 0,
                      a = p,
                      p = l.child;
                    p !== null;
                  )
                    (uu(p, a), (p = p.sibling));
                  return (
                    se(Sn, (Sn.current & 1) | 2),
                    _n && Ka(l, g.treeForkCount),
                    l.child
                  );
                }
                a = a.sibling;
              }
            g.tail !== null &&
              k() > Li &&
              ((l.flags |= 128), (M = !0), ao(g, !1), (l.lanes = 4194304));
          }
        else {
          if (!M)
            if (((a = Ls(A)), a !== null)) {
              if (
                ((l.flags |= 128),
                (M = !0),
                (a = a.updateQueue),
                (l.updateQueue = a),
                Uo(l, a),
                ao(g, !0),
                g.tail === null &&
                  g.tailMode === "hidden" &&
                  !A.alternate &&
                  !_n)
              )
                return (Wn(l), null);
            } else
              2 * k() - g.renderingStartTime > Li &&
                p !== 536870912 &&
                ((l.flags |= 128), (M = !0), ao(g, !1), (l.lanes = 4194304));
          g.isBackwards
            ? ((A.sibling = l.child), (l.child = A))
            : ((a = g.last),
              a !== null ? (a.sibling = A) : (l.child = A),
              (g.last = A));
        }
        return g.tail !== null
          ? ((a = g.tail),
            (g.rendering = a),
            (g.tail = a.sibling),
            (g.renderingStartTime = k()),
            (a.sibling = null),
            (p = Sn.current),
            se(Sn, M ? (p & 1) | 2 : p & 1),
            _n && Ka(l, g.treeForkCount),
            a)
          : (Wn(l), null);
      case 22:
      case 23:
        return (
          Ci(l),
          Pf(),
          (g = l.memoizedState !== null),
          a !== null
            ? (a.memoizedState !== null) !== g && (l.flags |= 8192)
            : g && (l.flags |= 8192),
          g
            ? (p & 536870912) !== 0 &&
              (l.flags & 128) === 0 &&
              (Wn(l), l.subtreeFlags & 6 && (l.flags |= 8192))
            : Wn(l),
          (p = l.updateQueue),
          p !== null && Uo(l, p.retryQueue),
          (p = null),
          a !== null &&
            a.memoizedState !== null &&
            a.memoizedState.cachePool !== null &&
            (p = a.memoizedState.cachePool.pool),
          (g = null),
          l.memoizedState !== null &&
            l.memoizedState.cachePool !== null &&
            (g = l.memoizedState.cachePool.pool),
          g !== p && (l.flags |= 2048),
          a !== null && Z(vl),
          null
        );
      case 24:
        return (
          (p = null),
          a !== null && (p = a.memoizedState.cache),
          l.memoizedState.cache !== p && (l.flags |= 2048),
          to(Hi),
          Wn(l),
          null
        );
      case 25:
        return null;
      case 30:
        return null;
    }
    throw Error(n(156, l.tag));
  }
  function aa(a, l) {
    switch (($h(l), l.tag)) {
      case 1:
        return (
          (a = l.flags),
          a & 65536 ? ((l.flags = (a & -65537) | 128), l) : null
        );
      case 3:
        return (
          to(Hi),
          ze(),
          (a = l.flags),
          (a & 65536) !== 0 && (a & 128) === 0
            ? ((l.flags = (a & -65537) | 128), l)
            : null
        );
      case 26:
      case 27:
      case 5:
        return (qe(l), null);
      case 31:
        if (l.memoizedState !== null) {
          if ((Ci(l), l.alternate === null)) throw Error(n(340));
          pl();
        }
        return (
          (a = l.flags),
          a & 65536 ? ((l.flags = (a & -65537) | 128), l) : null
        );
      case 13:
        if (
          (Ci(l), (a = l.memoizedState), a !== null && a.dehydrated !== null)
        ) {
          if (l.alternate === null) throw Error(n(340));
          pl();
        }
        return (
          (a = l.flags),
          a & 65536 ? ((l.flags = (a & -65537) | 128), l) : null
        );
      case 19:
        return (Z(Sn), null);
      case 4:
        return (ze(), null);
      case 10:
        return (to(l.type), null);
      case 22:
      case 23:
        return (
          Ci(l),
          Pf(),
          a !== null && Z(vl),
          (a = l.flags),
          a & 65536 ? ((l.flags = (a & -65537) | 128), l) : null
        );
      case 24:
        return (to(Hi), null);
      case 25:
        return null;
      default:
        return null;
    }
  }
  function Ns(a, l) {
    switch (($h(l), l.tag)) {
      case 3:
        (to(Hi), ze());
        break;
      case 26:
      case 27:
      case 5:
        qe(l);
        break;
      case 4:
        ze();
        break;
      case 31:
        l.memoizedState !== null && Ci(l);
        break;
      case 13:
        Ci(l);
        break;
      case 19:
        Z(Sn);
        break;
      case 10:
        to(l.type);
        break;
      case 22:
      case 23:
        (Ci(l), Pf(), a !== null && Z(vl));
        break;
      case 24:
        to(Hi);
    }
  }
  function oa(a, l) {
    try {
      var p = l.updateQueue,
        g = p !== null ? p.lastEffect : null;
      if (g !== null) {
        var M = g.next;
        p = M;
        do {
          if ((p.tag & a) === a) {
            g = void 0;
            var A = p.create,
              z = p.inst;
            ((g = A()), (z.destroy = g));
          }
          p = p.next;
        } while (p !== M);
      }
    } catch (Q) {
      Rn(l, l.return, Q);
    }
  }
  function xr(a, l, p) {
    try {
      var g = l.updateQueue,
        M = g !== null ? g.lastEffect : null;
      if (M !== null) {
        var A = M.next;
        g = A;
        do {
          if ((g.tag & a) === a) {
            var z = g.inst,
              Q = z.destroy;
            if (Q !== void 0) {
              ((z.destroy = void 0), (M = l));
              var pe = p,
                Ue = Q;
              try {
                Ue();
              } catch (tt) {
                Rn(M, pe, tt);
              }
            }
          }
          g = g.next;
        } while (g !== A);
      }
    } catch (tt) {
      Rn(l, l.return, tt);
    }
  }
  function wa(a) {
    var l = a.updateQueue;
    if (l !== null) {
      var p = a.stateNode;
      try {
        uv(l, p);
      } catch (g) {
        Rn(a, a.return, g);
      }
    }
  }
  function ur(a, l, p) {
    ((p.props = Sl(a.type, a.memoizedProps)), (p.state = a.memoizedState));
    try {
      p.componentWillUnmount();
    } catch (g) {
      Rn(a, l, g);
    }
  }
  function Po(a, l) {
    try {
      var p = a.ref;
      if (p !== null) {
        switch (a.tag) {
          case 26:
          case 27:
          case 5:
            var g = a.stateNode;
            break;
          case 30:
            g = a.stateNode;
            break;
          default:
            g = a.stateNode;
        }
        typeof p == "function" ? (a.refCleanup = p(g)) : (p.current = g);
      }
    } catch (M) {
      Rn(a, l, M);
    }
  }
  function br(a, l) {
    var p = a.ref,
      g = a.refCleanup;
    if (p !== null)
      if (typeof g == "function")
        try {
          g();
        } catch (M) {
          Rn(a, l, M);
        } finally {
          ((a.refCleanup = null),
            (a = a.alternate),
            a != null && (a.refCleanup = null));
        }
      else if (typeof p == "function")
        try {
          p(null);
        } catch (M) {
          Rn(a, l, M);
        }
      else p.current = null;
  }
  function Hf(a) {
    var l = a.type,
      p = a.memoizedProps,
      g = a.stateNode;
    try {
      e: switch (l) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          p.autoFocus && g.focus();
          break e;
        case "img":
          p.src ? (g.src = p.src) : p.srcSet && (g.srcset = p.srcSet);
      }
    } catch (M) {
      Rn(a, a.return, M);
    }
  }
  function $i(a, l, p) {
    try {
      var g = a.stateNode;
      (XU(g, a.type, p, l), (g[ii] = l));
    } catch (M) {
      Rn(a, a.return, M);
    }
  }
  function li(a) {
    return (
      a.tag === 5 ||
      a.tag === 3 ||
      a.tag === 26 ||
      (a.tag === 27 && Iu(a.type)) ||
      a.tag === 4
    );
  }
  function yn(a) {
    e: for (;;) {
      for (; a.sibling === null; ) {
        if (a.return === null || li(a.return)) return null;
        a = a.return;
      }
      for (
        a.sibling.return = a.return, a = a.sibling;
        a.tag !== 5 && a.tag !== 6 && a.tag !== 18;
      ) {
        if (
          (a.tag === 27 && Iu(a.type)) ||
          a.flags & 2 ||
          a.child === null ||
          a.tag === 4
        )
          continue e;
        ((a.child.return = a), (a = a.child));
      }
      if (!(a.flags & 2)) return a.stateNode;
    }
  }
  function oo(a, l, p) {
    var g = a.tag;
    if (g === 5 || g === 6)
      ((a = a.stateNode),
        l
          ? (p.nodeType === 9
              ? p.body
              : p.nodeName === "HTML"
                ? p.ownerDocument.body
                : p
            ).insertBefore(a, l)
          : ((l =
              p.nodeType === 9
                ? p.body
                : p.nodeName === "HTML"
                  ? p.ownerDocument.body
                  : p),
            l.appendChild(a),
            (p = p._reactRootContainer),
            p != null || l.onclick !== null || (l.onclick = wr)));
    else if (
      g !== 4 &&
      (g === 27 && Iu(a.type) && ((p = a.stateNode), (l = null)),
      (a = a.child),
      a !== null)
    )
      for (oo(a, l, p), a = a.sibling; a !== null; )
        (oo(a, l, p), (a = a.sibling));
  }
  function Gr(a, l, p) {
    var g = a.tag;
    if (g === 5 || g === 6)
      ((a = a.stateNode), l ? p.insertBefore(a, l) : p.appendChild(a));
    else if (
      g !== 4 &&
      (g === 27 && Iu(a.type) && (p = a.stateNode), (a = a.child), a !== null)
    )
      for (Gr(a, l, p), a = a.sibling; a !== null; )
        (Gr(a, l, p), (a = a.sibling));
  }
  function Dd(a) {
    var l = a.stateNode,
      p = a.memoizedProps;
    try {
      for (var g = a.type, M = l.attributes; M.length; )
        l.removeAttributeNode(M[0]);
      (Xr(l, g, p), (l[Un] = a), (l[ii] = p));
    } catch (A) {
      Rn(a, a.return, A);
    }
  }
  var la = !1,
    Kn = !1,
    Aa = !1,
    Jv = typeof WeakSet == "function" ? WeakSet : Set,
    fr = null;
  function Wb(a, l) {
    if (((a = a.containerInfo), (Qb = ly), (a = ev(a)), sm(a))) {
      if ("selectionStart" in a)
        var p = { start: a.selectionStart, end: a.selectionEnd };
      else
        e: {
          p = ((p = a.ownerDocument) && p.defaultView) || window;
          var g = p.getSelection && p.getSelection();
          if (g && g.rangeCount !== 0) {
            p = g.anchorNode;
            var M = g.anchorOffset,
              A = g.focusNode;
            g = g.focusOffset;
            try {
              (p.nodeType, A.nodeType);
            } catch {
              p = null;
              break e;
            }
            var z = 0,
              Q = -1,
              pe = -1,
              Ue = 0,
              tt = 0,
              at = a,
              Be = null;
            t: for (;;) {
              for (
                var Xe;
                at !== p || (M !== 0 && at.nodeType !== 3) || (Q = z + M),
                  at !== A || (g !== 0 && at.nodeType !== 3) || (pe = z + g),
                  at.nodeType === 3 && (z += at.nodeValue.length),
                  (Xe = at.firstChild) !== null;
              )
                ((Be = at), (at = Xe));
              for (;;) {
                if (at === a) break t;
                if (
                  (Be === p && ++Ue === M && (Q = z),
                  Be === A && ++tt === g && (pe = z),
                  (Xe = at.nextSibling) !== null)
                )
                  break;
                ((at = Be), (Be = at.parentNode));
              }
              at = Xe;
            }
            p = Q === -1 || pe === -1 ? null : { start: Q, end: pe };
          } else p = null;
        }
      p = p || { start: 0, end: 0 };
    } else p = null;
    for (
      Jb = { focusedElem: a, selectionRange: p }, ly = !1, fr = l;
      fr !== null;
    )
      if (
        ((l = fr), (a = l.child), (l.subtreeFlags & 1028) !== 0 && a !== null)
      )
        ((a.return = l), (fr = a));
      else
        for (; fr !== null; ) {
          switch (((l = fr), (A = l.alternate), (a = l.flags), l.tag)) {
            case 0:
              if (
                (a & 4) !== 0 &&
                ((a = l.updateQueue),
                (a = a !== null ? a.events : null),
                a !== null)
              )
                for (p = 0; p < a.length; p++)
                  ((M = a[p]), (M.ref.impl = M.nextImpl));
              break;
            case 11:
            case 15:
              break;
            case 1:
              if ((a & 1024) !== 0 && A !== null) {
                ((a = void 0),
                  (p = l),
                  (M = A.memoizedProps),
                  (A = A.memoizedState),
                  (g = p.stateNode));
                try {
                  var Nt = Sl(p.type, M);
                  ((a = g.getSnapshotBeforeUpdate(Nt, A)),
                    (g.__reactInternalSnapshotBeforeUpdate = a));
                } catch (jt) {
                  Rn(p, p.return, jt);
                }
              }
              break;
            case 3:
              if ((a & 1024) !== 0) {
                if (
                  ((a = l.stateNode.containerInfo), (p = a.nodeType), p === 9)
                )
                  t_(a);
                else if (p === 1)
                  switch (a.nodeName) {
                    case "HEAD":
                    case "HTML":
                    case "BODY":
                      t_(a);
                      break;
                    default:
                      a.textContent = "";
                  }
              }
              break;
            case 5:
            case 26:
            case 27:
            case 6:
            case 4:
            case 17:
              break;
            default:
              if ((a & 1024) !== 0) throw Error(n(163));
          }
          if (((a = l.sibling), a !== null)) {
            ((a.return = l.return), (fr = a));
            break;
          }
          fr = l.return;
        }
  }
  function ci(a, l, p) {
    var g = p.flags;
    switch (p.tag) {
      case 0:
      case 11:
      case 15:
        (fa(a, p), g & 4 && oa(5, p));
        break;
      case 1:
        if ((fa(a, p), g & 4))
          if (((a = p.stateNode), l === null))
            try {
              a.componentDidMount();
            } catch (z) {
              Rn(p, p.return, z);
            }
          else {
            var M = Sl(p.type, l.memoizedProps);
            l = l.memoizedState;
            try {
              a.componentDidUpdate(M, l, a.__reactInternalSnapshotBeforeUpdate);
            } catch (z) {
              Rn(p, p.return, z);
            }
          }
        (g & 64 && wa(p), g & 512 && Po(p, p.return));
        break;
      case 3:
        if ((fa(a, p), g & 64 && ((a = p.updateQueue), a !== null))) {
          if (((l = null), p.child !== null))
            switch (p.child.tag) {
              case 27:
              case 5:
                l = p.child.stateNode;
                break;
              case 1:
                l = p.child.stateNode;
            }
          try {
            uv(a, l);
          } catch (z) {
            Rn(p, p.return, z);
          }
        }
        break;
      case 27:
        l === null && g & 4 && Dd(p);
      case 26:
      case 5:
        (fa(a, p), l === null && g & 4 && Hf(p), g & 512 && Po(p, p.return));
        break;
      case 12:
        fa(a, p);
        break;
      case 31:
        (fa(a, p), g & 4 && Ml(a, p));
        break;
      case 13:
        (fa(a, p),
          g & 4 && wu(a, p),
          g & 64 &&
            ((a = p.memoizedState),
            a !== null &&
              ((a = a.dehydrated),
              a !== null && ((p = x.bind(null, p)), eP(a, p)))));
        break;
      case 22:
        if (((g = p.memoizedState !== null || la), !g)) {
          ((l = (l !== null && l.memoizedState !== null) || Kn), (M = la));
          var A = Kn;
          ((la = g),
            (Kn = l) && !A ? Hr(a, p, (p.subtreeFlags & 8772) !== 0) : fa(a, p),
            (la = M),
            (Kn = A));
        }
        break;
      case 30:
        break;
      default:
        fa(a, p);
    }
  }
  function jf(a) {
    var l = a.alternate;
    (l !== null && ((a.alternate = null), jf(l)),
      (a.child = null),
      (a.deletions = null),
      (a.sibling = null),
      a.tag === 5 && ((l = a.stateNode), l !== null && Xs(l)),
      (a.stateNode = null),
      (a.return = null),
      (a.dependencies = null),
      (a.memoizedProps = null),
      (a.memoizedState = null),
      (a.pendingProps = null),
      (a.stateNode = null),
      (a.updateQueue = null));
  }
  var kn = null,
    Lr = !1;
  function ca(a, l, p) {
    for (p = p.child; p !== null; ) (Ld(a, l, p), (p = p.sibling));
  }
  function Ld(a, l, p) {
    if (Ve && typeof Ve.onCommitFiberUnmount == "function")
      try {
        Ve.onCommitFiberUnmount(Ge, p);
      } catch {}
    switch (p.tag) {
      case 26:
        (Kn || br(p, l),
          ca(a, l, p),
          p.memoizedState
            ? p.memoizedState.count--
            : p.stateNode && ((p = p.stateNode), p.parentNode.removeChild(p)));
        break;
      case 27:
        Kn || br(p, l);
        var g = kn,
          M = Lr;
        (Iu(p.type) && ((kn = p.stateNode), (Lr = !1)),
          ca(a, l, p),
          ig(p.stateNode),
          (kn = g),
          (Lr = M));
        break;
      case 5:
        Kn || br(p, l);
      case 6:
        if (
          ((g = kn),
          (M = Lr),
          (kn = null),
          ca(a, l, p),
          (kn = g),
          (Lr = M),
          kn !== null)
        )
          if (Lr)
            try {
              (kn.nodeType === 9
                ? kn.body
                : kn.nodeName === "HTML"
                  ? kn.ownerDocument.body
                  : kn
              ).removeChild(p.stateNode);
            } catch (A) {
              Rn(p, l, A);
            }
          else
            try {
              kn.removeChild(p.stateNode);
            } catch (A) {
              Rn(p, l, A);
            }
        break;
      case 18:
        kn !== null &&
          (Lr
            ? ((a = kn),
              FE(
                a.nodeType === 9
                  ? a.body
                  : a.nodeName === "HTML"
                    ? a.ownerDocument.body
                    : a,
                p.stateNode,
              ),
              Bd(a))
            : FE(kn, p.stateNode));
        break;
      case 4:
        ((g = kn),
          (M = Lr),
          (kn = p.stateNode.containerInfo),
          (Lr = !0),
          ca(a, l, p),
          (kn = g),
          (Lr = M));
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        (xr(2, p, l), Kn || xr(4, p, l), ca(a, l, p));
        break;
      case 1:
        (Kn ||
          (br(p, l),
          (g = p.stateNode),
          typeof g.componentWillUnmount == "function" && ur(p, l, g)),
          ca(a, l, p));
        break;
      case 21:
        ca(a, l, p);
        break;
      case 22:
        ((Kn = (g = Kn) || p.memoizedState !== null), ca(a, l, p), (Kn = g));
        break;
      default:
        ca(a, l, p);
    }
  }
  function Ml(a, l) {
    if (
      l.memoizedState === null &&
      ((a = l.alternate), a !== null && ((a = a.memoizedState), a !== null))
    ) {
      a = a.dehydrated;
      try {
        Bd(a);
      } catch (p) {
        Rn(l, l.return, p);
      }
    }
  }
  function wu(a, l) {
    if (
      l.memoizedState === null &&
      ((a = l.alternate),
      a !== null &&
        ((a = a.memoizedState), a !== null && ((a = a.dehydrated), a !== null)))
    )
      try {
        Bd(a);
      } catch (p) {
        Rn(l, l.return, p);
      }
  }
  function Qm(a) {
    switch (a.tag) {
      case 31:
      case 13:
      case 19:
        var l = a.stateNode;
        return (l === null && (l = a.stateNode = new Jv()), l);
      case 22:
        return (
          (a = a.stateNode),
          (l = a._retryCache),
          l === null && (l = a._retryCache = new Jv()),
          l
        );
      default:
        throw Error(n(435, a.tag));
    }
  }
  function Io(a, l) {
    var p = Qm(a);
    l.forEach(function (g) {
      if (!p.has(g)) {
        p.add(g);
        var M = S.bind(null, a, g);
        g.then(M, M);
      }
    });
  }
  function er(a, l) {
    var p = l.deletions;
    if (p !== null)
      for (var g = 0; g < p.length; g++) {
        var M = p[g],
          A = a,
          z = l,
          Q = z;
        e: for (; Q !== null; ) {
          switch (Q.tag) {
            case 27:
              if (Iu(Q.type)) {
                ((kn = Q.stateNode), (Lr = !1));
                break e;
              }
              break;
            case 5:
              ((kn = Q.stateNode), (Lr = !1));
              break e;
            case 3:
            case 4:
              ((kn = Q.stateNode.containerInfo), (Lr = !0));
              break e;
          }
          Q = Q.return;
        }
        if (kn === null) throw Error(n(160));
        (Ld(A, z, M),
          (kn = null),
          (Lr = !1),
          (A = M.alternate),
          A !== null && (A.return = null),
          (M.return = null));
      }
    if (l.subtreeFlags & 13886)
      for (l = l.child; l !== null; ) (Tl(l, a), (l = l.sibling));
  }
  var ua = null;
  function Tl(a, l) {
    var p = a.alternate,
      g = a.flags;
    switch (a.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        (er(l, a),
          tr(a),
          g & 4 && (xr(3, a, a.return), oa(3, a), xr(5, a, a.return)));
        break;
      case 1:
        (er(l, a),
          tr(a),
          g & 512 && (Kn || p === null || br(p, p.return)),
          g & 64 &&
            la &&
            ((a = a.updateQueue),
            a !== null &&
              ((g = a.callbacks),
              g !== null &&
                ((p = a.shared.hiddenCallbacks),
                (a.shared.hiddenCallbacks = p === null ? g : p.concat(g))))));
        break;
      case 26:
        var M = ua;
        if (
          (er(l, a),
          tr(a),
          g & 512 && (Kn || p === null || br(p, p.return)),
          g & 4)
        ) {
          var A = p !== null ? p.memoizedState : null;
          if (((g = a.memoizedState), p === null))
            if (g === null)
              if (a.stateNode === null) {
                e: {
                  ((g = a.type),
                    (p = a.memoizedProps),
                    (M = M.ownerDocument || M));
                  t: switch (g) {
                    case "title":
                      ((A = M.getElementsByTagName("title")[0]),
                        (!A ||
                          A[Ss] ||
                          A[Un] ||
                          A.namespaceURI === "http://www.w3.org/2000/svg" ||
                          A.hasAttribute("itemprop")) &&
                          ((A = M.createElement(g)),
                          M.head.insertBefore(
                            A,
                            M.querySelector("head > title"),
                          )),
                        Xr(A, g, p),
                        (A[Un] = a),
                        ve(A),
                        (g = A));
                      break e;
                    case "link":
                      var z = YE("link", "href", M).get(g + (p.href || ""));
                      if (z) {
                        for (var Q = 0; Q < z.length; Q++)
                          if (
                            ((A = z[Q]),
                            A.getAttribute("href") ===
                              (p.href == null || p.href === ""
                                ? null
                                : p.href) &&
                              A.getAttribute("rel") ===
                                (p.rel == null ? null : p.rel) &&
                              A.getAttribute("title") ===
                                (p.title == null ? null : p.title) &&
                              A.getAttribute("crossorigin") ===
                                (p.crossOrigin == null ? null : p.crossOrigin))
                          ) {
                            z.splice(Q, 1);
                            break t;
                          }
                      }
                      ((A = M.createElement(g)),
                        Xr(A, g, p),
                        M.head.appendChild(A));
                      break;
                    case "meta":
                      if (
                        (z = YE("meta", "content", M).get(
                          g + (p.content || ""),
                        ))
                      ) {
                        for (Q = 0; Q < z.length; Q++)
                          if (
                            ((A = z[Q]),
                            A.getAttribute("content") ===
                              (p.content == null ? null : "" + p.content) &&
                              A.getAttribute("name") ===
                                (p.name == null ? null : p.name) &&
                              A.getAttribute("property") ===
                                (p.property == null ? null : p.property) &&
                              A.getAttribute("http-equiv") ===
                                (p.httpEquiv == null ? null : p.httpEquiv) &&
                              A.getAttribute("charset") ===
                                (p.charSet == null ? null : p.charSet))
                          ) {
                            z.splice(Q, 1);
                            break t;
                          }
                      }
                      ((A = M.createElement(g)),
                        Xr(A, g, p),
                        M.head.appendChild(A));
                      break;
                    default:
                      throw Error(n(468, g));
                  }
                  ((A[Un] = a), ve(A), (g = A));
                }
                a.stateNode = g;
              } else ZE(M, a.type, a.stateNode);
            else a.stateNode = qE(M, g, a.memoizedProps);
          else
            A !== g
              ? (A === null
                  ? p.stateNode !== null &&
                    ((p = p.stateNode), p.parentNode.removeChild(p))
                  : A.count--,
                g === null
                  ? ZE(M, a.type, a.stateNode)
                  : qE(M, g, a.memoizedProps))
              : g === null &&
                a.stateNode !== null &&
                $i(a, a.memoizedProps, p.memoizedProps);
        }
        break;
      case 27:
        (er(l, a),
          tr(a),
          g & 512 && (Kn || p === null || br(p, p.return)),
          p !== null && g & 4 && $i(a, a.memoizedProps, p.memoizedProps));
        break;
      case 5:
        if (
          (er(l, a),
          tr(a),
          g & 512 && (Kn || p === null || br(p, p.return)),
          a.flags & 32)
        ) {
          M = a.stateNode;
          try {
            Vi(M, "");
          } catch (Nt) {
            Rn(a, a.return, Nt);
          }
        }
        (g & 4 &&
          a.stateNode != null &&
          ((M = a.memoizedProps), $i(a, M, p !== null ? p.memoizedProps : M)),
          g & 1024 && (Aa = !0));
        break;
      case 6:
        if ((er(l, a), tr(a), g & 4)) {
          if (a.stateNode === null) throw Error(n(162));
          ((g = a.memoizedProps), (p = a.stateNode));
          try {
            p.nodeValue = g;
          } catch (Nt) {
            Rn(a, a.return, Nt);
          }
        }
        break;
      case 3:
        if (
          ((ry = null),
          (M = ua),
          (ua = ny(l.containerInfo)),
          er(l, a),
          (ua = M),
          tr(a),
          g & 4 && p !== null && p.memoizedState.isDehydrated)
        )
          try {
            Bd(l.containerInfo);
          } catch (Nt) {
            Rn(a, a.return, Nt);
          }
        Aa && ((Aa = !1), Nd(a));
        break;
      case 4:
        ((g = ua),
          (ua = ny(a.stateNode.containerInfo)),
          er(l, a),
          tr(a),
          (ua = g));
        break;
      case 12:
        (er(l, a), tr(a));
        break;
      case 31:
        (er(l, a),
          tr(a),
          g & 4 &&
            ((g = a.updateQueue),
            g !== null && ((a.updateQueue = null), Io(a, g))));
        break;
      case 13:
        (er(l, a),
          tr(a),
          a.child.flags & 8192 &&
            (a.memoizedState !== null) !=
              (p !== null && p.memoizedState !== null) &&
            (Au = k()),
          g & 4 &&
            ((g = a.updateQueue),
            g !== null && ((a.updateQueue = null), Io(a, g))));
        break;
      case 22:
        M = a.memoizedState !== null;
        var pe = p !== null && p.memoizedState !== null,
          Ue = la,
          tt = Kn;
        if (
          ((la = Ue || M),
          (Kn = tt || pe),
          er(l, a),
          (Kn = tt),
          (la = Ue),
          tr(a),
          g & 8192)
        )
          e: for (
            l = a.stateNode,
              l._visibility = M ? l._visibility & -2 : l._visibility | 1,
              M && (p === null || pe || la || Kn || lo(a)),
              p = null,
              l = a;
            ;
          ) {
            if (l.tag === 5 || l.tag === 26) {
              if (p === null) {
                pe = p = l;
                try {
                  if (((A = pe.stateNode), M))
                    ((z = A.style),
                      typeof z.setProperty == "function"
                        ? z.setProperty("display", "none", "important")
                        : (z.display = "none"));
                  else {
                    Q = pe.stateNode;
                    var at = pe.memoizedProps.style,
                      Be =
                        at != null && at.hasOwnProperty("display")
                          ? at.display
                          : null;
                    Q.style.display =
                      Be == null || typeof Be == "boolean"
                        ? ""
                        : ("" + Be).trim();
                  }
                } catch (Nt) {
                  Rn(pe, pe.return, Nt);
                }
              }
            } else if (l.tag === 6) {
              if (p === null) {
                pe = l;
                try {
                  pe.stateNode.nodeValue = M ? "" : pe.memoizedProps;
                } catch (Nt) {
                  Rn(pe, pe.return, Nt);
                }
              }
            } else if (l.tag === 18) {
              if (p === null) {
                pe = l;
                try {
                  var Xe = pe.stateNode;
                  M ? zE(Xe, !0) : zE(pe.stateNode, !1);
                } catch (Nt) {
                  Rn(pe, pe.return, Nt);
                }
              }
            } else if (
              ((l.tag !== 22 && l.tag !== 23) ||
                l.memoizedState === null ||
                l === a) &&
              l.child !== null
            ) {
              ((l.child.return = l), (l = l.child));
              continue;
            }
            if (l === a) break e;
            for (; l.sibling === null; ) {
              if (l.return === null || l.return === a) break e;
              (p === l && (p = null), (l = l.return));
            }
            (p === l && (p = null),
              (l.sibling.return = l.return),
              (l = l.sibling));
          }
        g & 4 &&
          ((g = a.updateQueue),
          g !== null &&
            ((p = g.retryQueue),
            p !== null && ((g.retryQueue = null), Io(a, p))));
        break;
      case 19:
        (er(l, a),
          tr(a),
          g & 4 &&
            ((g = a.updateQueue),
            g !== null && ((a.updateQueue = null), Io(a, g))));
        break;
      case 30:
        break;
      case 21:
        break;
      default:
        (er(l, a), tr(a));
    }
  }
  function tr(a) {
    var l = a.flags;
    if (l & 2) {
      try {
        for (var p, g = a.return; g !== null; ) {
          if (li(g)) {
            p = g;
            break;
          }
          g = g.return;
        }
        if (p == null) throw Error(n(160));
        switch (p.tag) {
          case 27:
            var M = p.stateNode,
              A = yn(a);
            Gr(a, A, M);
            break;
          case 5:
            var z = p.stateNode;
            p.flags & 32 && (Vi(z, ""), (p.flags &= -33));
            var Q = yn(a);
            Gr(a, Q, z);
            break;
          case 3:
          case 4:
            var pe = p.stateNode.containerInfo,
              Ue = yn(a);
            oo(a, Ue, pe);
            break;
          default:
            throw Error(n(161));
        }
      } catch (tt) {
        Rn(a, a.return, tt);
      }
      a.flags &= -3;
    }
    l & 4096 && (a.flags &= -4097);
  }
  function Nd(a) {
    if (a.subtreeFlags & 1024)
      for (a = a.child; a !== null; ) {
        var l = a;
        (Nd(l),
          l.tag === 5 && l.flags & 1024 && l.stateNode.reset(),
          (a = a.sibling));
      }
  }
  function fa(a, l) {
    if (l.subtreeFlags & 8772)
      for (l = l.child; l !== null; ) (ci(a, l.alternate, l), (l = l.sibling));
  }
  function lo(a) {
    for (a = a.child; a !== null; ) {
      var l = a;
      switch (l.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          (xr(4, l, l.return), lo(l));
          break;
        case 1:
          br(l, l.return);
          var p = l.stateNode;
          (typeof p.componentWillUnmount == "function" && ur(l, l.return, p),
            lo(l));
          break;
        case 27:
          ig(l.stateNode);
        case 26:
        case 5:
          (br(l, l.return), lo(l));
          break;
        case 22:
          l.memoizedState === null && lo(l);
          break;
        case 30:
          lo(l);
          break;
        default:
          lo(l);
      }
      a = a.sibling;
    }
  }
  function Hr(a, l, p) {
    for (p = p && (l.subtreeFlags & 8772) !== 0, l = l.child; l !== null; ) {
      var g = l.alternate,
        M = a,
        A = l,
        z = A.flags;
      switch (A.tag) {
        case 0:
        case 11:
        case 15:
          (Hr(M, A, p), oa(4, A));
          break;
        case 1:
          if (
            (Hr(M, A, p),
            (g = A),
            (M = g.stateNode),
            typeof M.componentDidMount == "function")
          )
            try {
              M.componentDidMount();
            } catch (Ue) {
              Rn(g, g.return, Ue);
            }
          if (((g = A), (M = g.updateQueue), M !== null)) {
            var Q = g.stateNode;
            try {
              var pe = M.shared.hiddenCallbacks;
              if (pe !== null)
                for (M.shared.hiddenCallbacks = null, M = 0; M < pe.length; M++)
                  bu(pe[M], Q);
            } catch (Ue) {
              Rn(g, g.return, Ue);
            }
          }
          (p && z & 64 && wa(A), Po(A, A.return));
          break;
        case 27:
          Dd(A);
        case 26:
        case 5:
          (Hr(M, A, p), p && g === null && z & 4 && Hf(A), Po(A, A.return));
          break;
        case 12:
          Hr(M, A, p);
          break;
        case 31:
          (Hr(M, A, p), p && z & 4 && Ml(M, A));
          break;
        case 13:
          (Hr(M, A, p), p && z & 4 && wu(M, A));
          break;
        case 22:
          (A.memoizedState === null && Hr(M, A, p), Po(A, A.return));
          break;
        case 30:
          break;
        default:
          Hr(M, A, p);
      }
      l = l.sibling;
    }
  }
  function El(a, l) {
    var p = null;
    (a !== null &&
      a.memoizedState !== null &&
      a.memoizedState.cachePool !== null &&
      (p = a.memoizedState.cachePool.pool),
      (a = null),
      l.memoizedState !== null &&
        l.memoizedState.cachePool !== null &&
        (a = l.memoizedState.cachePool.pool),
      a !== p && (a != null && a.refCount++, p != null && dc(p)));
  }
  function Ac(a, l) {
    ((a = null),
      l.alternate !== null && (a = l.alternate.memoizedState.cache),
      (l = l.memoizedState.cache),
      l !== a && (l.refCount++, a != null && dc(a)));
  }
  function _r(a, l, p, g) {
    if (l.subtreeFlags & 10256)
      for (l = l.child; l !== null; ) (Jm(a, l, p, g), (l = l.sibling));
  }
  function Jm(a, l, p, g) {
    var M = l.flags;
    switch (l.tag) {
      case 0:
      case 11:
      case 15:
        (_r(a, l, p, g), M & 2048 && oa(9, l));
        break;
      case 1:
        _r(a, l, p, g);
        break;
      case 3:
        (_r(a, l, p, g),
          M & 2048 &&
            ((a = null),
            l.alternate !== null && (a = l.alternate.memoizedState.cache),
            (l = l.memoizedState.cache),
            l !== a && (l.refCount++, a != null && dc(a))));
        break;
      case 12:
        if (M & 2048) {
          (_r(a, l, p, g), (a = l.stateNode));
          try {
            var A = l.memoizedProps,
              z = A.id,
              Q = A.onPostCommit;
            typeof Q == "function" &&
              Q(
                z,
                l.alternate === null ? "mount" : "update",
                a.passiveEffectDuration,
                -0,
              );
          } catch (pe) {
            Rn(l, l.return, pe);
          }
        } else _r(a, l, p, g);
        break;
      case 31:
        _r(a, l, p, g);
        break;
      case 13:
        _r(a, l, p, g);
        break;
      case 23:
        break;
      case 22:
        ((A = l.stateNode),
          (z = l.alternate),
          l.memoizedState !== null
            ? A._visibility & 2
              ? _r(a, l, p, g)
              : co(a, l)
            : A._visibility & 2
              ? _r(a, l, p, g)
              : ((A._visibility |= 2),
                Sr(a, l, p, g, (l.subtreeFlags & 10256) !== 0 || !1)),
          M & 2048 && El(z, l));
        break;
      case 24:
        (_r(a, l, p, g), M & 2048 && Ac(l.alternate, l));
        break;
      default:
        _r(a, l, p, g);
    }
  }
  function Sr(a, l, p, g, M) {
    for (
      M = M && ((l.subtreeFlags & 10256) !== 0 || !1), l = l.child;
      l !== null;
    ) {
      var A = a,
        z = l,
        Q = p,
        pe = g,
        Ue = z.flags;
      switch (z.tag) {
        case 0:
        case 11:
        case 15:
          (Sr(A, z, Q, pe, M), oa(8, z));
          break;
        case 23:
          break;
        case 22:
          var tt = z.stateNode;
          (z.memoizedState !== null
            ? tt._visibility & 2
              ? Sr(A, z, Q, pe, M)
              : co(A, z)
            : ((tt._visibility |= 2), Sr(A, z, Q, pe, M)),
            M && Ue & 2048 && El(z.alternate, z));
          break;
        case 24:
          (Sr(A, z, Q, pe, M), M && Ue & 2048 && Ac(z.alternate, z));
          break;
        default:
          Sr(A, z, Q, pe, M);
      }
      l = l.sibling;
    }
  }
  function co(a, l) {
    if (l.subtreeFlags & 10256)
      for (l = l.child; l !== null; ) {
        var p = a,
          g = l,
          M = g.flags;
        switch (g.tag) {
          case 22:
            (co(p, g), M & 2048 && El(g.alternate, g));
            break;
          case 24:
            (co(p, g), M & 2048 && Ac(g.alternate, g));
            break;
          default:
            co(p, g);
        }
        l = l.sibling;
      }
  }
  var Cc = 8192;
  function Us(a, l, p) {
    if (a.subtreeFlags & Cc)
      for (a = a.child; a !== null; ) (Ud(a, l, p), (a = a.sibling));
  }
  function Ud(a, l, p) {
    switch (a.tag) {
      case 26:
        (Us(a, l, p),
          a.flags & Cc &&
            a.memoizedState !== null &&
            hP(p, ua, a.memoizedState, a.memoizedProps));
        break;
      case 5:
        Us(a, l, p);
        break;
      case 3:
      case 4:
        var g = ua;
        ((ua = ny(a.stateNode.containerInfo)), Us(a, l, p), (ua = g));
        break;
      case 22:
        a.memoizedState === null &&
          ((g = a.alternate),
          g !== null && g.memoizedState !== null
            ? ((g = Cc), (Cc = 16777216), Us(a, l, p), (Cc = g))
            : Us(a, l, p));
        break;
      default:
        Us(a, l, p);
    }
  }
  function Rc(a) {
    var l = a.alternate;
    if (l !== null && ((a = l.child), a !== null)) {
      l.child = null;
      do ((l = a.sibling), (a.sibling = null), (a = l));
      while (a !== null);
    }
  }
  function wl(a) {
    var l = a.deletions;
    if ((a.flags & 16) !== 0) {
      if (l !== null)
        for (var p = 0; p < l.length; p++) {
          var g = l[p];
          ((fr = g), Si(g, a));
        }
      Rc(a);
    }
    if (a.subtreeFlags & 10256)
      for (a = a.child; a !== null; ) (us(a), (a = a.sibling));
  }
  function us(a) {
    switch (a.tag) {
      case 0:
      case 11:
      case 15:
        (wl(a), a.flags & 2048 && xr(9, a, a.return));
        break;
      case 3:
        wl(a);
        break;
      case 12:
        wl(a);
        break;
      case 22:
        var l = a.stateNode;
        a.memoizedState !== null &&
        l._visibility & 2 &&
        (a.return === null || a.return.tag !== 13)
          ? ((l._visibility &= -3), fs(a))
          : wl(a);
        break;
      default:
        wl(a);
    }
  }
  function fs(a) {
    var l = a.deletions;
    if ((a.flags & 16) !== 0) {
      if (l !== null)
        for (var p = 0; p < l.length; p++) {
          var g = l[p];
          ((fr = g), Si(g, a));
        }
      Rc(a);
    }
    for (a = a.child; a !== null; ) {
      switch (((l = a), l.tag)) {
        case 0:
        case 11:
        case 15:
          (xr(8, l, l.return), fs(l));
          break;
        case 22:
          ((p = l.stateNode),
            p._visibility & 2 && ((p._visibility &= -3), fs(l)));
          break;
        default:
          fs(l);
      }
      a = a.sibling;
    }
  }
  function Si(a, l) {
    for (; fr !== null; ) {
      var p = fr;
      switch (p.tag) {
        case 0:
        case 11:
        case 15:
          xr(8, p, l);
          break;
        case 23:
        case 22:
          if (p.memoizedState !== null && p.memoizedState.cachePool !== null) {
            var g = p.memoizedState.cachePool.pool;
            g != null && g.refCount++;
          }
          break;
        case 24:
          dc(p.memoizedState.cache);
      }
      if (((g = p.child), g !== null)) ((g.return = p), (fr = g));
      else
        e: for (p = a; fr !== null; ) {
          g = fr;
          var M = g.sibling,
            A = g.return;
          if ((jf(g), g === p)) {
            fr = null;
            break e;
          }
          if (M !== null) {
            ((M.return = A), (fr = M));
            break e;
          }
          fr = A;
        }
    }
  }
  var Oo = {
      getCacheForType: function (a) {
        var l = Xt(Hi),
          p = l.data.get(a);
        return (p === void 0 && ((p = a()), l.data.set(a, p)), p);
      },
      cacheSignal: function () {
        return Xt(Hi).controller.signal;
      },
    },
    $t = typeof WeakMap == "function" ? WeakMap : Map,
    Ot = 0,
    Zt = null,
    on = null,
    sn = 0,
    Mn = 0,
    Nr = null,
    ha = !1,
    Ca = !1,
    $m = !1,
    Ps = 0,
    pi = 0,
    uo = 0,
    Al = 0,
    Wf = 0,
    jr = 0,
    ti = 0,
    Dc = null,
    Mi = null,
    Ti = !1,
    Au = 0,
    eg = 0,
    Li = 1 / 0,
    mi = null,
    Ni = null,
    Vn = 0,
    Is = null,
    Cu = null,
    da = 0,
    Ru = 0,
    Du = null,
    Xf = null,
    Cl = 0,
    Lc = null;
  function Os() {
    return (Ot & 2) !== 0 && sn !== 0 ? sn & -sn : W.T !== null ? He() : zi();
  }
  function dn() {
    if (jr === 0)
      if ((sn & 536870912) === 0 || _n) {
        var a = Ke;
        ((Ke <<= 1), (Ke & 3932160) === 0 && (Ke = 262144), (jr = a));
      } else jr = 536870912;
    return ((a = as.current), a !== null && (a.flags |= 32), jr);
  }
  function ln(a, l, p) {
    (((a === Zt && (Mn === 2 || Mn === 9)) || a.cancelPendingCommit !== null) &&
      (Dl(a, 0), Wi(a, sn, jr, !1)),
      hn(a, p),
      ((Ot & 2) === 0 || a !== Zt) &&
        (a === Zt &&
          ((Ot & 2) === 0 && (Al |= p), pi === 4 && Wi(a, sn, jr, !1)),
        ut(a)));
  }
  function pn(a, l, p) {
    if ((Ot & 6) !== 0) throw Error(n(327));
    var g = (!p && (l & 127) === 0 && (l & a.expiredLanes) === 0) || ct(a, l),
      M = g ? qf(a, l) : Wr(a, l, !0),
      A = g;
    do {
      if (M === 0) {
        Ca && !g && Wi(a, l, 0, !1);
        break;
      } else {
        if (((p = a.current.alternate), A && !Gn(p))) {
          ((M = Wr(a, l, !1)), (A = !1));
          continue;
        }
        if (M === 2) {
          if (((A = l), a.errorRecoveryDisabledLanes & A)) var z = 0;
          else
            ((z = a.pendingLanes & -536870913),
              (z = z !== 0 ? z : z & 536870912 ? 536870912 : 0));
          if (z !== 0) {
            l = z;
            e: {
              var Q = a;
              M = Dc;
              var pe = Q.current.memoizedState.isDehydrated;
              if (
                (pe && (Dl(Q, z).flags |= 256), (z = Wr(Q, z, !1)), z !== 2)
              ) {
                if ($m && !pe) {
                  ((Q.errorRecoveryDisabledLanes |= A), (Al |= A), (M = 4));
                  break e;
                }
                ((A = Mi),
                  (Mi = M),
                  A !== null &&
                    (Mi === null ? (Mi = A) : Mi.push.apply(Mi, A)));
              }
              M = z;
            }
            if (((A = !1), M !== 2)) continue;
          }
        }
        if (M === 1) {
          (Dl(a, 0), Wi(a, l, 0, !0));
          break;
        }
        e: {
          switch (((g = a), (A = M), A)) {
            case 0:
            case 1:
              throw Error(n(345));
            case 4:
              if ((l & 4194048) !== l) break;
            case 6:
              Wi(g, l, jr, !ha);
              break e;
            case 2:
              Mi = null;
              break;
            case 3:
            case 5:
              break;
            default:
              throw Error(n(329));
          }
          if ((l & 62914560) === l && ((M = Au + 300 - k()), 10 < M)) {
            if ((Wi(g, l, jr, !ha), Ee(g, 0, !0) !== 0)) break e;
            ((da = l),
              (g.timeoutHandle = IE(
                xn.bind(
                  null,
                  g,
                  p,
                  Mi,
                  mi,
                  Ti,
                  l,
                  jr,
                  Al,
                  ti,
                  ha,
                  A,
                  "Throttled",
                  -0,
                  0,
                ),
                M,
              )));
            break e;
          }
          xn(g, p, Mi, mi, Ti, l, jr, Al, ti, ha, A, null, -0, 0);
        }
      }
      break;
    } while (!0);
    ut(a);
  }
  function xn(a, l, p, g, M, A, z, Q, pe, Ue, tt, at, Be, Xe) {
    if (
      ((a.timeoutHandle = -1),
      (at = l.subtreeFlags),
      at & 8192 || (at & 16785408) === 16785408)
    ) {
      ((at = {
        stylesheets: null,
        count: 0,
        imgCount: 0,
        imgBytes: 0,
        suspenseyImages: [],
        waitingForImages: !0,
        waitingForViewTransition: !1,
        unsuspend: wr,
      }),
        Ud(l, A, at));
      var Nt =
        (A & 62914560) === A ? Au - k() : (A & 4194048) === A ? eg - k() : 0;
      if (((Nt = dP(at, Nt)), Nt !== null)) {
        ((da = A),
          (a.cancelPendingCommit = Nt(
            zo.bind(null, a, l, A, p, g, M, z, Q, pe, tt, at, null, Be, Xe),
          )),
          Wi(a, A, z, !Ue));
        return;
      }
    }
    zo(a, l, A, p, g, M, z, Q, pe);
  }
  function Gn(a) {
    for (var l = a; ; ) {
      var p = l.tag;
      if (
        (p === 0 || p === 11 || p === 15) &&
        l.flags & 16384 &&
        ((p = l.updateQueue), p !== null && ((p = p.stores), p !== null))
      )
        for (var g = 0; g < p.length; g++) {
          var M = p[g],
            A = M.getSnapshot;
          M = M.value;
          try {
            if (!zr(A(), M)) return !1;
          } catch {
            return !1;
          }
        }
      if (((p = l.child), l.subtreeFlags & 16384 && p !== null))
        ((p.return = l), (l = p));
      else {
        if (l === a) break;
        for (; l.sibling === null; ) {
          if (l.return === null || l.return === a) return !0;
          l = l.return;
        }
        ((l.sibling.return = l.return), (l = l.sibling));
      }
    }
    return !0;
  }
  function Wi(a, l, p, g) {
    ((l &= ~Wf),
      (l &= ~Al),
      (a.suspendedLanes |= l),
      (a.pingedLanes &= ~l),
      g && (a.warmLanes |= l),
      (g = a.expirationTimes));
    for (var M = l; 0 < M; ) {
      var A = 31 - re(M),
        z = 1 << A;
      ((g[A] = -1), (M &= ~z));
    }
    p !== 0 && Bn(a, p, l);
  }
  function Ra() {
    return (Ot & 6) === 0 ? (Ct(0), !1) : !0;
  }
  function Rl() {
    if (on !== null) {
      if (Mn === 0) var a = on.return;
      else ((a = on), (eo = ml = null), Mm(a), (yc = null), (xc = 0), (a = on));
      for (; a !== null; ) (Ns(a.alternate, a), (a = a.return));
      on = null;
    }
  }
  function Dl(a, l) {
    var p = a.timeoutHandle;
    (p !== -1 && ((a.timeoutHandle = -1), ZU(p)),
      (p = a.cancelPendingCommit),
      p !== null && ((a.cancelPendingCommit = null), p()),
      (da = 0),
      Rl(),
      (Zt = a),
      (on = p = is(a.current, null)),
      (sn = l),
      (Mn = 0),
      (Nr = null),
      (ha = !1),
      (Ca = ct(a, l)),
      ($m = !1),
      (ti = jr = Wf = Al = uo = pi = 0),
      (Mi = Dc = null),
      (Ti = !1),
      (l & 8) !== 0 && (l |= l & 32));
    var g = a.entangledLanes;
    if (g !== 0)
      for (a = a.entanglements, g &= l; 0 < g; ) {
        var M = 31 - re(g),
          A = 1 << M;
        ((l |= a[M]), (g &= ~A));
      }
    return ((Ps = l), wf(), p);
  }
  function fo(a, l) {
    ((Jt = null),
      (W.H = Tu),
      l === pc || l === an
        ? ((l = gc()), (Mn = 3))
        : l === Df
          ? ((l = gc()), (Mn = 4))
          : (Mn =
              l === _d
                ? 8
                : l !== null &&
                    typeof l == "object" &&
                    typeof l.then == "function"
                  ? 6
                  : 1),
      (Nr = l),
      on === null && ((pi = 1), bd(a, Cs(l, a.current))));
  }
  function gi() {
    var a = as.current;
    return a === null
      ? !0
      : (sn & 4194048) === sn
        ? Vr === null
        : (sn & 62914560) === sn || (sn & 536870912) !== 0
          ? a === Vr
          : !1;
  }
  function Fo() {
    var a = W.H;
    return ((W.H = Tu), a === null ? Tu : a);
  }
  function Ll() {
    var a = W.A;
    return ((W.A = Oo), a);
  }
  function Lu() {
    ((pi = 4),
      ha || ((sn & 4194048) !== sn && as.current !== null) || (Ca = !0),
      ((uo & 134217727) === 0 && (Al & 134217727) === 0) ||
        Zt === null ||
        Wi(Zt, sn, jr, !1));
  }
  function Wr(a, l, p) {
    var g = Ot;
    Ot |= 2;
    var M = Fo(),
      A = Ll();
    ((Zt !== a || sn !== l) && ((mi = null), Dl(a, l)), (l = !1));
    var z = pi;
    e: do
      try {
        if (Mn !== 0 && on !== null) {
          var Q = on,
            pe = Nr;
          switch (Mn) {
            case 8:
              (Rl(), (z = 6));
              break e;
            case 3:
            case 2:
            case 9:
            case 6:
              as.current === null && (l = !0);
              var Ue = Mn;
              if (((Mn = 0), (Nr = null), Nc(a, Q, pe, Ue), p && Ca)) {
                z = 0;
                break e;
              }
              break;
            default:
              ((Ue = Mn), (Mn = 0), (Nr = null), Nc(a, Q, pe, Ue));
          }
        }
        (Nu(), (z = pi));
        break;
      } catch (tt) {
        fo(a, tt);
      }
    while (!0);
    return (
      l && a.shellSuspendCounter++,
      (eo = ml = null),
      (Ot = g),
      (W.H = M),
      (W.A = A),
      on === null && ((Zt = null), (sn = 0), wf()),
      z
    );
  }
  function Nu() {
    for (; on !== null; ) Pd(on);
  }
  function qf(a, l) {
    var p = Ot;
    Ot |= 2;
    var g = Fo(),
      M = Ll();
    Zt !== a || sn !== l
      ? ((mi = null), (Li = k() + 500), Dl(a, l))
      : (Ca = ct(a, l));
    e: do
      try {
        if (Mn !== 0 && on !== null) {
          l = on;
          var A = Nr;
          t: switch (Mn) {
            case 1:
              ((Mn = 0), (Nr = null), Nc(a, l, A, 1));
              break;
            case 2:
            case 9:
              if (ss(A)) {
                ((Mn = 0), (Nr = null), Yf(l));
                break;
              }
              ((l = function () {
                ((Mn !== 2 && Mn !== 9) || Zt !== a || (Mn = 7), ut(a));
              }),
                A.then(l, l));
              break e;
            case 3:
              Mn = 7;
              break e;
            case 4:
              Mn = 5;
              break e;
            case 7:
              ss(A)
                ? ((Mn = 0), (Nr = null), Yf(l))
                : ((Mn = 0), (Nr = null), Nc(a, l, A, 7));
              break;
            case 5:
              var z = null;
              switch (on.tag) {
                case 26:
                  z = on.memoizedState;
                case 5:
                case 27:
                  var Q = on;
                  if (z ? KE(z) : Q.stateNode.complete) {
                    ((Mn = 0), (Nr = null));
                    var pe = Q.sibling;
                    if (pe !== null) on = pe;
                    else {
                      var Ue = Q.return;
                      Ue !== null ? ((on = Ue), Nl(Ue)) : (on = null);
                    }
                    break t;
                  }
              }
              ((Mn = 0), (Nr = null), Nc(a, l, A, 5));
              break;
            case 6:
              ((Mn = 0), (Nr = null), Nc(a, l, A, 6));
              break;
            case 8:
              (Rl(), (pi = 6));
              break e;
            default:
              throw Error(n(462));
          }
        }
        hs();
        break;
      } catch (tt) {
        fo(a, tt);
      }
    while (!0);
    return (
      (eo = ml = null),
      (W.H = g),
      (W.A = M),
      (Ot = p),
      on !== null ? 0 : ((Zt = null), (sn = 0), wf(), pi)
    );
  }
  function hs() {
    for (; on !== null && !ke(); ) Pd(on);
  }
  function Pd(a) {
    var l = Rd(a.alternate, a, Ps);
    ((a.memoizedProps = a.pendingProps), l === null ? Nl(a) : (on = l));
  }
  function Yf(a) {
    var l = a,
      p = l.alternate;
    switch (l.tag) {
      case 15:
      case 0:
        l = Bf(p, l, l.pendingProps, l.type, void 0, sn);
        break;
      case 11:
        l = Bf(p, l, l.pendingProps, l.type.render, l.ref, sn);
        break;
      case 5:
        Mm(l);
      default:
        (Ns(p, l), (l = on = uu(l, Ps)), (l = Rd(p, l, Ps)));
    }
    ((a.memoizedProps = a.pendingProps), l === null ? Nl(a) : (on = l));
  }
  function Nc(a, l, p, g) {
    ((eo = ml = null), Mm(l), (yc = null), (xc = 0));
    var M = l.return;
    try {
      if (Ji(a, M, l, p, sn)) {
        ((pi = 1), bd(a, Cs(p, a.current)), (on = null));
        return;
      }
    } catch (A) {
      if (M !== null) throw ((on = M), A);
      ((pi = 1), bd(a, Cs(p, a.current)), (on = null));
      return;
    }
    l.flags & 32768
      ? (_n || g === 1
          ? (a = !0)
          : Ca || (sn & 536870912) !== 0
            ? (a = !1)
            : ((ha = a = !0),
              (g === 2 || g === 9 || g === 3 || g === 6) &&
                ((g = as.current),
                g !== null && g.tag === 13 && (g.flags |= 16384))),
        Zf(l, a))
      : Nl(l);
  }
  function Nl(a) {
    var l = a;
    do {
      if ((l.flags & 32768) !== 0) {
        Zf(l, ha);
        return;
      }
      a = l.return;
      var p = Gf(l.alternate, l, Ps);
      if (p !== null) {
        on = p;
        return;
      }
      if (((l = l.sibling), l !== null)) {
        on = l;
        return;
      }
      on = l = a;
    } while (l !== null);
    pi === 0 && (pi = 5);
  }
  function Zf(a, l) {
    do {
      var p = aa(a.alternate, a);
      if (p !== null) {
        ((p.flags &= 32767), (on = p));
        return;
      }
      if (
        ((p = a.return),
        p !== null &&
          ((p.flags |= 32768), (p.subtreeFlags = 0), (p.deletions = null)),
        !l && ((a = a.sibling), a !== null))
      ) {
        on = a;
        return;
      }
      on = a = p;
    } while (a !== null);
    ((pi = 6), (on = null));
  }
  function zo(a, l, p, g, M, A, z, Q, pe) {
    a.cancelPendingCommit = null;
    do Uu();
    while (Vn !== 0);
    if ((Ot & 6) !== 0) throw Error(n(327));
    if (l !== null) {
      if (l === a.current) throw Error(n(177));
      if (
        ((A = l.lanes | l.childLanes),
        (A |= or),
        bn(a, p, A, z, Q, pe),
        a === Zt && ((on = Zt = null), (sn = 0)),
        (Cu = l),
        (Is = a),
        (da = p),
        (Ru = A),
        (Du = M),
        (Xf = g),
        (l.subtreeFlags & 10256) !== 0 || (l.flags & 10256) !== 0
          ? ((a.callbackNode = null),
            (a.callbackPriority = 0),
            D(be, function () {
              return (Id(), null);
            }))
          : ((a.callbackNode = null), (a.callbackPriority = 0)),
        (g = (l.flags & 13878) !== 0),
        (l.subtreeFlags & 13878) !== 0 || g)
      ) {
        ((g = W.T), (W.T = null), (M = $.p), ($.p = 2), (z = Ot), (Ot |= 4));
        try {
          Wb(a, l, p);
        } finally {
          ((Ot = z), ($.p = M), (W.T = g));
        }
      }
      ((Vn = 1), Xi(), Bo(), Uc());
    }
  }
  function Xi() {
    if (Vn === 1) {
      Vn = 0;
      var a = Is,
        l = Cu,
        p = (l.flags & 13878) !== 0;
      if ((l.subtreeFlags & 13878) !== 0 || p) {
        ((p = W.T), (W.T = null));
        var g = $.p;
        $.p = 2;
        var M = Ot;
        Ot |= 4;
        try {
          Tl(l, a);
          var A = Jb,
            z = ev(a.containerInfo),
            Q = A.focusedElem,
            pe = A.selectionRange;
          if (
            z !== Q &&
            Q &&
            Q.ownerDocument &&
            Yn(Q.ownerDocument.documentElement, Q)
          ) {
            if (pe !== null && sm(Q)) {
              var Ue = pe.start,
                tt = pe.end;
              if ((tt === void 0 && (tt = Ue), "selectionStart" in Q))
                ((Q.selectionStart = Ue),
                  (Q.selectionEnd = Math.min(tt, Q.value.length)));
              else {
                var at = Q.ownerDocument || document,
                  Be = (at && at.defaultView) || window;
                if (Be.getSelection) {
                  var Xe = Be.getSelection(),
                    Nt = Q.textContent.length,
                    jt = Math.min(pe.start, Nt),
                    Jn = pe.end === void 0 ? jt : Math.min(pe.end, Nt);
                  !Xe.extend && jt > Jn && ((z = Jn), (Jn = jt), (jt = z));
                  var Me = ou(Q, jt),
                    xe = ou(Q, Jn);
                  if (
                    Me &&
                    xe &&
                    (Xe.rangeCount !== 1 ||
                      Xe.anchorNode !== Me.node ||
                      Xe.anchorOffset !== Me.offset ||
                      Xe.focusNode !== xe.node ||
                      Xe.focusOffset !== xe.offset)
                  ) {
                    var Ne = at.createRange();
                    (Ne.setStart(Me.node, Me.offset),
                      Xe.removeAllRanges(),
                      jt > Jn
                        ? (Xe.addRange(Ne), Xe.extend(xe.node, xe.offset))
                        : (Ne.setEnd(xe.node, xe.offset), Xe.addRange(Ne)));
                  }
                }
              }
            }
            for (at = [], Xe = Q; (Xe = Xe.parentNode); )
              Xe.nodeType === 1 &&
                at.push({
                  element: Xe,
                  left: Xe.scrollLeft,
                  top: Xe.scrollTop,
                });
            for (
              typeof Q.focus == "function" && Q.focus(), Q = 0;
              Q < at.length;
              Q++
            ) {
              var st = at[Q];
              ((st.element.scrollLeft = st.left),
                (st.element.scrollTop = st.top));
            }
          }
          ((ly = !!Qb), (Jb = Qb = null));
        } finally {
          ((Ot = M), ($.p = g), (W.T = p));
        }
      }
      ((a.current = l), (Vn = 2));
    }
  }
  function Bo() {
    if (Vn === 2) {
      Vn = 0;
      var a = Is,
        l = Cu,
        p = (l.flags & 8772) !== 0;
      if ((l.subtreeFlags & 8772) !== 0 || p) {
        ((p = W.T), (W.T = null));
        var g = $.p;
        $.p = 2;
        var M = Ot;
        Ot |= 4;
        try {
          ci(a, l.alternate, l);
        } finally {
          ((Ot = M), ($.p = g), (W.T = p));
        }
      }
      Vn = 3;
    }
  }
  function Uc() {
    if (Vn === 4 || Vn === 3) {
      ((Vn = 0), H());
      var a = Is,
        l = Cu,
        p = da,
        g = Xf;
      (l.subtreeFlags & 10256) !== 0 || (l.flags & 10256) !== 0
        ? (Vn = 5)
        : ((Vn = 0), (Cu = Is = null), ho(a, a.pendingLanes));
      var M = a.pendingLanes;
      if (
        (M === 0 && (Ni = null),
        ar(p),
        (l = l.stateNode),
        Ve && typeof Ve.onCommitFiberRoot == "function")
      )
        try {
          Ve.onCommitFiberRoot(Ge, l, void 0, (l.current.flags & 128) === 128);
        } catch {}
      if (g !== null) {
        ((l = W.T), (M = $.p), ($.p = 2), (W.T = null));
        try {
          for (var A = a.onRecoverableError, z = 0; z < g.length; z++) {
            var Q = g[z];
            A(Q.value, { componentStack: Q.stack });
          }
        } finally {
          ((W.T = l), ($.p = M));
        }
      }
      ((da & 3) !== 0 && Uu(),
        ut(a),
        (M = a.pendingLanes),
        (p & 261930) !== 0 && (M & 42) !== 0
          ? a === Lc
            ? Cl++
            : ((Cl = 0), (Lc = a))
          : (Cl = 0),
        Ct(0));
    }
  }
  function ho(a, l) {
    (a.pooledCacheLanes &= l) === 0 &&
      ((l = a.pooledCache), l != null && ((a.pooledCache = null), dc(l)));
  }
  function Uu() {
    return (Xi(), Bo(), Uc(), Id());
  }
  function Id() {
    if (Vn !== 5) return !1;
    var a = Is,
      l = Ru;
    Ru = 0;
    var p = ar(da),
      g = W.T,
      M = $.p;
    try {
      (($.p = 32 > p ? 32 : p), (W.T = null), (p = Du), (Du = null));
      var A = Is,
        z = da;
      if (((Vn = 0), (Cu = Is = null), (da = 0), (Ot & 6) !== 0))
        throw Error(n(331));
      var Q = Ot;
      if (
        ((Ot |= 4),
        us(A.current),
        Jm(A, A.current, z, p),
        (Ot = Q),
        Ct(0, !1),
        Ve && typeof Ve.onPostCommitFiberRoot == "function")
      )
        try {
          Ve.onPostCommitFiberRoot(Ge, A);
        } catch {}
      return !0;
    } finally {
      (($.p = M), (W.T = g), ho(a, l));
    }
  }
  function tg(a, l, p) {
    ((l = Cs(p, l)),
      (l = Wm(a.stateNode, l, 2)),
      (a = yl(a, l, 2)),
      a !== null && (hn(a, 2), ut(a)));
  }
  function Rn(a, l, p) {
    if (a.tag === 3) tg(a, a, p);
    else
      for (; l !== null; ) {
        if (l.tag === 3) {
          tg(l, a, p);
          break;
        } else if (l.tag === 1) {
          var g = l.stateNode;
          if (
            typeof l.type.getDerivedStateFromError == "function" ||
            (typeof g.componentDidCatch == "function" &&
              (Ni === null || !Ni.has(g)))
          ) {
            ((a = Cs(p, a)),
              (p = Xm(2)),
              (g = yl(l, p, 2)),
              g !== null && (qv(p, g, l, a), hn(g, 2), ut(g)));
            break;
          }
        }
        l = l.return;
      }
  }
  function Kf(a, l, p) {
    var g = a.pingCache;
    if (g === null) {
      g = a.pingCache = new $t();
      var M = new Set();
      g.set(l, M);
    } else ((M = g.get(l)), M === void 0 && ((M = new Set()), g.set(l, M)));
    M.has(p) ||
      (($m = !0), M.add(p), (a = c.bind(null, a, l, p)), l.then(a, a));
  }
  function c(a, l, p) {
    var g = a.pingCache;
    (g !== null && g.delete(l),
      (a.pingedLanes |= a.suspendedLanes & p),
      (a.warmLanes &= ~p),
      Zt === a &&
        (sn & p) === p &&
        (pi === 4 || (pi === 3 && (sn & 62914560) === sn && 300 > k() - Au)
          ? (Ot & 2) === 0 && Dl(a, 0)
          : (Wf |= p),
        ti === sn && (ti = 0)),
      ut(a));
  }
  function f(a, l) {
    (l === 0 && (l = St()), (a = Br(a, l)), a !== null && (hn(a, l), ut(a)));
  }
  function x(a) {
    var l = a.memoizedState,
      p = 0;
    (l !== null && (p = l.retryLane), f(a, p));
  }
  function S(a, l) {
    var p = 0;
    switch (a.tag) {
      case 31:
      case 13:
        var g = a.stateNode,
          M = a.memoizedState;
        M !== null && (p = M.retryLane);
        break;
      case 19:
        g = a.stateNode;
        break;
      case 22:
        g = a.stateNode._retryCache;
        break;
      default:
        throw Error(n(314));
    }
    (g !== null && g.delete(l), f(a, p));
  }
  function D(a, l) {
    return je(a, l);
  }
  var U = null,
    Y = null,
    me = !1,
    We = !1,
    ot = !1,
    xt = 0;
  function ut(a) {
    (a !== Y &&
      a.next === null &&
      (Y === null ? (U = Y = a) : (Y = Y.next = a)),
      (We = !0),
      me || ((me = !0), we()));
  }
  function Ct(a, l) {
    if (!ot && We) {
      ot = !0;
      do
        for (var p = !1, g = U; g !== null; ) {
          if (a !== 0) {
            var M = g.pendingLanes;
            if (M === 0) var A = 0;
            else {
              var z = g.suspendedLanes,
                Q = g.pingedLanes;
              ((A = (1 << (31 - re(42 | a) + 1)) - 1),
                (A &= M & ~(z & ~Q)),
                (A = A & 201326741 ? (A & 201326741) | 1 : A ? A | 2 : 0));
            }
            A !== 0 && ((p = !0), Pe(g, A));
          } else
            ((A = sn),
              (A = Ee(
                g,
                g === Zt ? A : 0,
                g.cancelPendingCommit !== null || g.timeoutHandle !== -1,
              )),
              (A & 3) === 0 || ct(g, A) || ((p = !0), Pe(g, A)));
          g = g.next;
        }
      while (p);
      ot = !1;
    }
  }
  function Qt() {
    Ui();
  }
  function Ui() {
    We = me = !1;
    var a = 0;
    xt !== 0 && YU() && (a = xt);
    for (var l = k(), p = null, g = U; g !== null; ) {
      var M = g.next,
        A = Pu(g, l);
      (A === 0
        ? ((g.next = null),
          p === null ? (U = M) : (p.next = M),
          M === null && (Y = p))
        : ((p = g), (a !== 0 || (A & 3) !== 0) && (We = !0)),
        (g = M));
    }
    ((Vn !== 0 && Vn !== 5) || Ct(a), xt !== 0 && (xt = 0));
  }
  function Pu(a, l) {
    for (
      var p = a.suspendedLanes,
        g = a.pingedLanes,
        M = a.expirationTimes,
        A = a.pendingLanes & -62914561;
      0 < A;
    ) {
      var z = 31 - re(A),
        Q = 1 << z,
        pe = M[z];
      (pe === -1
        ? ((Q & p) === 0 || (Q & g) !== 0) && (M[z] = Mt(Q, l))
        : pe <= l && (a.expiredLanes |= Q),
        (A &= ~Q));
    }
    if (
      ((l = Zt),
      (p = sn),
      (p = Ee(
        a,
        a === l ? p : 0,
        a.cancelPendingCommit !== null || a.timeoutHandle !== -1,
      )),
      (g = a.callbackNode),
      p === 0 ||
        (a === l && (Mn === 2 || Mn === 9)) ||
        a.cancelPendingCommit !== null)
    )
      return (
        g !== null && g !== null && Te(g),
        (a.callbackNode = null),
        (a.callbackPriority = 0)
      );
    if ((p & 3) === 0 || ct(a, p)) {
      if (((l = p & -p), l === a.callbackPriority)) return l;
      switch ((g !== null && Te(g), ar(p))) {
        case 2:
        case 8:
          p = _e;
          break;
        case 32:
          p = be;
          break;
        case 268435456:
          p = $e;
          break;
        default:
          p = be;
      }
      return (
        (g = Ul.bind(null, a)),
        (p = je(p, g)),
        (a.callbackPriority = l),
        (a.callbackNode = p),
        l
      );
    }
    return (
      g !== null && g !== null && Te(g),
      (a.callbackPriority = 2),
      (a.callbackNode = null),
      2
    );
  }
  function Ul(a, l) {
    if (Vn !== 0 && Vn !== 5)
      return ((a.callbackNode = null), (a.callbackPriority = 0), null);
    var p = a.callbackNode;
    if (Uu() && a.callbackNode !== p) return null;
    var g = sn;
    return (
      (g = Ee(
        a,
        a === Zt ? g : 0,
        a.cancelPendingCommit !== null || a.timeoutHandle !== -1,
      )),
      g === 0
        ? null
        : (pn(a, g, l),
          Pu(a, k()),
          a.callbackNode != null && a.callbackNode === p
            ? Ul.bind(null, a)
            : null)
    );
  }
  function Pe(a, l) {
    if (Uu()) return null;
    pn(a, l, !0);
  }
  function we() {
    KU(function () {
      (Ot & 6) !== 0 ? je(Ae, Qt) : Ui();
    });
  }
  function He() {
    if (xt === 0) {
      var a = Co;
      (a === 0 && ((a = Oe), (Oe <<= 1), (Oe & 261888) === 0 && (Oe = 256)),
        (xt = a));
    }
    return xt;
  }
  function mt(a) {
    return a == null || typeof a == "symbol" || typeof a == "boolean"
      ? null
      : typeof a == "function"
        ? a
        : Ys("" + a);
  }
  function Vt(a, l) {
    var p = l.ownerDocument.createElement("input");
    return (
      (p.name = l.name),
      (p.value = l.value),
      a.id && p.setAttribute("form", a.id),
      l.parentNode.insertBefore(p, l),
      (a = new FormData(a)),
      p.parentNode.removeChild(p),
      a
    );
  }
  function vi(a, l, p, g, M) {
    if (l === "submit" && p && p.stateNode === M) {
      var A = mt((M[ii] || null).action),
        z = g.submitter;
      z &&
        ((l = (l = z[ii] || null)
          ? mt(l.formAction)
          : z.getAttribute("formAction")),
        l !== null && ((A = l), (z = null)));
      var Q = new So("action", "action", null, g, M);
      a.push({
        event: Q,
        listeners: [
          {
            instance: null,
            listener: function () {
              if (g.defaultPrevented) {
                if (xt !== 0) {
                  var pe = z ? Vt(M, z) : new FormData(M);
                  Fm(
                    p,
                    { pending: !0, data: pe, method: M.method, action: A },
                    null,
                    pe,
                  );
                }
              } else
                typeof A == "function" &&
                  (Q.preventDefault(),
                  (pe = z ? Vt(M, z) : new FormData(M)),
                  Fm(
                    p,
                    { pending: !0, data: pe, method: M.method, action: A },
                    A,
                    pe,
                  ));
            },
            currentTarget: M,
          },
        ],
      });
    }
  }
  for (var Gt = 0; Gt < Tf.length; Gt++) {
    var wn = Tf[Gt],
      hr = wn.toLowerCase(),
      Nn = wn[0].toUpperCase() + wn.slice(1);
    $s(hr, "on" + Nn);
  }
  ($s(Yh, "onAnimationEnd"),
    $s(Mf, "onAnimationIteration"),
    $s(om, "onAnimationStart"),
    $s("dblclick", "onDoubleClick"),
    $s("focusin", "onFocus"),
    $s("focusout", "onBlur"),
    $s(nv, "onTransitionRun"),
    $s(Fb, "onTransitionStart"),
    $s(iv, "onTransitionCancel"),
    $s(lm, "onTransitionEnd"),
    pt("onMouseEnter", ["mouseout", "mouseover"]),
    pt("onMouseLeave", ["mouseout", "mouseover"]),
    pt("onPointerEnter", ["pointerout", "pointerover"]),
    pt("onPointerLeave", ["pointerout", "pointerover"]),
    Ce(
      "onChange",
      "change click focusin focusout input keydown keyup selectionchange".split(
        " ",
      ),
    ),
    Ce(
      "onSelect",
      "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
        " ",
      ),
    ),
    Ce("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]),
    Ce(
      "onCompositionEnd",
      "compositionend focusout keydown keypress keyup mousedown".split(" "),
    ),
    Ce(
      "onCompositionStart",
      "compositionstart focusout keydown keypress keyup mousedown".split(" "),
    ),
    Ce(
      "onCompositionUpdate",
      "compositionupdate focusout keydown keypress keyup mousedown".split(" "),
    ));
  var pa =
      "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
        " ",
      ),
    Xb = new Set(
      "beforetoggle cancel close invalid load scroll scrollend toggle"
        .split(" ")
        .concat(pa),
    );
  function AE(a, l) {
    l = (l & 4) !== 0;
    for (var p = 0; p < a.length; p++) {
      var g = a[p],
        M = g.event;
      g = g.listeners;
      e: {
        var A = void 0;
        if (l)
          for (var z = g.length - 1; 0 <= z; z--) {
            var Q = g[z],
              pe = Q.instance,
              Ue = Q.currentTarget;
            if (((Q = Q.listener), pe !== A && M.isPropagationStopped()))
              break e;
            ((A = Q), (M.currentTarget = Ue));
            try {
              A(M);
            } catch (tt) {
              Ef(tt);
            }
            ((M.currentTarget = null), (A = pe));
          }
        else
          for (z = 0; z < g.length; z++) {
            if (
              ((Q = g[z]),
              (pe = Q.instance),
              (Ue = Q.currentTarget),
              (Q = Q.listener),
              pe !== A && M.isPropagationStopped())
            )
              break e;
            ((A = Q), (M.currentTarget = Ue));
            try {
              A(M);
            } catch (tt) {
              Ef(tt);
            }
            ((M.currentTarget = null), (A = pe));
          }
      }
    }
  }
  function Tn(a, l) {
    var p = l[gr];
    p === void 0 && (p = l[gr] = new Set());
    var g = a + "__bubble";
    p.has(g) || (CE(l, a, 2, !1), p.add(g));
  }
  function qb(a, l, p) {
    var g = 0;
    (l && (g |= 4), CE(p, a, g, l));
  }
  var $v = "_reactListening" + Math.random().toString(36).slice(2);
  function Yb(a) {
    if (!a[$v]) {
      ((a[$v] = !0),
        Fe.forEach(function (p) {
          p !== "selectionchange" && (Xb.has(p) || qb(p, !1, a), qb(p, !0, a));
        }));
      var l = a.nodeType === 9 ? a : a.ownerDocument;
      l === null || l[$v] || ((l[$v] = !0), qb("selectionchange", !1, l));
    }
  }
  function CE(a, l, p, g) {
    switch (iw(l)) {
      case 2:
        var M = gP;
        break;
      case 8:
        M = vP;
        break;
      default:
        M = c_;
    }
    ((p = M.bind(null, l, p, a)),
      (M = void 0),
      !Fr ||
        (l !== "touchstart" && l !== "touchmove" && l !== "wheel") ||
        (M = !0),
      g
        ? M !== void 0
          ? a.addEventListener(l, p, { capture: !0, passive: M })
          : a.addEventListener(l, p, !0)
        : M !== void 0
          ? a.addEventListener(l, p, { passive: M })
          : a.addEventListener(l, p, !1));
  }
  function Zb(a, l, p, g, M) {
    var A = g;
    if ((l & 1) === 0 && (l & 2) === 0 && g !== null)
      e: for (;;) {
        if (g === null) return;
        var z = g.tag;
        if (z === 3 || z === 4) {
          var Q = g.stateNode.containerInfo;
          if (Q === M) break;
          if (z === 4)
            for (z = g.return; z !== null; ) {
              var pe = z.tag;
              if ((pe === 3 || pe === 4) && z.stateNode.containerInfo === M)
                return;
              z = z.return;
            }
          for (; Q !== null; ) {
            if (((z = ts(Q)), z === null)) return;
            if (
              ((pe = z.tag), pe === 5 || pe === 6 || pe === 26 || pe === 27)
            ) {
              g = A = z;
              continue e;
            }
            Q = Q.parentNode;
          }
        }
        g = g.return;
      }
    tl(function () {
      var Ue = A,
        tt = nc(p),
        at = [];
      e: {
        var Be = Js.get(a);
        if (Be !== void 0) {
          var Xe = So,
            Nt = a;
          switch (a) {
            case "keypress":
              if (il(p) === 0) break e;
            case "keydown":
            case "keyup":
              Xe = lc;
              break;
            case "focusin":
              ((Nt = "focus"), (Xe = iu));
              break;
            case "focusout":
              ((Nt = "blur"), (Xe = iu));
              break;
            case "beforeblur":
            case "afterblur":
              Xe = iu;
              break;
            case "click":
              if (p.button === 2) break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              Xe = vf;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              Xe = oc;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              Xe = G0;
              break;
            case Yh:
            case Mf:
            case om:
              Xe = As;
              break;
            case lm:
              Xe = Ob;
              break;
            case "scroll":
            case "scrollend":
              Xe = sl;
              break;
            case "wheel":
              Xe = j0;
              break;
            case "copy":
            case "cut":
            case "paste":
              Xe = Ta;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              Xe = qp;
              break;
            case "toggle":
            case "beforetoggle":
              Xe = X0;
          }
          var jt = (l & 4) !== 0,
            Jn = !jt && (a === "scroll" || a === "scrollend"),
            Me = jt ? (Be !== null ? Be + "Capture" : null) : Be;
          jt = [];
          for (var xe = Ue, Ne; xe !== null; ) {
            var st = xe;
            if (
              ((Ne = st.stateNode),
              (st = st.tag),
              (st !== 5 && st !== 26 && st !== 27) ||
                Ne === null ||
                Me === null ||
                ((st = Va(xe, Me)), st != null && jt.push(ng(xe, st, Ne))),
              Jn)
            )
              break;
            xe = xe.return;
          }
          0 < jt.length &&
            ((Be = new Xe(Be, Nt, null, p, tt)),
            at.push({ event: Be, listeners: jt }));
        }
      }
      if ((l & 7) === 0) {
        e: {
          if (
            ((Be = a === "mouseover" || a === "pointerover"),
            (Xe = a === "mouseout" || a === "pointerout"),
            Be &&
              p !== ka &&
              (Nt = p.relatedTarget || p.fromElement) &&
              (ts(Nt) || Nt[Ir]))
          )
            break e;
          if (
            (Xe || Be) &&
            ((Be =
              tt.window === tt
                ? tt
                : (Be = tt.ownerDocument)
                  ? Be.defaultView || Be.parentWindow
                  : window),
            Xe
              ? ((Nt = p.relatedTarget || p.toElement),
                (Xe = Ue),
                (Nt = Nt ? ts(Nt) : null),
                Nt !== null &&
                  ((Jn = s(Nt)),
                  (jt = Nt.tag),
                  Nt !== Jn || (jt !== 5 && jt !== 27 && jt !== 6)) &&
                  (Nt = null))
              : ((Xe = null), (Nt = Ue)),
            Xe !== Nt)
          ) {
            if (
              ((jt = vf),
              (st = "onMouseLeave"),
              (Me = "onMouseEnter"),
              (xe = "mouse"),
              (a === "pointerout" || a === "pointerover") &&
                ((jt = qp),
                (st = "onPointerLeave"),
                (Me = "onPointerEnter"),
                (xe = "pointer")),
              (Jn = Xe == null ? Be : qs(Xe)),
              (Ne = Nt == null ? Be : qs(Nt)),
              (Be = new jt(st, xe + "leave", Xe, p, tt)),
              (Be.target = Jn),
              (Be.relatedTarget = Ne),
              (st = null),
              ts(tt) === Ue &&
                ((jt = new jt(Me, xe + "enter", Nt, p, tt)),
                (jt.target = Ne),
                (jt.relatedTarget = Jn),
                (st = jt)),
              (Jn = st),
              Xe && Nt)
            )
              t: {
                for (
                  jt = HU, Me = Xe, xe = Nt, Ne = 0, st = Me;
                  st;
                  st = jt(st)
                )
                  Ne++;
                st = 0;
                for (var kt = xe; kt; kt = jt(kt)) st++;
                for (; 0 < Ne - st; ) ((Me = jt(Me)), Ne--);
                for (; 0 < st - Ne; ) ((xe = jt(xe)), st--);
                for (; Ne--; ) {
                  if (Me === xe || (xe !== null && Me === xe.alternate)) {
                    jt = Me;
                    break t;
                  }
                  ((Me = jt(Me)), (xe = jt(xe)));
                }
                jt = null;
              }
            else jt = null;
            (Xe !== null && RE(at, Be, Xe, jt, !1),
              Nt !== null && Jn !== null && RE(at, Jn, Nt, jt, !0));
          }
        }
        e: {
          if (
            ((Be = Ue ? qs(Ue) : window),
            (Xe = Be.nodeName && Be.nodeName.toLowerCase()),
            Xe === "select" || (Xe === "input" && Be.type === "file"))
          )
            var Fn = em;
          else if ($p(Be))
            if (Xa) Fn = $0;
            else {
              Fn = im;
              var It = Q0;
            }
          else
            ((Xe = Be.nodeName),
              !Xe ||
              Xe.toLowerCase() !== "input" ||
              (Be.type !== "checkbox" && Be.type !== "radio")
                ? Ue && Ts(Ue.elementType) && (Fn = em)
                : (Fn = J0));
          if (Fn && (Fn = Fn(a, Ue))) {
            Xh(at, Fn, p, tt);
            break e;
          }
          (It && It(a, Be, Ue),
            a === "focusout" &&
              Ue &&
              Be.type === "number" &&
              Ue.memoizedProps.value != null &&
              ei(Be, "number", Be.value));
        }
        switch (((It = Ue ? qs(Ue) : window), a)) {
          case "focusin":
            ($p(It) || It.contentEditable === "true") &&
              ((qa = It), (Ya = Ue), (lu = null));
            break;
          case "focusout":
            lu = Ya = qa = null;
            break;
          case "mousedown":
            qh = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            ((qh = !1), cu(at, p, tt));
            break;
          case "selectionchange":
            if (tv) break;
          case "keydown":
          case "keyup":
            cu(at, p, tt);
        }
        var fn;
        if (cc)
          e: {
            switch (a) {
              case "compositionstart":
                var An = "onCompositionStart";
                break e;
              case "compositionend":
                An = "onCompositionEnd";
                break e;
              case "compositionupdate":
                An = "onCompositionUpdate";
                break e;
            }
            An = void 0;
          }
        else
          uc
            ? Wh(a, p) && (An = "onCompositionEnd")
            : a === "keydown" &&
              p.keyCode === 229 &&
              (An = "onCompositionStart");
        (An &&
          (Zp &&
            p.locale !== "ko" &&
            (uc || An !== "onCompositionStart"
              ? An === "onCompositionEnd" && uc && (fn = nl())
              : ((Ar = tt),
                (sc = "value" in Ar ? Ar.value : Ar.textContent),
                (uc = !0))),
          (It = ey(Ue, An)),
          0 < It.length &&
            ((An = new kh(An, a, null, p, tt)),
            at.push({ event: An, listeners: It }),
            fn
              ? (An.data = fn)
              : ((fn = Kp(p)), fn !== null && (An.data = fn)))),
          (fn = jh ? Z0(a, p) : Qp(a, p)) &&
            ((An = ey(Ue, "onBeforeInput")),
            0 < An.length &&
              ((It = new kh("onBeforeInput", "beforeinput", null, p, tt)),
              at.push({ event: It, listeners: An }),
              (It.data = fn))),
          vi(at, a, Ue, p, tt));
      }
      AE(at, l);
    });
  }
  function ng(a, l, p) {
    return { instance: a, listener: l, currentTarget: p };
  }
  function ey(a, l) {
    for (var p = l + "Capture", g = []; a !== null; ) {
      var M = a,
        A = M.stateNode;
      if (
        ((M = M.tag),
        (M !== 5 && M !== 26 && M !== 27) ||
          A === null ||
          ((M = Va(a, p)),
          M != null && g.unshift(ng(a, M, A)),
          (M = Va(a, l)),
          M != null && g.push(ng(a, M, A))),
        a.tag === 3)
      )
        return g;
      a = a.return;
    }
    return [];
  }
  function HU(a) {
    if (a === null) return null;
    do a = a.return;
    while (a && a.tag !== 5 && a.tag !== 27);
    return a || null;
  }
  function RE(a, l, p, g, M) {
    for (var A = l._reactName, z = []; p !== null && p !== g; ) {
      var Q = p,
        pe = Q.alternate,
        Ue = Q.stateNode;
      if (((Q = Q.tag), pe !== null && pe === g)) break;
      ((Q !== 5 && Q !== 26 && Q !== 27) ||
        Ue === null ||
        ((pe = Ue),
        M
          ? ((Ue = Va(p, A)), Ue != null && z.unshift(ng(p, Ue, pe)))
          : M || ((Ue = Va(p, A)), Ue != null && z.push(ng(p, Ue, pe)))),
        (p = p.return));
    }
    z.length !== 0 && a.push({ event: l, listeners: z });
  }
  var jU = /\r\n?/g,
    WU = /\u0000|\uFFFD/g;
  function DE(a) {
    return (typeof a == "string" ? a : "" + a)
      .replace(
        jU,
        `
`,
      )
      .replace(WU, "");
  }
  function LE(a, l) {
    return ((l = DE(l)), DE(a) === l);
  }
  function Qn(a, l, p, g, M, A) {
    switch (p) {
      case "children":
        typeof g == "string"
          ? l === "body" || (l === "textarea" && g === "") || Vi(a, g)
          : (typeof g == "number" || typeof g == "bigint") &&
            l !== "body" &&
            Vi(a, "" + g);
        break;
      case "className":
        Wt(a, "class", g);
        break;
      case "tabIndex":
        Wt(a, "tabindex", g);
        break;
      case "dir":
      case "role":
      case "viewBox":
      case "width":
      case "height":
        Wt(a, p, g);
        break;
      case "style":
        ns(a, g, A);
        break;
      case "data":
        if (l !== "object") {
          Wt(a, "data", g);
          break;
        }
      case "src":
      case "href":
        if (g === "" && (l !== "a" || p !== "href")) {
          a.removeAttribute(p);
          break;
        }
        if (
          g == null ||
          typeof g == "function" ||
          typeof g == "symbol" ||
          typeof g == "boolean"
        ) {
          a.removeAttribute(p);
          break;
        }
        ((g = Ys("" + g)), a.setAttribute(p, g));
        break;
      case "action":
      case "formAction":
        if (typeof g == "function") {
          a.setAttribute(
            p,
            "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')",
          );
          break;
        } else
          typeof A == "function" &&
            (p === "formAction"
              ? (l !== "input" && Qn(a, l, "name", M.name, M, null),
                Qn(a, l, "formEncType", M.formEncType, M, null),
                Qn(a, l, "formMethod", M.formMethod, M, null),
                Qn(a, l, "formTarget", M.formTarget, M, null))
              : (Qn(a, l, "encType", M.encType, M, null),
                Qn(a, l, "method", M.method, M, null),
                Qn(a, l, "target", M.target, M, null)));
        if (g == null || typeof g == "symbol" || typeof g == "boolean") {
          a.removeAttribute(p);
          break;
        }
        ((g = Ys("" + g)), a.setAttribute(p, g));
        break;
      case "onClick":
        g != null && (a.onclick = wr);
        break;
      case "onScroll":
        g != null && Tn("scroll", a);
        break;
      case "onScrollEnd":
        g != null && Tn("scrollend", a);
        break;
      case "dangerouslySetInnerHTML":
        if (g != null) {
          if (typeof g != "object" || !("__html" in g)) throw Error(n(61));
          if (((p = g.__html), p != null)) {
            if (M.children != null) throw Error(n(60));
            a.innerHTML = p;
          }
        }
        break;
      case "multiple":
        a.multiple = g && typeof g != "function" && typeof g != "symbol";
        break;
      case "muted":
        a.muted = g && typeof g != "function" && typeof g != "symbol";
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "ref":
        break;
      case "autoFocus":
        break;
      case "xlinkHref":
        if (
          g == null ||
          typeof g == "function" ||
          typeof g == "boolean" ||
          typeof g == "symbol"
        ) {
          a.removeAttribute("xlink:href");
          break;
        }
        ((p = Ys("" + g)),
          a.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", p));
        break;
      case "contentEditable":
      case "spellCheck":
      case "draggable":
      case "value":
      case "autoReverse":
      case "externalResourcesRequired":
      case "focusable":
      case "preserveAlpha":
        g != null && typeof g != "function" && typeof g != "symbol"
          ? a.setAttribute(p, "" + g)
          : a.removeAttribute(p);
        break;
      case "inert":
      case "allowFullScreen":
      case "async":
      case "autoPlay":
      case "controls":
      case "default":
      case "defer":
      case "disabled":
      case "disablePictureInPicture":
      case "disableRemotePlayback":
      case "formNoValidate":
      case "hidden":
      case "loop":
      case "noModule":
      case "noValidate":
      case "open":
      case "playsInline":
      case "readOnly":
      case "required":
      case "reversed":
      case "scoped":
      case "seamless":
      case "itemScope":
        g && typeof g != "function" && typeof g != "symbol"
          ? a.setAttribute(p, "")
          : a.removeAttribute(p);
        break;
      case "capture":
      case "download":
        g === !0
          ? a.setAttribute(p, "")
          : g !== !1 &&
              g != null &&
              typeof g != "function" &&
              typeof g != "symbol"
            ? a.setAttribute(p, g)
            : a.removeAttribute(p);
        break;
      case "cols":
      case "rows":
      case "size":
      case "span":
        g != null &&
        typeof g != "function" &&
        typeof g != "symbol" &&
        !isNaN(g) &&
        1 <= g
          ? a.setAttribute(p, g)
          : a.removeAttribute(p);
        break;
      case "rowSpan":
      case "start":
        g == null || typeof g == "function" || typeof g == "symbol" || isNaN(g)
          ? a.removeAttribute(p)
          : a.setAttribute(p, g);
        break;
      case "popover":
        (Tn("beforetoggle", a), Tn("toggle", a), zt(a, "popover", g));
        break;
      case "xlinkActuate":
        At(a, "http://www.w3.org/1999/xlink", "xlink:actuate", g);
        break;
      case "xlinkArcrole":
        At(a, "http://www.w3.org/1999/xlink", "xlink:arcrole", g);
        break;
      case "xlinkRole":
        At(a, "http://www.w3.org/1999/xlink", "xlink:role", g);
        break;
      case "xlinkShow":
        At(a, "http://www.w3.org/1999/xlink", "xlink:show", g);
        break;
      case "xlinkTitle":
        At(a, "http://www.w3.org/1999/xlink", "xlink:title", g);
        break;
      case "xlinkType":
        At(a, "http://www.w3.org/1999/xlink", "xlink:type", g);
        break;
      case "xmlBase":
        At(a, "http://www.w3.org/XML/1998/namespace", "xml:base", g);
        break;
      case "xmlLang":
        At(a, "http://www.w3.org/XML/1998/namespace", "xml:lang", g);
        break;
      case "xmlSpace":
        At(a, "http://www.w3.org/XML/1998/namespace", "xml:space", g);
        break;
      case "is":
        zt(a, "is", g);
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        (!(2 < p.length) ||
          (p[0] !== "o" && p[0] !== "O") ||
          (p[1] !== "n" && p[1] !== "N")) &&
          ((p = gf.get(p) || p), zt(a, p, g));
    }
  }
  function Kb(a, l, p, g, M, A) {
    switch (p) {
      case "style":
        ns(a, g, A);
        break;
      case "dangerouslySetInnerHTML":
        if (g != null) {
          if (typeof g != "object" || !("__html" in g)) throw Error(n(61));
          if (((p = g.__html), p != null)) {
            if (M.children != null) throw Error(n(60));
            a.innerHTML = p;
          }
        }
        break;
      case "children":
        typeof g == "string"
          ? Vi(a, g)
          : (typeof g == "number" || typeof g == "bigint") && Vi(a, "" + g);
        break;
      case "onScroll":
        g != null && Tn("scroll", a);
        break;
      case "onScrollEnd":
        g != null && Tn("scrollend", a);
        break;
      case "onClick":
        g != null && (a.onclick = wr);
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "innerHTML":
      case "ref":
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        if (!Le.hasOwnProperty(p))
          e: {
            if (
              p[0] === "o" &&
              p[1] === "n" &&
              ((M = p.endsWith("Capture")),
              (l = p.slice(2, M ? p.length - 7 : void 0)),
              (A = a[ii] || null),
              (A = A != null ? A[p] : null),
              typeof A == "function" && a.removeEventListener(l, A, M),
              typeof g == "function")
            ) {
              (typeof A != "function" &&
                A !== null &&
                (p in a
                  ? (a[p] = null)
                  : a.hasAttribute(p) && a.removeAttribute(p)),
                a.addEventListener(l, g, M));
              break e;
            }
            p in a
              ? (a[p] = g)
              : g === !0
                ? a.setAttribute(p, "")
                : zt(a, p, g);
          }
    }
  }
  function Xr(a, l, p) {
    switch (l) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "img":
        (Tn("error", a), Tn("load", a));
        var g = !1,
          M = !1,
          A;
        for (A in p)
          if (p.hasOwnProperty(A)) {
            var z = p[A];
            if (z != null)
              switch (A) {
                case "src":
                  g = !0;
                  break;
                case "srcSet":
                  M = !0;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(n(137, l));
                default:
                  Qn(a, l, A, z, p, null);
              }
          }
        (M && Qn(a, l, "srcSet", p.srcSet, p, null),
          g && Qn(a, l, "src", p.src, p, null));
        return;
      case "input":
        Tn("invalid", a);
        var Q = (A = z = M = null),
          pe = null,
          Ue = null;
        for (g in p)
          if (p.hasOwnProperty(g)) {
            var tt = p[g];
            if (tt != null)
              switch (g) {
                case "name":
                  M = tt;
                  break;
                case "type":
                  z = tt;
                  break;
                case "checked":
                  pe = tt;
                  break;
                case "defaultChecked":
                  Ue = tt;
                  break;
                case "value":
                  A = tt;
                  break;
                case "defaultValue":
                  Q = tt;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  if (tt != null) throw Error(n(137, l));
                  break;
                default:
                  Qn(a, l, g, tt, p, null);
              }
          }
        ki(a, A, Q, pe, Ue, z, M, !1);
        return;
      case "select":
        (Tn("invalid", a), (g = z = A = null));
        for (M in p)
          if (p.hasOwnProperty(M) && ((Q = p[M]), Q != null))
            switch (M) {
              case "value":
                A = Q;
                break;
              case "defaultValue":
                z = Q;
                break;
              case "multiple":
                g = Q;
              default:
                Qn(a, l, M, Q, p, null);
            }
        ((l = A),
          (p = z),
          (a.multiple = !!g),
          l != null ? Ki(a, !!g, l, !1) : p != null && Ki(a, !!g, p, !0));
        return;
      case "textarea":
        (Tn("invalid", a), (A = M = g = null));
        for (z in p)
          if (p.hasOwnProperty(z) && ((Q = p[z]), Q != null))
            switch (z) {
              case "value":
                g = Q;
                break;
              case "defaultValue":
                M = Q;
                break;
              case "children":
                A = Q;
                break;
              case "dangerouslySetInnerHTML":
                if (Q != null) throw Error(n(91));
                break;
              default:
                Qn(a, l, z, Q, p, null);
            }
        qn(a, g, M, A);
        return;
      case "option":
        for (pe in p)
          if (p.hasOwnProperty(pe) && ((g = p[pe]), g != null))
            switch (pe) {
              case "selected":
                a.selected =
                  g && typeof g != "function" && typeof g != "symbol";
                break;
              default:
                Qn(a, l, pe, g, p, null);
            }
        return;
      case "dialog":
        (Tn("beforetoggle", a),
          Tn("toggle", a),
          Tn("cancel", a),
          Tn("close", a));
        break;
      case "iframe":
      case "object":
        Tn("load", a);
        break;
      case "video":
      case "audio":
        for (g = 0; g < pa.length; g++) Tn(pa[g], a);
        break;
      case "image":
        (Tn("error", a), Tn("load", a));
        break;
      case "details":
        Tn("toggle", a);
        break;
      case "embed":
      case "source":
      case "link":
        (Tn("error", a), Tn("load", a));
      case "area":
      case "base":
      case "br":
      case "col":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "track":
      case "wbr":
      case "menuitem":
        for (Ue in p)
          if (p.hasOwnProperty(Ue) && ((g = p[Ue]), g != null))
            switch (Ue) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(n(137, l));
              default:
                Qn(a, l, Ue, g, p, null);
            }
        return;
      default:
        if (Ts(l)) {
          for (tt in p)
            p.hasOwnProperty(tt) &&
              ((g = p[tt]), g !== void 0 && Kb(a, l, tt, g, p, void 0));
          return;
        }
    }
    for (Q in p)
      p.hasOwnProperty(Q) && ((g = p[Q]), g != null && Qn(a, l, Q, g, p, null));
  }
  function XU(a, l, p, g) {
    switch (l) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "input":
        var M = null,
          A = null,
          z = null,
          Q = null,
          pe = null,
          Ue = null,
          tt = null;
        for (Xe in p) {
          var at = p[Xe];
          if (p.hasOwnProperty(Xe) && at != null)
            switch (Xe) {
              case "checked":
                break;
              case "value":
                break;
              case "defaultValue":
                pe = at;
              default:
                g.hasOwnProperty(Xe) || Qn(a, l, Xe, null, g, at);
            }
        }
        for (var Be in g) {
          var Xe = g[Be];
          if (
            ((at = p[Be]), g.hasOwnProperty(Be) && (Xe != null || at != null))
          )
            switch (Be) {
              case "type":
                A = Xe;
                break;
              case "name":
                M = Xe;
                break;
              case "checked":
                Ue = Xe;
                break;
              case "defaultChecked":
                tt = Xe;
                break;
              case "value":
                z = Xe;
                break;
              case "defaultValue":
                Q = Xe;
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                if (Xe != null) throw Error(n(137, l));
                break;
              default:
                Xe !== at && Qn(a, l, Be, Xe, g, at);
            }
        }
        Bi(a, z, Q, pe, Ue, tt, A, M);
        return;
      case "select":
        Xe = z = Q = Be = null;
        for (A in p)
          if (((pe = p[A]), p.hasOwnProperty(A) && pe != null))
            switch (A) {
              case "value":
                break;
              case "multiple":
                Xe = pe;
              default:
                g.hasOwnProperty(A) || Qn(a, l, A, null, g, pe);
            }
        for (M in g)
          if (
            ((A = g[M]),
            (pe = p[M]),
            g.hasOwnProperty(M) && (A != null || pe != null))
          )
            switch (M) {
              case "value":
                Be = A;
                break;
              case "defaultValue":
                Q = A;
                break;
              case "multiple":
                z = A;
              default:
                A !== pe && Qn(a, l, M, A, g, pe);
            }
        ((l = Q),
          (p = z),
          (g = Xe),
          Be != null
            ? Ki(a, !!p, Be, !1)
            : !!g != !!p &&
              (l != null ? Ki(a, !!p, l, !0) : Ki(a, !!p, p ? [] : "", !1)));
        return;
      case "textarea":
        Xe = Be = null;
        for (Q in p)
          if (
            ((M = p[Q]),
            p.hasOwnProperty(Q) && M != null && !g.hasOwnProperty(Q))
          )
            switch (Q) {
              case "value":
                break;
              case "children":
                break;
              default:
                Qn(a, l, Q, null, g, M);
            }
        for (z in g)
          if (
            ((M = g[z]),
            (A = p[z]),
            g.hasOwnProperty(z) && (M != null || A != null))
          )
            switch (z) {
              case "value":
                Be = M;
                break;
              case "defaultValue":
                Xe = M;
                break;
              case "children":
                break;
              case "dangerouslySetInnerHTML":
                if (M != null) throw Error(n(91));
                break;
              default:
                M !== A && Qn(a, l, z, M, g, A);
            }
        gn(a, Be, Xe);
        return;
      case "option":
        for (var Nt in p)
          if (
            ((Be = p[Nt]),
            p.hasOwnProperty(Nt) && Be != null && !g.hasOwnProperty(Nt))
          )
            switch (Nt) {
              case "selected":
                a.selected = !1;
                break;
              default:
                Qn(a, l, Nt, null, g, Be);
            }
        for (pe in g)
          if (
            ((Be = g[pe]),
            (Xe = p[pe]),
            g.hasOwnProperty(pe) && Be !== Xe && (Be != null || Xe != null))
          )
            switch (pe) {
              case "selected":
                a.selected =
                  Be && typeof Be != "function" && typeof Be != "symbol";
                break;
              default:
                Qn(a, l, pe, Be, g, Xe);
            }
        return;
      case "img":
      case "link":
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
      case "menuitem":
        for (var jt in p)
          ((Be = p[jt]),
            p.hasOwnProperty(jt) &&
              Be != null &&
              !g.hasOwnProperty(jt) &&
              Qn(a, l, jt, null, g, Be));
        for (Ue in g)
          if (
            ((Be = g[Ue]),
            (Xe = p[Ue]),
            g.hasOwnProperty(Ue) && Be !== Xe && (Be != null || Xe != null))
          )
            switch (Ue) {
              case "children":
              case "dangerouslySetInnerHTML":
                if (Be != null) throw Error(n(137, l));
                break;
              default:
                Qn(a, l, Ue, Be, g, Xe);
            }
        return;
      default:
        if (Ts(l)) {
          for (var Jn in p)
            ((Be = p[Jn]),
              p.hasOwnProperty(Jn) &&
                Be !== void 0 &&
                !g.hasOwnProperty(Jn) &&
                Kb(a, l, Jn, void 0, g, Be));
          for (tt in g)
            ((Be = g[tt]),
              (Xe = p[tt]),
              !g.hasOwnProperty(tt) ||
                Be === Xe ||
                (Be === void 0 && Xe === void 0) ||
                Kb(a, l, tt, Be, g, Xe));
          return;
        }
    }
    for (var Me in p)
      ((Be = p[Me]),
        p.hasOwnProperty(Me) &&
          Be != null &&
          !g.hasOwnProperty(Me) &&
          Qn(a, l, Me, null, g, Be));
    for (at in g)
      ((Be = g[at]),
        (Xe = p[at]),
        !g.hasOwnProperty(at) ||
          Be === Xe ||
          (Be == null && Xe == null) ||
          Qn(a, l, at, Be, g, Xe));
  }
  function NE(a) {
    switch (a) {
      case "css":
      case "script":
      case "font":
      case "img":
      case "image":
      case "input":
      case "link":
        return !0;
      default:
        return !1;
    }
  }
  function qU() {
    if (typeof performance.getEntriesByType == "function") {
      for (
        var a = 0, l = 0, p = performance.getEntriesByType("resource"), g = 0;
        g < p.length;
        g++
      ) {
        var M = p[g],
          A = M.transferSize,
          z = M.initiatorType,
          Q = M.duration;
        if (A && Q && NE(z)) {
          for (z = 0, Q = M.responseEnd, g += 1; g < p.length; g++) {
            var pe = p[g],
              Ue = pe.startTime;
            if (Ue > Q) break;
            var tt = pe.transferSize,
              at = pe.initiatorType;
            tt &&
              NE(at) &&
              ((pe = pe.responseEnd),
              (z += tt * (pe < Q ? 1 : (Q - Ue) / (pe - Ue))));
          }
          if ((--g, (l += (8 * (A + z)) / (M.duration / 1e3)), a++, 10 < a))
            break;
        }
      }
      if (0 < a) return l / a / 1e6;
    }
    return navigator.connection &&
      ((a = navigator.connection.downlink), typeof a == "number")
      ? a
      : 5;
  }
  var Qb = null,
    Jb = null;
  function ty(a) {
    return a.nodeType === 9 ? a : a.ownerDocument;
  }
  function UE(a) {
    switch (a) {
      case "http://www.w3.org/2000/svg":
        return 1;
      case "http://www.w3.org/1998/Math/MathML":
        return 2;
      default:
        return 0;
    }
  }
  function PE(a, l) {
    if (a === 0)
      switch (l) {
        case "svg":
          return 1;
        case "math":
          return 2;
        default:
          return 0;
      }
    return a === 1 && l === "foreignObject" ? 0 : a;
  }
  function $b(a, l) {
    return (
      a === "textarea" ||
      a === "noscript" ||
      typeof l.children == "string" ||
      typeof l.children == "number" ||
      typeof l.children == "bigint" ||
      (typeof l.dangerouslySetInnerHTML == "object" &&
        l.dangerouslySetInnerHTML !== null &&
        l.dangerouslySetInnerHTML.__html != null)
    );
  }
  var e_ = null;
  function YU() {
    var a = window.event;
    return a && a.type === "popstate"
      ? a === e_
        ? !1
        : ((e_ = a), !0)
      : ((e_ = null), !1);
  }
  var IE = typeof setTimeout == "function" ? setTimeout : void 0,
    ZU = typeof clearTimeout == "function" ? clearTimeout : void 0,
    OE = typeof Promise == "function" ? Promise : void 0,
    KU =
      typeof queueMicrotask == "function"
        ? queueMicrotask
        : typeof OE < "u"
          ? function (a) {
              return OE.resolve(null).then(a).catch(QU);
            }
          : IE;
  function QU(a) {
    setTimeout(function () {
      throw a;
    });
  }
  function Iu(a) {
    return a === "head";
  }
  function FE(a, l) {
    var p = l,
      g = 0;
    do {
      var M = p.nextSibling;
      if ((a.removeChild(p), M && M.nodeType === 8))
        if (((p = M.data), p === "/$" || p === "/&")) {
          if (g === 0) {
            (a.removeChild(M), Bd(l));
            return;
          }
          g--;
        } else if (
          p === "$" ||
          p === "$?" ||
          p === "$~" ||
          p === "$!" ||
          p === "&"
        )
          g++;
        else if (p === "html") ig(a.ownerDocument.documentElement);
        else if (p === "head") {
          ((p = a.ownerDocument.head), ig(p));
          for (var A = p.firstChild; A; ) {
            var z = A.nextSibling,
              Q = A.nodeName;
            (A[Ss] ||
              Q === "SCRIPT" ||
              Q === "STYLE" ||
              (Q === "LINK" && A.rel.toLowerCase() === "stylesheet") ||
              p.removeChild(A),
              (A = z));
          }
        } else p === "body" && ig(a.ownerDocument.body);
      p = M;
    } while (p);
    Bd(l);
  }
  function zE(a, l) {
    var p = a;
    a = 0;
    do {
      var g = p.nextSibling;
      if (
        (p.nodeType === 1
          ? l
            ? ((p._stashedDisplay = p.style.display),
              (p.style.display = "none"))
            : ((p.style.display = p._stashedDisplay || ""),
              p.getAttribute("style") === "" && p.removeAttribute("style"))
          : p.nodeType === 3 &&
            (l
              ? ((p._stashedText = p.nodeValue), (p.nodeValue = ""))
              : (p.nodeValue = p._stashedText || "")),
        g && g.nodeType === 8)
      )
        if (((p = g.data), p === "/$")) {
          if (a === 0) break;
          a--;
        } else (p !== "$" && p !== "$?" && p !== "$~" && p !== "$!") || a++;
      p = g;
    } while (p);
  }
  function t_(a) {
    var l = a.firstChild;
    for (l && l.nodeType === 10 && (l = l.nextSibling); l; ) {
      var p = l;
      switch (((l = l.nextSibling), p.nodeName)) {
        case "HTML":
        case "HEAD":
        case "BODY":
          (t_(p), Xs(p));
          continue;
        case "SCRIPT":
        case "STYLE":
          continue;
        case "LINK":
          if (p.rel.toLowerCase() === "stylesheet") continue;
      }
      a.removeChild(p);
    }
  }
  function JU(a, l, p, g) {
    for (; a.nodeType === 1; ) {
      var M = p;
      if (a.nodeName.toLowerCase() !== l.toLowerCase()) {
        if (!g && (a.nodeName !== "INPUT" || a.type !== "hidden")) break;
      } else if (g) {
        if (!a[Ss])
          switch (l) {
            case "meta":
              if (!a.hasAttribute("itemprop")) break;
              return a;
            case "link":
              if (
                ((A = a.getAttribute("rel")),
                A === "stylesheet" && a.hasAttribute("data-precedence"))
              )
                break;
              if (
                A !== M.rel ||
                a.getAttribute("href") !==
                  (M.href == null || M.href === "" ? null : M.href) ||
                a.getAttribute("crossorigin") !==
                  (M.crossOrigin == null ? null : M.crossOrigin) ||
                a.getAttribute("title") !== (M.title == null ? null : M.title)
              )
                break;
              return a;
            case "style":
              if (a.hasAttribute("data-precedence")) break;
              return a;
            case "script":
              if (
                ((A = a.getAttribute("src")),
                (A !== (M.src == null ? null : M.src) ||
                  a.getAttribute("type") !== (M.type == null ? null : M.type) ||
                  a.getAttribute("crossorigin") !==
                    (M.crossOrigin == null ? null : M.crossOrigin)) &&
                  A &&
                  a.hasAttribute("async") &&
                  !a.hasAttribute("itemprop"))
              )
                break;
              return a;
            default:
              return a;
          }
      } else if (l === "input" && a.type === "hidden") {
        var A = M.name == null ? null : "" + M.name;
        if (M.type === "hidden" && a.getAttribute("name") === A) return a;
      } else return a;
      if (((a = po(a.nextSibling)), a === null)) break;
    }
    return null;
  }
  function $U(a, l, p) {
    if (l === "") return null;
    for (; a.nodeType !== 3; )
      if (
        ((a.nodeType !== 1 || a.nodeName !== "INPUT" || a.type !== "hidden") &&
          !p) ||
        ((a = po(a.nextSibling)), a === null)
      )
        return null;
    return a;
  }
  function BE(a, l) {
    for (; a.nodeType !== 8; )
      if (
        ((a.nodeType !== 1 || a.nodeName !== "INPUT" || a.type !== "hidden") &&
          !l) ||
        ((a = po(a.nextSibling)), a === null)
      )
        return null;
    return a;
  }
  function n_(a) {
    return a.data === "$?" || a.data === "$~";
  }
  function i_(a) {
    return (
      a.data === "$!" ||
      (a.data === "$?" && a.ownerDocument.readyState !== "loading")
    );
  }
  function eP(a, l) {
    var p = a.ownerDocument;
    if (a.data === "$~") a._reactRetry = l;
    else if (a.data !== "$?" || p.readyState !== "loading") l();
    else {
      var g = function () {
        (l(), p.removeEventListener("DOMContentLoaded", g));
      };
      (p.addEventListener("DOMContentLoaded", g), (a._reactRetry = g));
    }
  }
  function po(a) {
    for (; a != null; a = a.nextSibling) {
      var l = a.nodeType;
      if (l === 1 || l === 3) break;
      if (l === 8) {
        if (
          ((l = a.data),
          l === "$" ||
            l === "$!" ||
            l === "$?" ||
            l === "$~" ||
            l === "&" ||
            l === "F!" ||
            l === "F")
        )
          break;
        if (l === "/$" || l === "/&") return null;
      }
    }
    return a;
  }
  var r_ = null;
  function kE(a) {
    a = a.nextSibling;
    for (var l = 0; a; ) {
      if (a.nodeType === 8) {
        var p = a.data;
        if (p === "/$" || p === "/&") {
          if (l === 0) return po(a.nextSibling);
          l--;
        } else
          (p !== "$" && p !== "$!" && p !== "$?" && p !== "$~" && p !== "&") ||
            l++;
      }
      a = a.nextSibling;
    }
    return null;
  }
  function VE(a) {
    a = a.previousSibling;
    for (var l = 0; a; ) {
      if (a.nodeType === 8) {
        var p = a.data;
        if (p === "$" || p === "$!" || p === "$?" || p === "$~" || p === "&") {
          if (l === 0) return a;
          l--;
        } else (p !== "/$" && p !== "/&") || l++;
      }
      a = a.previousSibling;
    }
    return null;
  }
  function GE(a, l, p) {
    switch (((l = ty(p)), a)) {
      case "html":
        if (((a = l.documentElement), !a)) throw Error(n(452));
        return a;
      case "head":
        if (((a = l.head), !a)) throw Error(n(453));
        return a;
      case "body":
        if (((a = l.body), !a)) throw Error(n(454));
        return a;
      default:
        throw Error(n(451));
    }
  }
  function ig(a) {
    for (var l = a.attributes; l.length; ) a.removeAttributeNode(l[0]);
    Xs(a);
  }
  var mo = new Map(),
    HE = new Set();
  function ny(a) {
    return typeof a.getRootNode == "function"
      ? a.getRootNode()
      : a.nodeType === 9
        ? a
        : a.ownerDocument;
  }
  var Pc = $.d;
  $.d = { f: tP, r: nP, D: iP, C: rP, L: sP, m: aP, X: lP, S: oP, M: cP };
  function tP() {
    var a = Pc.f(),
      l = Ra();
    return a || l;
  }
  function nP(a) {
    var l = Ms(a);
    l !== null && l.tag === 5 && l.type === "form" ? zv(l) : Pc.r(a);
  }
  var Od = typeof document > "u" ? null : document;
  function jE(a, l, p) {
    var g = Od;
    if (g && typeof l == "string" && l) {
      var M = Pt(l);
      ((M = 'link[rel="' + a + '"][href="' + M + '"]'),
        typeof p == "string" && (M += '[crossorigin="' + p + '"]'),
        HE.has(M) ||
          (HE.add(M),
          (a = { rel: a, crossOrigin: p, href: l }),
          g.querySelector(M) === null &&
            ((l = g.createElement("link")),
            Xr(l, "link", a),
            ve(l),
            g.head.appendChild(l))));
    }
  }
  function iP(a) {
    (Pc.D(a), jE("dns-prefetch", a, null));
  }
  function rP(a, l) {
    (Pc.C(a, l), jE("preconnect", a, l));
  }
  function sP(a, l, p) {
    Pc.L(a, l, p);
    var g = Od;
    if (g && a && l) {
      var M = 'link[rel="preload"][as="' + Pt(l) + '"]';
      l === "image" && p && p.imageSrcSet
        ? ((M += '[imagesrcset="' + Pt(p.imageSrcSet) + '"]'),
          typeof p.imageSizes == "string" &&
            (M += '[imagesizes="' + Pt(p.imageSizes) + '"]'))
        : (M += '[href="' + Pt(a) + '"]');
      var A = M;
      switch (l) {
        case "style":
          A = Fd(a);
          break;
        case "script":
          A = zd(a);
      }
      mo.has(A) ||
        ((a = v(
          {
            rel: "preload",
            href: l === "image" && p && p.imageSrcSet ? void 0 : a,
            as: l,
          },
          p,
        )),
        mo.set(A, a),
        g.querySelector(M) !== null ||
          (l === "style" && g.querySelector(rg(A))) ||
          (l === "script" && g.querySelector(sg(A))) ||
          ((l = g.createElement("link")),
          Xr(l, "link", a),
          ve(l),
          g.head.appendChild(l)));
    }
  }
  function aP(a, l) {
    Pc.m(a, l);
    var p = Od;
    if (p && a) {
      var g = l && typeof l.as == "string" ? l.as : "script",
        M =
          'link[rel="modulepreload"][as="' + Pt(g) + '"][href="' + Pt(a) + '"]',
        A = M;
      switch (g) {
        case "audioworklet":
        case "paintworklet":
        case "serviceworker":
        case "sharedworker":
        case "worker":
        case "script":
          A = zd(a);
      }
      if (
        !mo.has(A) &&
        ((a = v({ rel: "modulepreload", href: a }, l)),
        mo.set(A, a),
        p.querySelector(M) === null)
      ) {
        switch (g) {
          case "audioworklet":
          case "paintworklet":
          case "serviceworker":
          case "sharedworker":
          case "worker":
          case "script":
            if (p.querySelector(sg(A))) return;
        }
        ((g = p.createElement("link")),
          Xr(g, "link", a),
          ve(g),
          p.head.appendChild(g));
      }
    }
  }
  function oP(a, l, p) {
    Pc.S(a, l, p);
    var g = Od;
    if (g && a) {
      var M = G(g).hoistableStyles,
        A = Fd(a);
      l = l || "default";
      var z = M.get(A);
      if (!z) {
        var Q = { loading: 0, preload: null };
        if ((z = g.querySelector(rg(A)))) Q.loading = 5;
        else {
          ((a = v({ rel: "stylesheet", href: a, "data-precedence": l }, p)),
            (p = mo.get(A)) && s_(a, p));
          var pe = (z = g.createElement("link"));
          (ve(pe),
            Xr(pe, "link", a),
            (pe._p = new Promise(function (Ue, tt) {
              ((pe.onload = Ue), (pe.onerror = tt));
            })),
            pe.addEventListener("load", function () {
              Q.loading |= 1;
            }),
            pe.addEventListener("error", function () {
              Q.loading |= 2;
            }),
            (Q.loading |= 4),
            iy(z, l, g));
        }
        ((z = { type: "stylesheet", instance: z, count: 1, state: Q }),
          M.set(A, z));
      }
    }
  }
  function lP(a, l) {
    Pc.X(a, l);
    var p = Od;
    if (p && a) {
      var g = G(p).hoistableScripts,
        M = zd(a),
        A = g.get(M);
      A ||
        ((A = p.querySelector(sg(M))),
        A ||
          ((a = v({ src: a, async: !0 }, l)),
          (l = mo.get(M)) && a_(a, l),
          (A = p.createElement("script")),
          ve(A),
          Xr(A, "link", a),
          p.head.appendChild(A)),
        (A = { type: "script", instance: A, count: 1, state: null }),
        g.set(M, A));
    }
  }
  function cP(a, l) {
    Pc.M(a, l);
    var p = Od;
    if (p && a) {
      var g = G(p).hoistableScripts,
        M = zd(a),
        A = g.get(M);
      A ||
        ((A = p.querySelector(sg(M))),
        A ||
          ((a = v({ src: a, async: !0, type: "module" }, l)),
          (l = mo.get(M)) && a_(a, l),
          (A = p.createElement("script")),
          ve(A),
          Xr(A, "link", a),
          p.head.appendChild(A)),
        (A = { type: "script", instance: A, count: 1, state: null }),
        g.set(M, A));
    }
  }
  function WE(a, l, p, g) {
    var M = (M = ae.current) ? ny(M) : null;
    if (!M) throw Error(n(446));
    switch (a) {
      case "meta":
      case "title":
        return null;
      case "style":
        return typeof p.precedence == "string" && typeof p.href == "string"
          ? ((l = Fd(p.href)),
            (p = G(M).hoistableStyles),
            (g = p.get(l)),
            g ||
              ((g = { type: "style", instance: null, count: 0, state: null }),
              p.set(l, g)),
            g)
          : { type: "void", instance: null, count: 0, state: null };
      case "link":
        if (
          p.rel === "stylesheet" &&
          typeof p.href == "string" &&
          typeof p.precedence == "string"
        ) {
          a = Fd(p.href);
          var A = G(M).hoistableStyles,
            z = A.get(a);
          if (
            (z ||
              ((M = M.ownerDocument || M),
              (z = {
                type: "stylesheet",
                instance: null,
                count: 0,
                state: { loading: 0, preload: null },
              }),
              A.set(a, z),
              (A = M.querySelector(rg(a))) &&
                !A._p &&
                ((z.instance = A), (z.state.loading = 5)),
              mo.has(a) ||
                ((p = {
                  rel: "preload",
                  as: "style",
                  href: p.href,
                  crossOrigin: p.crossOrigin,
                  integrity: p.integrity,
                  media: p.media,
                  hrefLang: p.hrefLang,
                  referrerPolicy: p.referrerPolicy,
                }),
                mo.set(a, p),
                A || uP(M, a, p, z.state))),
            l && g === null)
          )
            throw Error(n(528, ""));
          return z;
        }
        if (l && g !== null) throw Error(n(529, ""));
        return null;
      case "script":
        return (
          (l = p.async),
          (p = p.src),
          typeof p == "string" &&
          l &&
          typeof l != "function" &&
          typeof l != "symbol"
            ? ((l = zd(p)),
              (p = G(M).hoistableScripts),
              (g = p.get(l)),
              g ||
                ((g = {
                  type: "script",
                  instance: null,
                  count: 0,
                  state: null,
                }),
                p.set(l, g)),
              g)
            : { type: "void", instance: null, count: 0, state: null }
        );
      default:
        throw Error(n(444, a));
    }
  }
  function Fd(a) {
    return 'href="' + Pt(a) + '"';
  }
  function rg(a) {
    return 'link[rel="stylesheet"][' + a + "]";
  }
  function XE(a) {
    return v({}, a, { "data-precedence": a.precedence, precedence: null });
  }
  function uP(a, l, p, g) {
    a.querySelector('link[rel="preload"][as="style"][' + l + "]")
      ? (g.loading = 1)
      : ((l = a.createElement("link")),
        (g.preload = l),
        l.addEventListener("load", function () {
          return (g.loading |= 1);
        }),
        l.addEventListener("error", function () {
          return (g.loading |= 2);
        }),
        Xr(l, "link", p),
        ve(l),
        a.head.appendChild(l));
  }
  function zd(a) {
    return '[src="' + Pt(a) + '"]';
  }
  function sg(a) {
    return "script[async]" + a;
  }
  function qE(a, l, p) {
    if ((l.count++, l.instance === null))
      switch (l.type) {
        case "style":
          var g = a.querySelector('style[data-href~="' + Pt(p.href) + '"]');
          if (g) return ((l.instance = g), ve(g), g);
          var M = v({}, p, {
            "data-href": p.href,
            "data-precedence": p.precedence,
            href: null,
            precedence: null,
          });
          return (
            (g = (a.ownerDocument || a).createElement("style")),
            ve(g),
            Xr(g, "style", M),
            iy(g, p.precedence, a),
            (l.instance = g)
          );
        case "stylesheet":
          M = Fd(p.href);
          var A = a.querySelector(rg(M));
          if (A) return ((l.state.loading |= 4), (l.instance = A), ve(A), A);
          ((g = XE(p)),
            (M = mo.get(M)) && s_(g, M),
            (A = (a.ownerDocument || a).createElement("link")),
            ve(A));
          var z = A;
          return (
            (z._p = new Promise(function (Q, pe) {
              ((z.onload = Q), (z.onerror = pe));
            })),
            Xr(A, "link", g),
            (l.state.loading |= 4),
            iy(A, p.precedence, a),
            (l.instance = A)
          );
        case "script":
          return (
            (A = zd(p.src)),
            (M = a.querySelector(sg(A)))
              ? ((l.instance = M), ve(M), M)
              : ((g = p),
                (M = mo.get(A)) && ((g = v({}, p)), a_(g, M)),
                (a = a.ownerDocument || a),
                (M = a.createElement("script")),
                ve(M),
                Xr(M, "link", g),
                a.head.appendChild(M),
                (l.instance = M))
          );
        case "void":
          return null;
        default:
          throw Error(n(443, l.type));
      }
    else
      l.type === "stylesheet" &&
        (l.state.loading & 4) === 0 &&
        ((g = l.instance), (l.state.loading |= 4), iy(g, p.precedence, a));
    return l.instance;
  }
  function iy(a, l, p) {
    for (
      var g = p.querySelectorAll(
          'link[rel="stylesheet"][data-precedence],style[data-precedence]',
        ),
        M = g.length ? g[g.length - 1] : null,
        A = M,
        z = 0;
      z < g.length;
      z++
    ) {
      var Q = g[z];
      if (Q.dataset.precedence === l) A = Q;
      else if (A !== M) break;
    }
    A
      ? A.parentNode.insertBefore(a, A.nextSibling)
      : ((l = p.nodeType === 9 ? p.head : p), l.insertBefore(a, l.firstChild));
  }
  function s_(a, l) {
    (a.crossOrigin == null && (a.crossOrigin = l.crossOrigin),
      a.referrerPolicy == null && (a.referrerPolicy = l.referrerPolicy),
      a.title == null && (a.title = l.title));
  }
  function a_(a, l) {
    (a.crossOrigin == null && (a.crossOrigin = l.crossOrigin),
      a.referrerPolicy == null && (a.referrerPolicy = l.referrerPolicy),
      a.integrity == null && (a.integrity = l.integrity));
  }
  var ry = null;
  function YE(a, l, p) {
    if (ry === null) {
      var g = new Map(),
        M = (ry = new Map());
      M.set(p, g);
    } else ((M = ry), (g = M.get(p)), g || ((g = new Map()), M.set(p, g)));
    if (g.has(a)) return g;
    for (
      g.set(a, null), p = p.getElementsByTagName(a), M = 0;
      M < p.length;
      M++
    ) {
      var A = p[M];
      if (
        !(
          A[Ss] ||
          A[Un] ||
          (a === "link" && A.getAttribute("rel") === "stylesheet")
        ) &&
        A.namespaceURI !== "http://www.w3.org/2000/svg"
      ) {
        var z = A.getAttribute(l) || "";
        z = a + z;
        var Q = g.get(z);
        Q ? Q.push(A) : g.set(z, [A]);
      }
    }
    return g;
  }
  function ZE(a, l, p) {
    ((a = a.ownerDocument || a),
      a.head.insertBefore(
        p,
        l === "title" ? a.querySelector("head > title") : null,
      ));
  }
  function fP(a, l, p) {
    if (p === 1 || l.itemProp != null) return !1;
    switch (a) {
      case "meta":
      case "title":
        return !0;
      case "style":
        if (
          typeof l.precedence != "string" ||
          typeof l.href != "string" ||
          l.href === ""
        )
          break;
        return !0;
      case "link":
        if (
          typeof l.rel != "string" ||
          typeof l.href != "string" ||
          l.href === "" ||
          l.onLoad ||
          l.onError
        )
          break;
        switch (l.rel) {
          case "stylesheet":
            return (
              (a = l.disabled),
              typeof l.precedence == "string" && a == null
            );
          default:
            return !0;
        }
      case "script":
        if (
          l.async &&
          typeof l.async != "function" &&
          typeof l.async != "symbol" &&
          !l.onLoad &&
          !l.onError &&
          l.src &&
          typeof l.src == "string"
        )
          return !0;
    }
    return !1;
  }
  function KE(a) {
    return !(a.type === "stylesheet" && (a.state.loading & 3) === 0);
  }
  function hP(a, l, p, g) {
    if (
      p.type === "stylesheet" &&
      (typeof g.media != "string" || matchMedia(g.media).matches !== !1) &&
      (p.state.loading & 4) === 0
    ) {
      if (p.instance === null) {
        var M = Fd(g.href),
          A = l.querySelector(rg(M));
        if (A) {
          ((l = A._p),
            l !== null &&
              typeof l == "object" &&
              typeof l.then == "function" &&
              (a.count++, (a = sy.bind(a)), l.then(a, a)),
            (p.state.loading |= 4),
            (p.instance = A),
            ve(A));
          return;
        }
        ((A = l.ownerDocument || l),
          (g = XE(g)),
          (M = mo.get(M)) && s_(g, M),
          (A = A.createElement("link")),
          ve(A));
        var z = A;
        ((z._p = new Promise(function (Q, pe) {
          ((z.onload = Q), (z.onerror = pe));
        })),
          Xr(A, "link", g),
          (p.instance = A));
      }
      (a.stylesheets === null && (a.stylesheets = new Map()),
        a.stylesheets.set(p, l),
        (l = p.state.preload) &&
          (p.state.loading & 3) === 0 &&
          (a.count++,
          (p = sy.bind(a)),
          l.addEventListener("load", p),
          l.addEventListener("error", p)));
    }
  }
  var o_ = 0;
  function dP(a, l) {
    return (
      a.stylesheets && a.count === 0 && oy(a, a.stylesheets),
      0 < a.count || 0 < a.imgCount
        ? function (p) {
            var g = setTimeout(function () {
              if ((a.stylesheets && oy(a, a.stylesheets), a.unsuspend)) {
                var A = a.unsuspend;
                ((a.unsuspend = null), A());
              }
            }, 6e4 + l);
            0 < a.imgBytes && o_ === 0 && (o_ = 62500 * qU());
            var M = setTimeout(
              function () {
                if (
                  ((a.waitingForImages = !1),
                  a.count === 0 &&
                    (a.stylesheets && oy(a, a.stylesheets), a.unsuspend))
                ) {
                  var A = a.unsuspend;
                  ((a.unsuspend = null), A());
                }
              },
              (a.imgBytes > o_ ? 50 : 800) + l,
            );
            return (
              (a.unsuspend = p),
              function () {
                ((a.unsuspend = null), clearTimeout(g), clearTimeout(M));
              }
            );
          }
        : null
    );
  }
  function sy() {
    if (
      (this.count--,
      this.count === 0 && (this.imgCount === 0 || !this.waitingForImages))
    ) {
      if (this.stylesheets) oy(this, this.stylesheets);
      else if (this.unsuspend) {
        var a = this.unsuspend;
        ((this.unsuspend = null), a());
      }
    }
  }
  var ay = null;
  function oy(a, l) {
    ((a.stylesheets = null),
      a.unsuspend !== null &&
        (a.count++,
        (ay = new Map()),
        l.forEach(pP, a),
        (ay = null),
        sy.call(a)));
  }
  function pP(a, l) {
    if (!(l.state.loading & 4)) {
      var p = ay.get(a);
      if (p) var g = p.get(null);
      else {
        ((p = new Map()), ay.set(a, p));
        for (
          var M = a.querySelectorAll(
              "link[data-precedence],style[data-precedence]",
            ),
            A = 0;
          A < M.length;
          A++
        ) {
          var z = M[A];
          (z.nodeName === "LINK" || z.getAttribute("media") !== "not all") &&
            (p.set(z.dataset.precedence, z), (g = z));
        }
        g && p.set(null, g);
      }
      ((M = l.instance),
        (z = M.getAttribute("data-precedence")),
        (A = p.get(z) || g),
        A === g && p.set(null, M),
        p.set(z, M),
        this.count++,
        (g = sy.bind(this)),
        M.addEventListener("load", g),
        M.addEventListener("error", g),
        A
          ? A.parentNode.insertBefore(M, A.nextSibling)
          : ((a = a.nodeType === 9 ? a.head : a),
            a.insertBefore(M, a.firstChild)),
        (l.state.loading |= 4));
    }
  }
  var ag = {
    $$typeof: R,
    Provider: null,
    Consumer: null,
    _currentValue: de,
    _currentValue2: de,
    _threadCount: 0,
  };
  function mP(a, l, p, g, M, A, z, Q, pe) {
    ((this.tag = 1),
      (this.containerInfo = a),
      (this.pingCache = this.current = this.pendingChildren = null),
      (this.timeoutHandle = -1),
      (this.callbackNode =
        this.next =
        this.pendingContext =
        this.context =
        this.cancelPendingCommit =
          null),
      (this.callbackPriority = 0),
      (this.expirationTimes = Dt(-1)),
      (this.entangledLanes =
        this.shellSuspendCounter =
        this.errorRecoveryDisabledLanes =
        this.expiredLanes =
        this.warmLanes =
        this.pingedLanes =
        this.suspendedLanes =
        this.pendingLanes =
          0),
      (this.entanglements = Dt(0)),
      (this.hiddenUpdates = Dt(null)),
      (this.identifierPrefix = g),
      (this.onUncaughtError = M),
      (this.onCaughtError = A),
      (this.onRecoverableError = z),
      (this.pooledCache = null),
      (this.pooledCacheLanes = 0),
      (this.formState = pe),
      (this.incompleteTransitions = new Map()));
  }
  function QE(a, l, p, g, M, A, z, Q, pe, Ue, tt, at) {
    return (
      (a = new mP(a, l, p, z, pe, Ue, tt, at, Q)),
      (l = 1),
      A === !0 && (l |= 24),
      (A = fi(3, null, null, l)),
      (a.current = A),
      (A.stateNode = a),
      (l = um()),
      l.refCount++,
      (a.pooledCache = l),
      l.refCount++,
      (A.memoizedState = { element: g, isDehydrated: p, cache: l }),
      Nf(A),
      a
    );
  }
  function JE(a) {
    return a ? ((a = ul), a) : ul;
  }
  function $E(a, l, p, g, M, A) {
    ((M = JE(M)),
      g.context === null ? (g.context = M) : (g.pendingContext = M),
      (g = Do(l)),
      (g.payload = { element: p }),
      (A = A === void 0 ? null : A),
      A !== null && (g.callback = A),
      (p = yl(a, g, l)),
      p !== null && (ln(p, a, l), xl(p, a, l)));
  }
  function ew(a, l) {
    if (((a = a.memoizedState), a !== null && a.dehydrated !== null)) {
      var p = a.retryLane;
      a.retryLane = p !== 0 && p < l ? p : l;
    }
  }
  function l_(a, l) {
    (ew(a, l), (a = a.alternate) && ew(a, l));
  }
  function tw(a) {
    if (a.tag === 13 || a.tag === 31) {
      var l = Br(a, 67108864);
      (l !== null && ln(l, a, 67108864), l_(a, 67108864));
    }
  }
  function nw(a) {
    if (a.tag === 13 || a.tag === 31) {
      var l = Os();
      l = Zi(l);
      var p = Br(a, l);
      (p !== null && ln(p, a, l), l_(a, l));
    }
  }
  var ly = !0;
  function gP(a, l, p, g) {
    var M = W.T;
    W.T = null;
    var A = $.p;
    try {
      (($.p = 2), c_(a, l, p, g));
    } finally {
      (($.p = A), (W.T = M));
    }
  }
  function vP(a, l, p, g) {
    var M = W.T;
    W.T = null;
    var A = $.p;
    try {
      (($.p = 8), c_(a, l, p, g));
    } finally {
      (($.p = A), (W.T = M));
    }
  }
  function c_(a, l, p, g) {
    if (ly) {
      var M = u_(g);
      if (M === null) (Zb(a, l, g, cy, p), rw(a, g));
      else if (xP(M, a, l, p, g)) g.stopPropagation();
      else if ((rw(a, g), l & 4 && -1 < yP.indexOf(a))) {
        for (; M !== null; ) {
          var A = Ms(M);
          if (A !== null)
            switch (A.tag) {
              case 3:
                if (((A = A.stateNode), A.current.memoizedState.isDehydrated)) {
                  var z = Je(A.pendingLanes);
                  if (z !== 0) {
                    var Q = A;
                    for (Q.pendingLanes |= 2, Q.entangledLanes |= 2; z; ) {
                      var pe = 1 << (31 - re(z));
                      ((Q.entanglements[1] |= pe), (z &= ~pe));
                    }
                    (ut(A), (Ot & 6) === 0 && ((Li = k() + 500), Ct(0)));
                  }
                }
                break;
              case 31:
              case 13:
                ((Q = Br(A, 2)), Q !== null && ln(Q, A, 2), Ra(), l_(A, 2));
            }
          if (((A = u_(g)), A === null && Zb(a, l, g, cy, p), A === M)) break;
          M = A;
        }
        M !== null && g.stopPropagation();
      } else Zb(a, l, g, null, p);
    }
  }
  function u_(a) {
    return ((a = nc(a)), f_(a));
  }
  var cy = null;
  function f_(a) {
    if (((cy = null), (a = ts(a)), a !== null)) {
      var l = s(a);
      if (l === null) a = null;
      else {
        var p = l.tag;
        if (p === 13) {
          if (((a = o(l)), a !== null)) return a;
          a = null;
        } else if (p === 31) {
          if (((a = u(l)), a !== null)) return a;
          a = null;
        } else if (p === 3) {
          if (l.stateNode.current.memoizedState.isDehydrated)
            return l.tag === 3 ? l.stateNode.containerInfo : null;
          a = null;
        } else l !== a && (a = null);
      }
    }
    return ((cy = a), null);
  }
  function iw(a) {
    switch (a) {
      case "beforetoggle":
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "toggle":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 2;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 8;
      case "message":
        switch (oe()) {
          case Ae:
            return 2;
          case _e:
            return 8;
          case be:
          case et:
            return 32;
          case $e:
            return 268435456;
          default:
            return 32;
        }
      default:
        return 32;
    }
  }
  var h_ = !1,
    Ou = null,
    Fu = null,
    zu = null,
    og = new Map(),
    lg = new Map(),
    Bu = [],
    yP =
      "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
        " ",
      );
  function rw(a, l) {
    switch (a) {
      case "focusin":
      case "focusout":
        Ou = null;
        break;
      case "dragenter":
      case "dragleave":
        Fu = null;
        break;
      case "mouseover":
      case "mouseout":
        zu = null;
        break;
      case "pointerover":
      case "pointerout":
        og.delete(l.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        lg.delete(l.pointerId);
    }
  }
  function cg(a, l, p, g, M, A) {
    return a === null || a.nativeEvent !== A
      ? ((a = {
          blockedOn: l,
          domEventName: p,
          eventSystemFlags: g,
          nativeEvent: A,
          targetContainers: [M],
        }),
        l !== null && ((l = Ms(l)), l !== null && tw(l)),
        a)
      : ((a.eventSystemFlags |= g),
        (l = a.targetContainers),
        M !== null && l.indexOf(M) === -1 && l.push(M),
        a);
  }
  function xP(a, l, p, g, M) {
    switch (l) {
      case "focusin":
        return ((Ou = cg(Ou, a, l, p, g, M)), !0);
      case "dragenter":
        return ((Fu = cg(Fu, a, l, p, g, M)), !0);
      case "mouseover":
        return ((zu = cg(zu, a, l, p, g, M)), !0);
      case "pointerover":
        var A = M.pointerId;
        return (og.set(A, cg(og.get(A) || null, a, l, p, g, M)), !0);
      case "gotpointercapture":
        return (
          (A = M.pointerId),
          lg.set(A, cg(lg.get(A) || null, a, l, p, g, M)),
          !0
        );
    }
    return !1;
  }
  function sw(a) {
    var l = ts(a.target);
    if (l !== null) {
      var p = s(l);
      if (p !== null) {
        if (((l = p.tag), l === 13)) {
          if (((l = o(p)), l !== null)) {
            ((a.blockedOn = l),
              xi(a.priority, function () {
                nw(p);
              }));
            return;
          }
        } else if (l === 31) {
          if (((l = u(p)), l !== null)) {
            ((a.blockedOn = l),
              xi(a.priority, function () {
                nw(p);
              }));
            return;
          }
        } else if (l === 3 && p.stateNode.current.memoizedState.isDehydrated) {
          a.blockedOn = p.tag === 3 ? p.stateNode.containerInfo : null;
          return;
        }
      }
    }
    a.blockedOn = null;
  }
  function uy(a) {
    if (a.blockedOn !== null) return !1;
    for (var l = a.targetContainers; 0 < l.length; ) {
      var p = u_(a.nativeEvent);
      if (p === null) {
        p = a.nativeEvent;
        var g = new p.constructor(p.type, p);
        ((ka = g), p.target.dispatchEvent(g), (ka = null));
      } else return ((l = Ms(p)), l !== null && tw(l), (a.blockedOn = p), !1);
      l.shift();
    }
    return !0;
  }
  function aw(a, l, p) {
    uy(a) && p.delete(l);
  }
  function bP() {
    ((h_ = !1),
      Ou !== null && uy(Ou) && (Ou = null),
      Fu !== null && uy(Fu) && (Fu = null),
      zu !== null && uy(zu) && (zu = null),
      og.forEach(aw),
      lg.forEach(aw));
  }
  function fy(a, l) {
    a.blockedOn === l &&
      ((a.blockedOn = null),
      h_ ||
        ((h_ = !0),
        i.unstable_scheduleCallback(i.unstable_NormalPriority, bP)));
  }
  var hy = null;
  function ow(a) {
    hy !== a &&
      ((hy = a),
      i.unstable_scheduleCallback(i.unstable_NormalPriority, function () {
        hy === a && (hy = null);
        for (var l = 0; l < a.length; l += 3) {
          var p = a[l],
            g = a[l + 1],
            M = a[l + 2];
          if (typeof g != "function") {
            if (f_(g || p) === null) continue;
            break;
          }
          var A = Ms(p);
          A !== null &&
            (a.splice(l, 3),
            (l -= 3),
            Fm(A, { pending: !0, data: M, method: p.method, action: g }, g, M));
        }
      }));
  }
  function Bd(a) {
    function l(pe) {
      return fy(pe, a);
    }
    (Ou !== null && fy(Ou, a),
      Fu !== null && fy(Fu, a),
      zu !== null && fy(zu, a),
      og.forEach(l),
      lg.forEach(l));
    for (var p = 0; p < Bu.length; p++) {
      var g = Bu[p];
      g.blockedOn === a && (g.blockedOn = null);
    }
    for (; 0 < Bu.length && ((p = Bu[0]), p.blockedOn === null); )
      (sw(p), p.blockedOn === null && Bu.shift());
    if (((p = (a.ownerDocument || a).$$reactFormReplay), p != null))
      for (g = 0; g < p.length; g += 3) {
        var M = p[g],
          A = p[g + 1],
          z = M[ii] || null;
        if (typeof A == "function") z || ow(p);
        else if (z) {
          var Q = null;
          if (A && A.hasAttribute("formAction")) {
            if (((M = A), (z = A[ii] || null))) Q = z.formAction;
            else if (f_(M) !== null) continue;
          } else Q = z.action;
          (typeof Q == "function" ? (p[g + 1] = Q) : (p.splice(g, 3), (g -= 3)),
            ow(p));
        }
      }
  }
  function lw() {
    function a(A) {
      A.canIntercept &&
        A.info === "react-transition" &&
        A.intercept({
          handler: function () {
            return new Promise(function (z) {
              return (M = z);
            });
          },
          focusReset: "manual",
          scroll: "manual",
        });
    }
    function l() {
      (M !== null && (M(), (M = null)), g || setTimeout(p, 20));
    }
    function p() {
      if (!g && !navigation.transition) {
        var A = navigation.currentEntry;
        A &&
          A.url != null &&
          navigation.navigate(A.url, {
            state: A.getState(),
            info: "react-transition",
            history: "replace",
          });
      }
    }
    if (typeof navigation == "object") {
      var g = !1,
        M = null;
      return (
        navigation.addEventListener("navigate", a),
        navigation.addEventListener("navigatesuccess", l),
        navigation.addEventListener("navigateerror", l),
        setTimeout(p, 100),
        function () {
          ((g = !0),
            navigation.removeEventListener("navigate", a),
            navigation.removeEventListener("navigatesuccess", l),
            navigation.removeEventListener("navigateerror", l),
            M !== null && (M(), (M = null)));
        }
      );
    }
  }
  function d_(a) {
    this._internalRoot = a;
  }
  ((dy.prototype.render = d_.prototype.render =
    function (a) {
      var l = this._internalRoot;
      if (l === null) throw Error(n(409));
      var p = l.current,
        g = Os();
      $E(p, g, a, l, null, null);
    }),
    (dy.prototype.unmount = d_.prototype.unmount =
      function () {
        var a = this._internalRoot;
        if (a !== null) {
          this._internalRoot = null;
          var l = a.containerInfo;
          ($E(a.current, 2, null, a, null, null), Ra(), (l[Ir] = null));
        }
      }));
  function dy(a) {
    this._internalRoot = a;
  }
  dy.prototype.unstable_scheduleHydration = function (a) {
    if (a) {
      var l = zi();
      a = { blockedOn: null, target: a, priority: l };
      for (var p = 0; p < Bu.length && l !== 0 && l < Bu[p].priority; p++);
      (Bu.splice(p, 0, a), p === 0 && sw(a));
    }
  };
  var cw = e.version;
  if (cw !== "19.2.4") throw Error(n(527, cw, "19.2.4"));
  $.findDOMNode = function (a) {
    var l = a._reactInternals;
    if (l === void 0)
      throw typeof a.render == "function"
        ? Error(n(188))
        : ((a = Object.keys(a).join(",")), Error(n(268, a)));
    return (
      (a = d(l)),
      (a = a !== null ? m(a) : null),
      (a = a === null ? null : a.stateNode),
      a
    );
  };
  var _P = {
    bundleType: 0,
    version: "19.2.4",
    rendererPackageName: "react-dom",
    currentDispatcherRef: W,
    reconcilerVersion: "19.2.4",
  };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var py = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!py.isDisabled && py.supportsFiber)
      try {
        ((Ge = py.inject(_P)), (Ve = py));
      } catch {}
  }
  return (
    (fg.createRoot = function (a, l) {
      if (!r(a)) throw Error(n(299));
      var p = !1,
        g = "",
        M = Wv,
        A = Hm,
        z = jm;
      return (
        l != null &&
          (l.unstable_strictMode === !0 && (p = !0),
          l.identifierPrefix !== void 0 && (g = l.identifierPrefix),
          l.onUncaughtError !== void 0 && (M = l.onUncaughtError),
          l.onCaughtError !== void 0 && (A = l.onCaughtError),
          l.onRecoverableError !== void 0 && (z = l.onRecoverableError)),
        (l = QE(a, 1, !1, null, null, p, g, null, M, A, z, lw)),
        (a[Ir] = l.current),
        Yb(a),
        new d_(l)
      );
    }),
    (fg.hydrateRoot = function (a, l, p) {
      if (!r(a)) throw Error(n(299));
      var g = !1,
        M = "",
        A = Wv,
        z = Hm,
        Q = jm,
        pe = null;
      return (
        p != null &&
          (p.unstable_strictMode === !0 && (g = !0),
          p.identifierPrefix !== void 0 && (M = p.identifierPrefix),
          p.onUncaughtError !== void 0 && (A = p.onUncaughtError),
          p.onCaughtError !== void 0 && (z = p.onCaughtError),
          p.onRecoverableError !== void 0 && (Q = p.onRecoverableError),
          p.formState !== void 0 && (pe = p.formState)),
        (l = QE(a, 1, !0, l, p ?? null, g, M, pe, A, z, Q, lw)),
        (l.context = JE(null)),
        (p = l.current),
        (g = Os()),
        (g = Zi(g)),
        (M = Do(g)),
        (M.callback = null),
        yl(p, M, g),
        (p = g),
        (l.current.lanes = p),
        hn(l, p),
        ut(l),
        (a[Ir] = l.current),
        Yb(a),
        new dy(l)
      );
    }),
    (fg.version = "19.2.4"),
    fg
  );
}
var xw;
function DP() {
  if (xw) return g_.exports;
  xw = 1;
  function i() {
    if (
      !(
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" ||
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"
      )
    )
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(i);
      } catch (e) {
        console.error(e);
      }
  }
  return (i(), (g_.exports = RP()), g_.exports);
}
var LP = DP();
/**
 * react-router v7.13.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ var bw = "popstate";
function _w(i) {
  return (
    typeof i == "object" &&
    i != null &&
    "pathname" in i &&
    "search" in i &&
    "hash" in i &&
    "state" in i &&
    "key" in i
  );
}
function NP(i = {}) {
  function e(n, r) {
    var d;
    let s = (d = r.state) == null ? void 0 : d.masked,
      { pathname: o, search: u, hash: h } = s || n.location;
    return XS(
      "",
      { pathname: o, search: u, hash: h },
      (r.state && r.state.usr) || null,
      (r.state && r.state.key) || "default",
      s
        ? {
            pathname: n.location.pathname,
            search: n.location.search,
            hash: n.location.hash,
          }
        : void 0,
    );
  }
  function t(n, r) {
    return typeof r == "string" ? r : Qg(r);
  }
  return PP(e, t, null, i);
}
function Ei(i, e) {
  if (i === !1 || i === null || typeof i > "u") throw new Error(e);
}
function Qo(i, e) {
  if (!i) {
    typeof console < "u" && console.warn(e);
    try {
      throw new Error(e);
    } catch {}
  }
}
function UP() {
  return Math.random().toString(36).substring(2, 10);
}
function Sw(i, e) {
  return {
    usr: i.state,
    key: i.key,
    idx: e,
    masked: i.unstable_mask
      ? { pathname: i.pathname, search: i.search, hash: i.hash }
      : void 0,
  };
}
function XS(i, e, t = null, n, r) {
  return {
    pathname: typeof i == "string" ? i : i.pathname,
    search: "",
    hash: "",
    ...(typeof e == "string" ? Np(e) : e),
    state: t,
    key: (e && e.key) || n || UP(),
    unstable_mask: r,
  };
}
function Qg({ pathname: i = "/", search: e = "", hash: t = "" }) {
  return (
    e && e !== "?" && (i += e.charAt(0) === "?" ? e : "?" + e),
    t && t !== "#" && (i += t.charAt(0) === "#" ? t : "#" + t),
    i
  );
}
function Np(i) {
  let e = {};
  if (i) {
    let t = i.indexOf("#");
    t >= 0 && ((e.hash = i.substring(t)), (i = i.substring(0, t)));
    let n = i.indexOf("?");
    (n >= 0 && ((e.search = i.substring(n)), (i = i.substring(0, n))),
      i && (e.pathname = i));
  }
  return e;
}
function PP(i, e, t, n = {}) {
  let { window: r = document.defaultView, v5Compat: s = !1 } = n,
    o = r.history,
    u = "POP",
    h = null,
    d = m();
  d == null && ((d = 0), o.replaceState({ ...o.state, idx: d }, ""));
  function m() {
    return (o.state || { idx: null }).idx;
  }
  function v() {
    u = "POP";
    let E = m(),
      T = E == null ? null : E - d;
    ((d = E), h && h({ action: u, location: w.location, delta: T }));
  }
  function y(E, T) {
    u = "PUSH";
    let C = _w(E) ? E : XS(w.location, E, T);
    d = m() + 1;
    let R = Sw(C, d),
      L = w.createHref(C.unstable_mask || C);
    try {
      o.pushState(R, "", L);
    } catch (I) {
      if (I instanceof DOMException && I.name === "DataCloneError") throw I;
      r.location.assign(L);
    }
    s && h && h({ action: u, location: w.location, delta: 1 });
  }
  function b(E, T) {
    u = "REPLACE";
    let C = _w(E) ? E : XS(w.location, E, T);
    d = m();
    let R = Sw(C, d),
      L = w.createHref(C.unstable_mask || C);
    (o.replaceState(R, "", L),
      s && h && h({ action: u, location: w.location, delta: 0 }));
  }
  function _(E) {
    return IP(E);
  }
  let w = {
    get action() {
      return u;
    },
    get location() {
      return i(r, o);
    },
    listen(E) {
      if (h) throw new Error("A history only accepts one active listener");
      return (
        r.addEventListener(bw, v),
        (h = E),
        () => {
          (r.removeEventListener(bw, v), (h = null));
        }
      );
    },
    createHref(E) {
      return e(r, E);
    },
    createURL: _,
    encodeLocation(E) {
      let T = _(E);
      return { pathname: T.pathname, search: T.search, hash: T.hash };
    },
    push: y,
    replace: b,
    go(E) {
      return o.go(E);
    },
  };
  return w;
}
function IP(i, e = !1) {
  let t = "http://localhost";
  (typeof window < "u" &&
    (t =
      window.location.origin !== "null"
        ? window.location.origin
        : window.location.href),
    Ei(t, "No window.location.(origin|href) available to create URL"));
  let n = typeof i == "string" ? i : Qg(i);
  return (
    (n = n.replace(/ $/, "%20")),
    !e && n.startsWith("//") && (n = t + n),
    new URL(n, t)
  );
}
function iR(i, e, t = "/") {
  return OP(i, e, t, !1);
}
function OP(i, e, t, n) {
  let r = typeof e == "string" ? Np(e) : e,
    s = Xc(r.pathname || "/", t);
  if (s == null) return null;
  let o = rR(i);
  FP(o);
  let u = null;
  for (let h = 0; u == null && h < o.length; ++h) {
    let d = YP(s);
    u = XP(o[h], d, n);
  }
  return u;
}
function rR(i, e = [], t = [], n = "", r = !1) {
  let s = (o, u, h = r, d) => {
    let m = {
      relativePath: d === void 0 ? o.path || "" : d,
      caseSensitive: o.caseSensitive === !0,
      childrenIndex: u,
      route: o,
    };
    if (m.relativePath.startsWith("/")) {
      if (!m.relativePath.startsWith(n) && h) return;
      (Ei(
        m.relativePath.startsWith(n),
        `Absolute route path "${m.relativePath}" nested under path "${n}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`,
      ),
        (m.relativePath = m.relativePath.slice(n.length)));
    }
    let v = Wl([n, m.relativePath]),
      y = t.concat(m);
    (o.children &&
      o.children.length > 0 &&
      (Ei(
        o.index !== !0,
        `Index routes must not have child routes. Please remove all child routes from route path "${v}".`,
      ),
      rR(o.children, e, y, v, h)),
      !(o.path == null && !o.index) &&
        e.push({ path: v, score: jP(v, o.index), routesMeta: y }));
  };
  return (
    i.forEach((o, u) => {
      var h;
      if (o.path === "" || !((h = o.path) != null && h.includes("?"))) s(o, u);
      else for (let d of sR(o.path)) s(o, u, !0, d);
    }),
    e
  );
}
function sR(i) {
  let e = i.split("/");
  if (e.length === 0) return [];
  let [t, ...n] = e,
    r = t.endsWith("?"),
    s = t.replace(/\?$/, "");
  if (n.length === 0) return r ? [s, ""] : [s];
  let o = sR(n.join("/")),
    u = [];
  return (
    u.push(...o.map((h) => (h === "" ? s : [s, h].join("/")))),
    r && u.push(...o),
    u.map((h) => (i.startsWith("/") && h === "" ? "/" : h))
  );
}
function FP(i) {
  i.sort((e, t) =>
    e.score !== t.score
      ? t.score - e.score
      : WP(
          e.routesMeta.map((n) => n.childrenIndex),
          t.routesMeta.map((n) => n.childrenIndex),
        ),
  );
}
var zP = /^:[\w-]+$/,
  BP = 3,
  kP = 2,
  VP = 1,
  GP = 10,
  HP = -2,
  Mw = (i) => i === "*";
function jP(i, e) {
  let t = i.split("/"),
    n = t.length;
  return (
    t.some(Mw) && (n += HP),
    e && (n += kP),
    t
      .filter((r) => !Mw(r))
      .reduce((r, s) => r + (zP.test(s) ? BP : s === "" ? VP : GP), n)
  );
}
function WP(i, e) {
  return i.length === e.length && i.slice(0, -1).every((n, r) => n === e[r])
    ? i[i.length - 1] - e[e.length - 1]
    : 0;
}
function XP(i, e, t = !1) {
  let { routesMeta: n } = i,
    r = {},
    s = "/",
    o = [];
  for (let u = 0; u < n.length; ++u) {
    let h = n[u],
      d = u === n.length - 1,
      m = s === "/" ? e : e.slice(s.length) || "/",
      v = Px(
        { path: h.relativePath, caseSensitive: h.caseSensitive, end: d },
        m,
      ),
      y = h.route;
    if (
      (!v &&
        d &&
        t &&
        !n[n.length - 1].route.index &&
        (v = Px(
          { path: h.relativePath, caseSensitive: h.caseSensitive, end: !1 },
          m,
        )),
      !v)
    )
      return null;
    (Object.assign(r, v.params),
      o.push({
        params: r,
        pathname: Wl([s, v.pathname]),
        pathnameBase: JP(Wl([s, v.pathnameBase])),
        route: y,
      }),
      v.pathnameBase !== "/" && (s = Wl([s, v.pathnameBase])));
  }
  return o;
}
function Px(i, e) {
  typeof i == "string" && (i = { path: i, caseSensitive: !1, end: !0 });
  let [t, n] = qP(i.path, i.caseSensitive, i.end),
    r = e.match(t);
  if (!r) return null;
  let s = r[0],
    o = s.replace(/(.)\/+$/, "$1"),
    u = r.slice(1);
  return {
    params: n.reduce((d, { paramName: m, isOptional: v }, y) => {
      if (m === "*") {
        let _ = u[y] || "";
        o = s.slice(0, s.length - _.length).replace(/(.)\/+$/, "$1");
      }
      const b = u[y];
      return (
        v && !b ? (d[m] = void 0) : (d[m] = (b || "").replace(/%2F/g, "/")),
        d
      );
    }, {}),
    pathname: s,
    pathnameBase: o,
    pattern: i,
  };
}
function qP(i, e = !1, t = !0) {
  Qo(
    i === "*" || !i.endsWith("*") || i.endsWith("/*"),
    `Route path "${i}" will be treated as if it were "${i.replace(/\*$/, "/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${i.replace(/\*$/, "/*")}".`,
  );
  let n = [],
    r =
      "^" +
      i
        .replace(/\/*\*?$/, "")
        .replace(/^\/*/, "/")
        .replace(/[\\.*+^${}|()[\]]/g, "\\$&")
        .replace(/\/:([\w-]+)(\?)?/g, (o, u, h, d, m) => {
          if ((n.push({ paramName: u, isOptional: h != null }), h)) {
            let v = m.charAt(d + o.length);
            return v && v !== "/" ? "/([^\\/]*)" : "(?:/([^\\/]*))?";
          }
          return "/([^\\/]+)";
        })
        .replace(/\/([\w-]+)\?(\/|$)/g, "(/$1)?$2");
  return (
    i.endsWith("*")
      ? (n.push({ paramName: "*" }),
        (r += i === "*" || i === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$"))
      : t
        ? (r += "\\/*$")
        : i !== "" && i !== "/" && (r += "(?:(?=\\/|$))"),
    [new RegExp(r, e ? void 0 : "i"), n]
  );
}
function YP(i) {
  try {
    return i
      .split("/")
      .map((e) => decodeURIComponent(e).replace(/\//g, "%2F"))
      .join("/");
  } catch (e) {
    return (
      Qo(
        !1,
        `The URL path "${i}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${e}).`,
      ),
      i
    );
  }
}
function Xc(i, e) {
  if (e === "/") return i;
  if (!i.toLowerCase().startsWith(e.toLowerCase())) return null;
  let t = e.endsWith("/") ? e.length - 1 : e.length,
    n = i.charAt(t);
  return n && n !== "/" ? null : i.slice(t) || "/";
}
var ZP = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
function KP(i, e = "/") {
  let {
      pathname: t,
      search: n = "",
      hash: r = "",
    } = typeof i == "string" ? Np(i) : i,
    s;
  return (
    t
      ? ((t = t.replace(/\/\/+/g, "/")),
        t.startsWith("/") ? (s = Tw(t.substring(1), "/")) : (s = Tw(t, e)))
      : (s = e),
    { pathname: s, search: $P(n), hash: eI(r) }
  );
}
function Tw(i, e) {
  let t = e.replace(/\/+$/, "").split("/");
  return (
    i.split("/").forEach((r) => {
      r === ".." ? t.length > 1 && t.pop() : r !== "." && t.push(r);
    }),
    t.length > 1 ? t.join("/") : "/"
  );
}
function b_(i, e, t, n) {
  return `Cannot include a '${i}' character in a manually specified \`to.${e}\` field [${JSON.stringify(n)}].  Please separate it out to the \`to.${t}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`;
}
function QP(i) {
  return i.filter(
    (e, t) => t === 0 || (e.route.path && e.route.path.length > 0),
  );
}
function YM(i) {
  let e = QP(i);
  return e.map((t, n) => (n === e.length - 1 ? t.pathname : t.pathnameBase));
}
function H1(i, e, t, n = !1) {
  let r;
  typeof i == "string"
    ? (r = Np(i))
    : ((r = { ...i }),
      Ei(
        !r.pathname || !r.pathname.includes("?"),
        b_("?", "pathname", "search", r),
      ),
      Ei(
        !r.pathname || !r.pathname.includes("#"),
        b_("#", "pathname", "hash", r),
      ),
      Ei(!r.search || !r.search.includes("#"), b_("#", "search", "hash", r)));
  let s = i === "" || r.pathname === "",
    o = s ? "/" : r.pathname,
    u;
  if (o == null) u = t;
  else {
    let v = e.length - 1;
    if (!n && o.startsWith("..")) {
      let y = o.split("/");
      for (; y[0] === ".."; ) (y.shift(), (v -= 1));
      r.pathname = y.join("/");
    }
    u = v >= 0 ? e[v] : "/";
  }
  let h = KP(r, u),
    d = o && o !== "/" && o.endsWith("/"),
    m = (s || o === ".") && t.endsWith("/");
  return (!h.pathname.endsWith("/") && (d || m) && (h.pathname += "/"), h);
}
var Wl = (i) => i.join("/").replace(/\/\/+/g, "/"),
  JP = (i) => i.replace(/\/+$/, "").replace(/^\/*/, "/"),
  $P = (i) => (!i || i === "?" ? "" : i.startsWith("?") ? i : "?" + i),
  eI = (i) => (!i || i === "#" ? "" : i.startsWith("#") ? i : "#" + i),
  tI = class {
    constructor(i, e, t, n = !1) {
      ((this.status = i),
        (this.statusText = e || ""),
        (this.internal = n),
        t instanceof Error
          ? ((this.data = t.toString()), (this.error = t))
          : (this.data = t));
    }
  };
function nI(i) {
  return (
    i != null &&
    typeof i.status == "number" &&
    typeof i.statusText == "string" &&
    typeof i.internal == "boolean" &&
    "data" in i
  );
}
function iI(i) {
  return (
    i
      .map((e) => e.route.path)
      .filter(Boolean)
      .join("/")
      .replace(/\/\/*/g, "/") || "/"
  );
}
var aR =
  typeof window < "u" &&
  typeof window.document < "u" &&
  typeof window.document.createElement < "u";
function oR(i, e) {
  let t = i;
  if (typeof t != "string" || !ZP.test(t))
    return { absoluteURL: void 0, isExternal: !1, to: t };
  let n = t,
    r = !1;
  if (aR)
    try {
      let s = new URL(window.location.href),
        o = t.startsWith("//") ? new URL(s.protocol + t) : new URL(t),
        u = Xc(o.pathname, e);
      o.origin === s.origin && u != null
        ? (t = u + o.search + o.hash)
        : (r = !0);
    } catch {
      Qo(
        !1,
        `<Link to="${t}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`,
      );
    }
  return { absoluteURL: n, isExternal: r, to: t };
}
Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
var lR = ["POST", "PUT", "PATCH", "DELETE"];
new Set(lR);
var rI = ["GET", ...lR];
new Set(rI);
var Up = ie.createContext(null);
Up.displayName = "DataRouter";
var j1 = ie.createContext(null);
j1.displayName = "DataRouterState";
var sI = ie.createContext(!1),
  cR = ie.createContext({ isTransitioning: !1 });
cR.displayName = "ViewTransition";
var aI = ie.createContext(new Map());
aI.displayName = "Fetchers";
var oI = ie.createContext(null);
oI.displayName = "Await";
var za = ie.createContext(null);
za.displayName = "Navigation";
var T0 = ie.createContext(null);
T0.displayName = "Location";
var $l = ie.createContext({ outlet: null, matches: [], isDataRoute: !1 });
$l.displayName = "Route";
var ZM = ie.createContext(null);
ZM.displayName = "RouteError";
var uR = "REACT_ROUTER_ERROR",
  lI = "REDIRECT",
  cI = "ROUTE_ERROR_RESPONSE";
function uI(i) {
  if (i.startsWith(`${uR}:${lI}:{`))
    try {
      let e = JSON.parse(i.slice(28));
      if (
        typeof e == "object" &&
        e &&
        typeof e.status == "number" &&
        typeof e.statusText == "string" &&
        typeof e.location == "string" &&
        typeof e.reloadDocument == "boolean" &&
        typeof e.replace == "boolean"
      )
        return e;
    } catch {}
}
function fI(i) {
  if (i.startsWith(`${uR}:${cI}:{`))
    try {
      let e = JSON.parse(i.slice(40));
      if (
        typeof e == "object" &&
        e &&
        typeof e.status == "number" &&
        typeof e.statusText == "string"
      )
        return new tI(e.status, e.statusText, e.data);
    } catch {}
}
function hI(i, { relative: e } = {}) {
  Ei(
    Pp(),
    "useHref() may be used only in the context of a <Router> component.",
  );
  let { basename: t, navigator: n } = ie.useContext(za),
    { hash: r, pathname: s, search: o } = E0(i, { relative: e }),
    u = s;
  return (
    t !== "/" && (u = s === "/" ? t : Wl([t, s])),
    n.createHref({ pathname: u, search: o, hash: r })
  );
}
function Pp() {
  return ie.useContext(T0) != null;
}
function Qc() {
  return (
    Ei(
      Pp(),
      "useLocation() may be used only in the context of a <Router> component.",
    ),
    ie.useContext(T0).location
  );
}
var fR =
  "You should call navigate() in a React.useEffect(), not when your component is first rendered.";
function hR(i) {
  ie.useContext(za).static || ie.useLayoutEffect(i);
}
function dR() {
  let { isDataRoute: i } = ie.useContext($l);
  return i ? EI() : dI();
}
function dI() {
  Ei(
    Pp(),
    "useNavigate() may be used only in the context of a <Router> component.",
  );
  let i = ie.useContext(Up),
    { basename: e, navigator: t } = ie.useContext(za),
    { matches: n } = ie.useContext($l),
    { pathname: r } = Qc(),
    s = JSON.stringify(YM(n)),
    o = ie.useRef(!1);
  return (
    hR(() => {
      o.current = !0;
    }),
    ie.useCallback(
      (h, d = {}) => {
        if ((Qo(o.current, fR), !o.current)) return;
        if (typeof h == "number") {
          t.go(h);
          return;
        }
        let m = H1(h, JSON.parse(s), r, d.relative === "path");
        (i == null &&
          e !== "/" &&
          (m.pathname = m.pathname === "/" ? e : Wl([e, m.pathname])),
          (d.replace ? t.replace : t.push)(m, d.state, d));
      },
      [e, t, s, r, i],
    )
  );
}
ie.createContext(null);
function E0(i, { relative: e } = {}) {
  let { matches: t } = ie.useContext($l),
    { pathname: n } = Qc(),
    r = JSON.stringify(YM(t));
  return ie.useMemo(() => H1(i, JSON.parse(r), n, e === "path"), [i, r, n, e]);
}
function pI(i, e) {
  return pR(i, e);
}
function pR(i, e, t) {
  var E;
  Ei(
    Pp(),
    "useRoutes() may be used only in the context of a <Router> component.",
  );
  let { navigator: n } = ie.useContext(za),
    { matches: r } = ie.useContext($l),
    s = r[r.length - 1],
    o = s ? s.params : {},
    u = s ? s.pathname : "/",
    h = s ? s.pathnameBase : "/",
    d = s && s.route;
  {
    let T = (d && d.path) || "";
    gR(
      u,
      !d || T.endsWith("*") || T.endsWith("*?"),
      `You rendered descendant <Routes> (or called \`useRoutes()\`) at "${u}" (under <Route path="${T}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${T}"> to <Route path="${T === "/" ? "*" : `${T}/*`}">.`,
    );
  }
  let m = Qc(),
    v;
  if (e) {
    let T = typeof e == "string" ? Np(e) : e;
    (Ei(
      h === "/" || ((E = T.pathname) == null ? void 0 : E.startsWith(h)),
      `When overriding the location using \`<Routes location>\` or \`useRoutes(routes, location)\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "${h}" but pathname "${T.pathname}" was given in the \`location\` prop.`,
    ),
      (v = T));
  } else v = m;
  let y = v.pathname || "/",
    b = y;
  if (h !== "/") {
    let T = h.replace(/^\//, "").split("/");
    b = "/" + y.replace(/^\//, "").split("/").slice(T.length).join("/");
  }
  let _ = iR(i, { pathname: b });
  (Qo(
    d || _ != null,
    `No routes matched location "${v.pathname}${v.search}${v.hash}" `,
  ),
    Qo(
      _ == null ||
        _[_.length - 1].route.element !== void 0 ||
        _[_.length - 1].route.Component !== void 0 ||
        _[_.length - 1].route.lazy !== void 0,
      `Matched leaf route at location "${v.pathname}${v.search}${v.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`,
    ));
  let w = xI(
    _ &&
      _.map((T) =>
        Object.assign({}, T, {
          params: Object.assign({}, o, T.params),
          pathname: Wl([
            h,
            n.encodeLocation
              ? n.encodeLocation(
                  T.pathname.replace(/\?/g, "%3F").replace(/#/g, "%23"),
                ).pathname
              : T.pathname,
          ]),
          pathnameBase:
            T.pathnameBase === "/"
              ? h
              : Wl([
                  h,
                  n.encodeLocation
                    ? n.encodeLocation(
                        T.pathnameBase
                          .replace(/\?/g, "%3F")
                          .replace(/#/g, "%23"),
                      ).pathname
                    : T.pathnameBase,
                ]),
        }),
      ),
    r,
    t,
  );
  return e && w
    ? ie.createElement(
        T0.Provider,
        {
          value: {
            location: {
              pathname: "/",
              search: "",
              hash: "",
              state: null,
              key: "default",
              unstable_mask: void 0,
              ...v,
            },
            navigationType: "POP",
          },
        },
        w,
      )
    : w;
}
function mI() {
  let i = TI(),
    e = nI(i)
      ? `${i.status} ${i.statusText}`
      : i instanceof Error
        ? i.message
        : JSON.stringify(i),
    t = i instanceof Error ? i.stack : null,
    n = "rgba(200,200,200, 0.5)",
    r = { padding: "0.5rem", backgroundColor: n },
    s = { padding: "2px 4px", backgroundColor: n },
    o = null;
  return (
    console.error("Error handled by React Router default ErrorBoundary:", i),
    (o = ie.createElement(
      ie.Fragment,
      null,
      ie.createElement("p", null, " Hey developer "),
      ie.createElement(
        "p",
        null,
        "You can provide a way better UX than this when your app throws errors by providing your own ",
        ie.createElement("code", { style: s }, "ErrorBoundary"),
        " or",
        " ",
        ie.createElement("code", { style: s }, "errorElement"),
        " prop on your route.",
      ),
    )),
    ie.createElement(
      ie.Fragment,
      null,
      ie.createElement("h2", null, "Unexpected Application Error!"),
      ie.createElement("h3", { style: { fontStyle: "italic" } }, e),
      t ? ie.createElement("pre", { style: r }, t) : null,
      o,
    )
  );
}
var gI = ie.createElement(mI, null),
  mR = class extends ie.Component {
    constructor(i) {
      (super(i),
        (this.state = {
          location: i.location,
          revalidation: i.revalidation,
          error: i.error,
        }));
    }
    static getDerivedStateFromError(i) {
      return { error: i };
    }
    static getDerivedStateFromProps(i, e) {
      return e.location !== i.location ||
        (e.revalidation !== "idle" && i.revalidation === "idle")
        ? { error: i.error, location: i.location, revalidation: i.revalidation }
        : {
            error: i.error !== void 0 ? i.error : e.error,
            location: e.location,
            revalidation: i.revalidation || e.revalidation,
          };
    }
    componentDidCatch(i, e) {
      this.props.onError
        ? this.props.onError(i, e)
        : console.error(
            "React Router caught the following error during render",
            i,
          );
    }
    render() {
      let i = this.state.error;
      if (
        this.context &&
        typeof i == "object" &&
        i &&
        "digest" in i &&
        typeof i.digest == "string"
      ) {
        const t = fI(i.digest);
        t && (i = t);
      }
      let e =
        i !== void 0
          ? ie.createElement(
              $l.Provider,
              { value: this.props.routeContext },
              ie.createElement(ZM.Provider, {
                value: i,
                children: this.props.component,
              }),
            )
          : this.props.children;
      return this.context ? ie.createElement(vI, { error: i }, e) : e;
    }
  };
mR.contextType = sI;
var __ = new WeakMap();
function vI({ children: i, error: e }) {
  let { basename: t } = ie.useContext(za);
  if (
    typeof e == "object" &&
    e &&
    "digest" in e &&
    typeof e.digest == "string"
  ) {
    let n = uI(e.digest);
    if (n) {
      let r = __.get(e);
      if (r) throw r;
      let s = oR(n.location, t);
      if (aR && !__.get(e))
        if (s.isExternal || n.reloadDocument)
          window.location.href = s.absoluteURL || s.to;
        else {
          const o = Promise.resolve().then(() =>
            window.__reactRouterDataRouter.navigate(s.to, {
              replace: n.replace,
            }),
          );
          throw (__.set(e, o), o);
        }
      return ie.createElement("meta", {
        httpEquiv: "refresh",
        content: `0;url=${s.absoluteURL || s.to}`,
      });
    }
  }
  return i;
}
function yI({ routeContext: i, match: e, children: t }) {
  let n = ie.useContext(Up);
  return (
    n &&
      n.static &&
      n.staticContext &&
      (e.route.errorElement || e.route.ErrorBoundary) &&
      (n.staticContext._deepestRenderedBoundaryId = e.route.id),
    ie.createElement($l.Provider, { value: i }, t)
  );
}
function xI(i, e = [], t) {
  let n = t == null ? void 0 : t.state;
  if (i == null) {
    if (!n) return null;
    if (n.errors) i = n.matches;
    else if (e.length === 0 && !n.initialized && n.matches.length > 0)
      i = n.matches;
    else return null;
  }
  let r = i,
    s = n == null ? void 0 : n.errors;
  if (s != null) {
    let m = r.findIndex(
      (v) => v.route.id && (s == null ? void 0 : s[v.route.id]) !== void 0,
    );
    (Ei(
      m >= 0,
      `Could not find a matching route for errors on route IDs: ${Object.keys(s).join(",")}`,
    ),
      (r = r.slice(0, Math.min(r.length, m + 1))));
  }
  let o = !1,
    u = -1;
  if (t && n) {
    o = n.renderFallback;
    for (let m = 0; m < r.length; m++) {
      let v = r[m];
      if (
        ((v.route.HydrateFallback || v.route.hydrateFallbackElement) && (u = m),
        v.route.id)
      ) {
        let { loaderData: y, errors: b } = n,
          _ =
            v.route.loader &&
            !y.hasOwnProperty(v.route.id) &&
            (!b || b[v.route.id] === void 0);
        if (v.route.lazy || _) {
          (t.isStatic && (o = !0),
            u >= 0 ? (r = r.slice(0, u + 1)) : (r = [r[0]]));
          break;
        }
      }
    }
  }
  let h = t == null ? void 0 : t.onError,
    d =
      n && h
        ? (m, v) => {
            var y, b;
            h(m, {
              location: n.location,
              params:
                ((b = (y = n.matches) == null ? void 0 : y[0]) == null
                  ? void 0
                  : b.params) ?? {},
              unstable_pattern: iI(n.matches),
              errorInfo: v,
            });
          }
        : void 0;
  return r.reduceRight((m, v, y) => {
    let b,
      _ = !1,
      w = null,
      E = null;
    n &&
      ((b = s && v.route.id ? s[v.route.id] : void 0),
      (w = v.route.errorElement || gI),
      o &&
        (u < 0 && y === 0
          ? (gR(
              "route-fallback",
              !1,
              "No `HydrateFallback` element provided to render during initial hydration",
            ),
            (_ = !0),
            (E = null))
          : u === y &&
            ((_ = !0), (E = v.route.hydrateFallbackElement || null))));
    let T = e.concat(r.slice(0, y + 1)),
      C = () => {
        let R;
        return (
          b
            ? (R = w)
            : _
              ? (R = E)
              : v.route.Component
                ? (R = ie.createElement(v.route.Component, null))
                : v.route.element
                  ? (R = v.route.element)
                  : (R = m),
          ie.createElement(yI, {
            match: v,
            routeContext: { outlet: m, matches: T, isDataRoute: n != null },
            children: R,
          })
        );
      };
    return n && (v.route.ErrorBoundary || v.route.errorElement || y === 0)
      ? ie.createElement(mR, {
          location: n.location,
          revalidation: n.revalidation,
          component: w,
          error: b,
          children: C(),
          routeContext: { outlet: null, matches: T, isDataRoute: !0 },
          onError: d,
        })
      : C();
  }, null);
}
function KM(i) {
  return `${i} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
}
function bI(i) {
  let e = ie.useContext(Up);
  return (Ei(e, KM(i)), e);
}
function _I(i) {
  let e = ie.useContext(j1);
  return (Ei(e, KM(i)), e);
}
function SI(i) {
  let e = ie.useContext($l);
  return (Ei(e, KM(i)), e);
}
function QM(i) {
  let e = SI(i),
    t = e.matches[e.matches.length - 1];
  return (
    Ei(
      t.route.id,
      `${i} can only be used on routes that contain a unique "id"`,
    ),
    t.route.id
  );
}
function MI() {
  return QM("useRouteId");
}
function TI() {
  var n;
  let i = ie.useContext(ZM),
    e = _I("useRouteError"),
    t = QM("useRouteError");
  return i !== void 0 ? i : (n = e.errors) == null ? void 0 : n[t];
}
function EI() {
  let { router: i } = bI("useNavigate"),
    e = QM("useNavigate"),
    t = ie.useRef(!1);
  return (
    hR(() => {
      t.current = !0;
    }),
    ie.useCallback(
      async (r, s = {}) => {
        (Qo(t.current, fR),
          t.current &&
            (typeof r == "number"
              ? await i.navigate(r)
              : await i.navigate(r, { fromRouteId: e, ...s })));
      },
      [i, e],
    )
  );
}
var Ew = {};
function gR(i, e, t) {
  !e && !Ew[i] && ((Ew[i] = !0), Qo(!1, t));
}
ie.memo(wI);
function wI({ routes: i, future: e, state: t, isStatic: n, onError: r }) {
  return pR(i, void 0, { state: t, isStatic: n, onError: r });
}
function AI({ to: i, replace: e, state: t, relative: n }) {
  Ei(
    Pp(),
    "<Navigate> may be used only in the context of a <Router> component.",
  );
  let { static: r } = ie.useContext(za);
  Qo(
    !r,
    "<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change.",
  );
  let { matches: s } = ie.useContext($l),
    { pathname: o } = Qc(),
    u = dR(),
    h = H1(i, YM(s), o, n === "path"),
    d = JSON.stringify(h);
  return (
    ie.useEffect(() => {
      u(JSON.parse(d), { replace: e, state: t, relative: n });
    }, [u, d, n, e, t]),
    null
  );
}
function jo(i) {
  Ei(
    !1,
    "A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.",
  );
}
function CI({
  basename: i = "/",
  children: e = null,
  location: t,
  navigationType: n = "POP",
  navigator: r,
  static: s = !1,
  unstable_useTransitions: o,
}) {
  Ei(
    !Pp(),
    "You cannot render a <Router> inside another <Router>. You should never have more than one in your app.",
  );
  let u = i.replace(/^\/*/, "/"),
    h = ie.useMemo(
      () => ({
        basename: u,
        navigator: r,
        static: s,
        unstable_useTransitions: o,
        future: {},
      }),
      [u, r, s, o],
    );
  typeof t == "string" && (t = Np(t));
  let {
      pathname: d = "/",
      search: m = "",
      hash: v = "",
      state: y = null,
      key: b = "default",
      unstable_mask: _,
    } = t,
    w = ie.useMemo(() => {
      let E = Xc(d, u);
      return E == null
        ? null
        : {
            location: {
              pathname: E,
              search: m,
              hash: v,
              state: y,
              key: b,
              unstable_mask: _,
            },
            navigationType: n,
          };
    }, [u, d, m, v, y, b, n, _]);
  return (
    Qo(
      w != null,
      `<Router basename="${u}"> is not able to match the URL "${d}${m}${v}" because it does not start with the basename, so the <Router> won't render anything.`,
    ),
    w == null
      ? null
      : ie.createElement(
          za.Provider,
          { value: h },
          ie.createElement(T0.Provider, { children: e, value: w }),
        )
  );
}
function RI({ children: i, location: e }) {
  return pI(qS(i), e);
}
function qS(i, e = []) {
  let t = [];
  return (
    ie.Children.forEach(i, (n, r) => {
      if (!ie.isValidElement(n)) return;
      let s = [...e, r];
      if (n.type === ie.Fragment) {
        t.push.apply(t, qS(n.props.children, s));
        return;
      }
      (Ei(
        n.type === jo,
        `[${typeof n.type == "string" ? n.type : n.type.name}] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`,
      ),
        Ei(
          !n.props.index || !n.props.children,
          "An index route cannot have child routes.",
        ));
      let o = {
        id: n.props.id || s.join("-"),
        caseSensitive: n.props.caseSensitive,
        element: n.props.element,
        Component: n.props.Component,
        index: n.props.index,
        path: n.props.path,
        middleware: n.props.middleware,
        loader: n.props.loader,
        action: n.props.action,
        hydrateFallbackElement: n.props.hydrateFallbackElement,
        HydrateFallback: n.props.HydrateFallback,
        errorElement: n.props.errorElement,
        ErrorBoundary: n.props.ErrorBoundary,
        hasErrorBoundary:
          n.props.hasErrorBoundary === !0 ||
          n.props.ErrorBoundary != null ||
          n.props.errorElement != null,
        shouldRevalidate: n.props.shouldRevalidate,
        handle: n.props.handle,
        lazy: n.props.lazy,
      };
      (n.props.children && (o.children = qS(n.props.children, s)), t.push(o));
    }),
    t
  );
}
var bx = "get",
  _x = "application/x-www-form-urlencoded";
function W1(i) {
  return typeof HTMLElement < "u" && i instanceof HTMLElement;
}
function DI(i) {
  return W1(i) && i.tagName.toLowerCase() === "button";
}
function LI(i) {
  return W1(i) && i.tagName.toLowerCase() === "form";
}
function NI(i) {
  return W1(i) && i.tagName.toLowerCase() === "input";
}
function UI(i) {
  return !!(i.metaKey || i.altKey || i.ctrlKey || i.shiftKey);
}
function PI(i, e) {
  return i.button === 0 && (!e || e === "_self") && !UI(i);
}
var my = null;
function II() {
  if (my === null)
    try {
      (new FormData(document.createElement("form"), 0), (my = !1));
    } catch {
      my = !0;
    }
  return my;
}
var OI = new Set([
  "application/x-www-form-urlencoded",
  "multipart/form-data",
  "text/plain",
]);
function S_(i) {
  return i != null && !OI.has(i)
    ? (Qo(
        !1,
        `"${i}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${_x}"`,
      ),
      null)
    : i;
}
function FI(i, e) {
  let t, n, r, s, o;
  if (LI(i)) {
    let u = i.getAttribute("action");
    ((n = u ? Xc(u, e) : null),
      (t = i.getAttribute("method") || bx),
      (r = S_(i.getAttribute("enctype")) || _x),
      (s = new FormData(i)));
  } else if (DI(i) || (NI(i) && (i.type === "submit" || i.type === "image"))) {
    let u = i.form;
    if (u == null)
      throw new Error(
        'Cannot submit a <button> or <input type="submit"> without a <form>',
      );
    let h = i.getAttribute("formaction") || u.getAttribute("action");
    if (
      ((n = h ? Xc(h, e) : null),
      (t = i.getAttribute("formmethod") || u.getAttribute("method") || bx),
      (r =
        S_(i.getAttribute("formenctype")) ||
        S_(u.getAttribute("enctype")) ||
        _x),
      (s = new FormData(u, i)),
      !II())
    ) {
      let { name: d, type: m, value: v } = i;
      if (m === "image") {
        let y = d ? `${d}.` : "";
        (s.append(`${y}x`, "0"), s.append(`${y}y`, "0"));
      } else d && s.append(d, v);
    }
  } else {
    if (W1(i))
      throw new Error(
        'Cannot submit element that is not <form>, <button>, or <input type="submit|image">',
      );
    ((t = bx), (n = null), (r = _x), (o = i));
  }
  return (
    s && r === "text/plain" && ((o = s), (s = void 0)),
    { action: n, method: t.toLowerCase(), encType: r, formData: s, body: o }
  );
}
Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
function JM(i, e) {
  if (i === !1 || i === null || typeof i > "u") throw new Error(e);
}
function zI(i, e, t, n) {
  let r =
    typeof i == "string"
      ? new URL(
          i,
          typeof window > "u"
            ? "server://singlefetch/"
            : window.location.origin,
        )
      : i;
  return (
    t
      ? r.pathname.endsWith("/")
        ? (r.pathname = `${r.pathname}_.${n}`)
        : (r.pathname = `${r.pathname}.${n}`)
      : r.pathname === "/"
        ? (r.pathname = `_root.${n}`)
        : e && Xc(r.pathname, e) === "/"
          ? (r.pathname = `${e.replace(/\/$/, "")}/_root.${n}`)
          : (r.pathname = `${r.pathname.replace(/\/$/, "")}.${n}`),
    r
  );
}
async function BI(i, e) {
  if (i.id in e) return e[i.id];
  try {
    let t = await import(i.module);
    return ((e[i.id] = t), t);
  } catch (t) {
    return (
      console.error(
        `Error loading route module \`${i.module}\`, reloading page...`,
      ),
      console.error(t),
      window.__reactRouterContext && window.__reactRouterContext.isSpaMode,
      window.location.reload(),
      new Promise(() => {})
    );
  }
}
function kI(i) {
  return i == null
    ? !1
    : i.href == null
      ? i.rel === "preload" &&
        typeof i.imageSrcSet == "string" &&
        typeof i.imageSizes == "string"
      : typeof i.rel == "string" && typeof i.href == "string";
}
async function VI(i, e, t) {
  let n = await Promise.all(
    i.map(async (r) => {
      let s = e.routes[r.route.id];
      if (s) {
        let o = await BI(s, t);
        return o.links ? o.links() : [];
      }
      return [];
    }),
  );
  return WI(
    n
      .flat(1)
      .filter(kI)
      .filter((r) => r.rel === "stylesheet" || r.rel === "preload")
      .map((r) =>
        r.rel === "stylesheet"
          ? { ...r, rel: "prefetch", as: "style" }
          : { ...r, rel: "prefetch" },
      ),
  );
}
function ww(i, e, t, n, r, s) {
  let o = (h, d) => (t[d] ? h.route.id !== t[d].route.id : !0),
    u = (h, d) => {
      var m;
      return (
        t[d].pathname !== h.pathname ||
        (((m = t[d].route.path) == null ? void 0 : m.endsWith("*")) &&
          t[d].params["*"] !== h.params["*"])
      );
    };
  return s === "assets"
    ? e.filter((h, d) => o(h, d) || u(h, d))
    : s === "data"
      ? e.filter((h, d) => {
          var v;
          let m = n.routes[h.route.id];
          if (!m || !m.hasLoader) return !1;
          if (o(h, d) || u(h, d)) return !0;
          if (h.route.shouldRevalidate) {
            let y = h.route.shouldRevalidate({
              currentUrl: new URL(
                r.pathname + r.search + r.hash,
                window.origin,
              ),
              currentParams: ((v = t[0]) == null ? void 0 : v.params) || {},
              nextUrl: new URL(i, window.origin),
              nextParams: h.params,
              defaultShouldRevalidate: !0,
            });
            if (typeof y == "boolean") return y;
          }
          return !0;
        })
      : [];
}
function GI(i, e, { includeHydrateFallback: t } = {}) {
  return HI(
    i
      .map((n) => {
        let r = e.routes[n.route.id];
        if (!r) return [];
        let s = [r.module];
        return (
          r.clientActionModule && (s = s.concat(r.clientActionModule)),
          r.clientLoaderModule && (s = s.concat(r.clientLoaderModule)),
          t &&
            r.hydrateFallbackModule &&
            (s = s.concat(r.hydrateFallbackModule)),
          r.imports && (s = s.concat(r.imports)),
          s
        );
      })
      .flat(1),
  );
}
function HI(i) {
  return [...new Set(i)];
}
function jI(i) {
  let e = {},
    t = Object.keys(i).sort();
  for (let n of t) e[n] = i[n];
  return e;
}
function WI(i, e) {
  let t = new Set();
  return (
    new Set(e),
    i.reduce((n, r) => {
      let s = JSON.stringify(jI(r));
      return (t.has(s) || (t.add(s), n.push({ key: s, link: r })), n);
    }, [])
  );
}
function vR() {
  let i = ie.useContext(Up);
  return (
    JM(
      i,
      "You must render this element inside a <DataRouterContext.Provider> element",
    ),
    i
  );
}
function XI() {
  let i = ie.useContext(j1);
  return (
    JM(
      i,
      "You must render this element inside a <DataRouterStateContext.Provider> element",
    ),
    i
  );
}
var $M = ie.createContext(void 0);
$M.displayName = "FrameworkContext";
function yR() {
  let i = ie.useContext($M);
  return (
    JM(i, "You must render this element inside a <HydratedRouter> element"),
    i
  );
}
function qI(i, e) {
  let t = ie.useContext($M),
    [n, r] = ie.useState(!1),
    [s, o] = ie.useState(!1),
    {
      onFocus: u,
      onBlur: h,
      onMouseEnter: d,
      onMouseLeave: m,
      onTouchStart: v,
    } = e,
    y = ie.useRef(null);
  (ie.useEffect(() => {
    if ((i === "render" && o(!0), i === "viewport")) {
      let w = (T) => {
          T.forEach((C) => {
            o(C.isIntersecting);
          });
        },
        E = new IntersectionObserver(w, { threshold: 0.5 });
      return (
        y.current && E.observe(y.current),
        () => {
          E.disconnect();
        }
      );
    }
  }, [i]),
    ie.useEffect(() => {
      if (n) {
        let w = setTimeout(() => {
          o(!0);
        }, 100);
        return () => {
          clearTimeout(w);
        };
      }
    }, [n]));
  let b = () => {
      r(!0);
    },
    _ = () => {
      (r(!1), o(!1));
    };
  return t
    ? i !== "intent"
      ? [s, y, {}]
      : [
          s,
          y,
          {
            onFocus: hg(u, b),
            onBlur: hg(h, _),
            onMouseEnter: hg(d, b),
            onMouseLeave: hg(m, _),
            onTouchStart: hg(v, b),
          },
        ]
    : [!1, y, {}];
}
function hg(i, e) {
  return (t) => {
    (i && i(t), t.defaultPrevented || e(t));
  };
}
function YI({ page: i, ...e }) {
  let { router: t } = vR(),
    n = ie.useMemo(
      () => iR(t.routes, i, t.basename),
      [t.routes, i, t.basename],
    );
  return n ? ie.createElement(KI, { page: i, matches: n, ...e }) : null;
}
function ZI(i) {
  let { manifest: e, routeModules: t } = yR(),
    [n, r] = ie.useState([]);
  return (
    ie.useEffect(() => {
      let s = !1;
      return (
        VI(i, e, t).then((o) => {
          s || r(o);
        }),
        () => {
          s = !0;
        }
      );
    }, [i, e, t]),
    n
  );
}
function KI({ page: i, matches: e, ...t }) {
  let n = Qc(),
    { future: r, manifest: s, routeModules: o } = yR(),
    { basename: u } = vR(),
    { loaderData: h, matches: d } = XI(),
    m = ie.useMemo(() => ww(i, e, d, s, n, "data"), [i, e, d, s, n]),
    v = ie.useMemo(() => ww(i, e, d, s, n, "assets"), [i, e, d, s, n]),
    y = ie.useMemo(() => {
      if (i === n.pathname + n.search + n.hash) return [];
      let w = new Set(),
        E = !1;
      if (
        (e.forEach((C) => {
          var L;
          let R = s.routes[C.route.id];
          !R ||
            !R.hasLoader ||
            ((!m.some((I) => I.route.id === C.route.id) &&
              C.route.id in h &&
              (L = o[C.route.id]) != null &&
              L.shouldRevalidate) ||
            R.hasClientLoader
              ? (E = !0)
              : w.add(C.route.id));
        }),
        w.size === 0)
      )
        return [];
      let T = zI(i, u, r.unstable_trailingSlashAwareDataRequests, "data");
      return (
        E &&
          w.size > 0 &&
          T.searchParams.set(
            "_routes",
            e
              .filter((C) => w.has(C.route.id))
              .map((C) => C.route.id)
              .join(","),
          ),
        [T.pathname + T.search]
      );
    }, [u, r.unstable_trailingSlashAwareDataRequests, h, n, s, m, e, i, o]),
    b = ie.useMemo(() => GI(v, s), [v, s]),
    _ = ZI(v);
  return ie.createElement(
    ie.Fragment,
    null,
    y.map((w) =>
      ie.createElement("link", {
        key: w,
        rel: "prefetch",
        as: "fetch",
        href: w,
        ...t,
      }),
    ),
    b.map((w) =>
      ie.createElement("link", { key: w, rel: "modulepreload", href: w, ...t }),
    ),
    _.map(({ key: w, link: E }) =>
      ie.createElement("link", {
        key: w,
        nonce: t.nonce,
        ...E,
        crossOrigin: E.crossOrigin ?? t.crossOrigin,
      }),
    ),
  );
}
function QI(...i) {
  return (e) => {
    i.forEach((t) => {
      typeof t == "function" ? t(e) : t != null && (t.current = e);
    });
  };
}
var JI =
  typeof window < "u" &&
  typeof window.document < "u" &&
  typeof window.document.createElement < "u";
try {
  JI && (window.__reactRouterVersion = "7.13.1");
} catch {}
function $I({
  basename: i,
  children: e,
  unstable_useTransitions: t,
  window: n,
}) {
  let r = ie.useRef();
  r.current == null && (r.current = NP({ window: n, v5Compat: !0 }));
  let s = r.current,
    [o, u] = ie.useState({ action: s.action, location: s.location }),
    h = ie.useCallback(
      (d) => {
        t === !1 ? u(d) : ie.startTransition(() => u(d));
      },
      [t],
    );
  return (
    ie.useLayoutEffect(() => s.listen(h), [s, h]),
    ie.createElement(CI, {
      basename: i,
      children: e,
      location: o.location,
      navigationType: o.action,
      navigator: s,
      unstable_useTransitions: t,
    })
  );
}
var xR = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,
  Jo = ie.forwardRef(function (
    {
      onClick: e,
      discover: t = "render",
      prefetch: n = "none",
      relative: r,
      reloadDocument: s,
      replace: o,
      unstable_mask: u,
      state: h,
      target: d,
      to: m,
      preventScrollReset: v,
      viewTransition: y,
      unstable_defaultShouldRevalidate: b,
      ..._
    },
    w,
  ) {
    let {
        basename: E,
        navigator: T,
        unstable_useTransitions: C,
      } = ie.useContext(za),
      R = typeof m == "string" && xR.test(m),
      L = oR(m, E);
    m = L.to;
    let I = hI(m, { relative: r }),
      O = Qc(),
      B = null;
    if (u) {
      let ne = H1(u, [], O.unstable_mask ? O.unstable_mask.pathname : "/", !0);
      (E !== "/" &&
        (ne.pathname = ne.pathname === "/" ? E : Wl([E, ne.pathname])),
        (B = T.createHref(ne)));
    }
    let [N, F, j] = qI(n, _),
      q = iO(m, {
        replace: o,
        unstable_mask: u,
        state: h,
        target: d,
        preventScrollReset: v,
        relative: r,
        viewTransition: y,
        unstable_defaultShouldRevalidate: b,
        unstable_useTransitions: C,
      });
    function X(ne) {
      (e && e(ne), ne.defaultPrevented || q(ne));
    }
    let J = !(L.isExternal || s),
      ee = ie.createElement("a", {
        ..._,
        ...j,
        href: (J ? B : void 0) || L.absoluteURL || I,
        onClick: J ? X : e,
        ref: QI(w, F),
        target: d,
        "data-discover": !R && t === "render" ? "true" : void 0,
      });
    return N && !R
      ? ie.createElement(
          ie.Fragment,
          null,
          ee,
          ie.createElement(YI, { page: I }),
        )
      : ee;
  });
Jo.displayName = "Link";
var eO = ie.forwardRef(function (
  {
    "aria-current": e = "page",
    caseSensitive: t = !1,
    className: n = "",
    end: r = !1,
    style: s,
    to: o,
    viewTransition: u,
    children: h,
    ...d
  },
  m,
) {
  let v = E0(o, { relative: d.relative }),
    y = Qc(),
    b = ie.useContext(j1),
    { navigator: _, basename: w } = ie.useContext(za),
    E = b != null && lO(v) && u === !0,
    T = _.encodeLocation ? _.encodeLocation(v).pathname : v.pathname,
    C = y.pathname,
    R =
      b && b.navigation && b.navigation.location
        ? b.navigation.location.pathname
        : null;
  (t ||
    ((C = C.toLowerCase()),
    (R = R ? R.toLowerCase() : null),
    (T = T.toLowerCase())),
    R && w && (R = Xc(R, w) || R));
  const L = T !== "/" && T.endsWith("/") ? T.length - 1 : T.length;
  let I = C === T || (!r && C.startsWith(T) && C.charAt(L) === "/"),
    O =
      R != null &&
      (R === T || (!r && R.startsWith(T) && R.charAt(T.length) === "/")),
    B = { isActive: I, isPending: O, isTransitioning: E },
    N = I ? e : void 0,
    F;
  typeof n == "function"
    ? (F = n(B))
    : (F = [
        n,
        I ? "active" : null,
        O ? "pending" : null,
        E ? "transitioning" : null,
      ]
        .filter(Boolean)
        .join(" "));
  let j = typeof s == "function" ? s(B) : s;
  return ie.createElement(
    Jo,
    {
      ...d,
      "aria-current": N,
      className: F,
      ref: m,
      style: j,
      to: o,
      viewTransition: u,
    },
    typeof h == "function" ? h(B) : h,
  );
});
eO.displayName = "NavLink";
var tO = ie.forwardRef(
  (
    {
      discover: i = "render",
      fetcherKey: e,
      navigate: t,
      reloadDocument: n,
      replace: r,
      state: s,
      method: o = bx,
      action: u,
      onSubmit: h,
      relative: d,
      preventScrollReset: m,
      viewTransition: v,
      unstable_defaultShouldRevalidate: y,
      ...b
    },
    _,
  ) => {
    let { unstable_useTransitions: w } = ie.useContext(za),
      E = aO(),
      T = oO(u, { relative: d }),
      C = o.toLowerCase() === "get" ? "get" : "post",
      R = typeof u == "string" && xR.test(u),
      L = (I) => {
        if ((h && h(I), I.defaultPrevented)) return;
        I.preventDefault();
        let O = I.nativeEvent.submitter,
          B = (O == null ? void 0 : O.getAttribute("formmethod")) || o,
          N = () =>
            E(O || I.currentTarget, {
              fetcherKey: e,
              method: B,
              navigate: t,
              replace: r,
              state: s,
              relative: d,
              preventScrollReset: m,
              viewTransition: v,
              unstable_defaultShouldRevalidate: y,
            });
        w && t !== !1 ? ie.startTransition(() => N()) : N();
      };
    return ie.createElement("form", {
      ref: _,
      method: C,
      action: T,
      onSubmit: n ? h : L,
      ...b,
      "data-discover": !R && i === "render" ? "true" : void 0,
    });
  },
);
tO.displayName = "Form";
function nO(i) {
  return `${i} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
}
function bR(i) {
  let e = ie.useContext(Up);
  return (Ei(e, nO(i)), e);
}
function iO(
  i,
  {
    target: e,
    replace: t,
    unstable_mask: n,
    state: r,
    preventScrollReset: s,
    relative: o,
    viewTransition: u,
    unstable_defaultShouldRevalidate: h,
    unstable_useTransitions: d,
  } = {},
) {
  let m = dR(),
    v = Qc(),
    y = E0(i, { relative: o });
  return ie.useCallback(
    (b) => {
      if (PI(b, e)) {
        b.preventDefault();
        let _ = t !== void 0 ? t : Qg(v) === Qg(y),
          w = () =>
            m(i, {
              replace: _,
              unstable_mask: n,
              state: r,
              preventScrollReset: s,
              relative: o,
              viewTransition: u,
              unstable_defaultShouldRevalidate: h,
            });
        d ? ie.startTransition(() => w()) : w();
      }
    },
    [v, m, y, t, n, r, e, i, s, o, u, h, d],
  );
}
var rO = 0,
  sO = () => `__${String(++rO)}__`;
function aO() {
  let { router: i } = bR("useSubmit"),
    { basename: e } = ie.useContext(za),
    t = MI(),
    n = i.fetch,
    r = i.navigate;
  return ie.useCallback(
    async (s, o = {}) => {
      let { action: u, method: h, encType: d, formData: m, body: v } = FI(s, e);
      if (o.navigate === !1) {
        let y = o.fetcherKey || sO();
        await n(y, t, o.action || u, {
          unstable_defaultShouldRevalidate: o.unstable_defaultShouldRevalidate,
          preventScrollReset: o.preventScrollReset,
          formData: m,
          body: v,
          formMethod: o.method || h,
          formEncType: o.encType || d,
          flushSync: o.flushSync,
        });
      } else
        await r(o.action || u, {
          unstable_defaultShouldRevalidate: o.unstable_defaultShouldRevalidate,
          preventScrollReset: o.preventScrollReset,
          formData: m,
          body: v,
          formMethod: o.method || h,
          formEncType: o.encType || d,
          replace: o.replace,
          state: o.state,
          fromRouteId: t,
          flushSync: o.flushSync,
          viewTransition: o.viewTransition,
        });
    },
    [n, r, e, t],
  );
}
function oO(i, { relative: e } = {}) {
  let { basename: t } = ie.useContext(za),
    n = ie.useContext($l);
  Ei(n, "useFormAction must be used inside a RouteContext");
  let [r] = n.matches.slice(-1),
    s = { ...E0(i || ".", { relative: e }) },
    o = Qc();
  if (i == null) {
    s.search = o.search;
    let u = new URLSearchParams(s.search),
      h = u.getAll("index");
    if (h.some((m) => m === "")) {
      (u.delete("index"),
        h.filter((v) => v).forEach((v) => u.append("index", v)));
      let m = u.toString();
      s.search = m ? `?${m}` : "";
    }
  }
  return (
    (!i || i === ".") &&
      r.route.index &&
      (s.search = s.search ? s.search.replace(/^\?/, "?index&") : "?index"),
    t !== "/" && (s.pathname = s.pathname === "/" ? t : Wl([t, s.pathname])),
    Qg(s)
  );
}
function lO(i, { relative: e } = {}) {
  let t = ie.useContext(cR);
  Ei(
    t != null,
    "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?",
  );
  let { basename: n } = bR("useViewTransitionState"),
    r = E0(i, { relative: e });
  if (!t.isTransitioning) return !1;
  let s = Xc(t.currentLocation.pathname, n) || t.currentLocation.pathname,
    o = Xc(t.nextLocation.pathname, n) || t.nextLocation.pathname;
  return Px(r.pathname, o) != null || Px(r.pathname, s) != null;
}
const _R = ie.createContext({});
function cO(i) {
  const e = ie.useRef(null);
  return (e.current === null && (e.current = i()), e.current);
}
const SR = typeof window < "u",
  uO = SR ? ie.useLayoutEffect : ie.useEffect,
  eT = ie.createContext(null);
function tT(i, e) {
  i.indexOf(e) === -1 && i.push(e);
}
function Ix(i, e) {
  const t = i.indexOf(e);
  t > -1 && i.splice(t, 1);
}
const Yl = (i, e, t) => (t > e ? e : t < i ? i : t);
let nT = () => {};
const qc = {},
  MR = (i) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(i);
function TR(i) {
  return typeof i == "object" && i !== null;
}
const ER = (i) => /^0[^.\s]+$/u.test(i);
function wR(i) {
  let e;
  return () => (e === void 0 && (e = i()), e);
}
const yo = (i) => i,
  fO = (i, e) => (t) => e(i(t)),
  w0 = (...i) => i.reduce(fO),
  Jg = (i, e, t) => {
    const n = e - i;
    return n === 0 ? 1 : (t - i) / n;
  };
class iT {
  constructor() {
    this.subscriptions = [];
  }
  add(e) {
    return (tT(this.subscriptions, e), () => Ix(this.subscriptions, e));
  }
  notify(e, t, n) {
    const r = this.subscriptions.length;
    if (r)
      if (r === 1) this.subscriptions[0](e, t, n);
      else
        for (let s = 0; s < r; s++) {
          const o = this.subscriptions[s];
          o && o(e, t, n);
        }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
const Yo = (i) => i * 1e3,
  vo = (i) => i / 1e3;
function AR(i, e) {
  return e ? i * (1e3 / e) : 0;
}
const CR = (i, e, t) =>
    (((1 - 3 * t + 3 * e) * i + (3 * t - 6 * e)) * i + 3 * e) * i,
  hO = 1e-7,
  dO = 12;
function pO(i, e, t, n, r) {
  let s,
    o,
    u = 0;
  do ((o = e + (t - e) / 2), (s = CR(o, n, r) - i), s > 0 ? (t = o) : (e = o));
  while (Math.abs(s) > hO && ++u < dO);
  return o;
}
function A0(i, e, t, n) {
  if (i === e && t === n) return yo;
  const r = (s) => pO(s, 0, 1, i, t);
  return (s) => (s === 0 || s === 1 ? s : CR(r(s), e, n));
}
const RR = (i) => (e) => (e <= 0.5 ? i(2 * e) / 2 : (2 - i(2 * (1 - e))) / 2),
  DR = (i) => (e) => 1 - i(1 - e),
  LR = A0(0.33, 1.53, 0.69, 0.99),
  rT = DR(LR),
  NR = RR(rT),
  UR = (i) =>
    (i *= 2) < 1 ? 0.5 * rT(i) : 0.5 * (2 - Math.pow(2, -10 * (i - 1))),
  sT = (i) => 1 - Math.sin(Math.acos(i)),
  PR = DR(sT),
  IR = RR(sT),
  mO = A0(0.42, 0, 1, 1),
  gO = A0(0, 0, 0.58, 1),
  OR = A0(0.42, 0, 0.58, 1),
  vO = (i) => Array.isArray(i) && typeof i[0] != "number",
  FR = (i) => Array.isArray(i) && typeof i[0] == "number",
  yO = {
    linear: yo,
    easeIn: mO,
    easeInOut: OR,
    easeOut: gO,
    circIn: sT,
    circInOut: IR,
    circOut: PR,
    backIn: rT,
    backInOut: NR,
    backOut: LR,
    anticipate: UR,
  },
  xO = (i) => typeof i == "string",
  Aw = (i) => {
    if (FR(i)) {
      nT(i.length === 4);
      const [e, t, n, r] = i;
      return A0(e, t, n, r);
    } else if (xO(i)) return yO[i];
    return i;
  },
  gy = [
    "setup",
    "read",
    "resolveKeyframes",
    "preUpdate",
    "update",
    "preRender",
    "render",
    "postRender",
  ];
function bO(i, e) {
  let t = new Set(),
    n = new Set(),
    r = !1,
    s = !1;
  const o = new WeakSet();
  let u = { delta: 0, timestamp: 0, isProcessing: !1 };
  function h(m) {
    (o.has(m) && (d.schedule(m), i()), m(u));
  }
  const d = {
    schedule: (m, v = !1, y = !1) => {
      const _ = y && r ? t : n;
      return (v && o.add(m), _.has(m) || _.add(m), m);
    },
    cancel: (m) => {
      (n.delete(m), o.delete(m));
    },
    process: (m) => {
      if (((u = m), r)) {
        s = !0;
        return;
      }
      ((r = !0),
        ([t, n] = [n, t]),
        t.forEach(h),
        t.clear(),
        (r = !1),
        s && ((s = !1), d.process(m)));
    },
  };
  return d;
}
const _O = 40;
function zR(i, e) {
  let t = !1,
    n = !0;
  const r = { delta: 0, timestamp: 0, isProcessing: !1 },
    s = () => (t = !0),
    o = gy.reduce((R, L) => ((R[L] = bO(s)), R), {}),
    {
      setup: u,
      read: h,
      resolveKeyframes: d,
      preUpdate: m,
      update: v,
      preRender: y,
      render: b,
      postRender: _,
    } = o,
    w = () => {
      const R = qc.useManualTiming ? r.timestamp : performance.now();
      ((t = !1),
        qc.useManualTiming ||
          (r.delta = n ? 1e3 / 60 : Math.max(Math.min(R - r.timestamp, _O), 1)),
        (r.timestamp = R),
        (r.isProcessing = !0),
        u.process(r),
        h.process(r),
        d.process(r),
        m.process(r),
        v.process(r),
        y.process(r),
        b.process(r),
        _.process(r),
        (r.isProcessing = !1),
        t && e && ((n = !1), i(w)));
    },
    E = () => {
      ((t = !0), (n = !0), r.isProcessing || i(w));
    };
  return {
    schedule: gy.reduce((R, L) => {
      const I = o[L];
      return (
        (R[L] = (O, B = !1, N = !1) => (t || E(), I.schedule(O, B, N))),
        R
      );
    }, {}),
    cancel: (R) => {
      for (let L = 0; L < gy.length; L++) o[gy[L]].cancel(R);
    },
    state: r,
    steps: o,
  };
}
const {
  schedule: ui,
  cancel: nf,
  state: Qr,
  steps: M_,
} = zR(typeof requestAnimationFrame < "u" ? requestAnimationFrame : yo, !0);
let Sx;
function SO() {
  Sx = void 0;
}
const Vs = {
    now: () => (
      Sx === void 0 &&
        Vs.set(
          Qr.isProcessing || qc.useManualTiming
            ? Qr.timestamp
            : performance.now(),
        ),
      Sx
    ),
    set: (i) => {
      ((Sx = i), queueMicrotask(SO));
    },
  },
  BR = (i) => (e) => typeof e == "string" && e.startsWith(i),
  kR = BR("--"),
  MO = BR("var(--"),
  aT = (i) => (MO(i) ? TO.test(i.split("/*")[0].trim()) : !1),
  TO =
    /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu;
function Cw(i) {
  return typeof i != "string" ? !1 : i.split("/*")[0].includes("var(--");
}
const Ip = {
    test: (i) => typeof i == "number",
    parse: parseFloat,
    transform: (i) => i,
  },
  $g = { ...Ip, transform: (i) => Yl(0, 1, i) },
  vy = { ...Ip, default: 1 },
  Ug = (i) => Math.round(i * 1e5) / 1e5,
  oT = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
function EO(i) {
  return i == null;
}
const wO =
    /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu,
  lT = (i, e) => (t) =>
    !!(
      (typeof t == "string" && wO.test(t) && t.startsWith(i)) ||
      (e && !EO(t) && Object.prototype.hasOwnProperty.call(t, e))
    ),
  VR = (i, e, t) => (n) => {
    if (typeof n != "string") return n;
    const [r, s, o, u] = n.match(oT);
    return {
      [i]: parseFloat(r),
      [e]: parseFloat(s),
      [t]: parseFloat(o),
      alpha: u !== void 0 ? parseFloat(u) : 1,
    };
  },
  AO = (i) => Yl(0, 255, i),
  T_ = { ...Ip, transform: (i) => Math.round(AO(i)) },
  yh = {
    test: lT("rgb", "red"),
    parse: VR("red", "green", "blue"),
    transform: ({ red: i, green: e, blue: t, alpha: n = 1 }) =>
      "rgba(" +
      T_.transform(i) +
      ", " +
      T_.transform(e) +
      ", " +
      T_.transform(t) +
      ", " +
      Ug($g.transform(n)) +
      ")",
  };
function CO(i) {
  let e = "",
    t = "",
    n = "",
    r = "";
  return (
    i.length > 5
      ? ((e = i.substring(1, 3)),
        (t = i.substring(3, 5)),
        (n = i.substring(5, 7)),
        (r = i.substring(7, 9)))
      : ((e = i.substring(1, 2)),
        (t = i.substring(2, 3)),
        (n = i.substring(3, 4)),
        (r = i.substring(4, 5)),
        (e += e),
        (t += t),
        (n += n),
        (r += r)),
    {
      red: parseInt(e, 16),
      green: parseInt(t, 16),
      blue: parseInt(n, 16),
      alpha: r ? parseInt(r, 16) / 255 : 1,
    }
  );
}
const YS = { test: lT("#"), parse: CO, transform: yh.transform },
  C0 = (i) => ({
    test: (e) =>
      typeof e == "string" && e.endsWith(i) && e.split(" ").length === 1,
    parse: parseFloat,
    transform: (e) => `${e}${i}`,
  }),
  Yu = C0("deg"),
  Xl = C0("%"),
  Ut = C0("px"),
  RO = C0("vh"),
  DO = C0("vw"),
  Rw = {
    ...Xl,
    parse: (i) => Xl.parse(i) / 100,
    transform: (i) => Xl.transform(i * 100),
  },
  hp = {
    test: lT("hsl", "hue"),
    parse: VR("hue", "saturation", "lightness"),
    transform: ({ hue: i, saturation: e, lightness: t, alpha: n = 1 }) =>
      "hsla(" +
      Math.round(i) +
      ", " +
      Xl.transform(Ug(e)) +
      ", " +
      Xl.transform(Ug(t)) +
      ", " +
      Ug($g.transform(n)) +
      ")",
  },
  pr = {
    test: (i) => yh.test(i) || YS.test(i) || hp.test(i),
    parse: (i) =>
      yh.test(i) ? yh.parse(i) : hp.test(i) ? hp.parse(i) : YS.parse(i),
    transform: (i) =>
      typeof i == "string"
        ? i
        : i.hasOwnProperty("red")
          ? yh.transform(i)
          : hp.transform(i),
    getAnimatableNone: (i) => {
      const e = pr.parse(i);
      return ((e.alpha = 0), pr.transform(e));
    },
  },
  LO =
    /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
function NO(i) {
  var e, t;
  return (
    isNaN(i) &&
    typeof i == "string" &&
    (((e = i.match(oT)) == null ? void 0 : e.length) || 0) +
      (((t = i.match(LO)) == null ? void 0 : t.length) || 0) >
      0
  );
}
const GR = "number",
  HR = "color",
  UO = "var",
  PO = "var(",
  Dw = "${}",
  IO =
    /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function e0(i) {
  const e = i.toString(),
    t = [],
    n = { color: [], number: [], var: [] },
    r = [];
  let s = 0;
  const u = e
    .replace(
      IO,
      (h) => (
        pr.test(h)
          ? (n.color.push(s), r.push(HR), t.push(pr.parse(h)))
          : h.startsWith(PO)
            ? (n.var.push(s), r.push(UO), t.push(h))
            : (n.number.push(s), r.push(GR), t.push(parseFloat(h))),
        ++s,
        Dw
      ),
    )
    .split(Dw);
  return { values: t, split: u, indexes: n, types: r };
}
function jR(i) {
  return e0(i).values;
}
function WR(i) {
  const { split: e, types: t } = e0(i),
    n = e.length;
  return (r) => {
    let s = "";
    for (let o = 0; o < n; o++)
      if (((s += e[o]), r[o] !== void 0)) {
        const u = t[o];
        u === GR
          ? (s += Ug(r[o]))
          : u === HR
            ? (s += pr.transform(r[o]))
            : (s += r[o]);
      }
    return s;
  };
}
const OO = (i) =>
  typeof i == "number" ? 0 : pr.test(i) ? pr.getAnimatableNone(i) : i;
function FO(i) {
  const e = jR(i);
  return WR(i)(e.map(OO));
}
const Zo = {
  test: NO,
  parse: jR,
  createTransformer: WR,
  getAnimatableNone: FO,
};
function E_(i, e, t) {
  return (
    t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6
      ? i + (e - i) * 6 * t
      : t < 1 / 2
        ? e
        : t < 2 / 3
          ? i + (e - i) * (2 / 3 - t) * 6
          : i
  );
}
function zO({ hue: i, saturation: e, lightness: t, alpha: n }) {
  ((i /= 360), (e /= 100), (t /= 100));
  let r = 0,
    s = 0,
    o = 0;
  if (!e) r = s = o = t;
  else {
    const u = t < 0.5 ? t * (1 + e) : t + e - t * e,
      h = 2 * t - u;
    ((r = E_(h, u, i + 1 / 3)), (s = E_(h, u, i)), (o = E_(h, u, i - 1 / 3)));
  }
  return {
    red: Math.round(r * 255),
    green: Math.round(s * 255),
    blue: Math.round(o * 255),
    alpha: n,
  };
}
function Ox(i, e) {
  return (t) => (t > 0 ? e : i);
}
const Ii = (i, e, t) => i + (e - i) * t,
  w_ = (i, e, t) => {
    const n = i * i,
      r = t * (e * e - n) + n;
    return r < 0 ? 0 : Math.sqrt(r);
  },
  BO = [YS, yh, hp],
  kO = (i) => BO.find((e) => e.test(i));
function Lw(i) {
  const e = kO(i);
  if (!e) return !1;
  let t = e.parse(i);
  return (e === hp && (t = zO(t)), t);
}
const Nw = (i, e) => {
    const t = Lw(i),
      n = Lw(e);
    if (!t || !n) return Ox(i, e);
    const r = { ...t };
    return (s) => (
      (r.red = w_(t.red, n.red, s)),
      (r.green = w_(t.green, n.green, s)),
      (r.blue = w_(t.blue, n.blue, s)),
      (r.alpha = Ii(t.alpha, n.alpha, s)),
      yh.transform(r)
    );
  },
  ZS = new Set(["none", "hidden"]);
function VO(i, e) {
  return ZS.has(i) ? (t) => (t <= 0 ? i : e) : (t) => (t >= 1 ? e : i);
}
function GO(i, e) {
  return (t) => Ii(i, e, t);
}
function cT(i) {
  return typeof i == "number"
    ? GO
    : typeof i == "string"
      ? aT(i)
        ? Ox
        : pr.test(i)
          ? Nw
          : WO
      : Array.isArray(i)
        ? XR
        : typeof i == "object"
          ? pr.test(i)
            ? Nw
            : HO
          : Ox;
}
function XR(i, e) {
  const t = [...i],
    n = t.length,
    r = i.map((s, o) => cT(s)(s, e[o]));
  return (s) => {
    for (let o = 0; o < n; o++) t[o] = r[o](s);
    return t;
  };
}
function HO(i, e) {
  const t = { ...i, ...e },
    n = {};
  for (const r in t)
    i[r] !== void 0 && e[r] !== void 0 && (n[r] = cT(i[r])(i[r], e[r]));
  return (r) => {
    for (const s in n) t[s] = n[s](r);
    return t;
  };
}
function jO(i, e) {
  const t = [],
    n = { color: 0, var: 0, number: 0 };
  for (let r = 0; r < e.values.length; r++) {
    const s = e.types[r],
      o = i.indexes[s][n[s]],
      u = i.values[o] ?? 0;
    ((t[r] = u), n[s]++);
  }
  return t;
}
const WO = (i, e) => {
  const t = Zo.createTransformer(e),
    n = e0(i),
    r = e0(e);
  return n.indexes.var.length === r.indexes.var.length &&
    n.indexes.color.length === r.indexes.color.length &&
    n.indexes.number.length >= r.indexes.number.length
    ? (ZS.has(i) && !r.values.length) || (ZS.has(e) && !n.values.length)
      ? VO(i, e)
      : w0(XR(jO(n, r), r.values), t)
    : Ox(i, e);
};
function qR(i, e, t) {
  return typeof i == "number" && typeof e == "number" && typeof t == "number"
    ? Ii(i, e, t)
    : cT(i)(i, e);
}
const XO = (i) => {
    const e = ({ timestamp: t }) => i(t);
    return {
      start: (t = !0) => ui.update(e, t),
      stop: () => nf(e),
      now: () => (Qr.isProcessing ? Qr.timestamp : Vs.now()),
    };
  },
  YR = (i, e, t = 10) => {
    let n = "";
    const r = Math.max(Math.round(e / t), 2);
    for (let s = 0; s < r; s++)
      n += Math.round(i(s / (r - 1)) * 1e4) / 1e4 + ", ";
    return `linear(${n.substring(0, n.length - 2)})`;
  },
  Fx = 2e4;
function uT(i) {
  let e = 0;
  const t = 50;
  let n = i.next(e);
  for (; !n.done && e < Fx; ) ((e += t), (n = i.next(e)));
  return e >= Fx ? 1 / 0 : e;
}
function qO(i, e = 100, t) {
  const n = t({ ...i, keyframes: [0, e] }),
    r = Math.min(uT(n), Fx);
  return {
    type: "keyframes",
    ease: (s) => n.next(r * s).value / e,
    duration: vo(r),
  };
}
const YO = 5;
function ZR(i, e, t) {
  const n = Math.max(e - YO, 0);
  return AR(t - i(n), e - n);
}
const Yi = {
    stiffness: 100,
    damping: 10,
    mass: 1,
    velocity: 0,
    duration: 800,
    bounce: 0.3,
    visualDuration: 0.3,
    restSpeed: { granular: 0.01, default: 2 },
    restDelta: { granular: 0.005, default: 0.5 },
    minDuration: 0.01,
    maxDuration: 10,
    minDamping: 0.05,
    maxDamping: 1,
  },
  A_ = 0.001;
function ZO({
  duration: i = Yi.duration,
  bounce: e = Yi.bounce,
  velocity: t = Yi.velocity,
  mass: n = Yi.mass,
}) {
  let r,
    s,
    o = 1 - e;
  ((o = Yl(Yi.minDamping, Yi.maxDamping, o)),
    (i = Yl(Yi.minDuration, Yi.maxDuration, vo(i))),
    o < 1
      ? ((r = (d) => {
          const m = d * o,
            v = m * i,
            y = m - t,
            b = KS(d, o),
            _ = Math.exp(-v);
          return A_ - (y / b) * _;
        }),
        (s = (d) => {
          const v = d * o * i,
            y = v * t + t,
            b = Math.pow(o, 2) * Math.pow(d, 2) * i,
            _ = Math.exp(-v),
            w = KS(Math.pow(d, 2), o);
          return ((-r(d) + A_ > 0 ? -1 : 1) * ((y - b) * _)) / w;
        }))
      : ((r = (d) => {
          const m = Math.exp(-d * i),
            v = (d - t) * i + 1;
          return -A_ + m * v;
        }),
        (s = (d) => {
          const m = Math.exp(-d * i),
            v = (t - d) * (i * i);
          return m * v;
        })));
  const u = 5 / i,
    h = QO(r, s, u);
  if (((i = Yo(i)), isNaN(h)))
    return { stiffness: Yi.stiffness, damping: Yi.damping, duration: i };
  {
    const d = Math.pow(h, 2) * n;
    return { stiffness: d, damping: o * 2 * Math.sqrt(n * d), duration: i };
  }
}
const KO = 12;
function QO(i, e, t) {
  let n = t;
  for (let r = 1; r < KO; r++) n = n - i(n) / e(n);
  return n;
}
function KS(i, e) {
  return i * Math.sqrt(1 - e * e);
}
const JO = ["duration", "bounce"],
  $O = ["stiffness", "damping", "mass"];
function Uw(i, e) {
  return e.some((t) => i[t] !== void 0);
}
function e4(i) {
  let e = {
    velocity: Yi.velocity,
    stiffness: Yi.stiffness,
    damping: Yi.damping,
    mass: Yi.mass,
    isResolvedFromDuration: !1,
    ...i,
  };
  if (!Uw(i, $O) && Uw(i, JO))
    if (((e.velocity = 0), i.visualDuration)) {
      const t = i.visualDuration,
        n = (2 * Math.PI) / (t * 1.2),
        r = n * n,
        s = 2 * Yl(0.05, 1, 1 - (i.bounce || 0)) * Math.sqrt(r);
      e = { ...e, mass: Yi.mass, stiffness: r, damping: s };
    } else {
      const t = ZO({ ...i, velocity: 0 });
      ((e = { ...e, ...t, mass: Yi.mass }), (e.isResolvedFromDuration = !0));
    }
  return e;
}
function zx(i = Yi.visualDuration, e = Yi.bounce) {
  const t =
    typeof i != "object"
      ? { visualDuration: i, keyframes: [0, 1], bounce: e }
      : i;
  let { restSpeed: n, restDelta: r } = t;
  const s = t.keyframes[0],
    o = t.keyframes[t.keyframes.length - 1],
    u = { done: !1, value: s },
    {
      stiffness: h,
      damping: d,
      mass: m,
      duration: v,
      velocity: y,
      isResolvedFromDuration: b,
    } = e4({ ...t, velocity: -vo(t.velocity || 0) }),
    _ = y || 0,
    w = d / (2 * Math.sqrt(h * m)),
    E = o - s,
    T = vo(Math.sqrt(h / m)),
    C = Math.abs(E) < 5;
  (n || (n = C ? Yi.restSpeed.granular : Yi.restSpeed.default),
    r || (r = C ? Yi.restDelta.granular : Yi.restDelta.default));
  let R;
  if (w < 1) {
    const I = KS(T, w);
    R = (O) => {
      const B = Math.exp(-w * T * O);
      return (
        o - B * (((_ + w * T * E) / I) * Math.sin(I * O) + E * Math.cos(I * O))
      );
    };
  } else if (w === 1) R = (I) => o - Math.exp(-T * I) * (E + (_ + T * E) * I);
  else {
    const I = T * Math.sqrt(w * w - 1);
    R = (O) => {
      const B = Math.exp(-w * T * O),
        N = Math.min(I * O, 300);
      return (
        o - (B * ((_ + w * T * E) * Math.sinh(N) + I * E * Math.cosh(N))) / I
      );
    };
  }
  const L = {
    calculatedDuration: (b && v) || null,
    next: (I) => {
      const O = R(I);
      if (b) u.done = I >= v;
      else {
        let B = I === 0 ? _ : 0;
        w < 1 && (B = I === 0 ? Yo(_) : ZR(R, I, O));
        const N = Math.abs(B) <= n,
          F = Math.abs(o - O) <= r;
        u.done = N && F;
      }
      return ((u.value = u.done ? o : O), u);
    },
    toString: () => {
      const I = Math.min(uT(L), Fx),
        O = YR((B) => L.next(I * B).value, I, 30);
      return I + "ms " + O;
    },
    toTransition: () => {},
  };
  return L;
}
zx.applyToOptions = (i) => {
  const e = qO(i, 100, zx);
  return (
    (i.ease = e.ease),
    (i.duration = Yo(e.duration)),
    (i.type = "keyframes"),
    i
  );
};
function QS({
  keyframes: i,
  velocity: e = 0,
  power: t = 0.8,
  timeConstant: n = 325,
  bounceDamping: r = 10,
  bounceStiffness: s = 500,
  modifyTarget: o,
  min: u,
  max: h,
  restDelta: d = 0.5,
  restSpeed: m,
}) {
  const v = i[0],
    y = { done: !1, value: v },
    b = (N) => (u !== void 0 && N < u) || (h !== void 0 && N > h),
    _ = (N) =>
      u === void 0
        ? h
        : h === void 0 || Math.abs(u - N) < Math.abs(h - N)
          ? u
          : h;
  let w = t * e;
  const E = v + w,
    T = o === void 0 ? E : o(E);
  T !== E && (w = T - v);
  const C = (N) => -w * Math.exp(-N / n),
    R = (N) => T + C(N),
    L = (N) => {
      const F = C(N),
        j = R(N);
      ((y.done = Math.abs(F) <= d), (y.value = y.done ? T : j));
    };
  let I, O;
  const B = (N) => {
    b(y.value) &&
      ((I = N),
      (O = zx({
        keyframes: [y.value, _(y.value)],
        velocity: ZR(R, N, y.value),
        damping: r,
        stiffness: s,
        restDelta: d,
        restSpeed: m,
      })));
  };
  return (
    B(0),
    {
      calculatedDuration: null,
      next: (N) => {
        let F = !1;
        return (
          !O && I === void 0 && ((F = !0), L(N), B(N)),
          I !== void 0 && N >= I ? O.next(N - I) : (!F && L(N), y)
        );
      },
    }
  );
}
function t4(i, e, t) {
  const n = [],
    r = t || qc.mix || qR,
    s = i.length - 1;
  for (let o = 0; o < s; o++) {
    let u = r(i[o], i[o + 1]);
    if (e) {
      const h = Array.isArray(e) ? e[o] || yo : e;
      u = w0(h, u);
    }
    n.push(u);
  }
  return n;
}
function n4(i, e, { clamp: t = !0, ease: n, mixer: r } = {}) {
  const s = i.length;
  if ((nT(s === e.length), s === 1)) return () => e[0];
  if (s === 2 && e[0] === e[1]) return () => e[1];
  const o = i[0] === i[1];
  i[0] > i[s - 1] && ((i = [...i].reverse()), (e = [...e].reverse()));
  const u = t4(e, n, r),
    h = u.length,
    d = (m) => {
      if (o && m < i[0]) return e[0];
      let v = 0;
      if (h > 1) for (; v < i.length - 2 && !(m < i[v + 1]); v++);
      const y = Jg(i[v], i[v + 1], m);
      return u[v](y);
    };
  return t ? (m) => d(Yl(i[0], i[s - 1], m)) : d;
}
function i4(i, e) {
  const t = i[i.length - 1];
  for (let n = 1; n <= e; n++) {
    const r = Jg(0, e, n);
    i.push(Ii(t, 1, r));
  }
}
function r4(i) {
  const e = [0];
  return (i4(e, i.length - 1), e);
}
function s4(i, e) {
  return i.map((t) => t * e);
}
function a4(i, e) {
  return i.map(() => e || OR).splice(0, i.length - 1);
}
function Pg({
  duration: i = 300,
  keyframes: e,
  times: t,
  ease: n = "easeInOut",
}) {
  const r = vO(n) ? n.map(Aw) : Aw(n),
    s = { done: !1, value: e[0] },
    o = s4(t && t.length === e.length ? t : r4(e), i),
    u = n4(o, e, { ease: Array.isArray(r) ? r : a4(e, r) });
  return {
    calculatedDuration: i,
    next: (h) => ((s.value = u(h)), (s.done = h >= i), s),
  };
}
const o4 = (i) => i !== null;
function fT(i, { repeat: e, repeatType: t = "loop" }, n, r = 1) {
  const s = i.filter(o4),
    u = r < 0 || (e && t !== "loop" && e % 2 === 1) ? 0 : s.length - 1;
  return !u || n === void 0 ? s[u] : n;
}
const l4 = { decay: QS, inertia: QS, tween: Pg, keyframes: Pg, spring: zx };
function KR(i) {
  typeof i.type == "string" && (i.type = l4[i.type]);
}
class hT {
  constructor() {
    this.updateFinished();
  }
  get finished() {
    return this._finished;
  }
  updateFinished() {
    this._finished = new Promise((e) => {
      this.resolve = e;
    });
  }
  notifyFinished() {
    this.resolve();
  }
  then(e, t) {
    return this.finished.then(e, t);
  }
}
const c4 = (i) => i / 100;
class dT extends hT {
  constructor(e) {
    (super(),
      (this.state = "idle"),
      (this.startTime = null),
      (this.isStopped = !1),
      (this.currentTime = 0),
      (this.holdTime = null),
      (this.playbackSpeed = 1),
      (this.stop = () => {
        var n, r;
        const { motionValue: t } = this.options;
        (t && t.updatedAt !== Vs.now() && this.tick(Vs.now()),
          (this.isStopped = !0),
          this.state !== "idle" &&
            (this.teardown(),
            (r = (n = this.options).onStop) == null || r.call(n)));
      }),
      (this.options = e),
      this.initAnimation(),
      this.play(),
      e.autoplay === !1 && this.pause());
  }
  initAnimation() {
    const { options: e } = this;
    KR(e);
    const {
      type: t = Pg,
      repeat: n = 0,
      repeatDelay: r = 0,
      repeatType: s,
      velocity: o = 0,
    } = e;
    let { keyframes: u } = e;
    const h = t || Pg;
    h !== Pg &&
      typeof u[0] != "number" &&
      ((this.mixKeyframes = w0(c4, qR(u[0], u[1]))), (u = [0, 100]));
    const d = h({ ...e, keyframes: u });
    (s === "mirror" &&
      (this.mirroredGenerator = h({
        ...e,
        keyframes: [...u].reverse(),
        velocity: -o,
      })),
      d.calculatedDuration === null && (d.calculatedDuration = uT(d)));
    const { calculatedDuration: m } = d;
    ((this.calculatedDuration = m),
      (this.resolvedDuration = m + r),
      (this.totalDuration = this.resolvedDuration * (n + 1) - r),
      (this.generator = d));
  }
  updateTime(e) {
    const t = Math.round(e - this.startTime) * this.playbackSpeed;
    this.holdTime !== null
      ? (this.currentTime = this.holdTime)
      : (this.currentTime = t);
  }
  tick(e, t = !1) {
    const {
      generator: n,
      totalDuration: r,
      mixKeyframes: s,
      mirroredGenerator: o,
      resolvedDuration: u,
      calculatedDuration: h,
    } = this;
    if (this.startTime === null) return n.next(0);
    const {
      delay: d = 0,
      keyframes: m,
      repeat: v,
      repeatType: y,
      repeatDelay: b,
      type: _,
      onUpdate: w,
      finalKeyframe: E,
    } = this.options;
    (this.speed > 0
      ? (this.startTime = Math.min(this.startTime, e))
      : this.speed < 0 &&
        (this.startTime = Math.min(e - r / this.speed, this.startTime)),
      t ? (this.currentTime = e) : this.updateTime(e));
    const T = this.currentTime - d * (this.playbackSpeed >= 0 ? 1 : -1),
      C = this.playbackSpeed >= 0 ? T < 0 : T > r;
    ((this.currentTime = Math.max(T, 0)),
      this.state === "finished" &&
        this.holdTime === null &&
        (this.currentTime = r));
    let R = this.currentTime,
      L = n;
    if (v) {
      const N = Math.min(this.currentTime, r) / u;
      let F = Math.floor(N),
        j = N % 1;
      (!j && N >= 1 && (j = 1),
        j === 1 && F--,
        (F = Math.min(F, v + 1)),
        !!(F % 2) &&
          (y === "reverse"
            ? ((j = 1 - j), b && (j -= b / u))
            : y === "mirror" && (L = o)),
        (R = Yl(0, 1, j) * u));
    }
    const I = C ? { done: !1, value: m[0] } : L.next(R);
    s && (I.value = s(I.value));
    let { done: O } = I;
    !C &&
      h !== null &&
      (O =
        this.playbackSpeed >= 0
          ? this.currentTime >= r
          : this.currentTime <= 0);
    const B =
      this.holdTime === null &&
      (this.state === "finished" || (this.state === "running" && O));
    return (
      B && _ !== QS && (I.value = fT(m, this.options, E, this.speed)),
      w && w(I.value),
      B && this.finish(),
      I
    );
  }
  then(e, t) {
    return this.finished.then(e, t);
  }
  get duration() {
    return vo(this.calculatedDuration);
  }
  get iterationDuration() {
    const { delay: e = 0 } = this.options || {};
    return this.duration + vo(e);
  }
  get time() {
    return vo(this.currentTime);
  }
  set time(e) {
    var t;
    ((e = Yo(e)),
      (this.currentTime = e),
      this.startTime === null ||
      this.holdTime !== null ||
      this.playbackSpeed === 0
        ? (this.holdTime = e)
        : this.driver &&
          (this.startTime = this.driver.now() - e / this.playbackSpeed),
      (t = this.driver) == null || t.start(!1));
  }
  get speed() {
    return this.playbackSpeed;
  }
  set speed(e) {
    this.updateTime(Vs.now());
    const t = this.playbackSpeed !== e;
    ((this.playbackSpeed = e), t && (this.time = vo(this.currentTime)));
  }
  play() {
    var r, s;
    if (this.isStopped) return;
    const { driver: e = XO, startTime: t } = this.options;
    (this.driver || (this.driver = e((o) => this.tick(o))),
      (s = (r = this.options).onPlay) == null || s.call(r));
    const n = this.driver.now();
    (this.state === "finished"
      ? (this.updateFinished(), (this.startTime = n))
      : this.holdTime !== null
        ? (this.startTime = n - this.holdTime)
        : this.startTime || (this.startTime = t ?? n),
      this.state === "finished" &&
        this.speed < 0 &&
        (this.startTime += this.calculatedDuration),
      (this.holdTime = null),
      (this.state = "running"),
      this.driver.start());
  }
  pause() {
    ((this.state = "paused"),
      this.updateTime(Vs.now()),
      (this.holdTime = this.currentTime));
  }
  complete() {
    (this.state !== "running" && this.play(),
      (this.state = "finished"),
      (this.holdTime = null));
  }
  finish() {
    var e, t;
    (this.notifyFinished(),
      this.teardown(),
      (this.state = "finished"),
      (t = (e = this.options).onComplete) == null || t.call(e));
  }
  cancel() {
    var e, t;
    ((this.holdTime = null),
      (this.startTime = 0),
      this.tick(0),
      this.teardown(),
      (t = (e = this.options).onCancel) == null || t.call(e));
  }
  teardown() {
    ((this.state = "idle"),
      this.stopDriver(),
      (this.startTime = this.holdTime = null));
  }
  stopDriver() {
    this.driver && (this.driver.stop(), (this.driver = void 0));
  }
  sample(e) {
    return ((this.startTime = 0), this.tick(e, !0));
  }
  attachTimeline(e) {
    var t;
    return (
      this.options.allowFlatten &&
        ((this.options.type = "keyframes"),
        (this.options.ease = "linear"),
        this.initAnimation()),
      (t = this.driver) == null || t.stop(),
      e.observe(this)
    );
  }
}
function u4(i) {
  for (let e = 1; e < i.length; e++) i[e] ?? (i[e] = i[e - 1]);
}
const xh = (i) => (i * 180) / Math.PI,
  JS = (i) => {
    const e = xh(Math.atan2(i[1], i[0]));
    return $S(e);
  },
  f4 = {
    x: 4,
    y: 5,
    translateX: 4,
    translateY: 5,
    scaleX: 0,
    scaleY: 3,
    scale: (i) => (Math.abs(i[0]) + Math.abs(i[3])) / 2,
    rotate: JS,
    rotateZ: JS,
    skewX: (i) => xh(Math.atan(i[1])),
    skewY: (i) => xh(Math.atan(i[2])),
    skew: (i) => (Math.abs(i[1]) + Math.abs(i[2])) / 2,
  },
  $S = (i) => ((i = i % 360), i < 0 && (i += 360), i),
  Pw = JS,
  Iw = (i) => Math.sqrt(i[0] * i[0] + i[1] * i[1]),
  Ow = (i) => Math.sqrt(i[4] * i[4] + i[5] * i[5]),
  h4 = {
    x: 12,
    y: 13,
    z: 14,
    translateX: 12,
    translateY: 13,
    translateZ: 14,
    scaleX: Iw,
    scaleY: Ow,
    scale: (i) => (Iw(i) + Ow(i)) / 2,
    rotateX: (i) => $S(xh(Math.atan2(i[6], i[5]))),
    rotateY: (i) => $S(xh(Math.atan2(-i[2], i[0]))),
    rotateZ: Pw,
    rotate: Pw,
    skewX: (i) => xh(Math.atan(i[4])),
    skewY: (i) => xh(Math.atan(i[1])),
    skew: (i) => (Math.abs(i[1]) + Math.abs(i[4])) / 2,
  };
function eM(i) {
  return i.includes("scale") ? 1 : 0;
}
function tM(i, e) {
  if (!i || i === "none") return eM(e);
  const t = i.match(/^matrix3d\(([-\d.e\s,]+)\)$/u);
  let n, r;
  if (t) ((n = h4), (r = t));
  else {
    const u = i.match(/^matrix\(([-\d.e\s,]+)\)$/u);
    ((n = f4), (r = u));
  }
  if (!r) return eM(e);
  const s = n[e],
    o = r[1].split(",").map(p4);
  return typeof s == "function" ? s(o) : o[s];
}
const d4 = (i, e) => {
  const { transform: t = "none" } = getComputedStyle(i);
  return tM(t, e);
};
function p4(i) {
  return parseFloat(i.trim());
}
const Op = [
    "transformPerspective",
    "x",
    "y",
    "z",
    "translateX",
    "translateY",
    "translateZ",
    "scale",
    "scaleX",
    "scaleY",
    "rotate",
    "rotateX",
    "rotateY",
    "rotateZ",
    "skew",
    "skewX",
    "skewY",
  ],
  Fp = new Set(Op),
  Fw = (i) => i === Ip || i === Ut,
  m4 = new Set(["x", "y", "z"]),
  g4 = Op.filter((i) => !m4.has(i));
function v4(i) {
  const e = [];
  return (
    g4.forEach((t) => {
      const n = i.getValue(t);
      n !== void 0 &&
        (e.push([t, n.get()]), n.set(t.startsWith("scale") ? 1 : 0));
    }),
    e
  );
}
const Ju = {
  width: ({ x: i }, { paddingLeft: e = "0", paddingRight: t = "0" }) =>
    i.max - i.min - parseFloat(e) - parseFloat(t),
  height: ({ y: i }, { paddingTop: e = "0", paddingBottom: t = "0" }) =>
    i.max - i.min - parseFloat(e) - parseFloat(t),
  top: (i, { top: e }) => parseFloat(e),
  left: (i, { left: e }) => parseFloat(e),
  bottom: ({ y: i }, { top: e }) => parseFloat(e) + (i.max - i.min),
  right: ({ x: i }, { left: e }) => parseFloat(e) + (i.max - i.min),
  x: (i, { transform: e }) => tM(e, "x"),
  y: (i, { transform: e }) => tM(e, "y"),
};
Ju.translateX = Ju.x;
Ju.translateY = Ju.y;
const Th = new Set();
let nM = !1,
  iM = !1,
  rM = !1;
function QR() {
  if (iM) {
    const i = Array.from(Th).filter((n) => n.needsMeasurement),
      e = new Set(i.map((n) => n.element)),
      t = new Map();
    (e.forEach((n) => {
      const r = v4(n);
      r.length && (t.set(n, r), n.render());
    }),
      i.forEach((n) => n.measureInitialState()),
      e.forEach((n) => {
        n.render();
        const r = t.get(n);
        r &&
          r.forEach(([s, o]) => {
            var u;
            (u = n.getValue(s)) == null || u.set(o);
          });
      }),
      i.forEach((n) => n.measureEndState()),
      i.forEach((n) => {
        n.suspendedScrollY !== void 0 && window.scrollTo(0, n.suspendedScrollY);
      }));
  }
  ((iM = !1), (nM = !1), Th.forEach((i) => i.complete(rM)), Th.clear());
}
function JR() {
  Th.forEach((i) => {
    (i.readKeyframes(), i.needsMeasurement && (iM = !0));
  });
}
function y4() {
  ((rM = !0), JR(), QR(), (rM = !1));
}
class pT {
  constructor(e, t, n, r, s, o = !1) {
    ((this.state = "pending"),
      (this.isAsync = !1),
      (this.needsMeasurement = !1),
      (this.unresolvedKeyframes = [...e]),
      (this.onComplete = t),
      (this.name = n),
      (this.motionValue = r),
      (this.element = s),
      (this.isAsync = o));
  }
  scheduleResolve() {
    ((this.state = "scheduled"),
      this.isAsync
        ? (Th.add(this),
          nM || ((nM = !0), ui.read(JR), ui.resolveKeyframes(QR)))
        : (this.readKeyframes(), this.complete()));
  }
  readKeyframes() {
    const {
      unresolvedKeyframes: e,
      name: t,
      element: n,
      motionValue: r,
    } = this;
    if (e[0] === null) {
      const s = r == null ? void 0 : r.get(),
        o = e[e.length - 1];
      if (s !== void 0) e[0] = s;
      else if (n && t) {
        const u = n.readValue(t, o);
        u != null && (e[0] = u);
      }
      (e[0] === void 0 && (e[0] = o), r && s === void 0 && r.set(e[0]));
    }
    u4(e);
  }
  setFinalKeyframe() {}
  measureInitialState() {}
  renderEndStyles() {}
  measureEndState() {}
  complete(e = !1) {
    ((this.state = "complete"),
      this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, e),
      Th.delete(this));
  }
  cancel() {
    this.state === "scheduled" && (Th.delete(this), (this.state = "pending"));
  }
  resume() {
    this.state === "pending" && this.scheduleResolve();
  }
}
const x4 = (i) => i.startsWith("--");
function b4(i, e, t) {
  x4(e) ? i.style.setProperty(e, t) : (i.style[e] = t);
}
const _4 = {};
function $R(i, e) {
  const t = wR(i);
  return () => _4[e] ?? t();
}
const S4 = $R(() => window.ScrollTimeline !== void 0, "scrollTimeline"),
  eD = $R(() => {
    try {
      document
        .createElement("div")
        .animate({ opacity: 0 }, { easing: "linear(0, 1)" });
    } catch {
      return !1;
    }
    return !0;
  }, "linearEasing"),
  Cg = ([i, e, t, n]) => `cubic-bezier(${i}, ${e}, ${t}, ${n})`,
  zw = {
    linear: "linear",
    ease: "ease",
    easeIn: "ease-in",
    easeOut: "ease-out",
    easeInOut: "ease-in-out",
    circIn: Cg([0, 0.65, 0.55, 1]),
    circOut: Cg([0.55, 0, 1, 0.45]),
    backIn: Cg([0.31, 0.01, 0.66, -0.59]),
    backOut: Cg([0.33, 1.53, 0.69, 0.99]),
  };
function tD(i, e) {
  if (i)
    return typeof i == "function"
      ? eD()
        ? YR(i, e)
        : "ease-out"
      : FR(i)
        ? Cg(i)
        : Array.isArray(i)
          ? i.map((t) => tD(t, e) || zw.easeOut)
          : zw[i];
}
function M4(
  i,
  e,
  t,
  {
    delay: n = 0,
    duration: r = 300,
    repeat: s = 0,
    repeatType: o = "loop",
    ease: u = "easeOut",
    times: h,
  } = {},
  d = void 0,
) {
  const m = { [e]: t };
  h && (m.offset = h);
  const v = tD(u, r);
  Array.isArray(v) && (m.easing = v);
  const y = {
    delay: n,
    duration: r,
    easing: Array.isArray(v) ? "linear" : v,
    fill: "both",
    iterations: s + 1,
    direction: o === "reverse" ? "alternate" : "normal",
  };
  return (d && (y.pseudoElement = d), i.animate(m, y));
}
function nD(i) {
  return typeof i == "function" && "applyToOptions" in i;
}
function T4({ type: i, ...e }) {
  return nD(i) && eD()
    ? i.applyToOptions(e)
    : (e.duration ?? (e.duration = 300), e.ease ?? (e.ease = "easeOut"), e);
}
class iD extends hT {
  constructor(e) {
    if (
      (super(),
      (this.finishedTime = null),
      (this.isStopped = !1),
      (this.manualStartTime = null),
      !e)
    )
      return;
    const {
      element: t,
      name: n,
      keyframes: r,
      pseudoElement: s,
      allowFlatten: o = !1,
      finalKeyframe: u,
      onComplete: h,
    } = e;
    ((this.isPseudoElement = !!s),
      (this.allowFlatten = o),
      (this.options = e),
      nT(typeof e.type != "string"));
    const d = T4(e);
    ((this.animation = M4(t, n, r, d, s)),
      d.autoplay === !1 && this.animation.pause(),
      (this.animation.onfinish = () => {
        if (((this.finishedTime = this.time), !s)) {
          const m = fT(r, this.options, u, this.speed);
          (this.updateMotionValue ? this.updateMotionValue(m) : b4(t, n, m),
            this.animation.cancel());
        }
        (h == null || h(), this.notifyFinished());
      }));
  }
  play() {
    this.isStopped ||
      ((this.manualStartTime = null),
      this.animation.play(),
      this.state === "finished" && this.updateFinished());
  }
  pause() {
    this.animation.pause();
  }
  complete() {
    var e, t;
    (t = (e = this.animation).finish) == null || t.call(e);
  }
  cancel() {
    try {
      this.animation.cancel();
    } catch {}
  }
  stop() {
    if (this.isStopped) return;
    this.isStopped = !0;
    const { state: e } = this;
    e === "idle" ||
      e === "finished" ||
      (this.updateMotionValue ? this.updateMotionValue() : this.commitStyles(),
      this.isPseudoElement || this.cancel());
  }
  commitStyles() {
    var t, n, r;
    const e = (t = this.options) == null ? void 0 : t.element;
    !this.isPseudoElement &&
      e != null &&
      e.isConnected &&
      ((r = (n = this.animation).commitStyles) == null || r.call(n));
  }
  get duration() {
    var t, n;
    const e =
      ((n =
        (t = this.animation.effect) == null ? void 0 : t.getComputedTiming) ==
      null
        ? void 0
        : n.call(t).duration) || 0;
    return vo(Number(e));
  }
  get iterationDuration() {
    const { delay: e = 0 } = this.options || {};
    return this.duration + vo(e);
  }
  get time() {
    return vo(Number(this.animation.currentTime) || 0);
  }
  set time(e) {
    ((this.manualStartTime = null),
      (this.finishedTime = null),
      (this.animation.currentTime = Yo(e)));
  }
  get speed() {
    return this.animation.playbackRate;
  }
  set speed(e) {
    (e < 0 && (this.finishedTime = null), (this.animation.playbackRate = e));
  }
  get state() {
    return this.finishedTime !== null ? "finished" : this.animation.playState;
  }
  get startTime() {
    return this.manualStartTime ?? Number(this.animation.startTime);
  }
  set startTime(e) {
    this.manualStartTime = this.animation.startTime = e;
  }
  attachTimeline({ timeline: e, observe: t }) {
    var n;
    return (
      this.allowFlatten &&
        ((n = this.animation.effect) == null ||
          n.updateTiming({ easing: "linear" })),
      (this.animation.onfinish = null),
      e && S4() ? ((this.animation.timeline = e), yo) : t(this)
    );
  }
}
const rD = { anticipate: UR, backInOut: NR, circInOut: IR };
function E4(i) {
  return i in rD;
}
function w4(i) {
  typeof i.ease == "string" && E4(i.ease) && (i.ease = rD[i.ease]);
}
const C_ = 10;
class A4 extends iD {
  constructor(e) {
    (w4(e),
      KR(e),
      super(e),
      e.startTime !== void 0 && (this.startTime = e.startTime),
      (this.options = e));
  }
  updateMotionValue(e) {
    const {
      motionValue: t,
      onUpdate: n,
      onComplete: r,
      element: s,
      ...o
    } = this.options;
    if (!t) return;
    if (e !== void 0) {
      t.set(e);
      return;
    }
    const u = new dT({ ...o, autoplay: !1 }),
      h = Math.max(C_, Vs.now() - this.startTime),
      d = Yl(0, C_, h - C_);
    (t.setWithVelocity(
      u.sample(Math.max(0, h - d)).value,
      u.sample(h).value,
      d,
    ),
      u.stop());
  }
}
const Bw = (i, e) =>
  e === "zIndex"
    ? !1
    : !!(
        typeof i == "number" ||
        Array.isArray(i) ||
        (typeof i == "string" &&
          (Zo.test(i) || i === "0") &&
          !i.startsWith("url("))
      );
function C4(i) {
  const e = i[0];
  if (i.length === 1) return !0;
  for (let t = 0; t < i.length; t++) if (i[t] !== e) return !0;
}
function R4(i, e, t, n) {
  const r = i[0];
  if (r === null) return !1;
  if (e === "display" || e === "visibility") return !0;
  const s = i[i.length - 1],
    o = Bw(r, e),
    u = Bw(s, e);
  return !o || !u ? !1 : C4(i) || ((t === "spring" || nD(t)) && n);
}
function sM(i) {
  ((i.duration = 0), (i.type = "keyframes"));
}
const D4 = new Set(["opacity", "clipPath", "filter", "transform"]),
  L4 = wR(() => Object.hasOwnProperty.call(Element.prototype, "animate"));
function N4(i) {
  var m;
  const {
    motionValue: e,
    name: t,
    repeatDelay: n,
    repeatType: r,
    damping: s,
    type: o,
  } = i;
  if (
    !(
      ((m = e == null ? void 0 : e.owner) == null
        ? void 0
        : m.current) instanceof HTMLElement
    )
  )
    return !1;
  const { onUpdate: h, transformTemplate: d } = e.owner.getProps();
  return (
    L4() &&
    t &&
    D4.has(t) &&
    (t !== "transform" || !d) &&
    !h &&
    !n &&
    r !== "mirror" &&
    s !== 0 &&
    o !== "inertia"
  );
}
const U4 = 40;
class P4 extends hT {
  constructor({
    autoplay: e = !0,
    delay: t = 0,
    type: n = "keyframes",
    repeat: r = 0,
    repeatDelay: s = 0,
    repeatType: o = "loop",
    keyframes: u,
    name: h,
    motionValue: d,
    element: m,
    ...v
  }) {
    var _;
    (super(),
      (this.stop = () => {
        var w, E;
        (this._animation &&
          (this._animation.stop(),
          (w = this.stopTimeline) == null || w.call(this)),
          (E = this.keyframeResolver) == null || E.cancel());
      }),
      (this.createdAt = Vs.now()));
    const y = {
        autoplay: e,
        delay: t,
        type: n,
        repeat: r,
        repeatDelay: s,
        repeatType: o,
        name: h,
        motionValue: d,
        element: m,
        ...v,
      },
      b = (m == null ? void 0 : m.KeyframeResolver) || pT;
    ((this.keyframeResolver = new b(
      u,
      (w, E, T) => this.onKeyframesResolved(w, E, y, !T),
      h,
      d,
      m,
    )),
      (_ = this.keyframeResolver) == null || _.scheduleResolve());
  }
  onKeyframesResolved(e, t, n, r) {
    var E, T;
    this.keyframeResolver = void 0;
    const {
      name: s,
      type: o,
      velocity: u,
      delay: h,
      isHandoff: d,
      onUpdate: m,
    } = n;
    ((this.resolvedAt = Vs.now()),
      R4(e, s, o, u) ||
        ((qc.instantAnimations || !h) && (m == null || m(fT(e, n, t))),
        (e[0] = e[e.length - 1]),
        sM(n),
        (n.repeat = 0)));
    const y = {
        startTime: r
          ? this.resolvedAt
            ? this.resolvedAt - this.createdAt > U4
              ? this.resolvedAt
              : this.createdAt
            : this.createdAt
          : void 0,
        finalKeyframe: t,
        ...n,
        keyframes: e,
      },
      b = !d && N4(y),
      _ =
        (T = (E = y.motionValue) == null ? void 0 : E.owner) == null
          ? void 0
          : T.current,
      w = b ? new A4({ ...y, element: _ }) : new dT(y);
    (w.finished
      .then(() => {
        this.notifyFinished();
      })
      .catch(yo),
      this.pendingTimeline &&
        ((this.stopTimeline = w.attachTimeline(this.pendingTimeline)),
        (this.pendingTimeline = void 0)),
      (this._animation = w));
  }
  get finished() {
    return this._animation ? this.animation.finished : this._finished;
  }
  then(e, t) {
    return this.finished.finally(e).then(() => {});
  }
  get animation() {
    var e;
    return (
      this._animation ||
        ((e = this.keyframeResolver) == null || e.resume(), y4()),
      this._animation
    );
  }
  get duration() {
    return this.animation.duration;
  }
  get iterationDuration() {
    return this.animation.iterationDuration;
  }
  get time() {
    return this.animation.time;
  }
  set time(e) {
    this.animation.time = e;
  }
  get speed() {
    return this.animation.speed;
  }
  get state() {
    return this.animation.state;
  }
  set speed(e) {
    this.animation.speed = e;
  }
  get startTime() {
    return this.animation.startTime;
  }
  attachTimeline(e) {
    return (
      this._animation
        ? (this.stopTimeline = this.animation.attachTimeline(e))
        : (this.pendingTimeline = e),
      () => this.stop()
    );
  }
  play() {
    this.animation.play();
  }
  pause() {
    this.animation.pause();
  }
  complete() {
    this.animation.complete();
  }
  cancel() {
    var e;
    (this._animation && this.animation.cancel(),
      (e = this.keyframeResolver) == null || e.cancel());
  }
}
function sD(i, e, t, n = 0, r = 1) {
  const s = Array.from(i)
      .sort((d, m) => d.sortNodePosition(m))
      .indexOf(e),
    o = i.size,
    u = (o - 1) * n;
  return typeof t == "function" ? t(s, o) : r === 1 ? s * n : u - s * n;
}
const I4 = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u;
function O4(i) {
  const e = I4.exec(i);
  if (!e) return [,];
  const [, t, n, r] = e;
  return [`--${t ?? n}`, r];
}
function aD(i, e, t = 1) {
  const [n, r] = O4(i);
  if (!n) return;
  const s = window.getComputedStyle(e).getPropertyValue(n);
  if (s) {
    const o = s.trim();
    return MR(o) ? parseFloat(o) : o;
  }
  return aT(r) ? aD(r, e, t + 1) : r;
}
const F4 = { type: "spring", stiffness: 500, damping: 25, restSpeed: 10 },
  z4 = (i) => ({
    type: "spring",
    stiffness: 550,
    damping: i === 0 ? 2 * Math.sqrt(550) : 30,
    restSpeed: 10,
  }),
  B4 = { type: "keyframes", duration: 0.8 },
  k4 = { type: "keyframes", ease: [0.25, 0.1, 0.35, 1], duration: 0.3 },
  V4 = (i, { keyframes: e }) =>
    e.length > 2
      ? B4
      : Fp.has(i)
        ? i.startsWith("scale")
          ? z4(e[1])
          : F4
        : k4,
  G4 = (i) => i !== null;
function H4(i, { repeat: e, repeatType: t = "loop" }, n) {
  const r = i.filter(G4),
    s = e && t !== "loop" && e % 2 === 1 ? 0 : r.length - 1;
  return r[s];
}
function oD(i, e) {
  if (i != null && i.inherit && e) {
    const { inherit: t, ...n } = i;
    return { ...e, ...n };
  }
  return i;
}
function mT(i, e) {
  const t =
    (i == null ? void 0 : i[e]) ?? (i == null ? void 0 : i.default) ?? i;
  return t !== i ? oD(t, i) : t;
}
function j4({
  when: i,
  delay: e,
  delayChildren: t,
  staggerChildren: n,
  staggerDirection: r,
  repeat: s,
  repeatType: o,
  repeatDelay: u,
  from: h,
  elapsed: d,
  ...m
}) {
  return !!Object.keys(m).length;
}
const gT =
  (i, e, t, n = {}, r, s) =>
  (o) => {
    const u = mT(n, i) || {},
      h = u.delay || n.delay || 0;
    let { elapsed: d = 0 } = n;
    d = d - Yo(h);
    const m = {
      keyframes: Array.isArray(t) ? t : [null, t],
      ease: "easeOut",
      velocity: e.getVelocity(),
      ...u,
      delay: -d,
      onUpdate: (y) => {
        (e.set(y), u.onUpdate && u.onUpdate(y));
      },
      onComplete: () => {
        (o(), u.onComplete && u.onComplete());
      },
      name: i,
      motionValue: e,
      element: s ? void 0 : r,
    };
    (j4(u) || Object.assign(m, V4(i, m)),
      m.duration && (m.duration = Yo(m.duration)),
      m.repeatDelay && (m.repeatDelay = Yo(m.repeatDelay)),
      m.from !== void 0 && (m.keyframes[0] = m.from));
    let v = !1;
    if (
      ((m.type === !1 || (m.duration === 0 && !m.repeatDelay)) &&
        (sM(m), m.delay === 0 && (v = !0)),
      (qc.instantAnimations ||
        qc.skipAnimations ||
        (r != null && r.shouldSkipAnimations)) &&
        ((v = !0), sM(m), (m.delay = 0)),
      (m.allowFlatten = !u.type && !u.ease),
      v && !s && e.get() !== void 0)
    ) {
      const y = H4(m.keyframes, u);
      if (y !== void 0) {
        ui.update(() => {
          (m.onUpdate(y), m.onComplete());
        });
        return;
      }
    }
    return u.isSync ? new dT(m) : new P4(m);
  };
function kw(i) {
  const e = [{}, {}];
  return (
    i == null ||
      i.values.forEach((t, n) => {
        ((e[0][n] = t.get()), (e[1][n] = t.getVelocity()));
      }),
    e
  );
}
function vT(i, e, t, n) {
  if (typeof e == "function") {
    const [r, s] = kw(n);
    e = e(t !== void 0 ? t : i.custom, r, s);
  }
  if (
    (typeof e == "string" && (e = i.variants && i.variants[e]),
    typeof e == "function")
  ) {
    const [r, s] = kw(n);
    e = e(t !== void 0 ? t : i.custom, r, s);
  }
  return e;
}
function bp(i, e, t) {
  const n = i.getProps();
  return vT(n, e, t !== void 0 ? t : n.custom, i);
}
const lD = new Set([
    "width",
    "height",
    "top",
    "left",
    "right",
    "bottom",
    ...Op,
  ]),
  Vw = 30,
  W4 = (i) => !isNaN(parseFloat(i));
class X4 {
  constructor(e, t = {}) {
    ((this.canTrackVelocity = null),
      (this.events = {}),
      (this.updateAndNotify = (n) => {
        var s;
        const r = Vs.now();
        if (
          (this.updatedAt !== r && this.setPrevFrameValue(),
          (this.prev = this.current),
          this.setCurrent(n),
          this.current !== this.prev &&
            ((s = this.events.change) == null || s.notify(this.current),
            this.dependents))
        )
          for (const o of this.dependents) o.dirty();
      }),
      (this.hasAnimated = !1),
      this.setCurrent(e),
      (this.owner = t.owner));
  }
  setCurrent(e) {
    ((this.current = e),
      (this.updatedAt = Vs.now()),
      this.canTrackVelocity === null &&
        e !== void 0 &&
        (this.canTrackVelocity = W4(this.current)));
  }
  setPrevFrameValue(e = this.current) {
    ((this.prevFrameValue = e), (this.prevUpdatedAt = this.updatedAt));
  }
  onChange(e) {
    return this.on("change", e);
  }
  on(e, t) {
    this.events[e] || (this.events[e] = new iT());
    const n = this.events[e].add(t);
    return e === "change"
      ? () => {
          (n(),
            ui.read(() => {
              this.events.change.getSize() || this.stop();
            }));
        }
      : n;
  }
  clearListeners() {
    for (const e in this.events) this.events[e].clear();
  }
  attach(e, t) {
    ((this.passiveEffect = e), (this.stopPassiveEffect = t));
  }
  set(e) {
    this.passiveEffect
      ? this.passiveEffect(e, this.updateAndNotify)
      : this.updateAndNotify(e);
  }
  setWithVelocity(e, t, n) {
    (this.set(t),
      (this.prev = void 0),
      (this.prevFrameValue = e),
      (this.prevUpdatedAt = this.updatedAt - n));
  }
  jump(e, t = !0) {
    (this.updateAndNotify(e),
      (this.prev = e),
      (this.prevUpdatedAt = this.prevFrameValue = void 0),
      t && this.stop(),
      this.stopPassiveEffect && this.stopPassiveEffect());
  }
  dirty() {
    var e;
    (e = this.events.change) == null || e.notify(this.current);
  }
  addDependent(e) {
    (this.dependents || (this.dependents = new Set()), this.dependents.add(e));
  }
  removeDependent(e) {
    this.dependents && this.dependents.delete(e);
  }
  get() {
    return this.current;
  }
  getPrevious() {
    return this.prev;
  }
  getVelocity() {
    const e = Vs.now();
    if (
      !this.canTrackVelocity ||
      this.prevFrameValue === void 0 ||
      e - this.updatedAt > Vw
    )
      return 0;
    const t = Math.min(this.updatedAt - this.prevUpdatedAt, Vw);
    return AR(parseFloat(this.current) - parseFloat(this.prevFrameValue), t);
  }
  start(e) {
    return (
      this.stop(),
      new Promise((t) => {
        ((this.hasAnimated = !0),
          (this.animation = e(t)),
          this.events.animationStart && this.events.animationStart.notify());
      }).then(() => {
        (this.events.animationComplete &&
          this.events.animationComplete.notify(),
          this.clearAnimation());
      })
    );
  }
  stop() {
    (this.animation &&
      (this.animation.stop(),
      this.events.animationCancel && this.events.animationCancel.notify()),
      this.clearAnimation());
  }
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  destroy() {
    var e, t;
    ((e = this.dependents) == null || e.clear(),
      (t = this.events.destroy) == null || t.notify(),
      this.clearListeners(),
      this.stop(),
      this.stopPassiveEffect && this.stopPassiveEffect());
  }
}
function Mp(i, e) {
  return new X4(i, e);
}
const aM = (i) => Array.isArray(i);
function q4(i, e, t) {
  i.hasValue(e) ? i.getValue(e).set(t) : i.addValue(e, Mp(t));
}
function Y4(i) {
  return aM(i) ? i[i.length - 1] || 0 : i;
}
function Z4(i, e) {
  const t = bp(i, e);
  let { transitionEnd: n = {}, transition: r = {}, ...s } = t || {};
  s = { ...s, ...n };
  for (const o in s) {
    const u = Y4(s[o]);
    q4(i, o, u);
  }
}
const ys = (i) => !!(i && i.getVelocity);
function K4(i) {
  return !!(ys(i) && i.add);
}
function oM(i, e) {
  const t = i.getValue("willChange");
  if (K4(t)) return t.add(e);
  if (!t && qc.WillChange) {
    const n = new qc.WillChange("auto");
    (i.addValue("willChange", n), n.add(e));
  }
}
function yT(i) {
  return i.replace(/([A-Z])/g, (e) => `-${e.toLowerCase()}`);
}
const Q4 = "framerAppearId",
  cD = "data-" + yT(Q4);
function uD(i) {
  return i.props[cD];
}
function J4({ protectedKeys: i, needsAnimating: e }, t) {
  const n = i.hasOwnProperty(t) && e[t] !== !0;
  return ((e[t] = !1), n);
}
function fD(i, e, { delay: t = 0, transitionOverride: n, type: r } = {}) {
  let { transition: s, transitionEnd: o, ...u } = e;
  const h = i.getDefaultTransition();
  s = s ? oD(s, h) : h;
  const d = s == null ? void 0 : s.reduceMotion;
  n && (s = n);
  const m = [],
    v = r && i.animationState && i.animationState.getState()[r];
  for (const y in u) {
    const b = i.getValue(y, i.latestValues[y] ?? null),
      _ = u[y];
    if (_ === void 0 || (v && J4(v, y))) continue;
    const w = { delay: t, ...mT(s || {}, y) },
      E = b.get();
    if (
      E !== void 0 &&
      !b.isAnimating &&
      !Array.isArray(_) &&
      _ === E &&
      !w.velocity
    )
      continue;
    let T = !1;
    if (window.MotionHandoffAnimation) {
      const L = uD(i);
      if (L) {
        const I = window.MotionHandoffAnimation(L, y, ui);
        I !== null && ((w.startTime = I), (T = !0));
      }
    }
    oM(i, y);
    const C = d ?? i.shouldReduceMotion;
    b.start(gT(y, b, _, C && lD.has(y) ? { type: !1 } : w, i, T));
    const R = b.animation;
    R && m.push(R);
  }
  if (o) {
    const y = () =>
      ui.update(() => {
        o && Z4(i, o);
      });
    m.length ? Promise.all(m).then(y) : y();
  }
  return m;
}
function lM(i, e, t = {}) {
  var h;
  const n = bp(
    i,
    e,
    t.type === "exit"
      ? (h = i.presenceContext) == null
        ? void 0
        : h.custom
      : void 0,
  );
  let { transition: r = i.getDefaultTransition() || {} } = n || {};
  t.transitionOverride && (r = t.transitionOverride);
  const s = n ? () => Promise.all(fD(i, n, t)) : () => Promise.resolve(),
    o =
      i.variantChildren && i.variantChildren.size
        ? (d = 0) => {
            const {
              delayChildren: m = 0,
              staggerChildren: v,
              staggerDirection: y,
            } = r;
            return $4(i, e, d, m, v, y, t);
          }
        : () => Promise.resolve(),
    { when: u } = r;
  if (u) {
    const [d, m] = u === "beforeChildren" ? [s, o] : [o, s];
    return d().then(() => m());
  } else return Promise.all([s(), o(t.delay)]);
}
function $4(i, e, t = 0, n = 0, r = 0, s = 1, o) {
  const u = [];
  for (const h of i.variantChildren)
    (h.notify("AnimationStart", e),
      u.push(
        lM(h, e, {
          ...o,
          delay:
            t +
            (typeof n == "function" ? 0 : n) +
            sD(i.variantChildren, h, n, r, s),
        }).then(() => h.notify("AnimationComplete", e)),
      ));
  return Promise.all(u);
}
function e5(i, e, t = {}) {
  i.notify("AnimationStart", e);
  let n;
  if (Array.isArray(e)) {
    const r = e.map((s) => lM(i, s, t));
    n = Promise.all(r);
  } else if (typeof e == "string") n = lM(i, e, t);
  else {
    const r = typeof e == "function" ? bp(i, e, t.custom) : e;
    n = Promise.all(fD(i, r, t));
  }
  return n.then(() => {
    i.notify("AnimationComplete", e);
  });
}
const t5 = { test: (i) => i === "auto", parse: (i) => i },
  hD = (i) => (e) => e.test(i),
  dD = [Ip, Ut, Xl, Yu, DO, RO, t5],
  Gw = (i) => dD.find(hD(i));
function n5(i) {
  return typeof i == "number"
    ? i === 0
    : i !== null
      ? i === "none" || i === "0" || ER(i)
      : !0;
}
const i5 = new Set(["brightness", "contrast", "saturate", "opacity"]);
function r5(i) {
  const [e, t] = i.slice(0, -1).split("(");
  if (e === "drop-shadow") return i;
  const [n] = t.match(oT) || [];
  if (!n) return i;
  const r = t.replace(n, "");
  let s = i5.has(e) ? 1 : 0;
  return (n !== t && (s *= 100), e + "(" + s + r + ")");
}
const s5 = /\b([a-z-]*)\(.*?\)/gu,
  cM = {
    ...Zo,
    getAnimatableNone: (i) => {
      const e = i.match(s5);
      return e ? e.map(r5).join(" ") : i;
    },
  },
  uM = {
    ...Zo,
    getAnimatableNone: (i) => {
      const e = Zo.parse(i);
      return Zo.createTransformer(i)(
        e.map((n) =>
          typeof n == "number"
            ? 0
            : typeof n == "object"
              ? { ...n, alpha: 1 }
              : n,
        ),
      );
    },
  },
  Hw = { ...Ip, transform: Math.round },
  a5 = {
    rotate: Yu,
    rotateX: Yu,
    rotateY: Yu,
    rotateZ: Yu,
    scale: vy,
    scaleX: vy,
    scaleY: vy,
    scaleZ: vy,
    skew: Yu,
    skewX: Yu,
    skewY: Yu,
    distance: Ut,
    translateX: Ut,
    translateY: Ut,
    translateZ: Ut,
    x: Ut,
    y: Ut,
    z: Ut,
    perspective: Ut,
    transformPerspective: Ut,
    opacity: $g,
    originX: Rw,
    originY: Rw,
    originZ: Ut,
  },
  xT = {
    borderWidth: Ut,
    borderTopWidth: Ut,
    borderRightWidth: Ut,
    borderBottomWidth: Ut,
    borderLeftWidth: Ut,
    borderRadius: Ut,
    borderTopLeftRadius: Ut,
    borderTopRightRadius: Ut,
    borderBottomRightRadius: Ut,
    borderBottomLeftRadius: Ut,
    width: Ut,
    maxWidth: Ut,
    height: Ut,
    maxHeight: Ut,
    top: Ut,
    right: Ut,
    bottom: Ut,
    left: Ut,
    inset: Ut,
    insetBlock: Ut,
    insetBlockStart: Ut,
    insetBlockEnd: Ut,
    insetInline: Ut,
    insetInlineStart: Ut,
    insetInlineEnd: Ut,
    padding: Ut,
    paddingTop: Ut,
    paddingRight: Ut,
    paddingBottom: Ut,
    paddingLeft: Ut,
    paddingBlock: Ut,
    paddingBlockStart: Ut,
    paddingBlockEnd: Ut,
    paddingInline: Ut,
    paddingInlineStart: Ut,
    paddingInlineEnd: Ut,
    margin: Ut,
    marginTop: Ut,
    marginRight: Ut,
    marginBottom: Ut,
    marginLeft: Ut,
    marginBlock: Ut,
    marginBlockStart: Ut,
    marginBlockEnd: Ut,
    marginInline: Ut,
    marginInlineStart: Ut,
    marginInlineEnd: Ut,
    fontSize: Ut,
    backgroundPositionX: Ut,
    backgroundPositionY: Ut,
    ...a5,
    zIndex: Hw,
    fillOpacity: $g,
    strokeOpacity: $g,
    numOctaves: Hw,
  },
  o5 = {
    ...xT,
    color: pr,
    backgroundColor: pr,
    outlineColor: pr,
    fill: pr,
    stroke: pr,
    borderColor: pr,
    borderTopColor: pr,
    borderRightColor: pr,
    borderBottomColor: pr,
    borderLeftColor: pr,
    filter: cM,
    WebkitFilter: cM,
    mask: uM,
    WebkitMask: uM,
  },
  pD = (i) => o5[i],
  l5 = new Set([cM, uM]);
function mD(i, e) {
  let t = pD(i);
  return (
    l5.has(t) || (t = Zo),
    t.getAnimatableNone ? t.getAnimatableNone(e) : void 0
  );
}
const c5 = new Set(["auto", "none", "0"]);
function u5(i, e, t) {
  let n = 0,
    r;
  for (; n < i.length && !r; ) {
    const s = i[n];
    (typeof s == "string" && !c5.has(s) && e0(s).values.length && (r = i[n]),
      n++);
  }
  if (r && t) for (const s of e) i[s] = mD(t, r);
}
class f5 extends pT {
  constructor(e, t, n, r, s) {
    super(e, t, n, r, s, !0);
  }
  readKeyframes() {
    const { unresolvedKeyframes: e, element: t, name: n } = this;
    if (!t || !t.current) return;
    super.readKeyframes();
    for (let m = 0; m < e.length; m++) {
      let v = e[m];
      if (typeof v == "string" && ((v = v.trim()), aT(v))) {
        const y = aD(v, t.current);
        (y !== void 0 && (e[m] = y),
          m === e.length - 1 && (this.finalKeyframe = v));
      }
    }
    if ((this.resolveNoneKeyframes(), !lD.has(n) || e.length !== 2)) return;
    const [r, s] = e,
      o = Gw(r),
      u = Gw(s),
      h = Cw(r),
      d = Cw(s);
    if (h !== d && Ju[n]) {
      this.needsMeasurement = !0;
      return;
    }
    if (o !== u)
      if (Fw(o) && Fw(u))
        for (let m = 0; m < e.length; m++) {
          const v = e[m];
          typeof v == "string" && (e[m] = parseFloat(v));
        }
      else Ju[n] && (this.needsMeasurement = !0);
  }
  resolveNoneKeyframes() {
    const { unresolvedKeyframes: e, name: t } = this,
      n = [];
    for (let r = 0; r < e.length; r++) (e[r] === null || n5(e[r])) && n.push(r);
    n.length && u5(e, n, t);
  }
  measureInitialState() {
    const { element: e, unresolvedKeyframes: t, name: n } = this;
    if (!e || !e.current) return;
    (n === "height" && (this.suspendedScrollY = window.pageYOffset),
      (this.measuredOrigin = Ju[n](
        e.measureViewportBox(),
        window.getComputedStyle(e.current),
      )),
      (t[0] = this.measuredOrigin));
    const r = t[t.length - 1];
    r !== void 0 && e.getValue(n, r).jump(r, !1);
  }
  measureEndState() {
    var u;
    const { element: e, name: t, unresolvedKeyframes: n } = this;
    if (!e || !e.current) return;
    const r = e.getValue(t);
    r && r.jump(this.measuredOrigin, !1);
    const s = n.length - 1,
      o = n[s];
    ((n[s] = Ju[t](e.measureViewportBox(), window.getComputedStyle(e.current))),
      o !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = o),
      (u = this.removedTransforms) != null &&
        u.length &&
        this.removedTransforms.forEach(([h, d]) => {
          e.getValue(h).set(d);
        }),
      this.resolveNoneKeyframes());
  }
}
const h5 = new Set(["opacity", "clipPath", "filter", "transform"]);
function gD(i, e, t) {
  if (i == null) return [];
  if (i instanceof EventTarget) return [i];
  if (typeof i == "string") {
    let n = document;
    const r = (t == null ? void 0 : t[i]) ?? n.querySelectorAll(i);
    return r ? Array.from(r) : [];
  }
  return Array.from(i).filter((n) => n != null);
}
const vD = (i, e) => (e && typeof i == "number" ? e.transform(i) : i);
function d5(i) {
  return TR(i) && "offsetHeight" in i;
}
const { schedule: bT } = zR(queueMicrotask, !1),
  Wo = { x: !1, y: !1 };
function yD() {
  return Wo.x || Wo.y;
}
function p5(i) {
  return i === "x" || i === "y"
    ? Wo[i]
      ? null
      : ((Wo[i] = !0),
        () => {
          Wo[i] = !1;
        })
    : Wo.x || Wo.y
      ? null
      : ((Wo.x = Wo.y = !0),
        () => {
          Wo.x = Wo.y = !1;
        });
}
function xD(i, e) {
  const t = gD(i),
    n = new AbortController(),
    r = { passive: !0, ...e, signal: n.signal };
  return [t, r, () => n.abort()];
}
function m5(i) {
  return !(i.pointerType === "touch" || yD());
}
function g5(i, e, t = {}) {
  const [n, r, s] = xD(i, t);
  return (
    n.forEach((o) => {
      let u = !1,
        h = !1,
        d;
      const m = () => {
          o.removeEventListener("pointerleave", _);
        },
        v = (E) => {
          (d && (d(E), (d = void 0)), m());
        },
        y = (E) => {
          ((u = !1),
            window.removeEventListener("pointerup", y),
            window.removeEventListener("pointercancel", y),
            h && ((h = !1), v(E)));
        },
        b = () => {
          ((u = !0),
            window.addEventListener("pointerup", y, r),
            window.addEventListener("pointercancel", y, r));
        },
        _ = (E) => {
          if (E.pointerType !== "touch") {
            if (u) {
              h = !0;
              return;
            }
            v(E);
          }
        },
        w = (E) => {
          if (!m5(E)) return;
          h = !1;
          const T = e(o, E);
          typeof T == "function" &&
            ((d = T), o.addEventListener("pointerleave", _, r));
        };
      (o.addEventListener("pointerenter", w, r),
        o.addEventListener("pointerdown", b, r));
    }),
    s
  );
}
const bD = (i, e) => (e ? (i === e ? !0 : bD(i, e.parentElement)) : !1),
  _T = (i) =>
    i.pointerType === "mouse"
      ? typeof i.button != "number" || i.button <= 0
      : i.isPrimary !== !1,
  v5 = new Set(["BUTTON", "INPUT", "SELECT", "TEXTAREA", "A"]);
function y5(i) {
  return v5.has(i.tagName) || i.isContentEditable === !0;
}
const x5 = new Set(["INPUT", "SELECT", "TEXTAREA"]);
function b5(i) {
  return x5.has(i.tagName) || i.isContentEditable === !0;
}
const Mx = new WeakSet();
function jw(i) {
  return (e) => {
    e.key === "Enter" && i(e);
  };
}
function R_(i, e) {
  i.dispatchEvent(
    new PointerEvent("pointer" + e, { isPrimary: !0, bubbles: !0 }),
  );
}
const _5 = (i, e) => {
  const t = i.currentTarget;
  if (!t) return;
  const n = jw(() => {
    if (Mx.has(t)) return;
    R_(t, "down");
    const r = jw(() => {
        R_(t, "up");
      }),
      s = () => R_(t, "cancel");
    (t.addEventListener("keyup", r, e), t.addEventListener("blur", s, e));
  });
  (t.addEventListener("keydown", n, e),
    t.addEventListener("blur", () => t.removeEventListener("keydown", n), e));
};
function Ww(i) {
  return _T(i) && !yD();
}
const Xw = new WeakSet();
function S5(i, e, t = {}) {
  const [n, r, s] = xD(i, t),
    o = (u) => {
      const h = u.currentTarget;
      if (!Ww(u) || Xw.has(u)) return;
      (Mx.add(h), t.stopPropagation && Xw.add(u));
      const d = e(h, u),
        m = (b, _) => {
          (window.removeEventListener("pointerup", v),
            window.removeEventListener("pointercancel", y),
            Mx.has(h) && Mx.delete(h),
            Ww(b) && typeof d == "function" && d(b, { success: _ }));
        },
        v = (b) => {
          m(
            b,
            h === window ||
              h === document ||
              t.useGlobalTarget ||
              bD(h, b.target),
          );
        },
        y = (b) => {
          m(b, !1);
        };
      (window.addEventListener("pointerup", v, r),
        window.addEventListener("pointercancel", y, r));
    };
  return (
    n.forEach((u) => {
      ((t.useGlobalTarget ? window : u).addEventListener("pointerdown", o, r),
        d5(u) &&
          (u.addEventListener("focus", (d) => _5(d, r)),
          !y5(u) && !u.hasAttribute("tabindex") && (u.tabIndex = 0)));
    }),
    s
  );
}
function ST(i) {
  return TR(i) && "ownerSVGElement" in i;
}
const Tx = new WeakMap();
let Zu;
const _D = (i, e, t) => (n, r) =>
    r && r[0]
      ? r[0][i + "Size"]
      : ST(n) && "getBBox" in n
        ? n.getBBox()[e]
        : n[t],
  M5 = _D("inline", "width", "offsetWidth"),
  T5 = _D("block", "height", "offsetHeight");
function E5({ target: i, borderBoxSize: e }) {
  var t;
  (t = Tx.get(i)) == null ||
    t.forEach((n) => {
      n(i, {
        get width() {
          return M5(i, e);
        },
        get height() {
          return T5(i, e);
        },
      });
    });
}
function w5(i) {
  i.forEach(E5);
}
function A5() {
  typeof ResizeObserver > "u" || (Zu = new ResizeObserver(w5));
}
function C5(i, e) {
  Zu || A5();
  const t = gD(i);
  return (
    t.forEach((n) => {
      let r = Tx.get(n);
      (r || ((r = new Set()), Tx.set(n, r)),
        r.add(e),
        Zu == null || Zu.observe(n));
    }),
    () => {
      t.forEach((n) => {
        const r = Tx.get(n);
        (r == null || r.delete(e),
          (r != null && r.size) || Zu == null || Zu.unobserve(n));
      });
    }
  );
}
const Ex = new Set();
let dp;
function R5() {
  ((dp = () => {
    const i = {
      get width() {
        return window.innerWidth;
      },
      get height() {
        return window.innerHeight;
      },
    };
    Ex.forEach((e) => e(i));
  }),
    window.addEventListener("resize", dp));
}
function D5(i) {
  return (
    Ex.add(i),
    dp || R5(),
    () => {
      (Ex.delete(i),
        !Ex.size &&
          typeof dp == "function" &&
          (window.removeEventListener("resize", dp), (dp = void 0)));
    }
  );
}
function qw(i, e) {
  return typeof i == "function" ? D5(i) : C5(i, e);
}
function L5(i) {
  return ST(i) && i.tagName === "svg";
}
const N5 = [...dD, pr, Zo],
  U5 = (i) => N5.find(hD(i)),
  Yw = () => ({ translate: 0, scale: 1, origin: 0, originPoint: 0 }),
  pp = () => ({ x: Yw(), y: Yw() }),
  Zw = () => ({ min: 0, max: 0 }),
  Mr = () => ({ x: Zw(), y: Zw() }),
  P5 = new WeakMap();
function X1(i) {
  return i !== null && typeof i == "object" && typeof i.start == "function";
}
function t0(i) {
  return typeof i == "string" || Array.isArray(i);
}
const MT = [
    "animate",
    "whileInView",
    "whileFocus",
    "whileHover",
    "whileTap",
    "whileDrag",
    "exit",
  ],
  TT = ["initial", ...MT];
function q1(i) {
  return X1(i.animate) || TT.some((e) => t0(i[e]));
}
function SD(i) {
  return !!(q1(i) || i.variants);
}
function I5(i, e, t) {
  for (const n in e) {
    const r = e[n],
      s = t[n];
    if (ys(r)) i.addValue(n, r);
    else if (ys(s)) i.addValue(n, Mp(r, { owner: i }));
    else if (s !== r)
      if (i.hasValue(n)) {
        const o = i.getValue(n);
        o.liveStyle === !0 ? o.jump(r) : o.hasAnimated || o.set(r);
      } else {
        const o = i.getStaticValue(n);
        i.addValue(n, Mp(o !== void 0 ? o : r, { owner: i }));
      }
  }
  for (const n in t) e[n] === void 0 && i.removeValue(n);
  return e;
}
const fM = { current: null },
  MD = { current: !1 },
  O5 = typeof window < "u";
function F5() {
  if (((MD.current = !0), !!O5))
    if (window.matchMedia) {
      const i = window.matchMedia("(prefers-reduced-motion)"),
        e = () => (fM.current = i.matches);
      (i.addEventListener("change", e), e());
    } else fM.current = !1;
}
const Kw = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete",
];
let Bx = {};
function TD(i) {
  Bx = i;
}
function z5() {
  return Bx;
}
class B5 {
  scrapeMotionValuesFromProps(e, t, n) {
    return {};
  }
  constructor(
    {
      parent: e,
      props: t,
      presenceContext: n,
      reducedMotionConfig: r,
      skipAnimations: s,
      blockInitialAnimation: o,
      visualState: u,
    },
    h = {},
  ) {
    ((this.current = null),
      (this.children = new Set()),
      (this.isVariantNode = !1),
      (this.isControllingVariants = !1),
      (this.shouldReduceMotion = null),
      (this.shouldSkipAnimations = !1),
      (this.values = new Map()),
      (this.KeyframeResolver = pT),
      (this.features = {}),
      (this.valueSubscriptions = new Map()),
      (this.prevMotionValues = {}),
      (this.hasBeenMounted = !1),
      (this.events = {}),
      (this.propEventSubscriptions = {}),
      (this.notifyUpdate = () => this.notify("Update", this.latestValues)),
      (this.render = () => {
        this.current &&
          (this.triggerBuild(),
          this.renderInstance(
            this.current,
            this.renderState,
            this.props.style,
            this.projection,
          ));
      }),
      (this.renderScheduledAt = 0),
      (this.scheduleRender = () => {
        const b = Vs.now();
        this.renderScheduledAt < b &&
          ((this.renderScheduledAt = b), ui.render(this.render, !1, !0));
      }));
    const { latestValues: d, renderState: m } = u;
    ((this.latestValues = d),
      (this.baseTarget = { ...d }),
      (this.initialValues = t.initial ? { ...d } : {}),
      (this.renderState = m),
      (this.parent = e),
      (this.props = t),
      (this.presenceContext = n),
      (this.depth = e ? e.depth + 1 : 0),
      (this.reducedMotionConfig = r),
      (this.skipAnimationsConfig = s),
      (this.options = h),
      (this.blockInitialAnimation = !!o),
      (this.isControllingVariants = q1(t)),
      (this.isVariantNode = SD(t)),
      this.isVariantNode && (this.variantChildren = new Set()),
      (this.manuallyAnimateOnMount = !!(e && e.current)));
    const { willChange: v, ...y } = this.scrapeMotionValuesFromProps(
      t,
      {},
      this,
    );
    for (const b in y) {
      const _ = y[b];
      d[b] !== void 0 && ys(_) && _.set(d[b]);
    }
  }
  mount(e) {
    var t, n;
    if (this.hasBeenMounted)
      for (const r in this.initialValues)
        ((t = this.values.get(r)) == null || t.jump(this.initialValues[r]),
          (this.latestValues[r] = this.initialValues[r]));
    ((this.current = e),
      P5.set(e, this),
      this.projection && !this.projection.instance && this.projection.mount(e),
      this.parent &&
        this.isVariantNode &&
        !this.isControllingVariants &&
        (this.removeFromVariantTree = this.parent.addVariantChild(this)),
      this.values.forEach((r, s) => this.bindToMotionValue(s, r)),
      this.reducedMotionConfig === "never"
        ? (this.shouldReduceMotion = !1)
        : this.reducedMotionConfig === "always"
          ? (this.shouldReduceMotion = !0)
          : (MD.current || F5(), (this.shouldReduceMotion = fM.current)),
      (this.shouldSkipAnimations = this.skipAnimationsConfig ?? !1),
      (n = this.parent) == null || n.addChild(this),
      this.update(this.props, this.presenceContext),
      (this.hasBeenMounted = !0));
  }
  unmount() {
    var e;
    (this.projection && this.projection.unmount(),
      nf(this.notifyUpdate),
      nf(this.render),
      this.valueSubscriptions.forEach((t) => t()),
      this.valueSubscriptions.clear(),
      this.removeFromVariantTree && this.removeFromVariantTree(),
      (e = this.parent) == null || e.removeChild(this));
    for (const t in this.events) this.events[t].clear();
    for (const t in this.features) {
      const n = this.features[t];
      n && (n.unmount(), (n.isMounted = !1));
    }
    this.current = null;
  }
  addChild(e) {
    (this.children.add(e),
      this.enteringChildren ?? (this.enteringChildren = new Set()),
      this.enteringChildren.add(e));
  }
  removeChild(e) {
    (this.children.delete(e),
      this.enteringChildren && this.enteringChildren.delete(e));
  }
  bindToMotionValue(e, t) {
    if (
      (this.valueSubscriptions.has(e) && this.valueSubscriptions.get(e)(),
      t.accelerate && h5.has(e) && this.current instanceof HTMLElement)
    ) {
      const {
          factory: o,
          keyframes: u,
          times: h,
          ease: d,
          duration: m,
        } = t.accelerate,
        v = new iD({
          element: this.current,
          name: e,
          keyframes: u,
          times: h,
          ease: d,
          duration: Yo(m),
        }),
        y = o(v);
      this.valueSubscriptions.set(e, () => {
        (y(), v.cancel());
      });
      return;
    }
    const n = Fp.has(e);
    n && this.onBindTransform && this.onBindTransform();
    const r = t.on("change", (o) => {
      ((this.latestValues[e] = o),
        this.props.onUpdate && ui.preRender(this.notifyUpdate),
        n && this.projection && (this.projection.isTransformDirty = !0),
        this.scheduleRender());
    });
    let s;
    (typeof window < "u" &&
      window.MotionCheckAppearSync &&
      (s = window.MotionCheckAppearSync(this, e, t)),
      this.valueSubscriptions.set(e, () => {
        (r(), s && s(), t.owner && t.stop());
      }));
  }
  sortNodePosition(e) {
    return !this.current ||
      !this.sortInstanceNodePosition ||
      this.type !== e.type
      ? 0
      : this.sortInstanceNodePosition(this.current, e.current);
  }
  updateFeatures() {
    let e = "animation";
    for (e in Bx) {
      const t = Bx[e];
      if (!t) continue;
      const { isEnabled: n, Feature: r } = t;
      if (
        (!this.features[e] &&
          r &&
          n(this.props) &&
          (this.features[e] = new r(this)),
        this.features[e])
      ) {
        const s = this.features[e];
        s.isMounted ? s.update() : (s.mount(), (s.isMounted = !0));
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.props);
  }
  measureViewportBox() {
    return this.current
      ? this.measureInstanceViewportBox(this.current, this.props)
      : Mr();
  }
  getStaticValue(e) {
    return this.latestValues[e];
  }
  setStaticValue(e, t) {
    this.latestValues[e] = t;
  }
  update(e, t) {
    ((e.transformTemplate || this.props.transformTemplate) &&
      this.scheduleRender(),
      (this.prevProps = this.props),
      (this.props = e),
      (this.prevPresenceContext = this.presenceContext),
      (this.presenceContext = t));
    for (let n = 0; n < Kw.length; n++) {
      const r = Kw[n];
      this.propEventSubscriptions[r] &&
        (this.propEventSubscriptions[r](),
        delete this.propEventSubscriptions[r]);
      const s = "on" + r,
        o = e[s];
      o && (this.propEventSubscriptions[r] = this.on(r, o));
    }
    ((this.prevMotionValues = I5(
      this,
      this.scrapeMotionValuesFromProps(e, this.prevProps || {}, this),
      this.prevMotionValues,
    )),
      this.handleChildMotionValue && this.handleChildMotionValue());
  }
  getProps() {
    return this.props;
  }
  getVariant(e) {
    return this.props.variants ? this.props.variants[e] : void 0;
  }
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode
      ? this
      : this.parent
        ? this.parent.getClosestVariantNode()
        : void 0;
  }
  addVariantChild(e) {
    const t = this.getClosestVariantNode();
    if (t)
      return (
        t.variantChildren && t.variantChildren.add(e),
        () => t.variantChildren.delete(e)
      );
  }
  addValue(e, t) {
    const n = this.values.get(e);
    t !== n &&
      (n && this.removeValue(e),
      this.bindToMotionValue(e, t),
      this.values.set(e, t),
      (this.latestValues[e] = t.get()));
  }
  removeValue(e) {
    this.values.delete(e);
    const t = this.valueSubscriptions.get(e);
    (t && (t(), this.valueSubscriptions.delete(e)),
      delete this.latestValues[e],
      this.removeValueFromRenderState(e, this.renderState));
  }
  hasValue(e) {
    return this.values.has(e);
  }
  getValue(e, t) {
    if (this.props.values && this.props.values[e]) return this.props.values[e];
    let n = this.values.get(e);
    return (
      n === void 0 &&
        t !== void 0 &&
        ((n = Mp(t === null ? void 0 : t, { owner: this })),
        this.addValue(e, n)),
      n
    );
  }
  readValue(e, t) {
    let n =
      this.latestValues[e] !== void 0 || !this.current
        ? this.latestValues[e]
        : (this.getBaseTargetFromProps(this.props, e) ??
          this.readValueFromInstance(this.current, e, this.options));
    return (
      n != null &&
        (typeof n == "string" && (MR(n) || ER(n))
          ? (n = parseFloat(n))
          : !U5(n) && Zo.test(t) && (n = mD(e, t)),
        this.setBaseTarget(e, ys(n) ? n.get() : n)),
      ys(n) ? n.get() : n
    );
  }
  setBaseTarget(e, t) {
    this.baseTarget[e] = t;
  }
  getBaseTarget(e) {
    var s;
    const { initial: t } = this.props;
    let n;
    if (typeof t == "string" || typeof t == "object") {
      const o = vT(
        this.props,
        t,
        (s = this.presenceContext) == null ? void 0 : s.custom,
      );
      o && (n = o[e]);
    }
    if (t && n !== void 0) return n;
    const r = this.getBaseTargetFromProps(this.props, e);
    return r !== void 0 && !ys(r)
      ? r
      : this.initialValues[e] !== void 0 && n === void 0
        ? void 0
        : this.baseTarget[e];
  }
  on(e, t) {
    return (
      this.events[e] || (this.events[e] = new iT()),
      this.events[e].add(t)
    );
  }
  notify(e, ...t) {
    this.events[e] && this.events[e].notify(...t);
  }
  scheduleRenderMicrotask() {
    bT.render(this.render);
  }
}
class ED extends B5 {
  constructor() {
    (super(...arguments), (this.KeyframeResolver = f5));
  }
  sortInstanceNodePosition(e, t) {
    return e.compareDocumentPosition(t) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(e, t) {
    const n = e.style;
    return n ? n[t] : void 0;
  }
  removeValueFromRenderState(e, { vars: t, style: n }) {
    (delete t[e], delete n[e]);
  }
  handleChildMotionValue() {
    this.childSubscription &&
      (this.childSubscription(), delete this.childSubscription);
    const { children: e } = this.props;
    ys(e) &&
      (this.childSubscription = e.on("change", (t) => {
        this.current && (this.current.textContent = `${t}`);
      }));
  }
}
class uf {
  constructor(e) {
    ((this.isMounted = !1), (this.node = e));
  }
  update() {}
}
function wD({ top: i, left: e, right: t, bottom: n }) {
  return { x: { min: e, max: t }, y: { min: i, max: n } };
}
function k5({ x: i, y: e }) {
  return { top: e.min, right: i.max, bottom: e.max, left: i.min };
}
function V5(i, e) {
  if (!e) return i;
  const t = e({ x: i.left, y: i.top }),
    n = e({ x: i.right, y: i.bottom });
  return { top: t.y, left: t.x, bottom: n.y, right: n.x };
}
function D_(i) {
  return i === void 0 || i === 1;
}
function hM({ scale: i, scaleX: e, scaleY: t }) {
  return !D_(i) || !D_(e) || !D_(t);
}
function dh(i) {
  return (
    hM(i) ||
    AD(i) ||
    i.z ||
    i.rotate ||
    i.rotateX ||
    i.rotateY ||
    i.skewX ||
    i.skewY
  );
}
function AD(i) {
  return Qw(i.x) || Qw(i.y);
}
function Qw(i) {
  return i && i !== "0%";
}
function kx(i, e, t) {
  const n = i - t,
    r = e * n;
  return t + r;
}
function Jw(i, e, t, n, r) {
  return (r !== void 0 && (i = kx(i, r, n)), kx(i, t, n) + e);
}
function dM(i, e = 0, t = 1, n, r) {
  ((i.min = Jw(i.min, e, t, n, r)), (i.max = Jw(i.max, e, t, n, r)));
}
function CD(i, { x: e, y: t }) {
  (dM(i.x, e.translate, e.scale, e.originPoint),
    dM(i.y, t.translate, t.scale, t.originPoint));
}
const $w = 0.999999999999,
  eA = 1.0000000000001;
function G5(i, e, t, n = !1) {
  const r = t.length;
  if (!r) return;
  e.x = e.y = 1;
  let s, o;
  for (let u = 0; u < r; u++) {
    ((s = t[u]), (o = s.projectionDelta));
    const { visualElement: h } = s.options;
    (h && h.props.style && h.props.style.display === "contents") ||
      (n &&
        s.options.layoutScroll &&
        s.scroll &&
        s !== s.root &&
        gp(i, { x: -s.scroll.offset.x, y: -s.scroll.offset.y }),
      o && ((e.x *= o.x.scale), (e.y *= o.y.scale), CD(i, o)),
      n && dh(s.latestValues) && gp(i, s.latestValues));
  }
  (e.x < eA && e.x > $w && (e.x = 1), e.y < eA && e.y > $w && (e.y = 1));
}
function mp(i, e) {
  ((i.min = i.min + e), (i.max = i.max + e));
}
function tA(i, e, t, n, r = 0.5) {
  const s = Ii(i.min, i.max, r);
  dM(i, e, t, s, n);
}
function gp(i, e) {
  (tA(i.x, e.x, e.scaleX, e.scale, e.originX),
    tA(i.y, e.y, e.scaleY, e.scale, e.originY));
}
function RD(i, e) {
  return wD(V5(i.getBoundingClientRect(), e));
}
function H5(i, e, t) {
  const n = RD(i, t),
    { scroll: r } = e;
  return (r && (mp(n.x, r.offset.x), mp(n.y, r.offset.y)), n);
}
const j5 = {
    x: "translateX",
    y: "translateY",
    z: "translateZ",
    transformPerspective: "perspective",
  },
  W5 = Op.length;
function X5(i, e, t) {
  let n = "",
    r = !0;
  for (let s = 0; s < W5; s++) {
    const o = Op[s],
      u = i[o];
    if (u === void 0) continue;
    let h = !0;
    if (typeof u == "number") h = u === (o.startsWith("scale") ? 1 : 0);
    else {
      const d = parseFloat(u);
      h = o.startsWith("scale") ? d === 1 : d === 0;
    }
    if (!h || t) {
      const d = vD(u, xT[o]);
      if (!h) {
        r = !1;
        const m = j5[o] || o;
        n += `${m}(${d}) `;
      }
      t && (e[o] = d);
    }
  }
  return ((n = n.trim()), t ? (n = t(e, r ? "" : n)) : r && (n = "none"), n);
}
function ET(i, e, t) {
  const { style: n, vars: r, transformOrigin: s } = i;
  let o = !1,
    u = !1;
  for (const h in e) {
    const d = e[h];
    if (Fp.has(h)) {
      o = !0;
      continue;
    } else if (kR(h)) {
      r[h] = d;
      continue;
    } else {
      const m = vD(d, xT[h]);
      h.startsWith("origin") ? ((u = !0), (s[h] = m)) : (n[h] = m);
    }
  }
  if (
    (e.transform ||
      (o || t
        ? (n.transform = X5(e, i.transform, t))
        : n.transform && (n.transform = "none")),
    u)
  ) {
    const { originX: h = "50%", originY: d = "50%", originZ: m = 0 } = s;
    n.transformOrigin = `${h} ${d} ${m}`;
  }
}
function DD(i, { style: e, vars: t }, n, r) {
  const s = i.style;
  let o;
  for (o in e) s[o] = e[o];
  r == null || r.applyProjectionStyles(s, n);
  for (o in t) s.setProperty(o, t[o]);
}
function nA(i, e) {
  return e.max === e.min ? 0 : (i / (e.max - e.min)) * 100;
}
const dg = {
    correct: (i, e) => {
      if (!e.target) return i;
      if (typeof i == "string")
        if (Ut.test(i)) i = parseFloat(i);
        else return i;
      const t = nA(i, e.target.x),
        n = nA(i, e.target.y);
      return `${t}% ${n}%`;
    },
  },
  q5 = {
    correct: (i, { treeScale: e, projectionDelta: t }) => {
      const n = i,
        r = Zo.parse(i);
      if (r.length > 5) return n;
      const s = Zo.createTransformer(i),
        o = typeof r[0] != "number" ? 1 : 0,
        u = t.x.scale * e.x,
        h = t.y.scale * e.y;
      ((r[0 + o] /= u), (r[1 + o] /= h));
      const d = Ii(u, h, 0.5);
      return (
        typeof r[2 + o] == "number" && (r[2 + o] /= d),
        typeof r[3 + o] == "number" && (r[3 + o] /= d),
        s(r)
      );
    },
  },
  pM = {
    borderRadius: {
      ...dg,
      applyTo: [
        "borderTopLeftRadius",
        "borderTopRightRadius",
        "borderBottomLeftRadius",
        "borderBottomRightRadius",
      ],
    },
    borderTopLeftRadius: dg,
    borderTopRightRadius: dg,
    borderBottomLeftRadius: dg,
    borderBottomRightRadius: dg,
    boxShadow: q5,
  };
function LD(i, { layout: e, layoutId: t }) {
  return (
    Fp.has(i) ||
    i.startsWith("origin") ||
    ((e || t !== void 0) && (!!pM[i] || i === "opacity"))
  );
}
function wT(i, e, t) {
  var o;
  const n = i.style,
    r = e == null ? void 0 : e.style,
    s = {};
  if (!n) return s;
  for (const u in n)
    (ys(n[u]) ||
      (r && ys(r[u])) ||
      LD(u, i) ||
      ((o = t == null ? void 0 : t.getValue(u)) == null
        ? void 0
        : o.liveStyle) !== void 0) &&
      (s[u] = n[u]);
  return s;
}
function Y5(i) {
  return window.getComputedStyle(i);
}
class Z5 extends ED {
  constructor() {
    (super(...arguments), (this.type = "html"), (this.renderInstance = DD));
  }
  readValueFromInstance(e, t) {
    var n;
    if (Fp.has(t))
      return (n = this.projection) != null && n.isProjecting ? eM(t) : d4(e, t);
    {
      const r = Y5(e),
        s = (kR(t) ? r.getPropertyValue(t) : r[t]) || 0;
      return typeof s == "string" ? s.trim() : s;
    }
  }
  measureInstanceViewportBox(e, { transformPagePoint: t }) {
    return RD(e, t);
  }
  build(e, t, n) {
    ET(e, t, n.transformTemplate);
  }
  scrapeMotionValuesFromProps(e, t, n) {
    return wT(e, t, n);
  }
}
const K5 = { offset: "stroke-dashoffset", array: "stroke-dasharray" },
  Q5 = { offset: "strokeDashoffset", array: "strokeDasharray" };
function J5(i, e, t = 1, n = 0, r = !0) {
  i.pathLength = 1;
  const s = r ? K5 : Q5;
  ((i[s.offset] = `${-n}`), (i[s.array] = `${e} ${t}`));
}
const $5 = ["offsetDistance", "offsetPath", "offsetRotate", "offsetAnchor"];
function ND(
  i,
  {
    attrX: e,
    attrY: t,
    attrScale: n,
    pathLength: r,
    pathSpacing: s = 1,
    pathOffset: o = 0,
    ...u
  },
  h,
  d,
  m,
) {
  if ((ET(i, u, d), h)) {
    i.style.viewBox && (i.attrs.viewBox = i.style.viewBox);
    return;
  }
  ((i.attrs = i.style), (i.style = {}));
  const { attrs: v, style: y } = i;
  (v.transform && ((y.transform = v.transform), delete v.transform),
    (y.transform || v.transformOrigin) &&
      ((y.transformOrigin = v.transformOrigin ?? "50% 50%"),
      delete v.transformOrigin),
    y.transform &&
      ((y.transformBox = (m == null ? void 0 : m.transformBox) ?? "fill-box"),
      delete v.transformBox));
  for (const b of $5) v[b] !== void 0 && ((y[b] = v[b]), delete v[b]);
  (e !== void 0 && (v.x = e),
    t !== void 0 && (v.y = t),
    n !== void 0 && (v.scale = n),
    r !== void 0 && J5(v, r, s, o, !1));
}
const UD = new Set([
    "baseFrequency",
    "diffuseConstant",
    "kernelMatrix",
    "kernelUnitLength",
    "keySplines",
    "keyTimes",
    "limitingConeAngle",
    "markerHeight",
    "markerWidth",
    "numOctaves",
    "targetX",
    "targetY",
    "surfaceScale",
    "specularConstant",
    "specularExponent",
    "stdDeviation",
    "tableValues",
    "viewBox",
    "gradientTransform",
    "pathLength",
    "startOffset",
    "textLength",
    "lengthAdjust",
  ]),
  PD = (i) => typeof i == "string" && i.toLowerCase() === "svg";
function e2(i, e, t, n) {
  DD(i, e, void 0, n);
  for (const r in e.attrs) i.setAttribute(UD.has(r) ? r : yT(r), e.attrs[r]);
}
function ID(i, e, t) {
  const n = wT(i, e, t);
  for (const r in i)
    if (ys(i[r]) || ys(e[r])) {
      const s =
        Op.indexOf(r) !== -1
          ? "attr" + r.charAt(0).toUpperCase() + r.substring(1)
          : r;
      n[s] = i[r];
    }
  return n;
}
class t2 extends ED {
  constructor() {
    (super(...arguments),
      (this.type = "svg"),
      (this.isSVGTag = !1),
      (this.measureInstanceViewportBox = Mr));
  }
  getBaseTargetFromProps(e, t) {
    return e[t];
  }
  readValueFromInstance(e, t) {
    if (Fp.has(t)) {
      const n = pD(t);
      return (n && n.default) || 0;
    }
    return ((t = UD.has(t) ? t : yT(t)), e.getAttribute(t));
  }
  scrapeMotionValuesFromProps(e, t, n) {
    return ID(e, t, n);
  }
  build(e, t, n) {
    ND(e, t, this.isSVGTag, n.transformTemplate, n.style);
  }
  renderInstance(e, t, n, r) {
    e2(e, t, n, r);
  }
  mount(e) {
    ((this.isSVGTag = PD(e.tagName)), super.mount(e));
  }
}
const n2 = TT.length;
function OD(i) {
  if (!i) return;
  if (!i.isControllingVariants) {
    const t = i.parent ? OD(i.parent) || {} : {};
    return (i.props.initial !== void 0 && (t.initial = i.props.initial), t);
  }
  const e = {};
  for (let t = 0; t < n2; t++) {
    const n = TT[t],
      r = i.props[n];
    (t0(r) || r === !1) && (e[n] = r);
  }
  return e;
}
function FD(i, e) {
  if (!Array.isArray(e)) return !1;
  const t = e.length;
  if (t !== i.length) return !1;
  for (let n = 0; n < t; n++) if (e[n] !== i[n]) return !1;
  return !0;
}
const i2 = [...MT].reverse(),
  r2 = MT.length;
function s2(i) {
  return (e) =>
    Promise.all(e.map(({ animation: t, options: n }) => e5(i, t, n)));
}
function a2(i) {
  let e = s2(i),
    t = iA(),
    n = !0;
  const r = (h) => (d, m) => {
    var y;
    const v = bp(
      i,
      m,
      h === "exit"
        ? (y = i.presenceContext) == null
          ? void 0
          : y.custom
        : void 0,
    );
    if (v) {
      const { transition: b, transitionEnd: _, ...w } = v;
      d = { ...d, ...w, ..._ };
    }
    return d;
  };
  function s(h) {
    e = h(i);
  }
  function o(h) {
    const { props: d } = i,
      m = OD(i.parent) || {},
      v = [],
      y = new Set();
    let b = {},
      _ = 1 / 0;
    for (let E = 0; E < r2; E++) {
      const T = i2[E],
        C = t[T],
        R = d[T] !== void 0 ? d[T] : m[T],
        L = t0(R),
        I = T === h ? C.isActive : null;
      I === !1 && (_ = E);
      let O = R === m[T] && R !== d[T] && L;
      if (
        (O && n && i.manuallyAnimateOnMount && (O = !1),
        (C.protectedKeys = { ...b }),
        (!C.isActive && I === null) ||
          (!R && !C.prevProp) ||
          X1(R) ||
          typeof R == "boolean")
      )
        continue;
      if (T === "exit" && C.isActive && I !== !0) {
        C.prevResolvedValues && (b = { ...b, ...C.prevResolvedValues });
        continue;
      }
      const B = o2(C.prevProp, R);
      let N = B || (T === h && C.isActive && !O && L) || (E > _ && L),
        F = !1;
      const j = Array.isArray(R) ? R : [R];
      let q = j.reduce(r(T), {});
      I === !1 && (q = {});
      const { prevResolvedValues: X = {} } = C,
        J = { ...X, ...q },
        ee = ($) => {
          ((N = !0),
            y.has($) && ((F = !0), y.delete($)),
            (C.needsAnimating[$] = !0));
          const de = i.getValue($);
          de && (de.liveStyle = !1);
        };
      for (const $ in J) {
        const de = q[$],
          le = X[$];
        if (b.hasOwnProperty($)) continue;
        let fe = !1;
        (aM(de) && aM(le) ? (fe = !FD(de, le)) : (fe = de !== le),
          fe
            ? de != null
              ? ee($)
              : y.add($)
            : de !== void 0 && y.has($)
              ? ee($)
              : (C.protectedKeys[$] = !0));
      }
      ((C.prevProp = R),
        (C.prevResolvedValues = q),
        C.isActive && (b = { ...b, ...q }),
        n && i.blockInitialAnimation && (N = !1));
      const ne = O && B;
      N &&
        (!ne || F) &&
        v.push(
          ...j.map(($) => {
            const de = { type: T };
            if (
              typeof $ == "string" &&
              n &&
              !ne &&
              i.manuallyAnimateOnMount &&
              i.parent
            ) {
              const { parent: le } = i,
                fe = bp(le, $);
              if (le.enteringChildren && fe) {
                const { delayChildren: V } = fe.transition || {};
                de.delay = sD(le.enteringChildren, i, V);
              }
            }
            return { animation: $, options: de };
          }),
        );
    }
    if (y.size) {
      const E = {};
      if (typeof d.initial != "boolean") {
        const T = bp(i, Array.isArray(d.initial) ? d.initial[0] : d.initial);
        T && T.transition && (E.transition = T.transition);
      }
      (y.forEach((T) => {
        const C = i.getBaseTarget(T),
          R = i.getValue(T);
        (R && (R.liveStyle = !0), (E[T] = C ?? null));
      }),
        v.push({ animation: E }));
    }
    let w = !!v.length;
    return (
      n &&
        (d.initial === !1 || d.initial === d.animate) &&
        !i.manuallyAnimateOnMount &&
        (w = !1),
      (n = !1),
      w ? e(v) : Promise.resolve()
    );
  }
  function u(h, d) {
    var v;
    if (t[h].isActive === d) return Promise.resolve();
    ((v = i.variantChildren) == null ||
      v.forEach((y) => {
        var b;
        return (b = y.animationState) == null ? void 0 : b.setActive(h, d);
      }),
      (t[h].isActive = d));
    const m = o(h);
    for (const y in t) t[y].protectedKeys = {};
    return m;
  }
  return {
    animateChanges: o,
    setActive: u,
    setAnimateFunction: s,
    getState: () => t,
    reset: () => {
      t = iA();
    },
  };
}
function o2(i, e) {
  return typeof e == "string" ? e !== i : Array.isArray(e) ? !FD(e, i) : !1;
}
function Qf(i = !1) {
  return {
    isActive: i,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {},
  };
}
function iA() {
  return {
    animate: Qf(!0),
    whileInView: Qf(),
    whileHover: Qf(),
    whileTap: Qf(),
    whileDrag: Qf(),
    whileFocus: Qf(),
    exit: Qf(),
  };
}
function rA(i, e) {
  ((i.min = e.min), (i.max = e.max));
}
function ko(i, e) {
  (rA(i.x, e.x), rA(i.y, e.y));
}
function sA(i, e) {
  ((i.translate = e.translate),
    (i.scale = e.scale),
    (i.originPoint = e.originPoint),
    (i.origin = e.origin));
}
const zD = 1e-4,
  l2 = 1 - zD,
  c2 = 1 + zD,
  BD = 0.01,
  u2 = 0 - BD,
  f2 = 0 + BD;
function Gs(i) {
  return i.max - i.min;
}
function h2(i, e, t) {
  return Math.abs(i - e) <= t;
}
function aA(i, e, t, n = 0.5) {
  ((i.origin = n),
    (i.originPoint = Ii(e.min, e.max, i.origin)),
    (i.scale = Gs(t) / Gs(e)),
    (i.translate = Ii(t.min, t.max, i.origin) - i.originPoint),
    ((i.scale >= l2 && i.scale <= c2) || isNaN(i.scale)) && (i.scale = 1),
    ((i.translate >= u2 && i.translate <= f2) || isNaN(i.translate)) &&
      (i.translate = 0));
}
function Ig(i, e, t, n) {
  (aA(i.x, e.x, t.x, n ? n.originX : void 0),
    aA(i.y, e.y, t.y, n ? n.originY : void 0));
}
function oA(i, e, t) {
  ((i.min = t.min + e.min), (i.max = i.min + Gs(e)));
}
function d2(i, e, t) {
  (oA(i.x, e.x, t.x), oA(i.y, e.y, t.y));
}
function lA(i, e, t) {
  ((i.min = e.min - t.min), (i.max = i.min + Gs(e)));
}
function Vx(i, e, t) {
  (lA(i.x, e.x, t.x), lA(i.y, e.y, t.y));
}
function cA(i, e, t, n, r) {
  return (
    (i -= e),
    (i = kx(i, 1 / t, n)),
    r !== void 0 && (i = kx(i, 1 / r, n)),
    i
  );
}
function p2(i, e = 0, t = 1, n = 0.5, r, s = i, o = i) {
  if (
    (Xl.test(e) &&
      ((e = parseFloat(e)), (e = Ii(o.min, o.max, e / 100) - o.min)),
    typeof e != "number")
  )
    return;
  let u = Ii(s.min, s.max, n);
  (i === s && (u -= e),
    (i.min = cA(i.min, e, t, u, r)),
    (i.max = cA(i.max, e, t, u, r)));
}
function uA(i, e, [t, n, r], s, o) {
  p2(i, e[t], e[n], e[r], e.scale, s, o);
}
const m2 = ["x", "scaleX", "originX"],
  g2 = ["y", "scaleY", "originY"];
function fA(i, e, t, n) {
  (uA(i.x, e, m2, t ? t.x : void 0, n ? n.x : void 0),
    uA(i.y, e, g2, t ? t.y : void 0, n ? n.y : void 0));
}
function hA(i) {
  return i.translate === 0 && i.scale === 1;
}
function kD(i) {
  return hA(i.x) && hA(i.y);
}
function dA(i, e) {
  return i.min === e.min && i.max === e.max;
}
function v2(i, e) {
  return dA(i.x, e.x) && dA(i.y, e.y);
}
function pA(i, e) {
  return (
    Math.round(i.min) === Math.round(e.min) &&
    Math.round(i.max) === Math.round(e.max)
  );
}
function VD(i, e) {
  return pA(i.x, e.x) && pA(i.y, e.y);
}
function mA(i) {
  return Gs(i.x) / Gs(i.y);
}
function gA(i, e) {
  return (
    i.translate === e.translate &&
    i.scale === e.scale &&
    i.originPoint === e.originPoint
  );
}
function kl(i) {
  return [i("x"), i("y")];
}
function y2(i, e, t) {
  let n = "";
  const r = i.x.translate / e.x,
    s = i.y.translate / e.y,
    o = (t == null ? void 0 : t.z) || 0;
  if (
    ((r || s || o) && (n = `translate3d(${r}px, ${s}px, ${o}px) `),
    (e.x !== 1 || e.y !== 1) && (n += `scale(${1 / e.x}, ${1 / e.y}) `),
    t)
  ) {
    const {
      transformPerspective: d,
      rotate: m,
      rotateX: v,
      rotateY: y,
      skewX: b,
      skewY: _,
    } = t;
    (d && (n = `perspective(${d}px) ${n}`),
      m && (n += `rotate(${m}deg) `),
      v && (n += `rotateX(${v}deg) `),
      y && (n += `rotateY(${y}deg) `),
      b && (n += `skewX(${b}deg) `),
      _ && (n += `skewY(${_}deg) `));
  }
  const u = i.x.scale * e.x,
    h = i.y.scale * e.y;
  return ((u !== 1 || h !== 1) && (n += `scale(${u}, ${h})`), n || "none");
}
const GD = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"],
  x2 = GD.length,
  vA = (i) => (typeof i == "string" ? parseFloat(i) : i),
  yA = (i) => typeof i == "number" || Ut.test(i);
function b2(i, e, t, n, r, s) {
  r
    ? ((i.opacity = Ii(0, t.opacity ?? 1, _2(n))),
      (i.opacityExit = Ii(e.opacity ?? 1, 0, S2(n))))
    : s && (i.opacity = Ii(e.opacity ?? 1, t.opacity ?? 1, n));
  for (let o = 0; o < x2; o++) {
    const u = `border${GD[o]}Radius`;
    let h = xA(e, u),
      d = xA(t, u);
    if (h === void 0 && d === void 0) continue;
    (h || (h = 0),
      d || (d = 0),
      h === 0 || d === 0 || yA(h) === yA(d)
        ? ((i[u] = Math.max(Ii(vA(h), vA(d), n), 0)),
          (Xl.test(d) || Xl.test(h)) && (i[u] += "%"))
        : (i[u] = d));
  }
  (e.rotate || t.rotate) && (i.rotate = Ii(e.rotate || 0, t.rotate || 0, n));
}
function xA(i, e) {
  return i[e] !== void 0 ? i[e] : i.borderRadius;
}
const _2 = HD(0, 0.5, PR),
  S2 = HD(0.5, 0.95, yo);
function HD(i, e, t) {
  return (n) => (n < i ? 0 : n > e ? 1 : t(Jg(i, e, n)));
}
function M2(i, e, t) {
  const n = ys(i) ? i : Mp(i);
  return (n.start(gT("", n, e, t)), n.animation);
}
function n0(i, e, t, n = { passive: !0 }) {
  return (i.addEventListener(e, t, n), () => i.removeEventListener(e, t));
}
const T2 = (i, e) => i.depth - e.depth;
class E2 {
  constructor() {
    ((this.children = []), (this.isDirty = !1));
  }
  add(e) {
    (tT(this.children, e), (this.isDirty = !0));
  }
  remove(e) {
    (Ix(this.children, e), (this.isDirty = !0));
  }
  forEach(e) {
    (this.isDirty && this.children.sort(T2),
      (this.isDirty = !1),
      this.children.forEach(e));
  }
}
function w2(i, e) {
  const t = Vs.now(),
    n = ({ timestamp: r }) => {
      const s = r - t;
      s >= e && (nf(n), i(s - e));
    };
  return (ui.setup(n, !0), () => nf(n));
}
function wx(i) {
  return ys(i) ? i.get() : i;
}
class A2 {
  constructor() {
    this.members = [];
  }
  add(e) {
    tT(this.members, e);
    for (let t = this.members.length - 1; t >= 0; t--) {
      const n = this.members[t];
      if (n === e || n === this.lead || n === this.prevLead) continue;
      const r = n.instance;
      r &&
        r.isConnected === !1 &&
        n.isPresent !== !1 &&
        !n.snapshot &&
        Ix(this.members, n);
    }
    e.scheduleRender();
  }
  remove(e) {
    if (
      (Ix(this.members, e),
      e === this.prevLead && (this.prevLead = void 0),
      e === this.lead)
    ) {
      const t = this.members[this.members.length - 1];
      t && this.promote(t);
    }
  }
  relegate(e) {
    const t = this.members.findIndex((r) => e === r);
    if (t === 0) return !1;
    let n;
    for (let r = t; r >= 0; r--) {
      const s = this.members[r],
        o = s.instance;
      if (s.isPresent !== !1 && (!o || o.isConnected !== !1)) {
        n = s;
        break;
      }
    }
    return n ? (this.promote(n), !0) : !1;
  }
  promote(e, t) {
    const n = this.lead;
    if (e !== n && ((this.prevLead = n), (this.lead = e), e.show(), n)) {
      (n.instance && n.scheduleRender(), e.scheduleRender());
      const r = n.options.layoutDependency,
        s = e.options.layoutDependency;
      if (!(r !== void 0 && s !== void 0 && r === s)) {
        const h = n.instance;
        (h && h.isConnected === !1 && !n.snapshot) ||
          ((e.resumeFrom = n),
          t && (e.resumeFrom.preserveOpacity = !0),
          n.snapshot &&
            ((e.snapshot = n.snapshot),
            (e.snapshot.latestValues = n.animationValues || n.latestValues)),
          e.root && e.root.isUpdating && (e.isLayoutDirty = !0));
      }
      const { crossfade: u } = e.options;
      u === !1 && n.hide();
    }
  }
  exitAnimationComplete() {
    this.members.forEach((e) => {
      const { options: t, resumingFrom: n } = e;
      (t.onExitComplete && t.onExitComplete(),
        n && n.options.onExitComplete && n.options.onExitComplete());
    });
  }
  scheduleRender() {
    this.members.forEach((e) => {
      e.instance && e.scheduleRender(!1);
    });
  }
  removeLeadSnapshot() {
    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
  }
}
const Ax = { hasAnimatedSinceResize: !0, hasEverUpdated: !1 },
  L_ = ["", "X", "Y", "Z"],
  C2 = 1e3;
let R2 = 0;
function N_(i, e, t, n) {
  const { latestValues: r } = e;
  r[i] && ((t[i] = r[i]), e.setStaticValue(i, 0), n && (n[i] = 0));
}
function jD(i) {
  if (((i.hasCheckedOptimisedAppear = !0), i.root === i)) return;
  const { visualElement: e } = i.options;
  if (!e) return;
  const t = uD(e);
  if (window.MotionHasOptimisedAnimation(t, "transform")) {
    const { layout: r, layoutId: s } = i.options;
    window.MotionCancelOptimisedAnimation(t, "transform", ui, !(r || s));
  }
  const { parent: n } = i;
  n && !n.hasCheckedOptimisedAppear && jD(n);
}
function WD({
  attachResizeListener: i,
  defaultParent: e,
  measureScroll: t,
  checkIsScrollRoot: n,
  resetTransform: r,
}) {
  return class {
    constructor(o = {}, u = e == null ? void 0 : e()) {
      ((this.id = R2++),
        (this.animationId = 0),
        (this.animationCommitId = 0),
        (this.children = new Set()),
        (this.options = {}),
        (this.isTreeAnimating = !1),
        (this.isAnimationBlocked = !1),
        (this.isLayoutDirty = !1),
        (this.isProjectionDirty = !1),
        (this.isSharedProjectionDirty = !1),
        (this.isTransformDirty = !1),
        (this.updateManuallyBlocked = !1),
        (this.updateBlockedByResize = !1),
        (this.isUpdating = !1),
        (this.isSVG = !1),
        (this.needsReset = !1),
        (this.shouldResetTransform = !1),
        (this.hasCheckedOptimisedAppear = !1),
        (this.treeScale = { x: 1, y: 1 }),
        (this.eventHandlers = new Map()),
        (this.hasTreeAnimated = !1),
        (this.layoutVersion = 0),
        (this.updateScheduled = !1),
        (this.scheduleUpdate = () => this.update()),
        (this.projectionUpdateScheduled = !1),
        (this.checkUpdateFailed = () => {
          this.isUpdating && ((this.isUpdating = !1), this.clearAllSnapshots());
        }),
        (this.updateProjection = () => {
          ((this.projectionUpdateScheduled = !1),
            this.nodes.forEach(N2),
            this.nodes.forEach(O2),
            this.nodes.forEach(F2),
            this.nodes.forEach(U2));
        }),
        (this.resolvedRelativeTargetAt = 0),
        (this.linkedParentVersion = 0),
        (this.hasProjected = !1),
        (this.isVisible = !0),
        (this.animationProgress = 0),
        (this.sharedNodes = new Map()),
        (this.latestValues = o),
        (this.root = u ? u.root || u : this),
        (this.path = u ? [...u.path, u] : []),
        (this.parent = u),
        (this.depth = u ? u.depth + 1 : 0));
      for (let h = 0; h < this.path.length; h++)
        this.path[h].shouldResetTransform = !0;
      this.root === this && (this.nodes = new E2());
    }
    addEventListener(o, u) {
      return (
        this.eventHandlers.has(o) || this.eventHandlers.set(o, new iT()),
        this.eventHandlers.get(o).add(u)
      );
    }
    notifyListeners(o, ...u) {
      const h = this.eventHandlers.get(o);
      h && h.notify(...u);
    }
    hasListeners(o) {
      return this.eventHandlers.has(o);
    }
    mount(o) {
      if (this.instance) return;
      ((this.isSVG = ST(o) && !L5(o)), (this.instance = o));
      const { layoutId: u, layout: h, visualElement: d } = this.options;
      if (
        (d && !d.current && d.mount(o),
        this.root.nodes.add(this),
        this.parent && this.parent.children.add(this),
        this.root.hasTreeAnimated && (h || u) && (this.isLayoutDirty = !0),
        i)
      ) {
        let m,
          v = 0;
        const y = () => (this.root.updateBlockedByResize = !1);
        (ui.read(() => {
          v = window.innerWidth;
        }),
          i(o, () => {
            const b = window.innerWidth;
            b !== v &&
              ((v = b),
              (this.root.updateBlockedByResize = !0),
              m && m(),
              (m = w2(y, 250)),
              Ax.hasAnimatedSinceResize &&
                ((Ax.hasAnimatedSinceResize = !1), this.nodes.forEach(SA)));
          }));
      }
      (u && this.root.registerSharedNode(u, this),
        this.options.animate !== !1 &&
          d &&
          (u || h) &&
          this.addEventListener(
            "didUpdate",
            ({
              delta: m,
              hasLayoutChanged: v,
              hasRelativeLayoutChanged: y,
              layout: b,
            }) => {
              if (this.isTreeAnimationBlocked()) {
                ((this.target = void 0), (this.relativeTarget = void 0));
                return;
              }
              const _ =
                  this.options.transition || d.getDefaultTransition() || G2,
                { onLayoutAnimationStart: w, onLayoutAnimationComplete: E } =
                  d.getProps(),
                T = !this.targetLayout || !VD(this.targetLayout, b),
                C = !v && y;
              if (
                this.options.layoutRoot ||
                this.resumeFrom ||
                C ||
                (v && (T || !this.currentAnimation))
              ) {
                this.resumeFrom &&
                  ((this.resumingFrom = this.resumeFrom),
                  (this.resumingFrom.resumingFrom = void 0));
                const R = { ...mT(_, "layout"), onPlay: w, onComplete: E };
                ((d.shouldReduceMotion || this.options.layoutRoot) &&
                  ((R.delay = 0), (R.type = !1)),
                  this.startAnimation(R),
                  this.setAnimationOrigin(m, C));
              } else
                (v || SA(this),
                  this.isLead() &&
                    this.options.onExitComplete &&
                    this.options.onExitComplete());
              this.targetLayout = b;
            },
          ));
    }
    unmount() {
      (this.options.layoutId && this.willUpdate(),
        this.root.nodes.remove(this));
      const o = this.getStack();
      (o && o.remove(this),
        this.parent && this.parent.children.delete(this),
        (this.instance = void 0),
        this.eventHandlers.clear(),
        nf(this.updateProjection));
    }
    blockUpdate() {
      this.updateManuallyBlocked = !0;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = !1;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return (
        this.isAnimationBlocked ||
        (this.parent && this.parent.isTreeAnimationBlocked()) ||
        !1
      );
    }
    startUpdate() {
      this.isUpdateBlocked() ||
        ((this.isUpdating = !0),
        this.nodes && this.nodes.forEach(z2),
        this.animationId++);
    }
    getTransformTemplate() {
      const { visualElement: o } = this.options;
      return o && o.getProps().transformTemplate;
    }
    willUpdate(o = !0) {
      if (((this.root.hasTreeAnimated = !0), this.root.isUpdateBlocked())) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if (
        (window.MotionCancelOptimisedAnimation &&
          !this.hasCheckedOptimisedAppear &&
          jD(this),
        !this.root.isUpdating && this.root.startUpdate(),
        this.isLayoutDirty)
      )
        return;
      this.isLayoutDirty = !0;
      for (let m = 0; m < this.path.length; m++) {
        const v = this.path[m];
        ((v.shouldResetTransform = !0),
          v.updateScroll("snapshot"),
          v.options.layoutRoot && v.willUpdate(!1));
      }
      const { layoutId: u, layout: h } = this.options;
      if (u === void 0 && !h) return;
      const d = this.getTransformTemplate();
      ((this.prevTransformTemplateValue = d
        ? d(this.latestValues, "")
        : void 0),
        this.updateSnapshot(),
        o && this.notifyListeners("willUpdate"));
    }
    update() {
      if (((this.updateScheduled = !1), this.isUpdateBlocked())) {
        (this.unblockUpdate(),
          this.clearAllSnapshots(),
          this.nodes.forEach(bA));
        return;
      }
      if (this.animationId <= this.animationCommitId) {
        this.nodes.forEach(_A);
        return;
      }
      ((this.animationCommitId = this.animationId),
        this.isUpdating
          ? ((this.isUpdating = !1),
            this.nodes.forEach(I2),
            this.nodes.forEach(D2),
            this.nodes.forEach(L2))
          : this.nodes.forEach(_A),
        this.clearAllSnapshots());
      const u = Vs.now();
      ((Qr.delta = Yl(0, 1e3 / 60, u - Qr.timestamp)),
        (Qr.timestamp = u),
        (Qr.isProcessing = !0),
        M_.update.process(Qr),
        M_.preRender.process(Qr),
        M_.render.process(Qr),
        (Qr.isProcessing = !1));
    }
    didUpdate() {
      this.updateScheduled ||
        ((this.updateScheduled = !0), bT.read(this.scheduleUpdate));
    }
    clearAllSnapshots() {
      (this.nodes.forEach(P2), this.sharedNodes.forEach(B2));
    }
    scheduleUpdateProjection() {
      this.projectionUpdateScheduled ||
        ((this.projectionUpdateScheduled = !0),
        ui.preRender(this.updateProjection, !1, !0));
    }
    scheduleCheckAfterUnmount() {
      ui.postRender(() => {
        this.isLayoutDirty
          ? this.root.didUpdate()
          : this.root.checkUpdateFailed();
      });
    }
    updateSnapshot() {
      this.snapshot ||
        !this.instance ||
        ((this.snapshot = this.measure()),
        this.snapshot &&
          !Gs(this.snapshot.measuredBox.x) &&
          !Gs(this.snapshot.measuredBox.y) &&
          (this.snapshot = void 0));
    }
    updateLayout() {
      if (
        !this.instance ||
        (this.updateScroll(),
        !(this.options.alwaysMeasureLayout && this.isLead()) &&
          !this.isLayoutDirty)
      )
        return;
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let h = 0; h < this.path.length; h++) this.path[h].updateScroll();
      const o = this.layout;
      ((this.layout = this.measure(!1)),
        this.layoutVersion++,
        (this.layoutCorrected = Mr()),
        (this.isLayoutDirty = !1),
        (this.projectionDelta = void 0),
        this.notifyListeners("measure", this.layout.layoutBox));
      const { visualElement: u } = this.options;
      u &&
        u.notify(
          "LayoutMeasure",
          this.layout.layoutBox,
          o ? o.layoutBox : void 0,
        );
    }
    updateScroll(o = "measure") {
      let u = !!(this.options.layoutScroll && this.instance);
      if (
        (this.scroll &&
          this.scroll.animationId === this.root.animationId &&
          this.scroll.phase === o &&
          (u = !1),
        u && this.instance)
      ) {
        const h = n(this.instance);
        this.scroll = {
          animationId: this.root.animationId,
          phase: o,
          isRoot: h,
          offset: t(this.instance),
          wasRoot: this.scroll ? this.scroll.isRoot : h,
        };
      }
    }
    resetTransform() {
      if (!r) return;
      const o =
          this.isLayoutDirty ||
          this.shouldResetTransform ||
          this.options.alwaysMeasureLayout,
        u = this.projectionDelta && !kD(this.projectionDelta),
        h = this.getTransformTemplate(),
        d = h ? h(this.latestValues, "") : void 0,
        m = d !== this.prevTransformTemplateValue;
      o &&
        this.instance &&
        (u || dh(this.latestValues) || m) &&
        (r(this.instance, d),
        (this.shouldResetTransform = !1),
        this.scheduleRender());
    }
    measure(o = !0) {
      const u = this.measurePageBox();
      let h = this.removeElementScroll(u);
      return (
        o && (h = this.removeTransform(h)),
        H2(h),
        {
          animationId: this.root.animationId,
          measuredBox: u,
          layoutBox: h,
          latestValues: {},
          source: this.id,
        }
      );
    }
    measurePageBox() {
      var d;
      const { visualElement: o } = this.options;
      if (!o) return Mr();
      const u = o.measureViewportBox();
      if (
        !(
          ((d = this.scroll) == null ? void 0 : d.wasRoot) || this.path.some(j2)
        )
      ) {
        const { scroll: m } = this.root;
        m && (mp(u.x, m.offset.x), mp(u.y, m.offset.y));
      }
      return u;
    }
    removeElementScroll(o) {
      var h;
      const u = Mr();
      if ((ko(u, o), (h = this.scroll) != null && h.wasRoot)) return u;
      for (let d = 0; d < this.path.length; d++) {
        const m = this.path[d],
          { scroll: v, options: y } = m;
        m !== this.root &&
          v &&
          y.layoutScroll &&
          (v.wasRoot && ko(u, o), mp(u.x, v.offset.x), mp(u.y, v.offset.y));
      }
      return u;
    }
    applyTransform(o, u = !1) {
      const h = Mr();
      ko(h, o);
      for (let d = 0; d < this.path.length; d++) {
        const m = this.path[d];
        (!u &&
          m.options.layoutScroll &&
          m.scroll &&
          m !== m.root &&
          gp(h, { x: -m.scroll.offset.x, y: -m.scroll.offset.y }),
          dh(m.latestValues) && gp(h, m.latestValues));
      }
      return (dh(this.latestValues) && gp(h, this.latestValues), h);
    }
    removeTransform(o) {
      const u = Mr();
      ko(u, o);
      for (let h = 0; h < this.path.length; h++) {
        const d = this.path[h];
        if (!d.instance || !dh(d.latestValues)) continue;
        hM(d.latestValues) && d.updateSnapshot();
        const m = Mr(),
          v = d.measurePageBox();
        (ko(m, v),
          fA(u, d.latestValues, d.snapshot ? d.snapshot.layoutBox : void 0, m));
      }
      return (dh(this.latestValues) && fA(u, this.latestValues), u);
    }
    setTargetDelta(o) {
      ((this.targetDelta = o),
        this.root.scheduleUpdateProjection(),
        (this.isProjectionDirty = !0));
    }
    setOptions(o) {
      this.options = {
        ...this.options,
        ...o,
        crossfade: o.crossfade !== void 0 ? o.crossfade : !0,
      };
    }
    clearMeasurements() {
      ((this.scroll = void 0),
        (this.layout = void 0),
        (this.snapshot = void 0),
        (this.prevTransformTemplateValue = void 0),
        (this.targetDelta = void 0),
        (this.target = void 0),
        (this.isLayoutDirty = !1));
    }
    forceRelativeParentToResolveTarget() {
      this.relativeParent &&
        this.relativeParent.resolvedRelativeTargetAt !== Qr.timestamp &&
        this.relativeParent.resolveTargetDelta(!0);
    }
    resolveTargetDelta(o = !1) {
      var b;
      const u = this.getLead();
      (this.isProjectionDirty || (this.isProjectionDirty = u.isProjectionDirty),
        this.isTransformDirty || (this.isTransformDirty = u.isTransformDirty),
        this.isSharedProjectionDirty ||
          (this.isSharedProjectionDirty = u.isSharedProjectionDirty));
      const h = !!this.resumingFrom || this !== u;
      if (
        !(
          o ||
          (h && this.isSharedProjectionDirty) ||
          this.isProjectionDirty ||
          ((b = this.parent) != null && b.isProjectionDirty) ||
          this.attemptToResolveRelativeTarget ||
          this.root.updateBlockedByResize
        )
      )
        return;
      const { layout: m, layoutId: v } = this.options;
      if (!this.layout || !(m || v)) return;
      this.resolvedRelativeTargetAt = Qr.timestamp;
      const y = this.getClosestProjectingParent();
      (y &&
        this.linkedParentVersion !== y.layoutVersion &&
        !y.options.layoutRoot &&
        this.removeRelativeTarget(),
        !this.targetDelta &&
          !this.relativeTarget &&
          (y && y.layout
            ? this.createRelativeTarget(
                y,
                this.layout.layoutBox,
                y.layout.layoutBox,
              )
            : this.removeRelativeTarget()),
        !(!this.relativeTarget && !this.targetDelta) &&
          (this.target ||
            ((this.target = Mr()), (this.targetWithTransforms = Mr())),
          this.relativeTarget &&
          this.relativeTargetOrigin &&
          this.relativeParent &&
          this.relativeParent.target
            ? (this.forceRelativeParentToResolveTarget(),
              d2(this.target, this.relativeTarget, this.relativeParent.target))
            : this.targetDelta
              ? (this.resumingFrom
                  ? (this.target = this.applyTransform(this.layout.layoutBox))
                  : ko(this.target, this.layout.layoutBox),
                CD(this.target, this.targetDelta))
              : ko(this.target, this.layout.layoutBox),
          this.attemptToResolveRelativeTarget &&
            ((this.attemptToResolveRelativeTarget = !1),
            y &&
            !!y.resumingFrom == !!this.resumingFrom &&
            !y.options.layoutScroll &&
            y.target &&
            this.animationProgress !== 1
              ? this.createRelativeTarget(y, this.target, y.target)
              : (this.relativeParent = this.relativeTarget = void 0))));
    }
    getClosestProjectingParent() {
      if (
        !(
          !this.parent ||
          hM(this.parent.latestValues) ||
          AD(this.parent.latestValues)
        )
      )
        return this.parent.isProjecting()
          ? this.parent
          : this.parent.getClosestProjectingParent();
    }
    isProjecting() {
      return !!(
        (this.relativeTarget || this.targetDelta || this.options.layoutRoot) &&
        this.layout
      );
    }
    createRelativeTarget(o, u, h) {
      ((this.relativeParent = o),
        (this.linkedParentVersion = o.layoutVersion),
        this.forceRelativeParentToResolveTarget(),
        (this.relativeTarget = Mr()),
        (this.relativeTargetOrigin = Mr()),
        Vx(this.relativeTargetOrigin, u, h),
        ko(this.relativeTarget, this.relativeTargetOrigin));
    }
    removeRelativeTarget() {
      this.relativeParent = this.relativeTarget = void 0;
    }
    calcProjection() {
      var _;
      const o = this.getLead(),
        u = !!this.resumingFrom || this !== o;
      let h = !0;
      if (
        ((this.isProjectionDirty ||
          ((_ = this.parent) != null && _.isProjectionDirty)) &&
          (h = !1),
        u &&
          (this.isSharedProjectionDirty || this.isTransformDirty) &&
          (h = !1),
        this.resolvedRelativeTargetAt === Qr.timestamp && (h = !1),
        h)
      )
        return;
      const { layout: d, layoutId: m } = this.options;
      if (
        ((this.isTreeAnimating = !!(
          (this.parent && this.parent.isTreeAnimating) ||
          this.currentAnimation ||
          this.pendingAnimation
        )),
        this.isTreeAnimating ||
          (this.targetDelta = this.relativeTarget = void 0),
        !this.layout || !(d || m))
      )
        return;
      ko(this.layoutCorrected, this.layout.layoutBox);
      const v = this.treeScale.x,
        y = this.treeScale.y;
      (G5(this.layoutCorrected, this.treeScale, this.path, u),
        o.layout &&
          !o.target &&
          (this.treeScale.x !== 1 || this.treeScale.y !== 1) &&
          ((o.target = o.layout.layoutBox), (o.targetWithTransforms = Mr())));
      const { target: b } = o;
      if (!b) {
        this.prevProjectionDelta &&
          (this.createProjectionDeltas(), this.scheduleRender());
        return;
      }
      (!this.projectionDelta || !this.prevProjectionDelta
        ? this.createProjectionDeltas()
        : (sA(this.prevProjectionDelta.x, this.projectionDelta.x),
          sA(this.prevProjectionDelta.y, this.projectionDelta.y)),
        Ig(this.projectionDelta, this.layoutCorrected, b, this.latestValues),
        (this.treeScale.x !== v ||
          this.treeScale.y !== y ||
          !gA(this.projectionDelta.x, this.prevProjectionDelta.x) ||
          !gA(this.projectionDelta.y, this.prevProjectionDelta.y)) &&
          ((this.hasProjected = !0),
          this.scheduleRender(),
          this.notifyListeners("projectionUpdate", b)));
    }
    hide() {
      this.isVisible = !1;
    }
    show() {
      this.isVisible = !0;
    }
    scheduleRender(o = !0) {
      var u;
      if (((u = this.options.visualElement) == null || u.scheduleRender(), o)) {
        const h = this.getStack();
        h && h.scheduleRender();
      }
      this.resumingFrom &&
        !this.resumingFrom.instance &&
        (this.resumingFrom = void 0);
    }
    createProjectionDeltas() {
      ((this.prevProjectionDelta = pp()),
        (this.projectionDelta = pp()),
        (this.projectionDeltaWithTransform = pp()));
    }
    setAnimationOrigin(o, u = !1) {
      const h = this.snapshot,
        d = h ? h.latestValues : {},
        m = { ...this.latestValues },
        v = pp();
      ((!this.relativeParent || !this.relativeParent.options.layoutRoot) &&
        (this.relativeTarget = this.relativeTargetOrigin = void 0),
        (this.attemptToResolveRelativeTarget = !u));
      const y = Mr(),
        b = h ? h.source : void 0,
        _ = this.layout ? this.layout.source : void 0,
        w = b !== _,
        E = this.getStack(),
        T = !E || E.members.length <= 1,
        C = !!(w && !T && this.options.crossfade === !0 && !this.path.some(V2));
      this.animationProgress = 0;
      let R;
      ((this.mixTargetDelta = (L) => {
        const I = L / 1e3;
        (MA(v.x, o.x, I),
          MA(v.y, o.y, I),
          this.setTargetDelta(v),
          this.relativeTarget &&
            this.relativeTargetOrigin &&
            this.layout &&
            this.relativeParent &&
            this.relativeParent.layout &&
            (Vx(y, this.layout.layoutBox, this.relativeParent.layout.layoutBox),
            k2(this.relativeTarget, this.relativeTargetOrigin, y, I),
            R && v2(this.relativeTarget, R) && (this.isProjectionDirty = !1),
            R || (R = Mr()),
            ko(R, this.relativeTarget)),
          w &&
            ((this.animationValues = m), b2(m, d, this.latestValues, I, C, T)),
          this.root.scheduleUpdateProjection(),
          this.scheduleRender(),
          (this.animationProgress = I));
      }),
        this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0));
    }
    startAnimation(o) {
      var u, h, d;
      (this.notifyListeners("animationStart"),
        (u = this.currentAnimation) == null || u.stop(),
        (d = (h = this.resumingFrom) == null ? void 0 : h.currentAnimation) ==
          null || d.stop(),
        this.pendingAnimation &&
          (nf(this.pendingAnimation), (this.pendingAnimation = void 0)),
        (this.pendingAnimation = ui.update(() => {
          ((Ax.hasAnimatedSinceResize = !0),
            this.motionValue || (this.motionValue = Mp(0)),
            this.motionValue.jump(0, !1),
            (this.currentAnimation = M2(this.motionValue, [0, 1e3], {
              ...o,
              velocity: 0,
              isSync: !0,
              onUpdate: (m) => {
                (this.mixTargetDelta(m), o.onUpdate && o.onUpdate(m));
              },
              onStop: () => {},
              onComplete: () => {
                (o.onComplete && o.onComplete(), this.completeAnimation());
              },
            })),
            this.resumingFrom &&
              (this.resumingFrom.currentAnimation = this.currentAnimation),
            (this.pendingAnimation = void 0));
        })));
    }
    completeAnimation() {
      this.resumingFrom &&
        ((this.resumingFrom.currentAnimation = void 0),
        (this.resumingFrom.preserveOpacity = void 0));
      const o = this.getStack();
      (o && o.exitAnimationComplete(),
        (this.resumingFrom =
          this.currentAnimation =
          this.animationValues =
            void 0),
        this.notifyListeners("animationComplete"));
    }
    finishAnimation() {
      (this.currentAnimation &&
        (this.mixTargetDelta && this.mixTargetDelta(C2),
        this.currentAnimation.stop()),
        this.completeAnimation());
    }
    applyTransformsToTarget() {
      const o = this.getLead();
      let {
        targetWithTransforms: u,
        target: h,
        layout: d,
        latestValues: m,
      } = o;
      if (!(!u || !h || !d)) {
        if (
          this !== o &&
          this.layout &&
          d &&
          XD(this.options.animationType, this.layout.layoutBox, d.layoutBox)
        ) {
          h = this.target || Mr();
          const v = Gs(this.layout.layoutBox.x);
          ((h.x.min = o.target.x.min), (h.x.max = h.x.min + v));
          const y = Gs(this.layout.layoutBox.y);
          ((h.y.min = o.target.y.min), (h.y.max = h.y.min + y));
        }
        (ko(u, h),
          gp(u, m),
          Ig(this.projectionDeltaWithTransform, this.layoutCorrected, u, m));
      }
    }
    registerSharedNode(o, u) {
      (this.sharedNodes.has(o) || this.sharedNodes.set(o, new A2()),
        this.sharedNodes.get(o).add(u));
      const d = u.options.initialPromotionConfig;
      u.promote({
        transition: d ? d.transition : void 0,
        preserveFollowOpacity:
          d && d.shouldPreserveFollowOpacity
            ? d.shouldPreserveFollowOpacity(u)
            : void 0,
      });
    }
    isLead() {
      const o = this.getStack();
      return o ? o.lead === this : !0;
    }
    getLead() {
      var u;
      const { layoutId: o } = this.options;
      return o
        ? ((u = this.getStack()) == null ? void 0 : u.lead) || this
        : this;
    }
    getPrevLead() {
      var u;
      const { layoutId: o } = this.options;
      return o ? ((u = this.getStack()) == null ? void 0 : u.prevLead) : void 0;
    }
    getStack() {
      const { layoutId: o } = this.options;
      if (o) return this.root.sharedNodes.get(o);
    }
    promote({ needsReset: o, transition: u, preserveFollowOpacity: h } = {}) {
      const d = this.getStack();
      (d && d.promote(this, h),
        o && ((this.projectionDelta = void 0), (this.needsReset = !0)),
        u && this.setOptions({ transition: u }));
    }
    relegate() {
      const o = this.getStack();
      return o ? o.relegate(this) : !1;
    }
    resetSkewAndRotation() {
      const { visualElement: o } = this.options;
      if (!o) return;
      let u = !1;
      const { latestValues: h } = o;
      if (
        ((h.z ||
          h.rotate ||
          h.rotateX ||
          h.rotateY ||
          h.rotateZ ||
          h.skewX ||
          h.skewY) &&
          (u = !0),
        !u)
      )
        return;
      const d = {};
      h.z && N_("z", o, d, this.animationValues);
      for (let m = 0; m < L_.length; m++)
        (N_(`rotate${L_[m]}`, o, d, this.animationValues),
          N_(`skew${L_[m]}`, o, d, this.animationValues));
      o.render();
      for (const m in d)
        (o.setStaticValue(m, d[m]),
          this.animationValues && (this.animationValues[m] = d[m]));
      o.scheduleRender();
    }
    applyProjectionStyles(o, u) {
      if (!this.instance || this.isSVG) return;
      if (!this.isVisible) {
        o.visibility = "hidden";
        return;
      }
      const h = this.getTransformTemplate();
      if (this.needsReset) {
        ((this.needsReset = !1),
          (o.visibility = ""),
          (o.opacity = ""),
          (o.pointerEvents = wx(u == null ? void 0 : u.pointerEvents) || ""),
          (o.transform = h ? h(this.latestValues, "") : "none"));
        return;
      }
      const d = this.getLead();
      if (!this.projectionDelta || !this.layout || !d.target) {
        (this.options.layoutId &&
          ((o.opacity =
            this.latestValues.opacity !== void 0
              ? this.latestValues.opacity
              : 1),
          (o.pointerEvents = wx(u == null ? void 0 : u.pointerEvents) || "")),
          this.hasProjected &&
            !dh(this.latestValues) &&
            ((o.transform = h ? h({}, "") : "none"), (this.hasProjected = !1)));
        return;
      }
      o.visibility = "";
      const m = d.animationValues || d.latestValues;
      this.applyTransformsToTarget();
      let v = y2(this.projectionDeltaWithTransform, this.treeScale, m);
      (h && (v = h(m, v)), (o.transform = v));
      const { x: y, y: b } = this.projectionDelta;
      ((o.transformOrigin = `${y.origin * 100}% ${b.origin * 100}% 0`),
        d.animationValues
          ? (o.opacity =
              d === this
                ? (m.opacity ?? this.latestValues.opacity ?? 1)
                : this.preserveOpacity
                  ? this.latestValues.opacity
                  : m.opacityExit)
          : (o.opacity =
              d === this
                ? m.opacity !== void 0
                  ? m.opacity
                  : ""
                : m.opacityExit !== void 0
                  ? m.opacityExit
                  : 0));
      for (const _ in pM) {
        if (m[_] === void 0) continue;
        const { correct: w, applyTo: E, isCSSVariable: T } = pM[_],
          C = v === "none" ? m[_] : w(m[_], d);
        if (E) {
          const R = E.length;
          for (let L = 0; L < R; L++) o[E[L]] = C;
        } else
          T ? (this.options.visualElement.renderState.vars[_] = C) : (o[_] = C);
      }
      this.options.layoutId &&
        (o.pointerEvents =
          d === this ? wx(u == null ? void 0 : u.pointerEvents) || "" : "none");
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    resetTree() {
      (this.root.nodes.forEach((o) => {
        var u;
        return (u = o.currentAnimation) == null ? void 0 : u.stop();
      }),
        this.root.nodes.forEach(bA),
        this.root.sharedNodes.clear());
    }
  };
}
function D2(i) {
  i.updateLayout();
}
function L2(i) {
  var t;
  const e = ((t = i.resumeFrom) == null ? void 0 : t.snapshot) || i.snapshot;
  if (i.isLead() && i.layout && e && i.hasListeners("didUpdate")) {
    const { layoutBox: n, measuredBox: r } = i.layout,
      { animationType: s } = i.options,
      o = e.source !== i.layout.source;
    s === "size"
      ? kl((v) => {
          const y = o ? e.measuredBox[v] : e.layoutBox[v],
            b = Gs(y);
          ((y.min = n[v].min), (y.max = y.min + b));
        })
      : XD(s, e.layoutBox, n) &&
        kl((v) => {
          const y = o ? e.measuredBox[v] : e.layoutBox[v],
            b = Gs(n[v]);
          ((y.max = y.min + b),
            i.relativeTarget &&
              !i.currentAnimation &&
              ((i.isProjectionDirty = !0),
              (i.relativeTarget[v].max = i.relativeTarget[v].min + b)));
        });
    const u = pp();
    Ig(u, n, e.layoutBox);
    const h = pp();
    o ? Ig(h, i.applyTransform(r, !0), e.measuredBox) : Ig(h, n, e.layoutBox);
    const d = !kD(u);
    let m = !1;
    if (!i.resumeFrom) {
      const v = i.getClosestProjectingParent();
      if (v && !v.resumeFrom) {
        const { snapshot: y, layout: b } = v;
        if (y && b) {
          const _ = Mr();
          Vx(_, e.layoutBox, y.layoutBox);
          const w = Mr();
          (Vx(w, n, b.layoutBox),
            VD(_, w) || (m = !0),
            v.options.layoutRoot &&
              ((i.relativeTarget = w),
              (i.relativeTargetOrigin = _),
              (i.relativeParent = v)));
        }
      }
    }
    i.notifyListeners("didUpdate", {
      layout: n,
      snapshot: e,
      delta: h,
      layoutDelta: u,
      hasLayoutChanged: d,
      hasRelativeLayoutChanged: m,
    });
  } else if (i.isLead()) {
    const { onExitComplete: n } = i.options;
    n && n();
  }
  i.options.transition = void 0;
}
function N2(i) {
  i.parent &&
    (i.isProjecting() || (i.isProjectionDirty = i.parent.isProjectionDirty),
    i.isSharedProjectionDirty ||
      (i.isSharedProjectionDirty = !!(
        i.isProjectionDirty ||
        i.parent.isProjectionDirty ||
        i.parent.isSharedProjectionDirty
      )),
    i.isTransformDirty || (i.isTransformDirty = i.parent.isTransformDirty));
}
function U2(i) {
  i.isProjectionDirty = i.isSharedProjectionDirty = i.isTransformDirty = !1;
}
function P2(i) {
  i.clearSnapshot();
}
function bA(i) {
  i.clearMeasurements();
}
function _A(i) {
  i.isLayoutDirty = !1;
}
function I2(i) {
  const { visualElement: e } = i.options;
  (e && e.getProps().onBeforeLayoutMeasure && e.notify("BeforeLayoutMeasure"),
    i.resetTransform());
}
function SA(i) {
  (i.finishAnimation(),
    (i.targetDelta = i.relativeTarget = i.target = void 0),
    (i.isProjectionDirty = !0));
}
function O2(i) {
  i.resolveTargetDelta();
}
function F2(i) {
  i.calcProjection();
}
function z2(i) {
  i.resetSkewAndRotation();
}
function B2(i) {
  i.removeLeadSnapshot();
}
function MA(i, e, t) {
  ((i.translate = Ii(e.translate, 0, t)),
    (i.scale = Ii(e.scale, 1, t)),
    (i.origin = e.origin),
    (i.originPoint = e.originPoint));
}
function TA(i, e, t, n) {
  ((i.min = Ii(e.min, t.min, n)), (i.max = Ii(e.max, t.max, n)));
}
function k2(i, e, t, n) {
  (TA(i.x, e.x, t.x, n), TA(i.y, e.y, t.y, n));
}
function V2(i) {
  return i.animationValues && i.animationValues.opacityExit !== void 0;
}
const G2 = { duration: 0.45, ease: [0.4, 0, 0.1, 1] },
  EA = (i) =>
    typeof navigator < "u" &&
    navigator.userAgent &&
    navigator.userAgent.toLowerCase().includes(i),
  wA = EA("applewebkit/") && !EA("chrome/") ? Math.round : yo;
function AA(i) {
  ((i.min = wA(i.min)), (i.max = wA(i.max)));
}
function H2(i) {
  (AA(i.x), AA(i.y));
}
function XD(i, e, t) {
  return (
    i === "position" || (i === "preserve-aspect" && !h2(mA(e), mA(t), 0.2))
  );
}
function j2(i) {
  var e;
  return i !== i.root && ((e = i.scroll) == null ? void 0 : e.wasRoot);
}
const W2 = WD({
    attachResizeListener: (i, e) => n0(i, "resize", e),
    measureScroll: () => {
      var i, e;
      return {
        x:
          document.documentElement.scrollLeft ||
          ((i = document.body) == null ? void 0 : i.scrollLeft) ||
          0,
        y:
          document.documentElement.scrollTop ||
          ((e = document.body) == null ? void 0 : e.scrollTop) ||
          0,
      };
    },
    checkIsScrollRoot: () => !0,
  }),
  U_ = { current: void 0 },
  qD = WD({
    measureScroll: (i) => ({ x: i.scrollLeft, y: i.scrollTop }),
    defaultParent: () => {
      if (!U_.current) {
        const i = new W2({});
        (i.mount(window), i.setOptions({ layoutScroll: !0 }), (U_.current = i));
      }
      return U_.current;
    },
    resetTransform: (i, e) => {
      i.style.transform = e !== void 0 ? e : "none";
    },
    checkIsScrollRoot: (i) => window.getComputedStyle(i).position === "fixed",
  }),
  YD = ie.createContext({
    transformPagePoint: (i) => i,
    isStatic: !1,
    reducedMotion: "never",
  });
function X2(i = !0) {
  const e = ie.useContext(eT);
  if (e === null) return [!0, null];
  const { isPresent: t, onExitComplete: n, register: r } = e,
    s = ie.useId();
  ie.useEffect(() => {
    if (i) return r(s);
  }, [i]);
  const o = ie.useCallback(() => i && n && n(s), [s, n, i]);
  return !t && n ? [!1, o] : [!0];
}
const ZD = ie.createContext({ strict: !1 }),
  CA = {
    animation: [
      "animate",
      "variants",
      "whileHover",
      "whileTap",
      "exit",
      "whileInView",
      "whileFocus",
      "whileDrag",
    ],
    exit: ["exit"],
    drag: ["drag", "dragControls"],
    focus: ["whileFocus"],
    hover: ["whileHover", "onHoverStart", "onHoverEnd"],
    tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
    pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
    inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
    layout: ["layout", "layoutId"],
  };
let RA = !1;
function q2() {
  if (RA) return;
  const i = {};
  for (const e in CA) i[e] = { isEnabled: (t) => CA[e].some((n) => !!t[n]) };
  (TD(i), (RA = !0));
}
function KD() {
  return (q2(), z5());
}
function Y2(i) {
  const e = KD();
  for (const t in i) e[t] = { ...e[t], ...i[t] };
  TD(e);
}
const Z2 = new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "custom",
  "inherit",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "globalTapTarget",
  "propagate",
  "ignoreStrict",
  "viewport",
]);
function Gx(i) {
  return (
    i.startsWith("while") ||
    (i.startsWith("drag") && i !== "draggable") ||
    i.startsWith("layout") ||
    i.startsWith("onTap") ||
    i.startsWith("onPan") ||
    i.startsWith("onLayout") ||
    Z2.has(i)
  );
}
let QD = (i) => !Gx(i);
function K2(i) {
  typeof i == "function" && (QD = (e) => (e.startsWith("on") ? !Gx(e) : i(e)));
}
try {
  K2(require("@emotion/is-prop-valid").default);
} catch {}
function Q2(i, e, t) {
  const n = {};
  for (const r in i)
    (r === "values" && typeof i.values == "object") ||
      ((QD(r) ||
        (t === !0 && Gx(r)) ||
        (!e && !Gx(r)) ||
        (i.draggable && r.startsWith("onDrag"))) &&
        (n[r] = i[r]));
  return n;
}
const Y1 = ie.createContext({});
function J2(i, e) {
  if (q1(i)) {
    const { initial: t, animate: n } = i;
    return {
      initial: t === !1 || t0(t) ? t : void 0,
      animate: t0(n) ? n : void 0,
    };
  }
  return i.inherit !== !1 ? e : {};
}
function $2(i) {
  const { initial: e, animate: t } = J2(i, ie.useContext(Y1));
  return ie.useMemo(() => ({ initial: e, animate: t }), [DA(e), DA(t)]);
}
function DA(i) {
  return Array.isArray(i) ? i.join(" ") : i;
}
const AT = () => ({ style: {}, transform: {}, transformOrigin: {}, vars: {} });
function JD(i, e, t) {
  for (const n in e) !ys(e[n]) && !LD(n, t) && (i[n] = e[n]);
}
function eF({ transformTemplate: i }, e) {
  return ie.useMemo(() => {
    const t = AT();
    return (ET(t, e, i), Object.assign({}, t.vars, t.style));
  }, [e]);
}
function tF(i, e) {
  const t = i.style || {},
    n = {};
  return (JD(n, t, i), Object.assign(n, eF(i, e)), n);
}
function nF(i, e) {
  const t = {},
    n = tF(i, e);
  return (
    i.drag &&
      i.dragListener !== !1 &&
      ((t.draggable = !1),
      (n.userSelect = n.WebkitUserSelect = n.WebkitTouchCallout = "none"),
      (n.touchAction =
        i.drag === !0 ? "none" : `pan-${i.drag === "x" ? "y" : "x"}`)),
    i.tabIndex === void 0 &&
      (i.onTap || i.onTapStart || i.whileTap) &&
      (t.tabIndex = 0),
    (t.style = n),
    t
  );
}
const $D = () => ({ ...AT(), attrs: {} });
function iF(i, e, t, n) {
  const r = ie.useMemo(() => {
    const s = $D();
    return (
      ND(s, e, PD(n), i.transformTemplate, i.style),
      { ...s.attrs, style: { ...s.style } }
    );
  }, [e]);
  if (i.style) {
    const s = {};
    (JD(s, i.style, i), (r.style = { ...s, ...r.style }));
  }
  return r;
}
const rF = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view",
];
function CT(i) {
  return typeof i != "string" || i.includes("-")
    ? !1
    : !!(rF.indexOf(i) > -1 || /[A-Z]/u.test(i));
}
function sF(i, e, t, { latestValues: n }, r, s = !1, o) {
  const h = ((o ?? CT(i)) ? iF : nF)(e, n, r, i),
    d = Q2(e, typeof i == "string", s),
    m = i !== ie.Fragment ? { ...d, ...h, ref: t } : {},
    { children: v } = e,
    y = ie.useMemo(() => (ys(v) ? v.get() : v), [v]);
  return ie.createElement(i, { ...m, children: y });
}
function aF({ scrapeMotionValuesFromProps: i, createRenderState: e }, t, n, r) {
  return { latestValues: oF(t, n, r, i), renderState: e() };
}
function oF(i, e, t, n) {
  const r = {},
    s = n(i, {});
  for (const y in s) r[y] = wx(s[y]);
  let { initial: o, animate: u } = i;
  const h = q1(i),
    d = SD(i);
  e &&
    d &&
    !h &&
    i.inherit !== !1 &&
    (o === void 0 && (o = e.initial), u === void 0 && (u = e.animate));
  let m = t ? t.initial === !1 : !1;
  m = m || o === !1;
  const v = m ? u : o;
  if (v && typeof v != "boolean" && !X1(v)) {
    const y = Array.isArray(v) ? v : [v];
    for (let b = 0; b < y.length; b++) {
      const _ = vT(i, y[b]);
      if (_) {
        const { transitionEnd: w, transition: E, ...T } = _;
        for (const C in T) {
          let R = T[C];
          if (Array.isArray(R)) {
            const L = m ? R.length - 1 : 0;
            R = R[L];
          }
          R !== null && (r[C] = R);
        }
        for (const C in w) r[C] = w[C];
      }
    }
  }
  return r;
}
const eL = (i) => (e, t) => {
    const n = ie.useContext(Y1),
      r = ie.useContext(eT),
      s = () => aF(i, e, n, r);
    return t ? s() : cO(s);
  },
  lF = eL({ scrapeMotionValuesFromProps: wT, createRenderState: AT }),
  cF = eL({ scrapeMotionValuesFromProps: ID, createRenderState: $D }),
  uF = Symbol.for("motionComponentSymbol");
function fF(i, e, t) {
  const n = ie.useRef(t);
  ie.useInsertionEffect(() => {
    n.current = t;
  });
  const r = ie.useRef(null);
  return ie.useCallback(
    (s) => {
      var u;
      (s && ((u = i.onMount) == null || u.call(i, s)),
        e && (s ? e.mount(s) : e.unmount()));
      const o = n.current;
      if (typeof o == "function")
        if (s) {
          const h = o(s);
          typeof h == "function" && (r.current = h);
        } else r.current ? (r.current(), (r.current = null)) : o(s);
      else o && (o.current = s);
    },
    [e],
  );
}
const tL = ie.createContext({});
function fp(i) {
  return (
    i &&
    typeof i == "object" &&
    Object.prototype.hasOwnProperty.call(i, "current")
  );
}
function hF(i, e, t, n, r, s) {
  var R, L;
  const { visualElement: o } = ie.useContext(Y1),
    u = ie.useContext(ZD),
    h = ie.useContext(eT),
    d = ie.useContext(YD),
    m = d.reducedMotion,
    v = d.skipAnimations,
    y = ie.useRef(null),
    b = ie.useRef(!1);
  ((n = n || u.renderer),
    !y.current &&
      n &&
      ((y.current = n(i, {
        visualState: e,
        parent: o,
        props: t,
        presenceContext: h,
        blockInitialAnimation: h ? h.initial === !1 : !1,
        reducedMotionConfig: m,
        skipAnimations: v,
        isSVG: s,
      })),
      b.current && y.current && (y.current.manuallyAnimateOnMount = !0)));
  const _ = y.current,
    w = ie.useContext(tL);
  _ &&
    !_.projection &&
    r &&
    (_.type === "html" || _.type === "svg") &&
    dF(y.current, t, r, w);
  const E = ie.useRef(!1);
  ie.useInsertionEffect(() => {
    _ && E.current && _.update(t, h);
  });
  const T = t[cD],
    C = ie.useRef(
      !!T &&
        !((R = window.MotionHandoffIsComplete) != null && R.call(window, T)) &&
        ((L = window.MotionHasOptimisedAnimation) == null
          ? void 0
          : L.call(window, T)),
    );
  return (
    uO(() => {
      ((b.current = !0),
        _ &&
          ((E.current = !0),
          (window.MotionIsMounted = !0),
          _.updateFeatures(),
          _.scheduleRenderMicrotask(),
          C.current && _.animationState && _.animationState.animateChanges()));
    }),
    ie.useEffect(() => {
      _ &&
        (!C.current && _.animationState && _.animationState.animateChanges(),
        C.current &&
          (queueMicrotask(() => {
            var I;
            (I = window.MotionHandoffMarkAsComplete) == null ||
              I.call(window, T);
          }),
          (C.current = !1)),
        (_.enteringChildren = void 0));
    }),
    _
  );
}
function dF(i, e, t, n) {
  const {
    layoutId: r,
    layout: s,
    drag: o,
    dragConstraints: u,
    layoutScroll: h,
    layoutRoot: d,
    layoutCrossfade: m,
  } = e;
  ((i.projection = new t(
    i.latestValues,
    e["data-framer-portal-id"] ? void 0 : nL(i.parent),
  )),
    i.projection.setOptions({
      layoutId: r,
      layout: s,
      alwaysMeasureLayout: !!o || (u && fp(u)),
      visualElement: i,
      animationType: typeof s == "string" ? s : "both",
      initialPromotionConfig: n,
      crossfade: m,
      layoutScroll: h,
      layoutRoot: d,
    }));
}
function nL(i) {
  if (i) return i.options.allowProjection !== !1 ? i.projection : nL(i.parent);
}
function P_(i, { forwardMotionProps: e = !1, type: t } = {}, n, r) {
  n && Y2(n);
  const s = t ? t === "svg" : CT(i),
    o = s ? cF : lF;
  function u(d, m) {
    let v;
    const y = { ...ie.useContext(YD), ...d, layoutId: pF(d) },
      { isStatic: b } = y,
      _ = $2(d),
      w = o(d, b);
    if (!b && SR) {
      mF();
      const E = gF(y);
      ((v = E.MeasureLayout),
        (_.visualElement = hF(i, w, y, r, E.ProjectionNode, s)));
    }
    return P.jsxs(Y1.Provider, {
      value: _,
      children: [
        v && _.visualElement
          ? P.jsx(v, { visualElement: _.visualElement, ...y })
          : null,
        sF(i, d, fF(w, _.visualElement, m), w, b, e, s),
      ],
    });
  }
  u.displayName = `motion.${typeof i == "string" ? i : `create(${i.displayName ?? i.name ?? ""})`}`;
  const h = ie.forwardRef(u);
  return ((h[uF] = i), h);
}
function pF({ layoutId: i }) {
  const e = ie.useContext(_R).id;
  return e && i !== void 0 ? e + "-" + i : i;
}
function mF(i, e) {
  ie.useContext(ZD).strict;
}
function gF(i) {
  const e = KD(),
    { drag: t, layout: n } = e;
  if (!t && !n) return {};
  const r = { ...t, ...n };
  return {
    MeasureLayout:
      (t != null && t.isEnabled(i)) || (n != null && n.isEnabled(i))
        ? r.MeasureLayout
        : void 0,
    ProjectionNode: r.ProjectionNode,
  };
}
function vF(i, e) {
  if (typeof Proxy > "u") return P_;
  const t = new Map(),
    n = (s, o) => P_(s, o, i, e),
    r = (s, o) => n(s, o);
  return new Proxy(r, {
    get: (s, o) =>
      o === "create"
        ? n
        : (t.has(o) || t.set(o, P_(o, void 0, i, e)), t.get(o)),
  });
}
const yF = (i, e) =>
  (e.isSVG ?? CT(i))
    ? new t2(e)
    : new Z5(e, { allowProjection: i !== ie.Fragment });
class xF extends uf {
  constructor(e) {
    (super(e), e.animationState || (e.animationState = a2(e)));
  }
  updateAnimationControlsSubscription() {
    const { animate: e } = this.node.getProps();
    X1(e) && (this.unmountControls = e.subscribe(this.node));
  }
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate: e } = this.node.getProps(),
      { animate: t } = this.node.prevProps || {};
    e !== t && this.updateAnimationControlsSubscription();
  }
  unmount() {
    var e;
    (this.node.animationState.reset(),
      (e = this.unmountControls) == null || e.call(this));
  }
}
let bF = 0;
class _F extends uf {
  constructor() {
    (super(...arguments), (this.id = bF++));
  }
  update() {
    if (!this.node.presenceContext) return;
    const { isPresent: e, onExitComplete: t } = this.node.presenceContext,
      { isPresent: n } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || e === n) return;
    const r = this.node.animationState.setActive("exit", !e);
    t &&
      !e &&
      r.then(() => {
        t(this.id);
      });
  }
  mount() {
    const { register: e, onExitComplete: t } = this.node.presenceContext || {};
    (t && t(this.id), e && (this.unmount = e(this.id)));
  }
  unmount() {}
}
const SF = { animation: { Feature: xF }, exit: { Feature: _F } };
function R0(i) {
  return { point: { x: i.pageX, y: i.pageY } };
}
const MF = (i) => (e) => _T(e) && i(e, R0(e));
function Og(i, e, t, n) {
  return n0(i, e, MF(t), n);
}
const iL = ({ current: i }) => (i ? i.ownerDocument.defaultView : null),
  LA = (i, e) => Math.abs(i - e);
function TF(i, e) {
  const t = LA(i.x, e.x),
    n = LA(i.y, e.y);
  return Math.sqrt(t ** 2 + n ** 2);
}
const NA = new Set(["auto", "scroll"]);
class rL {
  constructor(
    e,
    t,
    {
      transformPagePoint: n,
      contextWindow: r = window,
      dragSnapToOrigin: s = !1,
      distanceThreshold: o = 3,
      element: u,
    } = {},
  ) {
    if (
      ((this.startEvent = null),
      (this.lastMoveEvent = null),
      (this.lastMoveEventInfo = null),
      (this.handlers = {}),
      (this.contextWindow = window),
      (this.scrollPositions = new Map()),
      (this.removeScrollListeners = null),
      (this.onElementScroll = (b) => {
        this.handleScroll(b.target);
      }),
      (this.onWindowScroll = () => {
        this.handleScroll(window);
      }),
      (this.updatePoint = () => {
        if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return;
        const b = O_(this.lastMoveEventInfo, this.history),
          _ = this.startEvent !== null,
          w = TF(b.offset, { x: 0, y: 0 }) >= this.distanceThreshold;
        if (!_ && !w) return;
        const { point: E } = b,
          { timestamp: T } = Qr;
        this.history.push({ ...E, timestamp: T });
        const { onStart: C, onMove: R } = this.handlers;
        (_ ||
          (C && C(this.lastMoveEvent, b),
          (this.startEvent = this.lastMoveEvent)),
          R && R(this.lastMoveEvent, b));
      }),
      (this.handlePointerMove = (b, _) => {
        ((this.lastMoveEvent = b),
          (this.lastMoveEventInfo = I_(_, this.transformPagePoint)),
          ui.update(this.updatePoint, !0));
      }),
      (this.handlePointerUp = (b, _) => {
        this.end();
        const { onEnd: w, onSessionEnd: E, resumeAnimation: T } = this.handlers;
        if (
          ((this.dragSnapToOrigin || !this.startEvent) && T && T(),
          !(this.lastMoveEvent && this.lastMoveEventInfo))
        )
          return;
        const C = O_(
          b.type === "pointercancel"
            ? this.lastMoveEventInfo
            : I_(_, this.transformPagePoint),
          this.history,
        );
        (this.startEvent && w && w(b, C), E && E(b, C));
      }),
      !_T(e))
    )
      return;
    ((this.dragSnapToOrigin = s),
      (this.handlers = t),
      (this.transformPagePoint = n),
      (this.distanceThreshold = o),
      (this.contextWindow = r || window));
    const h = R0(e),
      d = I_(h, this.transformPagePoint),
      { point: m } = d,
      { timestamp: v } = Qr;
    this.history = [{ ...m, timestamp: v }];
    const { onSessionStart: y } = t;
    (y && y(e, O_(d, this.history)),
      (this.removeListeners = w0(
        Og(this.contextWindow, "pointermove", this.handlePointerMove),
        Og(this.contextWindow, "pointerup", this.handlePointerUp),
        Og(this.contextWindow, "pointercancel", this.handlePointerUp),
      )),
      u && this.startScrollTracking(u));
  }
  startScrollTracking(e) {
    let t = e.parentElement;
    for (; t; ) {
      const n = getComputedStyle(t);
      ((NA.has(n.overflowX) || NA.has(n.overflowY)) &&
        this.scrollPositions.set(t, { x: t.scrollLeft, y: t.scrollTop }),
        (t = t.parentElement));
    }
    (this.scrollPositions.set(window, { x: window.scrollX, y: window.scrollY }),
      window.addEventListener("scroll", this.onElementScroll, { capture: !0 }),
      window.addEventListener("scroll", this.onWindowScroll),
      (this.removeScrollListeners = () => {
        (window.removeEventListener("scroll", this.onElementScroll, {
          capture: !0,
        }),
          window.removeEventListener("scroll", this.onWindowScroll));
      }));
  }
  handleScroll(e) {
    const t = this.scrollPositions.get(e);
    if (!t) return;
    const n = e === window,
      r = n
        ? { x: window.scrollX, y: window.scrollY }
        : { x: e.scrollLeft, y: e.scrollTop },
      s = { x: r.x - t.x, y: r.y - t.y };
    (s.x === 0 && s.y === 0) ||
      (n
        ? this.lastMoveEventInfo &&
          ((this.lastMoveEventInfo.point.x += s.x),
          (this.lastMoveEventInfo.point.y += s.y))
        : this.history.length > 0 &&
          ((this.history[0].x -= s.x), (this.history[0].y -= s.y)),
      this.scrollPositions.set(e, r),
      ui.update(this.updatePoint, !0));
  }
  updateHandlers(e) {
    this.handlers = e;
  }
  end() {
    (this.removeListeners && this.removeListeners(),
      this.removeScrollListeners && this.removeScrollListeners(),
      this.scrollPositions.clear(),
      nf(this.updatePoint));
  }
}
function I_(i, e) {
  return e ? { point: e(i.point) } : i;
}
function UA(i, e) {
  return { x: i.x - e.x, y: i.y - e.y };
}
function O_({ point: i }, e) {
  return {
    point: i,
    delta: UA(i, sL(e)),
    offset: UA(i, EF(e)),
    velocity: wF(e, 0.1),
  };
}
function EF(i) {
  return i[0];
}
function sL(i) {
  return i[i.length - 1];
}
function wF(i, e) {
  if (i.length < 2) return { x: 0, y: 0 };
  let t = i.length - 1,
    n = null;
  const r = sL(i);
  for (; t >= 0 && ((n = i[t]), !(r.timestamp - n.timestamp > Yo(e))); ) t--;
  if (!n) return { x: 0, y: 0 };
  n === i[0] &&
    i.length > 2 &&
    r.timestamp - n.timestamp > Yo(e) * 2 &&
    (n = i[1]);
  const s = vo(r.timestamp - n.timestamp);
  if (s === 0) return { x: 0, y: 0 };
  const o = { x: (r.x - n.x) / s, y: (r.y - n.y) / s };
  return (o.x === 1 / 0 && (o.x = 0), o.y === 1 / 0 && (o.y = 0), o);
}
function AF(i, { min: e, max: t }, n) {
  return (
    e !== void 0 && i < e
      ? (i = n ? Ii(e, i, n.min) : Math.max(i, e))
      : t !== void 0 && i > t && (i = n ? Ii(t, i, n.max) : Math.min(i, t)),
    i
  );
}
function PA(i, e, t) {
  return {
    min: e !== void 0 ? i.min + e : void 0,
    max: t !== void 0 ? i.max + t - (i.max - i.min) : void 0,
  };
}
function CF(i, { top: e, left: t, bottom: n, right: r }) {
  return { x: PA(i.x, t, r), y: PA(i.y, e, n) };
}
function IA(i, e) {
  let t = e.min - i.min,
    n = e.max - i.max;
  return (
    e.max - e.min < i.max - i.min && ([t, n] = [n, t]),
    { min: t, max: n }
  );
}
function RF(i, e) {
  return { x: IA(i.x, e.x), y: IA(i.y, e.y) };
}
function DF(i, e) {
  let t = 0.5;
  const n = Gs(i),
    r = Gs(e);
  return (
    r > n
      ? (t = Jg(e.min, e.max - n, i.min))
      : n > r && (t = Jg(i.min, i.max - r, e.min)),
    Yl(0, 1, t)
  );
}
function LF(i, e) {
  const t = {};
  return (
    e.min !== void 0 && (t.min = e.min - i.min),
    e.max !== void 0 && (t.max = e.max - i.min),
    t
  );
}
const mM = 0.35;
function NF(i = mM) {
  return (
    i === !1 ? (i = 0) : i === !0 && (i = mM),
    { x: OA(i, "left", "right"), y: OA(i, "top", "bottom") }
  );
}
function OA(i, e, t) {
  return { min: FA(i, e), max: FA(i, t) };
}
function FA(i, e) {
  return typeof i == "number" ? i : i[e] || 0;
}
const UF = new WeakMap();
class PF {
  constructor(e) {
    ((this.openDragLock = null),
      (this.isDragging = !1),
      (this.currentDirection = null),
      (this.originPoint = { x: 0, y: 0 }),
      (this.constraints = !1),
      (this.hasMutatedConstraints = !1),
      (this.elastic = Mr()),
      (this.latestPointerEvent = null),
      (this.latestPanInfo = null),
      (this.visualElement = e));
  }
  start(e, { snapToCursor: t = !1, distanceThreshold: n } = {}) {
    const { presenceContext: r } = this.visualElement;
    if (r && r.isPresent === !1) return;
    const s = (v) => {
        (t && this.snapToCursor(R0(v).point), this.stopAnimation());
      },
      o = (v, y) => {
        const { drag: b, dragPropagation: _, onDragStart: w } = this.getProps();
        if (
          b &&
          !_ &&
          (this.openDragLock && this.openDragLock(),
          (this.openDragLock = p5(b)),
          !this.openDragLock)
        )
          return;
        ((this.latestPointerEvent = v),
          (this.latestPanInfo = y),
          (this.isDragging = !0),
          (this.currentDirection = null),
          this.resolveConstraints(),
          this.visualElement.projection &&
            ((this.visualElement.projection.isAnimationBlocked = !0),
            (this.visualElement.projection.target = void 0)),
          kl((T) => {
            let C = this.getAxisMotionValue(T).get() || 0;
            if (Xl.test(C)) {
              const { projection: R } = this.visualElement;
              if (R && R.layout) {
                const L = R.layout.layoutBox[T];
                L && (C = Gs(L) * (parseFloat(C) / 100));
              }
            }
            this.originPoint[T] = C;
          }),
          w && ui.update(() => w(v, y), !1, !0),
          oM(this.visualElement, "transform"));
        const { animationState: E } = this.visualElement;
        E && E.setActive("whileDrag", !0);
      },
      u = (v, y) => {
        ((this.latestPointerEvent = v), (this.latestPanInfo = y));
        const {
          dragPropagation: b,
          dragDirectionLock: _,
          onDirectionLock: w,
          onDrag: E,
        } = this.getProps();
        if (!b && !this.openDragLock) return;
        const { offset: T } = y;
        if (_ && this.currentDirection === null) {
          ((this.currentDirection = OF(T)),
            this.currentDirection !== null && w && w(this.currentDirection));
          return;
        }
        (this.updateAxis("x", y.point, T),
          this.updateAxis("y", y.point, T),
          this.visualElement.render(),
          E && ui.update(() => E(v, y), !1, !0));
      },
      h = (v, y) => {
        ((this.latestPointerEvent = v),
          (this.latestPanInfo = y),
          this.stop(v, y),
          (this.latestPointerEvent = null),
          (this.latestPanInfo = null));
      },
      d = () => {
        const { dragSnapToOrigin: v } = this.getProps();
        (v || this.constraints) && this.startAnimation({ x: 0, y: 0 });
      },
      { dragSnapToOrigin: m } = this.getProps();
    this.panSession = new rL(
      e,
      {
        onSessionStart: s,
        onStart: o,
        onMove: u,
        onSessionEnd: h,
        resumeAnimation: d,
      },
      {
        transformPagePoint: this.visualElement.getTransformPagePoint(),
        dragSnapToOrigin: m,
        distanceThreshold: n,
        contextWindow: iL(this.visualElement),
        element: this.visualElement.current,
      },
    );
  }
  stop(e, t) {
    const n = e || this.latestPointerEvent,
      r = t || this.latestPanInfo,
      s = this.isDragging;
    if ((this.cancel(), !s || !r || !n)) return;
    const { velocity: o } = r;
    this.startAnimation(o);
    const { onDragEnd: u } = this.getProps();
    u && ui.postRender(() => u(n, r));
  }
  cancel() {
    this.isDragging = !1;
    const { projection: e, animationState: t } = this.visualElement;
    (e && (e.isAnimationBlocked = !1), this.endPanSession());
    const { dragPropagation: n } = this.getProps();
    (!n &&
      this.openDragLock &&
      (this.openDragLock(), (this.openDragLock = null)),
      t && t.setActive("whileDrag", !1));
  }
  endPanSession() {
    (this.panSession && this.panSession.end(), (this.panSession = void 0));
  }
  updateAxis(e, t, n) {
    const { drag: r } = this.getProps();
    if (!n || !yy(e, r, this.currentDirection)) return;
    const s = this.getAxisMotionValue(e);
    let o = this.originPoint[e] + n[e];
    (this.constraints &&
      this.constraints[e] &&
      (o = AF(o, this.constraints[e], this.elastic[e])),
      s.set(o));
  }
  resolveConstraints() {
    var s;
    const { dragConstraints: e, dragElastic: t } = this.getProps(),
      n =
        this.visualElement.projection && !this.visualElement.projection.layout
          ? this.visualElement.projection.measure(!1)
          : (s = this.visualElement.projection) == null
            ? void 0
            : s.layout,
      r = this.constraints;
    (e && fp(e)
      ? this.constraints || (this.constraints = this.resolveRefConstraints())
      : e && n
        ? (this.constraints = CF(n.layoutBox, e))
        : (this.constraints = !1),
      (this.elastic = NF(t)),
      r !== this.constraints &&
        !fp(e) &&
        n &&
        this.constraints &&
        !this.hasMutatedConstraints &&
        kl((o) => {
          this.constraints !== !1 &&
            this.getAxisMotionValue(o) &&
            (this.constraints[o] = LF(n.layoutBox[o], this.constraints[o]));
        }));
  }
  resolveRefConstraints() {
    const { dragConstraints: e, onMeasureDragConstraints: t } = this.getProps();
    if (!e || !fp(e)) return !1;
    const n = e.current,
      { projection: r } = this.visualElement;
    if (!r || !r.layout) return !1;
    const s = H5(n, r.root, this.visualElement.getTransformPagePoint());
    let o = RF(r.layout.layoutBox, s);
    if (t) {
      const u = t(k5(o));
      ((this.hasMutatedConstraints = !!u), u && (o = wD(u)));
    }
    return o;
  }
  startAnimation(e) {
    const {
        drag: t,
        dragMomentum: n,
        dragElastic: r,
        dragTransition: s,
        dragSnapToOrigin: o,
        onDragTransitionEnd: u,
      } = this.getProps(),
      h = this.constraints || {},
      d = kl((m) => {
        if (!yy(m, t, this.currentDirection)) return;
        let v = (h && h[m]) || {};
        o && (v = { min: 0, max: 0 });
        const y = r ? 200 : 1e6,
          b = r ? 40 : 1e7,
          _ = {
            type: "inertia",
            velocity: n ? e[m] : 0,
            bounceStiffness: y,
            bounceDamping: b,
            timeConstant: 750,
            restDelta: 1,
            restSpeed: 10,
            ...s,
            ...v,
          };
        return this.startAxisValueAnimation(m, _);
      });
    return Promise.all(d).then(u);
  }
  startAxisValueAnimation(e, t) {
    const n = this.getAxisMotionValue(e);
    return (
      oM(this.visualElement, e),
      n.start(gT(e, n, 0, t, this.visualElement, !1))
    );
  }
  stopAnimation() {
    kl((e) => this.getAxisMotionValue(e).stop());
  }
  getAxisMotionValue(e) {
    const t = `_drag${e.toUpperCase()}`,
      n = this.visualElement.getProps(),
      r = n[t];
    return (
      r ||
      this.visualElement.getValue(e, (n.initial ? n.initial[e] : void 0) || 0)
    );
  }
  snapToCursor(e) {
    kl((t) => {
      const { drag: n } = this.getProps();
      if (!yy(t, n, this.currentDirection)) return;
      const { projection: r } = this.visualElement,
        s = this.getAxisMotionValue(t);
      if (r && r.layout) {
        const { min: o, max: u } = r.layout.layoutBox[t],
          h = s.get() || 0;
        s.set(e[t] - Ii(o, u, 0.5) + h);
      }
    });
  }
  scalePositionWithinConstraints() {
    if (!this.visualElement.current) return;
    const { drag: e, dragConstraints: t } = this.getProps(),
      { projection: n } = this.visualElement;
    if (!fp(t) || !n || !this.constraints) return;
    this.stopAnimation();
    const r = { x: 0, y: 0 };
    kl((o) => {
      const u = this.getAxisMotionValue(o);
      if (u && this.constraints !== !1) {
        const h = u.get();
        r[o] = DF({ min: h, max: h }, this.constraints[o]);
      }
    });
    const { transformTemplate: s } = this.visualElement.getProps();
    ((this.visualElement.current.style.transform = s ? s({}, "") : "none"),
      n.root && n.root.updateScroll(),
      n.updateLayout(),
      (this.constraints = !1),
      this.resolveConstraints(),
      kl((o) => {
        if (!yy(o, e, null)) return;
        const u = this.getAxisMotionValue(o),
          { min: h, max: d } = this.constraints[o];
        u.set(Ii(h, d, r[o]));
      }),
      this.visualElement.render());
  }
  addListeners() {
    if (!this.visualElement.current) return;
    UF.set(this.visualElement, this);
    const e = this.visualElement.current,
      t = Og(e, "pointerdown", (d) => {
        const { drag: m, dragListener: v = !0 } = this.getProps(),
          y = d.target,
          b = y !== e && b5(y);
        m && v && !b && this.start(d);
      });
    let n;
    const r = () => {
        const { dragConstraints: d } = this.getProps();
        fp(d) &&
          d.current &&
          ((this.constraints = this.resolveRefConstraints()),
          n ||
            (n = IF(e, d.current, () =>
              this.scalePositionWithinConstraints(),
            )));
      },
      { projection: s } = this.visualElement,
      o = s.addEventListener("measure", r);
    (s && !s.layout && (s.root && s.root.updateScroll(), s.updateLayout()),
      ui.read(r));
    const u = n0(window, "resize", () => this.scalePositionWithinConstraints()),
      h = s.addEventListener(
        "didUpdate",
        ({ delta: d, hasLayoutChanged: m }) => {
          this.isDragging &&
            m &&
            (kl((v) => {
              const y = this.getAxisMotionValue(v);
              y &&
                ((this.originPoint[v] += d[v].translate),
                y.set(y.get() + d[v].translate));
            }),
            this.visualElement.render());
        },
      );
    return () => {
      (u(), t(), o(), h && h(), n && n());
    };
  }
  getProps() {
    const e = this.visualElement.getProps(),
      {
        drag: t = !1,
        dragDirectionLock: n = !1,
        dragPropagation: r = !1,
        dragConstraints: s = !1,
        dragElastic: o = mM,
        dragMomentum: u = !0,
      } = e;
    return {
      ...e,
      drag: t,
      dragDirectionLock: n,
      dragPropagation: r,
      dragConstraints: s,
      dragElastic: o,
      dragMomentum: u,
    };
  }
}
function zA(i) {
  let e = !0;
  return () => {
    if (e) {
      e = !1;
      return;
    }
    i();
  };
}
function IF(i, e, t) {
  const n = qw(i, zA(t)),
    r = qw(e, zA(t));
  return () => {
    (n(), r());
  };
}
function yy(i, e, t) {
  return (e === !0 || e === i) && (t === null || t === i);
}
function OF(i, e = 10) {
  let t = null;
  return (Math.abs(i.y) > e ? (t = "y") : Math.abs(i.x) > e && (t = "x"), t);
}
class FF extends uf {
  constructor(e) {
    (super(e),
      (this.removeGroupControls = yo),
      (this.removeListeners = yo),
      (this.controls = new PF(e)));
  }
  mount() {
    const { dragControls: e } = this.node.getProps();
    (e && (this.removeGroupControls = e.subscribe(this.controls)),
      (this.removeListeners = this.controls.addListeners() || yo));
  }
  update() {
    const { dragControls: e } = this.node.getProps(),
      { dragControls: t } = this.node.prevProps || {};
    e !== t &&
      (this.removeGroupControls(),
      e && (this.removeGroupControls = e.subscribe(this.controls)));
  }
  unmount() {
    (this.removeGroupControls(),
      this.removeListeners(),
      this.controls.isDragging || this.controls.endPanSession());
  }
}
const F_ = (i) => (e, t) => {
  i && ui.update(() => i(e, t), !1, !0);
};
class zF extends uf {
  constructor() {
    (super(...arguments), (this.removePointerDownListener = yo));
  }
  onPointerDown(e) {
    this.session = new rL(e, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
      contextWindow: iL(this.node),
    });
  }
  createPanHandlers() {
    const {
      onPanSessionStart: e,
      onPanStart: t,
      onPan: n,
      onPanEnd: r,
    } = this.node.getProps();
    return {
      onSessionStart: F_(e),
      onStart: F_(t),
      onMove: F_(n),
      onEnd: (s, o) => {
        (delete this.session, r && ui.postRender(() => r(s, o)));
      },
    };
  }
  mount() {
    this.removePointerDownListener = Og(this.node.current, "pointerdown", (e) =>
      this.onPointerDown(e),
    );
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    (this.removePointerDownListener(), this.session && this.session.end());
  }
}
let z_ = !1;
class BF extends ie.Component {
  componentDidMount() {
    const {
        visualElement: e,
        layoutGroup: t,
        switchLayoutGroup: n,
        layoutId: r,
      } = this.props,
      { projection: s } = e;
    (s &&
      (t.group && t.group.add(s),
      n && n.register && r && n.register(s),
      z_ && s.root.didUpdate(),
      s.addEventListener("animationComplete", () => {
        this.safeToRemove();
      }),
      s.setOptions({
        ...s.options,
        layoutDependency: this.props.layoutDependency,
        onExitComplete: () => this.safeToRemove(),
      })),
      (Ax.hasEverUpdated = !0));
  }
  getSnapshotBeforeUpdate(e) {
    const {
        layoutDependency: t,
        visualElement: n,
        drag: r,
        isPresent: s,
      } = this.props,
      { projection: o } = n;
    return (
      o &&
        ((o.isPresent = s),
        e.layoutDependency !== t &&
          o.setOptions({ ...o.options, layoutDependency: t }),
        (z_ = !0),
        r || e.layoutDependency !== t || t === void 0 || e.isPresent !== s
          ? o.willUpdate()
          : this.safeToRemove(),
        e.isPresent !== s &&
          (s
            ? o.promote()
            : o.relegate() ||
              ui.postRender(() => {
                const u = o.getStack();
                (!u || !u.members.length) && this.safeToRemove();
              }))),
      null
    );
  }
  componentDidUpdate() {
    const { projection: e } = this.props.visualElement;
    e &&
      (e.root.didUpdate(),
      bT.postRender(() => {
        !e.currentAnimation && e.isLead() && this.safeToRemove();
      }));
  }
  componentWillUnmount() {
    const {
        visualElement: e,
        layoutGroup: t,
        switchLayoutGroup: n,
      } = this.props,
      { projection: r } = e;
    ((z_ = !0),
      r &&
        (r.scheduleCheckAfterUnmount(),
        t && t.group && t.group.remove(r),
        n && n.deregister && n.deregister(r)));
  }
  safeToRemove() {
    const { safeToRemove: e } = this.props;
    e && e();
  }
  render() {
    return null;
  }
}
function aL(i) {
  const [e, t] = X2(),
    n = ie.useContext(_R);
  return P.jsx(BF, {
    ...i,
    layoutGroup: n,
    switchLayoutGroup: ie.useContext(tL),
    isPresent: e,
    safeToRemove: t,
  });
}
const kF = {
  pan: { Feature: zF },
  drag: { Feature: FF, ProjectionNode: qD, MeasureLayout: aL },
};
function BA(i, e, t) {
  const { props: n } = i;
  i.animationState &&
    n.whileHover &&
    i.animationState.setActive("whileHover", t === "Start");
  const r = "onHover" + t,
    s = n[r];
  s && ui.postRender(() => s(e, R0(e)));
}
class VF extends uf {
  mount() {
    const { current: e } = this.node;
    e &&
      (this.unmount = g5(
        e,
        (t, n) => (BA(this.node, n, "Start"), (r) => BA(this.node, r, "End")),
      ));
  }
  unmount() {}
}
class GF extends uf {
  constructor() {
    (super(...arguments), (this.isActive = !1));
  }
  onFocus() {
    let e = !1;
    try {
      e = this.node.current.matches(":focus-visible");
    } catch {
      e = !0;
    }
    !e ||
      !this.node.animationState ||
      (this.node.animationState.setActive("whileFocus", !0),
      (this.isActive = !0));
  }
  onBlur() {
    !this.isActive ||
      !this.node.animationState ||
      (this.node.animationState.setActive("whileFocus", !1),
      (this.isActive = !1));
  }
  mount() {
    this.unmount = w0(
      n0(this.node.current, "focus", () => this.onFocus()),
      n0(this.node.current, "blur", () => this.onBlur()),
    );
  }
  unmount() {}
}
function kA(i, e, t) {
  const { props: n } = i;
  if (i.current instanceof HTMLButtonElement && i.current.disabled) return;
  i.animationState &&
    n.whileTap &&
    i.animationState.setActive("whileTap", t === "Start");
  const r = "onTap" + (t === "End" ? "" : t),
    s = n[r];
  s && ui.postRender(() => s(e, R0(e)));
}
class HF extends uf {
  mount() {
    const { current: e } = this.node;
    if (!e) return;
    const { globalTapTarget: t, propagate: n } = this.node.props;
    this.unmount = S5(
      e,
      (r, s) => (
        kA(this.node, s, "Start"),
        (o, { success: u }) => kA(this.node, o, u ? "End" : "Cancel")
      ),
      {
        useGlobalTarget: t,
        stopPropagation: (n == null ? void 0 : n.tap) === !1,
      },
    );
  }
  unmount() {}
}
const gM = new WeakMap(),
  B_ = new WeakMap(),
  jF = (i) => {
    const e = gM.get(i.target);
    e && e(i);
  },
  WF = (i) => {
    i.forEach(jF);
  };
function XF({ root: i, ...e }) {
  const t = i || document;
  B_.has(t) || B_.set(t, {});
  const n = B_.get(t),
    r = JSON.stringify(e);
  return (
    n[r] || (n[r] = new IntersectionObserver(WF, { root: i, ...e })),
    n[r]
  );
}
function qF(i, e, t) {
  const n = XF(e);
  return (
    gM.set(i, t),
    n.observe(i),
    () => {
      (gM.delete(i), n.unobserve(i));
    }
  );
}
const YF = { some: 0, all: 1 };
class ZF extends uf {
  constructor() {
    (super(...arguments), (this.hasEnteredView = !1), (this.isInView = !1));
  }
  startObserver() {
    this.unmount();
    const { viewport: e = {} } = this.node.getProps(),
      { root: t, margin: n, amount: r = "some", once: s } = e,
      o = {
        root: t ? t.current : void 0,
        rootMargin: n,
        threshold: typeof r == "number" ? r : YF[r],
      },
      u = (h) => {
        const { isIntersecting: d } = h;
        if (
          this.isInView === d ||
          ((this.isInView = d), s && !d && this.hasEnteredView)
        )
          return;
        (d && (this.hasEnteredView = !0),
          this.node.animationState &&
            this.node.animationState.setActive("whileInView", d));
        const { onViewportEnter: m, onViewportLeave: v } = this.node.getProps(),
          y = d ? m : v;
        y && y(h);
      };
    return qF(this.node.current, o, u);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver > "u") return;
    const { props: e, prevProps: t } = this.node;
    ["amount", "margin", "root"].some(KF(e, t)) && this.startObserver();
  }
  unmount() {}
}
function KF({ viewport: i = {} }, { viewport: e = {} } = {}) {
  return (t) => i[t] !== e[t];
}
const QF = {
    inView: { Feature: ZF },
    tap: { Feature: HF },
    focus: { Feature: GF },
    hover: { Feature: VF },
  },
  JF = { layout: { ProjectionNode: qD, MeasureLayout: aL } },
  $F = { ...SF, ...QF, ...kF, ...JF },
  En = vF($F, yF);
/**
 * @license lucide-react v0.546.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const ez = (i) => i.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(),
  tz = (i) =>
    i.replace(/^([A-Z])|[\s-_]+(\w)/g, (e, t, n) =>
      n ? n.toUpperCase() : t.toLowerCase(),
    ),
  VA = (i) => {
    const e = tz(i);
    return e.charAt(0).toUpperCase() + e.slice(1);
  },
  oL = (...i) =>
    i
      .filter((e, t, n) => !!e && e.trim() !== "" && n.indexOf(e) === t)
      .join(" ")
      .trim(),
  nz = (i) => {
    for (const e in i)
      if (e.startsWith("aria-") || e === "role" || e === "title") return !0;
  };
/**
 * @license lucide-react v0.546.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ var iz = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
};
/**
 * @license lucide-react v0.546.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const rz = ie.forwardRef(
  (
    {
      color: i = "currentColor",
      size: e = 24,
      strokeWidth: t = 2,
      absoluteStrokeWidth: n,
      className: r = "",
      children: s,
      iconNode: o,
      ...u
    },
    h,
  ) =>
    ie.createElement(
      "svg",
      {
        ref: h,
        ...iz,
        width: e,
        height: e,
        stroke: i,
        strokeWidth: n ? (Number(t) * 24) / Number(e) : t,
        className: oL("lucide", r),
        ...(!s && !nz(u) && { "aria-hidden": "true" }),
        ...u,
      },
      [
        ...o.map(([d, m]) => ie.createElement(d, m)),
        ...(Array.isArray(s) ? s : [s]),
      ],
    ),
);
/**
 * @license lucide-react v0.546.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const yi = (i, e) => {
  const t = ie.forwardRef(({ className: n, ...r }, s) =>
    ie.createElement(rz, {
      ref: s,
      iconNode: e,
      className: oL(`lucide-${ez(VA(i))}`, `lucide-${i}`, n),
      ...r,
    }),
  );
  return ((t.displayName = VA(i)), t);
};
/**
 * @license lucide-react v0.546.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const sz = [
    ["path", { d: "M8 3 4 7l4 4", key: "9rb6wj" }],
    ["path", { d: "M4 7h16", key: "6tx8e3" }],
    ["path", { d: "m16 21 4-4-4-4", key: "siv7j2" }],
    ["path", { d: "M20 17H4", key: "h6l3hr" }],
  ],
  lL = yi("arrow-left-right", sz);
/**
 * @license lucide-react v0.546.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const az = [
    ["path", { d: "m12 19-7-7 7-7", key: "1l729n" }],
    ["path", { d: "M19 12H5", key: "x3x0zl" }],
  ],
  ff = yi("arrow-left", az);
/**
 * @license lucide-react v0.546.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const oz = [
    [
      "path",
      {
        d: "M21 8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16Z",
        key: "hh9hay",
      },
    ],
    ["path", { d: "m3.3 7 8.7 5 8.7-5", key: "g66t2b" }],
    ["path", { d: "M12 22V12", key: "d0xqtd" }],
  ],
  cL = yi("box", oz);
/**
 * @license lucide-react v0.546.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const lz = [
    [
      "rect",
      { width: "16", height: "20", x: "4", y: "2", rx: "2", key: "1nb95v" },
    ],
    ["line", { x1: "8", x2: "16", y1: "6", y2: "6", key: "x4nwl0" }],
    ["line", { x1: "16", x2: "16", y1: "14", y2: "18", key: "wjye3r" }],
    ["path", { d: "M16 10h.01", key: "1m94wz" }],
    ["path", { d: "M12 10h.01", key: "1nrarc" }],
    ["path", { d: "M8 10h.01", key: "19clt8" }],
    ["path", { d: "M12 14h.01", key: "1etili" }],
    ["path", { d: "M8 14h.01", key: "6423bh" }],
    ["path", { d: "M12 18h.01", key: "mhygvu" }],
    ["path", { d: "M8 18h.01", key: "lrp35t" }],
  ],
  cz = yi("calculator", lz);
/**
 * @license lucide-react v0.546.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const uz = [
    ["path", { d: "M5 21v-6", key: "1hz6c0" }],
    ["path", { d: "M12 21V3", key: "1lcnhd" }],
    ["path", { d: "M19 21V9", key: "unv183" }],
  ],
  fz = yi("chart-no-axes-column", uz);
/**
 * @license lucide-react v0.546.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const hz = [
    ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
    ["line", { x1: "12", x2: "12", y1: "8", y2: "12", key: "1pkeuh" }],
    ["line", { x1: "12", x2: "12.01", y1: "16", y2: "16", key: "4dfq90" }],
  ],
  dz = yi("circle-alert", hz);
/**
 * @license lucide-react v0.546.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const pz = [
    ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
    ["path", { d: "m9 12 2 2 4-4", key: "dzmm74" }],
  ],
  uL = yi("circle-check", pz);
/**
 * @license lucide-react v0.546.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const mz = [
    [
      "rect",
      {
        width: "8",
        height: "4",
        x: "8",
        y: "2",
        rx: "1",
        ry: "1",
        key: "tgr4d6",
      },
    ],
    [
      "path",
      {
        d: "M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2",
        key: "116196",
      },
    ],
    ["path", { d: "M12 11h4", key: "1jrz19" }],
    ["path", { d: "M12 16h4", key: "n85exb" }],
    ["path", { d: "M8 11h.01", key: "1dfujw" }],
    ["path", { d: "M8 16h.01", key: "18s6g9" }],
  ],
  gz = yi("clipboard-list", mz);
/**
 * @license lucide-react v0.546.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const vz = [
    ["path", { d: "M12 20v2", key: "1lh1kg" }],
    ["path", { d: "M12 2v2", key: "tus03m" }],
    ["path", { d: "M17 20v2", key: "1rnc9c" }],
    ["path", { d: "M17 2v2", key: "11trls" }],
    ["path", { d: "M2 12h2", key: "1t8f8n" }],
    ["path", { d: "M2 17h2", key: "7oei6x" }],
    ["path", { d: "M2 7h2", key: "asdhe0" }],
    ["path", { d: "M20 12h2", key: "1q8mjw" }],
    ["path", { d: "M20 17h2", key: "1fpfkl" }],
    ["path", { d: "M20 7h2", key: "1o8tra" }],
    ["path", { d: "M7 20v2", key: "4gnj0m" }],
    ["path", { d: "M7 2v2", key: "1i4yhu" }],
    [
      "rect",
      { x: "4", y: "4", width: "16", height: "16", rx: "2", key: "1vbyd7" },
    ],
    [
      "rect",
      { x: "8", y: "8", width: "8", height: "8", rx: "1", key: "z9xiuo" },
    ],
  ],
  vM = yi("cpu", vz);
/**
 * @license lucide-react v0.546.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const yz = [
    ["ellipse", { cx: "12", cy: "5", rx: "9", ry: "3", key: "msslwz" }],
    ["path", { d: "M3 5V19A9 3 0 0 0 21 19V5", key: "1wlel7" }],
    ["path", { d: "M3 12A9 3 0 0 0 21 12", key: "mv7ke4" }],
  ],
  xz = yi("database", yz);
/**
 * @license lucide-react v0.546.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const bz = [
    ["path", { d: "M12 15V3", key: "m9g1x1" }],
    ["path", { d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4", key: "ih7n3h" }],
    ["path", { d: "m7 10 5 5 5-5", key: "brsn70" }],
  ],
  i0 = yi("download", bz);
/**
 * @license lucide-react v0.546.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const _z = [
    ["path", { d: "M15 3h6v6", key: "1q9fwt" }],
    ["path", { d: "M10 14 21 3", key: "gplh6r" }],
    [
      "path",
      {
        d: "M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6",
        key: "a6xqqp",
      },
    ],
  ],
  Yc = yi("external-link", _z);
/**
 * @license lucide-react v0.546.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const Sz = [
    [
      "path",
      {
        d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z",
        key: "1rqfz7",
      },
    ],
    ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4", key: "tnqrlb" }],
    ["path", { d: "m9 15 2 2 4-4", key: "1grp1n" }],
  ],
  Mz = yi("file-check", Sz);
/**
 * @license lucide-react v0.546.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const Tz = [
    [
      "path",
      {
        d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z",
        key: "1rqfz7",
      },
    ],
    ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4", key: "tnqrlb" }],
    [
      "path",
      {
        d: "M10 12a1 1 0 0 0-1 1v1a1 1 0 0 1-1 1 1 1 0 0 1 1 1v1a1 1 0 0 0 1 1",
        key: "1oajmo",
      },
    ],
    [
      "path",
      {
        d: "M14 18a1 1 0 0 0 1-1v-1a1 1 0 0 1 1-1 1 1 0 0 1-1-1v-1a1 1 0 0 0-1-1",
        key: "mpwhp6",
      },
    ],
  ],
  fL = yi("file-json", Tz);
/**
 * @license lucide-react v0.546.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const Ez = [
    [
      "path",
      {
        d: "M12.5 22H18a2 2 0 0 0 2-2V7l-5-5H6a2 2 0 0 0-2 2v9.5",
        key: "1couwa",
      },
    ],
    ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4", key: "tnqrlb" }],
    [
      "path",
      {
        d: "M13.378 15.626a1 1 0 1 0-3.004-3.004l-5.01 5.012a2 2 0 0 0-.506.854l-.837 2.87a.5.5 0 0 0 .62.62l2.87-.837a2 2 0 0 0 .854-.506z",
        key: "1y4qbx",
      },
    ],
  ],
  wz = yi("file-pen", Ez);
/**
 * @license lucide-react v0.546.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const Az = [
    ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4", key: "tnqrlb" }],
    [
      "path",
      {
        d: "M4.268 21a2 2 0 0 0 1.727 1H18a2 2 0 0 0 2-2V7l-5-5H6a2 2 0 0 0-2 2v3",
        key: "ms7g94",
      },
    ],
    ["path", { d: "m9 18-1.5-1.5", key: "1j6qii" }],
    ["circle", { cx: "5", cy: "14", r: "3", key: "ufru5t" }],
  ],
  Cz = yi("file-search", Az);
/**
 * @license lucide-react v0.546.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const Rz = [
    [
      "path",
      {
        d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z",
        key: "1rqfz7",
      },
    ],
    ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4", key: "tnqrlb" }],
    ["path", { d: "M8 13h2", key: "yr2amv" }],
    ["path", { d: "M14 13h2", key: "un5t4a" }],
    ["path", { d: "M8 17h2", key: "2yhykz" }],
    ["path", { d: "M14 17h2", key: "10kma7" }],
  ],
  rf = yi("file-spreadsheet", Rz);
/**
 * @license lucide-react v0.546.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const Dz = [
    ["path", { d: "m10 17 5-5-5-5", key: "1bsop3" }],
    ["path", { d: "M15 12H3", key: "6jk70r" }],
    ["path", { d: "M15 3h4a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-4", key: "u53s6r" }],
  ],
  Lz = yi("log-in", Dz);
/**
 * @license lucide-react v0.546.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const Nz = [
    ["path", { d: "m16 17 5-5-5-5", key: "1bji2h" }],
    ["path", { d: "M21 12H9", key: "dn1m92" }],
    ["path", { d: "M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4", key: "1uf3rs" }],
  ],
  Uz = yi("log-out", Nz);
/**
 * @license lucide-react v0.546.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const Pz = [
    [
      "path",
      {
        d: "M21.3 15.3a2.4 2.4 0 0 1 0 3.4l-2.6 2.6a2.4 2.4 0 0 1-3.4 0L2.7 8.7a2.41 2.41 0 0 1 0-3.4l2.6-2.6a2.41 2.41 0 0 1 3.4 0Z",
        key: "icamh8",
      },
    ],
    ["path", { d: "m14.5 12.5 2-2", key: "inckbg" }],
    ["path", { d: "m11.5 9.5 2-2", key: "fmmyf7" }],
    ["path", { d: "m8.5 6.5 2-2", key: "vc6u1g" }],
    ["path", { d: "m17.5 15.5 2-2", key: "wo5hmg" }],
  ],
  hL = yi("ruler", Pz);
/**
 * @license lucide-react v0.546.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const Iz = [
    ["circle", { cx: "6", cy: "6", r: "3", key: "1lh9wr" }],
    ["path", { d: "M8.12 8.12 12 12", key: "1alkpv" }],
    ["path", { d: "M20 4 8.12 15.88", key: "xgtan2" }],
    ["circle", { cx: "6", cy: "18", r: "3", key: "fqmcym" }],
    ["path", { d: "M14.8 14.8 20 20", key: "ptml3r" }],
  ],
  dL = yi("scissors", Iz);
/**
 * @license lucide-react v0.546.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const Oz = [
    [
      "path",
      {
        d: "M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z",
        key: "oel41y",
      },
    ],
    ["path", { d: "M12 8v4", key: "1got3b" }],
    ["path", { d: "M12 16h.01", key: "1drbdi" }],
  ],
  yM = yi("shield-alert", Oz);
/**
 * @license lucide-react v0.546.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const Fz = [
    [
      "path",
      {
        d: "M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z",
        key: "oel41y",
      },
    ],
    ["path", { d: "m9 12 2 2 4-4", key: "dzmm74" }],
  ],
  zz = yi("shield-check", Fz);
/**
 * @license lucide-react v0.546.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const Bz = [
    [
      "path",
      {
        d: "m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3",
        key: "wmoenq",
      },
    ],
    ["path", { d: "M12 9v4", key: "juzpu7" }],
    ["path", { d: "M12 17h.01", key: "p32p05" }],
  ],
  kz = yi("triangle-alert", Bz);
/**
 * @license lucide-react v0.546.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const Vz = [
    [
      "path",
      {
        d: "M4 14a1 1 0 0 1-.78-1.63l9.9-10.2a.5.5 0 0 1 .86.46l-1.92 6.02A1 1 0 0 0 13 10h7a1 1 0 0 1 .78 1.63l-9.9 10.2a.5.5 0 0 1-.86-.46l1.92-6.02A1 1 0 0 0 11 14z",
        key: "1xq2db",
      },
    ],
  ],
  Gz = yi("zap", Vz);
/**
 * @license
 * Copyright 2010-2026 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ const zp = "183",
  ph = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 },
  mh = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
  pL = 0,
  xM = 1,
  mL = 2,
  Hz = 3,
  gL = 0,
  _p = 1,
  Fg = 2,
  bh = 3,
  Zc = 0,
  js = 1,
  Na = 2,
  ql = 0,
  Eh = 1,
  Hx = 2,
  bM = 3,
  _M = 4,
  vL = 5,
  jz = 6,
  Ku = 100,
  yL = 101,
  xL = 102,
  bL = 103,
  _L = 104,
  SL = 200,
  ML = 201,
  TL = 202,
  EL = 203,
  jx = 204,
  Wx = 205,
  wL = 206,
  AL = 207,
  CL = 208,
  RL = 209,
  DL = 210,
  LL = 211,
  NL = 212,
  UL = 213,
  PL = 214,
  Xx = 0,
  qx = 1,
  Yx = 2,
  Dh = 3,
  Zx = 4,
  Kx = 5,
  Qx = 6,
  Jx = 7,
  D0 = 0,
  IL = 1,
  OL = 2,
  xo = 0,
  RT = 1,
  DT = 2,
  LT = 3,
  Z1 = 4,
  NT = 5,
  UT = 6,
  PT = 7,
  SM = "attached",
  FL = "detached",
  K1 = 300,
  Zl = 301,
  sf = 302,
  zg = 303,
  Bg = 304,
  Bp = 306,
  r0 = 1e3,
  xa = 1001,
  s0 = 1002,
  rr = 1003,
  IT = 1004,
  Wz = 1004,
  vp = 1005,
  Xz = 1005,
  ni = 1006,
  kg = 1007,
  qz = 1007,
  Hl = 1008,
  Yz = 1008,
  Bs = 1009,
  OT = 1010,
  FT = 1011,
  Tp = 1012,
  Q1 = 1013,
  bo = 1014,
  Hs = 1015,
  Kl = 1016,
  J1 = 1017,
  $1 = 1018,
  Ep = 1020,
  zT = 35902,
  BT = 35899,
  kT = 1021,
  VT = 1022,
  xs = 1023,
  Ql = 1026,
  $u = 1027,
  eb = 1028,
  L0 = 1029,
  Lh = 1030,
  tb = 1031,
  Zz = 1032,
  nb = 1033,
  Vg = 33776,
  Gg = 33777,
  Hg = 33778,
  jg = 33779,
  $x = 35840,
  e1 = 35841,
  t1 = 35842,
  n1 = 35843,
  i1 = 36196,
  r1 = 37492,
  s1 = 37496,
  a1 = 37488,
  o1 = 37489,
  l1 = 37490,
  c1 = 37491,
  u1 = 37808,
  f1 = 37809,
  h1 = 37810,
  d1 = 37811,
  p1 = 37812,
  m1 = 37813,
  g1 = 37814,
  v1 = 37815,
  y1 = 37816,
  x1 = 37817,
  b1 = 37818,
  _1 = 37819,
  S1 = 37820,
  M1 = 37821,
  T1 = 36492,
  E1 = 36494,
  w1 = 36495,
  A1 = 36283,
  C1 = 36284,
  R1 = 36285,
  D1 = 36286,
  zL = 2200,
  BL = 2201,
  kL = 2202,
  a0 = 2300,
  L1 = 2301,
  Cx = 2302,
  MM = 2303,
  _h = 2400,
  Sh = 2401,
  o0 = 2402,
  ib = 2500,
  GT = 2501,
  Kz = 0,
  Qz = 1,
  Jz = 2,
  VL = 3200,
  GL = 3201,
  $z = 3202,
  eB = 3203,
  hf = 0,
  HL = 1,
  Gc = "",
  vs = "srgb",
  af = "srgb-linear",
  l0 = "linear",
  Xn = "srgb",
  tB = "",
  nB = "rg",
  iB = "ga",
  rB = 0,
  gh = 7680,
  sB = 7681,
  aB = 7682,
  oB = 7683,
  lB = 34055,
  cB = 34056,
  uB = 5386,
  fB = 512,
  hB = 513,
  dB = 514,
  pB = 515,
  mB = 516,
  gB = 517,
  vB = 518,
  TM = 519,
  jL = 512,
  WL = 513,
  XL = 514,
  rb = 515,
  qL = 516,
  YL = 517,
  sb = 518,
  ZL = 519,
  c0 = 35044,
  yB = 35048,
  xB = 35040,
  bB = 35045,
  _B = 35049,
  SB = 35041,
  MB = 35046,
  TB = 35050,
  EB = 35042,
  wB = "100",
  EM = "300 es",
  Ua = 2e3,
  Nh = 2001,
  AB = { COMPUTE: "compute", RENDER: "render" },
  CB = { PERSPECTIVE: "perspective", LINEAR: "linear", FLAT: "flat" },
  RB = {
    NORMAL: "normal",
    CENTROID: "centroid",
    SAMPLE: "sample",
    FIRST: "first",
    EITHER: "either",
  },
  DB = { TEXTURE_COMPARE: "depthTextureCompare" };
function LB(i) {
  for (let e = i.length - 1; e >= 0; --e) if (i[e] >= 65535) return !0;
  return !1;
}
const NB = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array,
};
function yp(i, e) {
  return new NB[i](e);
}
function KL(i) {
  return ArrayBuffer.isView(i) && !(i instanceof DataView);
}
function u0(i) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", i);
}
function QL() {
  const i = u0("canvas");
  return ((i.style.display = "block"), i);
}
const GA = {};
let of = null;
function UB(i) {
  of = i;
}
function PB() {
  return of;
}
function f0(...i) {
  const e = "THREE." + i.shift();
  of ? of("log", e, ...i) : console.log(e, ...i);
}
function JL(i) {
  const e = i[0];
  if (typeof e == "string" && e.startsWith("TSL:")) {
    const t = i[1];
    t && t.isStackTrace
      ? (i[0] += " " + t.getLocation())
      : (i[1] =
          'Stack trace not available. Enable "THREE.Node.captureStackTrace" to capture stack traces.');
  }
  return i;
}
function Tt(...i) {
  i = JL(i);
  const e = "THREE." + i.shift();
  if (of) of("warn", e, ...i);
  else {
    const t = i[0];
    t && t.isStackTrace ? console.warn(t.getError(e)) : console.warn(e, ...i);
  }
}
function Ft(...i) {
  i = JL(i);
  const e = "THREE." + i.shift();
  if (of) of("error", e, ...i);
  else {
    const t = i[0];
    t && t.isStackTrace ? console.error(t.getError(e)) : console.error(e, ...i);
  }
}
function h0(...i) {
  const e = i.join(" ");
  e in GA || ((GA[e] = !0), Tt(...i));
}
function IB(i, e, t) {
  return new Promise(function (n, r) {
    function s() {
      switch (i.clientWaitSync(e, i.SYNC_FLUSH_COMMANDS_BIT, 0)) {
        case i.WAIT_FAILED:
          r();
          break;
        case i.TIMEOUT_EXPIRED:
          setTimeout(s, t);
          break;
        default:
          n();
      }
    }
    setTimeout(s, t);
  });
}
const OB = {
  [Xx]: qx,
  [Yx]: Qx,
  [Zx]: Jx,
  [Dh]: Kx,
  [qx]: Xx,
  [Qx]: Yx,
  [Jx]: Zx,
  [Kx]: Dh,
};
let ec = class {
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const n = this._listeners;
    (n[e] === void 0 && (n[e] = []), n[e].indexOf(t) === -1 && n[e].push(t));
  }
  hasEventListener(e, t) {
    const n = this._listeners;
    return n === void 0 ? !1 : n[e] !== void 0 && n[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    const n = this._listeners;
    if (n === void 0) return;
    const r = n[e];
    if (r !== void 0) {
      const s = r.indexOf(t);
      s !== -1 && r.splice(s, 1);
    }
  }
  dispatchEvent(e) {
    const t = this._listeners;
    if (t === void 0) return;
    const n = t[e.type];
    if (n !== void 0) {
      e.target = this;
      const r = n.slice(0);
      for (let s = 0, o = r.length; s < o; s++) r[s].call(this, e);
      e.target = null;
    }
  }
};
const ps = [
  "00",
  "01",
  "02",
  "03",
  "04",
  "05",
  "06",
  "07",
  "08",
  "09",
  "0a",
  "0b",
  "0c",
  "0d",
  "0e",
  "0f",
  "10",
  "11",
  "12",
  "13",
  "14",
  "15",
  "16",
  "17",
  "18",
  "19",
  "1a",
  "1b",
  "1c",
  "1d",
  "1e",
  "1f",
  "20",
  "21",
  "22",
  "23",
  "24",
  "25",
  "26",
  "27",
  "28",
  "29",
  "2a",
  "2b",
  "2c",
  "2d",
  "2e",
  "2f",
  "30",
  "31",
  "32",
  "33",
  "34",
  "35",
  "36",
  "37",
  "38",
  "39",
  "3a",
  "3b",
  "3c",
  "3d",
  "3e",
  "3f",
  "40",
  "41",
  "42",
  "43",
  "44",
  "45",
  "46",
  "47",
  "48",
  "49",
  "4a",
  "4b",
  "4c",
  "4d",
  "4e",
  "4f",
  "50",
  "51",
  "52",
  "53",
  "54",
  "55",
  "56",
  "57",
  "58",
  "59",
  "5a",
  "5b",
  "5c",
  "5d",
  "5e",
  "5f",
  "60",
  "61",
  "62",
  "63",
  "64",
  "65",
  "66",
  "67",
  "68",
  "69",
  "6a",
  "6b",
  "6c",
  "6d",
  "6e",
  "6f",
  "70",
  "71",
  "72",
  "73",
  "74",
  "75",
  "76",
  "77",
  "78",
  "79",
  "7a",
  "7b",
  "7c",
  "7d",
  "7e",
  "7f",
  "80",
  "81",
  "82",
  "83",
  "84",
  "85",
  "86",
  "87",
  "88",
  "89",
  "8a",
  "8b",
  "8c",
  "8d",
  "8e",
  "8f",
  "90",
  "91",
  "92",
  "93",
  "94",
  "95",
  "96",
  "97",
  "98",
  "99",
  "9a",
  "9b",
  "9c",
  "9d",
  "9e",
  "9f",
  "a0",
  "a1",
  "a2",
  "a3",
  "a4",
  "a5",
  "a6",
  "a7",
  "a8",
  "a9",
  "aa",
  "ab",
  "ac",
  "ad",
  "ae",
  "af",
  "b0",
  "b1",
  "b2",
  "b3",
  "b4",
  "b5",
  "b6",
  "b7",
  "b8",
  "b9",
  "ba",
  "bb",
  "bc",
  "bd",
  "be",
  "bf",
  "c0",
  "c1",
  "c2",
  "c3",
  "c4",
  "c5",
  "c6",
  "c7",
  "c8",
  "c9",
  "ca",
  "cb",
  "cc",
  "cd",
  "ce",
  "cf",
  "d0",
  "d1",
  "d2",
  "d3",
  "d4",
  "d5",
  "d6",
  "d7",
  "d8",
  "d9",
  "da",
  "db",
  "dc",
  "dd",
  "de",
  "df",
  "e0",
  "e1",
  "e2",
  "e3",
  "e4",
  "e5",
  "e6",
  "e7",
  "e8",
  "e9",
  "ea",
  "eb",
  "ec",
  "ed",
  "ee",
  "ef",
  "f0",
  "f1",
  "f2",
  "f3",
  "f4",
  "f5",
  "f6",
  "f7",
  "f8",
  "f9",
  "fa",
  "fb",
  "fc",
  "fd",
  "fe",
  "ff",
];
let HA = 1234567;
const wh = Math.PI / 180,
  wp = 180 / Math.PI;
function Ia() {
  const i = (Math.random() * 4294967295) | 0,
    e = (Math.random() * 4294967295) | 0,
    t = (Math.random() * 4294967295) | 0,
    n = (Math.random() * 4294967295) | 0;
  return (
    ps[i & 255] +
    ps[(i >> 8) & 255] +
    ps[(i >> 16) & 255] +
    ps[(i >> 24) & 255] +
    "-" +
    ps[e & 255] +
    ps[(e >> 8) & 255] +
    "-" +
    ps[((e >> 16) & 15) | 64] +
    ps[(e >> 24) & 255] +
    "-" +
    ps[(t & 63) | 128] +
    ps[(t >> 8) & 255] +
    "-" +
    ps[(t >> 16) & 255] +
    ps[(t >> 24) & 255] +
    ps[n & 255] +
    ps[(n >> 8) & 255] +
    ps[(n >> 16) & 255] +
    ps[(n >> 24) & 255]
  ).toLowerCase();
}
function Yt(i, e, t) {
  return Math.max(e, Math.min(t, i));
}
function HT(i, e) {
  return ((i % e) + e) % e;
}
function FB(i, e, t, n, r) {
  return n + ((i - e) * (r - n)) / (t - e);
}
function zB(i, e, t) {
  return i !== e ? (t - i) / (e - i) : 0;
}
function Wg(i, e, t) {
  return (1 - t) * i + t * e;
}
function BB(i, e, t, n) {
  return Wg(i, e, 1 - Math.exp(-t * n));
}
function kB(i, e = 1) {
  return e - Math.abs(HT(i, e * 2) - e);
}
function VB(i, e, t) {
  return i <= e
    ? 0
    : i >= t
      ? 1
      : ((i = (i - e) / (t - e)), i * i * (3 - 2 * i));
}
function GB(i, e, t) {
  return i <= e
    ? 0
    : i >= t
      ? 1
      : ((i = (i - e) / (t - e)), i * i * i * (i * (i * 6 - 15) + 10));
}
function HB(i, e) {
  return i + Math.floor(Math.random() * (e - i + 1));
}
function jB(i, e) {
  return i + Math.random() * (e - i);
}
function WB(i) {
  return i * (0.5 - Math.random());
}
function XB(i) {
  i !== void 0 && (HA = i);
  let e = (HA += 1831565813);
  return (
    (e = Math.imul(e ^ (e >>> 15), e | 1)),
    (e ^= e + Math.imul(e ^ (e >>> 7), e | 61)),
    ((e ^ (e >>> 14)) >>> 0) / 4294967296
  );
}
function qB(i) {
  return i * wh;
}
function YB(i) {
  return i * wp;
}
function ZB(i) {
  return (i & (i - 1)) === 0 && i !== 0;
}
function KB(i) {
  return Math.pow(2, Math.ceil(Math.log(i) / Math.LN2));
}
function QB(i) {
  return Math.pow(2, Math.floor(Math.log(i) / Math.LN2));
}
function JB(i, e, t, n, r) {
  const s = Math.cos,
    o = Math.sin,
    u = s(t / 2),
    h = o(t / 2),
    d = s((e + n) / 2),
    m = o((e + n) / 2),
    v = s((e - n) / 2),
    y = o((e - n) / 2),
    b = s((n - e) / 2),
    _ = o((n - e) / 2);
  switch (r) {
    case "XYX":
      i.set(u * m, h * v, h * y, u * d);
      break;
    case "YZY":
      i.set(h * y, u * m, h * v, u * d);
      break;
    case "ZXZ":
      i.set(h * v, h * y, u * m, u * d);
      break;
    case "XZX":
      i.set(u * m, h * _, h * b, u * d);
      break;
    case "YXY":
      i.set(h * b, u * m, h * _, u * d);
      break;
    case "ZYZ":
      i.set(h * _, h * b, u * m, u * d);
      break;
    default:
      Tt(
        "MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
          r,
      );
  }
}
function ks(i, e) {
  switch (e.constructor) {
    case Float32Array:
      return i;
    case Uint32Array:
      return i / 4294967295;
    case Uint16Array:
      return i / 65535;
    case Uint8Array:
      return i / 255;
    case Int32Array:
      return Math.max(i / 2147483647, -1);
    case Int16Array:
      return Math.max(i / 32767, -1);
    case Int8Array:
      return Math.max(i / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function un(i, e) {
  switch (e.constructor) {
    case Float32Array:
      return i;
    case Uint32Array:
      return Math.round(i * 4294967295);
    case Uint16Array:
      return Math.round(i * 65535);
    case Uint8Array:
      return Math.round(i * 255);
    case Int32Array:
      return Math.round(i * 2147483647);
    case Int16Array:
      return Math.round(i * 32767);
    case Int8Array:
      return Math.round(i * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const jT = {
  DEG2RAD: wh,
  RAD2DEG: wp,
  generateUUID: Ia,
  clamp: Yt,
  euclideanModulo: HT,
  mapLinear: FB,
  inverseLerp: zB,
  lerp: Wg,
  damp: BB,
  pingpong: kB,
  smoothstep: VB,
  smootherstep: GB,
  randInt: HB,
  randFloat: jB,
  randFloatSpread: WB,
  seededRandom: XB,
  degToRad: qB,
  radToDeg: YB,
  isPowerOfTwo: ZB,
  ceilPowerOfTwo: KB,
  floorPowerOfTwo: QB,
  setQuaternionFromProperEuler: JB,
  normalize: un,
  denormalize: ks,
};
class nt {
  constructor(e = 0, t = 0) {
    ((nt.prototype.isVector2 = !0), (this.x = e), (this.y = t));
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return ((this.x = e), (this.y = t), this);
  }
  setScalar(e) {
    return ((this.x = e), (this.y = e), this);
  }
  setX(e) {
    return ((this.x = e), this);
  }
  setY(e) {
    return ((this.y = e), this);
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return ((this.x = e.x), (this.y = e.y), this);
  }
  add(e) {
    return ((this.x += e.x), (this.y += e.y), this);
  }
  addScalar(e) {
    return ((this.x += e), (this.y += e), this);
  }
  addVectors(e, t) {
    return ((this.x = e.x + t.x), (this.y = e.y + t.y), this);
  }
  addScaledVector(e, t) {
    return ((this.x += e.x * t), (this.y += e.y * t), this);
  }
  sub(e) {
    return ((this.x -= e.x), (this.y -= e.y), this);
  }
  subScalar(e) {
    return ((this.x -= e), (this.y -= e), this);
  }
  subVectors(e, t) {
    return ((this.x = e.x - t.x), (this.y = e.y - t.y), this);
  }
  multiply(e) {
    return ((this.x *= e.x), (this.y *= e.y), this);
  }
  multiplyScalar(e) {
    return ((this.x *= e), (this.y *= e), this);
  }
  divide(e) {
    return ((this.x /= e.x), (this.y /= e.y), this);
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x,
      n = this.y,
      r = e.elements;
    return (
      (this.x = r[0] * t + r[3] * n + r[6]),
      (this.y = r[1] * t + r[4] * n + r[7]),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Yt(this.x, e.x, t.x)),
      (this.y = Yt(this.y, e.y, t.y)),
      this
    );
  }
  clampScalar(e, t) {
    return ((this.x = Yt(this.x, e, t)), (this.y = Yt(this.y, e, t)), this);
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Yt(n, e, t));
  }
  floor() {
    return ((this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this);
  }
  ceil() {
    return ((this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this);
  }
  round() {
    return ((this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this);
  }
  roundToZero() {
    return ((this.x = Math.trunc(this.x)), (this.y = Math.trunc(this.y)), this);
  }
  negate() {
    return ((this.x = -this.x), (this.y = -this.y), this);
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const n = this.dot(e) / t;
    return Math.acos(Yt(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      n = this.y - e.y;
    return t * t + n * n;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      this
    );
  }
  lerpVectors(e, t, n) {
    return (
      (this.x = e.x + (t.x - e.x) * n),
      (this.y = e.y + (t.y - e.y) * n),
      this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return ((this.x = e[t]), (this.y = e[t + 1]), this);
  }
  toArray(e = [], t = 0) {
    return ((e[t] = this.x), (e[t + 1] = this.y), e);
  }
  fromBufferAttribute(e, t) {
    return ((this.x = e.getX(t)), (this.y = e.getY(t)), this);
  }
  rotateAround(e, t) {
    const n = Math.cos(t),
      r = Math.sin(t),
      s = this.x - e.x,
      o = this.y - e.y;
    return (
      (this.x = s * n - o * r + e.x),
      (this.y = s * r + o * n + e.y),
      this
    );
  }
  random() {
    return ((this.x = Math.random()), (this.y = Math.random()), this);
  }
  *[Symbol.iterator]() {
    (yield this.x, yield this.y);
  }
}
class Jr {
  constructor(e = 0, t = 0, n = 0, r = 1) {
    ((this.isQuaternion = !0),
      (this._x = e),
      (this._y = t),
      (this._z = n),
      (this._w = r));
  }
  static slerpFlat(e, t, n, r, s, o, u) {
    let h = n[r + 0],
      d = n[r + 1],
      m = n[r + 2],
      v = n[r + 3],
      y = s[o + 0],
      b = s[o + 1],
      _ = s[o + 2],
      w = s[o + 3];
    if (v !== w || h !== y || d !== b || m !== _) {
      let E = h * y + d * b + m * _ + v * w;
      E < 0 && ((y = -y), (b = -b), (_ = -_), (w = -w), (E = -E));
      let T = 1 - u;
      if (E < 0.9995) {
        const C = Math.acos(E),
          R = Math.sin(C);
        ((T = Math.sin(T * C) / R),
          (u = Math.sin(u * C) / R),
          (h = h * T + y * u),
          (d = d * T + b * u),
          (m = m * T + _ * u),
          (v = v * T + w * u));
      } else {
        ((h = h * T + y * u),
          (d = d * T + b * u),
          (m = m * T + _ * u),
          (v = v * T + w * u));
        const C = 1 / Math.sqrt(h * h + d * d + m * m + v * v);
        ((h *= C), (d *= C), (m *= C), (v *= C));
      }
    }
    ((e[t] = h), (e[t + 1] = d), (e[t + 2] = m), (e[t + 3] = v));
  }
  static multiplyQuaternionsFlat(e, t, n, r, s, o) {
    const u = n[r],
      h = n[r + 1],
      d = n[r + 2],
      m = n[r + 3],
      v = s[o],
      y = s[o + 1],
      b = s[o + 2],
      _ = s[o + 3];
    return (
      (e[t] = u * _ + m * v + h * b - d * y),
      (e[t + 1] = h * _ + m * y + d * v - u * b),
      (e[t + 2] = d * _ + m * b + u * y - h * v),
      (e[t + 3] = m * _ - u * v - h * y - d * b),
      e
    );
  }
  get x() {
    return this._x;
  }
  set x(e) {
    ((this._x = e), this._onChangeCallback());
  }
  get y() {
    return this._y;
  }
  set y(e) {
    ((this._y = e), this._onChangeCallback());
  }
  get z() {
    return this._z;
  }
  set z(e) {
    ((this._z = e), this._onChangeCallback());
  }
  get w() {
    return this._w;
  }
  set w(e) {
    ((this._w = e), this._onChangeCallback());
  }
  set(e, t, n, r) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = n),
      (this._w = r),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return (
      (this._x = e.x),
      (this._y = e.y),
      (this._z = e.z),
      (this._w = e.w),
      this._onChangeCallback(),
      this
    );
  }
  setFromEuler(e, t = !0) {
    const n = e._x,
      r = e._y,
      s = e._z,
      o = e._order,
      u = Math.cos,
      h = Math.sin,
      d = u(n / 2),
      m = u(r / 2),
      v = u(s / 2),
      y = h(n / 2),
      b = h(r / 2),
      _ = h(s / 2);
    switch (o) {
      case "XYZ":
        ((this._x = y * m * v + d * b * _),
          (this._y = d * b * v - y * m * _),
          (this._z = d * m * _ + y * b * v),
          (this._w = d * m * v - y * b * _));
        break;
      case "YXZ":
        ((this._x = y * m * v + d * b * _),
          (this._y = d * b * v - y * m * _),
          (this._z = d * m * _ - y * b * v),
          (this._w = d * m * v + y * b * _));
        break;
      case "ZXY":
        ((this._x = y * m * v - d * b * _),
          (this._y = d * b * v + y * m * _),
          (this._z = d * m * _ + y * b * v),
          (this._w = d * m * v - y * b * _));
        break;
      case "ZYX":
        ((this._x = y * m * v - d * b * _),
          (this._y = d * b * v + y * m * _),
          (this._z = d * m * _ - y * b * v),
          (this._w = d * m * v + y * b * _));
        break;
      case "YZX":
        ((this._x = y * m * v + d * b * _),
          (this._y = d * b * v + y * m * _),
          (this._z = d * m * _ - y * b * v),
          (this._w = d * m * v - y * b * _));
        break;
      case "XZY":
        ((this._x = y * m * v - d * b * _),
          (this._y = d * b * v - y * m * _),
          (this._z = d * m * _ + y * b * v),
          (this._w = d * m * v + y * b * _));
        break;
      default:
        Tt("Quaternion: .setFromEuler() encountered an unknown order: " + o);
    }
    return (t === !0 && this._onChangeCallback(), this);
  }
  setFromAxisAngle(e, t) {
    const n = t / 2,
      r = Math.sin(n);
    return (
      (this._x = e.x * r),
      (this._y = e.y * r),
      (this._z = e.z * r),
      (this._w = Math.cos(n)),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e) {
    const t = e.elements,
      n = t[0],
      r = t[4],
      s = t[8],
      o = t[1],
      u = t[5],
      h = t[9],
      d = t[2],
      m = t[6],
      v = t[10],
      y = n + u + v;
    if (y > 0) {
      const b = 0.5 / Math.sqrt(y + 1);
      ((this._w = 0.25 / b),
        (this._x = (m - h) * b),
        (this._y = (s - d) * b),
        (this._z = (o - r) * b));
    } else if (n > u && n > v) {
      const b = 2 * Math.sqrt(1 + n - u - v);
      ((this._w = (m - h) / b),
        (this._x = 0.25 * b),
        (this._y = (r + o) / b),
        (this._z = (s + d) / b));
    } else if (u > v) {
      const b = 2 * Math.sqrt(1 + u - n - v);
      ((this._w = (s - d) / b),
        (this._x = (r + o) / b),
        (this._y = 0.25 * b),
        (this._z = (h + m) / b));
    } else {
      const b = 2 * Math.sqrt(1 + v - n - u);
      ((this._w = (o - r) / b),
        (this._x = (s + d) / b),
        (this._y = (h + m) / b),
        (this._z = 0.25 * b));
    }
    return (this._onChangeCallback(), this);
  }
  setFromUnitVectors(e, t) {
    let n = e.dot(t) + 1;
    return (
      n < 1e-8
        ? ((n = 0),
          Math.abs(e.x) > Math.abs(e.z)
            ? ((this._x = -e.y), (this._y = e.x), (this._z = 0), (this._w = n))
            : ((this._x = 0), (this._y = -e.z), (this._z = e.y), (this._w = n)))
        : ((this._x = e.y * t.z - e.z * t.y),
          (this._y = e.z * t.x - e.x * t.z),
          (this._z = e.x * t.y - e.y * t.x),
          (this._w = n)),
      this.normalize()
    );
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(Yt(this.dot(e), -1, 1)));
  }
  rotateTowards(e, t) {
    const n = this.angleTo(e);
    if (n === 0) return this;
    const r = Math.min(1, t / n);
    return (this.slerp(e, r), this);
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return (
      (this._x *= -1),
      (this._y *= -1),
      (this._z *= -1),
      this._onChangeCallback(),
      this
    );
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return (
      this._x * this._x +
      this._y * this._y +
      this._z * this._z +
      this._w * this._w
    );
  }
  length() {
    return Math.sqrt(
      this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w,
    );
  }
  normalize() {
    let e = this.length();
    return (
      e === 0
        ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
        : ((e = 1 / e),
          (this._x = this._x * e),
          (this._y = this._y * e),
          (this._z = this._z * e),
          (this._w = this._w * e)),
      this._onChangeCallback(),
      this
    );
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    const n = e._x,
      r = e._y,
      s = e._z,
      o = e._w,
      u = t._x,
      h = t._y,
      d = t._z,
      m = t._w;
    return (
      (this._x = n * m + o * u + r * d - s * h),
      (this._y = r * m + o * h + s * u - n * d),
      (this._z = s * m + o * d + n * h - r * u),
      (this._w = o * m - n * u - r * h - s * d),
      this._onChangeCallback(),
      this
    );
  }
  slerp(e, t) {
    let n = e._x,
      r = e._y,
      s = e._z,
      o = e._w,
      u = this.dot(e);
    u < 0 && ((n = -n), (r = -r), (s = -s), (o = -o), (u = -u));
    let h = 1 - t;
    if (u < 0.9995) {
      const d = Math.acos(u),
        m = Math.sin(d);
      ((h = Math.sin(h * d) / m),
        (t = Math.sin(t * d) / m),
        (this._x = this._x * h + n * t),
        (this._y = this._y * h + r * t),
        (this._z = this._z * h + s * t),
        (this._w = this._w * h + o * t),
        this._onChangeCallback());
    } else
      ((this._x = this._x * h + n * t),
        (this._y = this._y * h + r * t),
        (this._z = this._z * h + s * t),
        (this._w = this._w * h + o * t),
        this.normalize());
    return this;
  }
  slerpQuaternions(e, t, n) {
    return this.copy(e).slerp(t, n);
  }
  random() {
    const e = 2 * Math.PI * Math.random(),
      t = 2 * Math.PI * Math.random(),
      n = Math.random(),
      r = Math.sqrt(1 - n),
      s = Math.sqrt(n);
    return this.set(
      r * Math.sin(e),
      r * Math.cos(e),
      s * Math.sin(t),
      s * Math.cos(t),
    );
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._w === this._w
    );
  }
  fromArray(e, t = 0) {
    return (
      (this._x = e[t]),
      (this._y = e[t + 1]),
      (this._z = e[t + 2]),
      (this._w = e[t + 3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._w),
      e
    );
  }
  fromBufferAttribute(e, t) {
    return (
      (this._x = e.getX(t)),
      (this._y = e.getY(t)),
      (this._z = e.getZ(t)),
      (this._w = e.getW(t)),
      this._onChangeCallback(),
      this
    );
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return ((this._onChangeCallback = e), this);
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    (yield this._x, yield this._y, yield this._z, yield this._w);
  }
}
class te {
  constructor(e = 0, t = 0, n = 0) {
    ((te.prototype.isVector3 = !0), (this.x = e), (this.y = t), (this.z = n));
  }
  set(e, t, n) {
    return (
      n === void 0 && (n = this.z),
      (this.x = e),
      (this.y = t),
      (this.z = n),
      this
    );
  }
  setScalar(e) {
    return ((this.x = e), (this.y = e), (this.z = e), this);
  }
  setX(e) {
    return ((this.x = e), this);
  }
  setY(e) {
    return ((this.y = e), this);
  }
  setZ(e) {
    return ((this.z = e), this);
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return ((this.x = e.x), (this.y = e.y), (this.z = e.z), this);
  }
  add(e) {
    return ((this.x += e.x), (this.y += e.y), (this.z += e.z), this);
  }
  addScalar(e) {
    return ((this.x += e), (this.y += e), (this.z += e), this);
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x),
      (this.y = e.y + t.y),
      (this.z = e.z + t.z),
      this
    );
  }
  addScaledVector(e, t) {
    return (
      (this.x += e.x * t),
      (this.y += e.y * t),
      (this.z += e.z * t),
      this
    );
  }
  sub(e) {
    return ((this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this);
  }
  subScalar(e) {
    return ((this.x -= e), (this.y -= e), (this.z -= e), this);
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x),
      (this.y = e.y - t.y),
      (this.z = e.z - t.z),
      this
    );
  }
  multiply(e) {
    return ((this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this);
  }
  multiplyScalar(e) {
    return ((this.x *= e), (this.y *= e), (this.z *= e), this);
  }
  multiplyVectors(e, t) {
    return (
      (this.x = e.x * t.x),
      (this.y = e.y * t.y),
      (this.z = e.z * t.z),
      this
    );
  }
  applyEuler(e) {
    return this.applyQuaternion(jA.setFromEuler(e));
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(jA.setFromAxisAngle(e, t));
  }
  applyMatrix3(e) {
    const t = this.x,
      n = this.y,
      r = this.z,
      s = e.elements;
    return (
      (this.x = s[0] * t + s[3] * n + s[6] * r),
      (this.y = s[1] * t + s[4] * n + s[7] * r),
      (this.z = s[2] * t + s[5] * n + s[8] * r),
      this
    );
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const t = this.x,
      n = this.y,
      r = this.z,
      s = e.elements,
      o = 1 / (s[3] * t + s[7] * n + s[11] * r + s[15]);
    return (
      (this.x = (s[0] * t + s[4] * n + s[8] * r + s[12]) * o),
      (this.y = (s[1] * t + s[5] * n + s[9] * r + s[13]) * o),
      (this.z = (s[2] * t + s[6] * n + s[10] * r + s[14]) * o),
      this
    );
  }
  applyQuaternion(e) {
    const t = this.x,
      n = this.y,
      r = this.z,
      s = e.x,
      o = e.y,
      u = e.z,
      h = e.w,
      d = 2 * (o * r - u * n),
      m = 2 * (u * t - s * r),
      v = 2 * (s * n - o * t);
    return (
      (this.x = t + h * d + o * v - u * m),
      (this.y = n + h * m + u * d - s * v),
      (this.z = r + h * v + s * m - o * d),
      this
    );
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
      e.projectionMatrix,
    );
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
      e.matrixWorld,
    );
  }
  transformDirection(e) {
    const t = this.x,
      n = this.y,
      r = this.z,
      s = e.elements;
    return (
      (this.x = s[0] * t + s[4] * n + s[8] * r),
      (this.y = s[1] * t + s[5] * n + s[9] * r),
      (this.z = s[2] * t + s[6] * n + s[10] * r),
      this.normalize()
    );
  }
  divide(e) {
    return ((this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this);
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Yt(this.x, e.x, t.x)),
      (this.y = Yt(this.y, e.y, t.y)),
      (this.z = Yt(this.z, e.z, t.z)),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Yt(this.x, e, t)),
      (this.y = Yt(this.y, e, t)),
      (this.z = Yt(this.z, e, t)),
      this
    );
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Yt(n, e, t));
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      this
    );
  }
  negate() {
    return ((this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this);
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      this
    );
  }
  lerpVectors(e, t, n) {
    return (
      (this.x = e.x + (t.x - e.x) * n),
      (this.y = e.y + (t.y - e.y) * n),
      (this.z = e.z + (t.z - e.z) * n),
      this
    );
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, t) {
    const n = e.x,
      r = e.y,
      s = e.z,
      o = t.x,
      u = t.y,
      h = t.z;
    return (
      (this.x = r * h - s * u),
      (this.y = s * o - n * h),
      (this.z = n * u - r * o),
      this
    );
  }
  projectOnVector(e) {
    const t = e.lengthSq();
    if (t === 0) return this.set(0, 0, 0);
    const n = e.dot(this) / t;
    return this.copy(e).multiplyScalar(n);
  }
  projectOnPlane(e) {
    return (k_.copy(this).projectOnVector(e), this.sub(k_));
  }
  reflect(e) {
    return this.sub(k_.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const n = this.dot(e) / t;
    return Math.acos(Yt(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      n = this.y - e.y,
      r = this.z - e.z;
    return t * t + n * n + r * r;
  }
  manhattanDistanceTo(e) {
    return (
      Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    );
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, t, n) {
    const r = Math.sin(t) * e;
    return (
      (this.x = r * Math.sin(n)),
      (this.y = Math.cos(t) * e),
      (this.z = r * Math.cos(n)),
      this
    );
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, t, n) {
    return (
      (this.x = e * Math.sin(t)),
      (this.y = n),
      (this.z = e * Math.cos(t)),
      this
    );
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return ((this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this);
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(),
      n = this.setFromMatrixColumn(e, 1).length(),
      r = this.setFromMatrixColumn(e, 2).length();
    return ((this.x = t), (this.y = n), (this.z = r), this);
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4);
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3);
  }
  setFromEuler(e) {
    return ((this.x = e._x), (this.y = e._y), (this.z = e._z), this);
  }
  setFromColor(e) {
    return ((this.x = e.r), (this.y = e.g), (this.z = e.b), this);
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, t = 0) {
    return ((this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), this);
  }
  toArray(e = [], t = 0) {
    return ((e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e);
  }
  fromBufferAttribute(e, t) {
    return (
      (this.x = e.getX(t)),
      (this.y = e.getY(t)),
      (this.z = e.getZ(t)),
      this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      this
    );
  }
  randomDirection() {
    const e = Math.random() * Math.PI * 2,
      t = Math.random() * 2 - 1,
      n = Math.sqrt(1 - t * t);
    return (
      (this.x = n * Math.cos(e)),
      (this.y = t),
      (this.z = n * Math.sin(e)),
      this
    );
  }
  *[Symbol.iterator]() {
    (yield this.x, yield this.y, yield this.z);
  }
}
const k_ = new te(),
  jA = new Jr();
class tn {
  constructor(e, t, n, r, s, o, u, h, d) {
    ((tn.prototype.isMatrix3 = !0),
      (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
      e !== void 0 && this.set(e, t, n, r, s, o, u, h, d));
  }
  set(e, t, n, r, s, o, u, h, d) {
    const m = this.elements;
    return (
      (m[0] = e),
      (m[1] = r),
      (m[2] = u),
      (m[3] = t),
      (m[4] = s),
      (m[5] = h),
      (m[6] = n),
      (m[7] = o),
      (m[8] = d),
      this
    );
  }
  identity() {
    return (this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this);
  }
  copy(e) {
    const t = this.elements,
      n = e.elements;
    return (
      (t[0] = n[0]),
      (t[1] = n[1]),
      (t[2] = n[2]),
      (t[3] = n[3]),
      (t[4] = n[4]),
      (t[5] = n[5]),
      (t[6] = n[6]),
      (t[7] = n[7]),
      (t[8] = n[8]),
      this
    );
  }
  extractBasis(e, t, n) {
    return (
      e.setFromMatrix3Column(this, 0),
      t.setFromMatrix3Column(this, 1),
      n.setFromMatrix3Column(this, 2),
      this
    );
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return (
      this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]),
      this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const n = e.elements,
      r = t.elements,
      s = this.elements,
      o = n[0],
      u = n[3],
      h = n[6],
      d = n[1],
      m = n[4],
      v = n[7],
      y = n[2],
      b = n[5],
      _ = n[8],
      w = r[0],
      E = r[3],
      T = r[6],
      C = r[1],
      R = r[4],
      L = r[7],
      I = r[2],
      O = r[5],
      B = r[8];
    return (
      (s[0] = o * w + u * C + h * I),
      (s[3] = o * E + u * R + h * O),
      (s[6] = o * T + u * L + h * B),
      (s[1] = d * w + m * C + v * I),
      (s[4] = d * E + m * R + v * O),
      (s[7] = d * T + m * L + v * B),
      (s[2] = y * w + b * C + _ * I),
      (s[5] = y * E + b * R + _ * O),
      (s[8] = y * T + b * L + _ * B),
      this
    );
  }
  multiplyScalar(e) {
    const t = this.elements;
    return (
      (t[0] *= e),
      (t[3] *= e),
      (t[6] *= e),
      (t[1] *= e),
      (t[4] *= e),
      (t[7] *= e),
      (t[2] *= e),
      (t[5] *= e),
      (t[8] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      n = e[1],
      r = e[2],
      s = e[3],
      o = e[4],
      u = e[5],
      h = e[6],
      d = e[7],
      m = e[8];
    return (
      t * o * m - t * u * d - n * s * m + n * u * h + r * s * d - r * o * h
    );
  }
  invert() {
    const e = this.elements,
      t = e[0],
      n = e[1],
      r = e[2],
      s = e[3],
      o = e[4],
      u = e[5],
      h = e[6],
      d = e[7],
      m = e[8],
      v = m * o - u * d,
      y = u * h - m * s,
      b = d * s - o * h,
      _ = t * v + n * y + r * b;
    if (_ === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const w = 1 / _;
    return (
      (e[0] = v * w),
      (e[1] = (r * d - m * n) * w),
      (e[2] = (u * n - r * o) * w),
      (e[3] = y * w),
      (e[4] = (m * t - r * h) * w),
      (e[5] = (r * s - u * t) * w),
      (e[6] = b * w),
      (e[7] = (n * h - d * t) * w),
      (e[8] = (o * t - n * s) * w),
      this
    );
  }
  transpose() {
    let e;
    const t = this.elements;
    return (
      (e = t[1]),
      (t[1] = t[3]),
      (t[3] = e),
      (e = t[2]),
      (t[2] = t[6]),
      (t[6] = e),
      (e = t[5]),
      (t[5] = t[7]),
      (t[7] = e),
      this
    );
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return (
      (e[0] = t[0]),
      (e[1] = t[3]),
      (e[2] = t[6]),
      (e[3] = t[1]),
      (e[4] = t[4]),
      (e[5] = t[7]),
      (e[6] = t[2]),
      (e[7] = t[5]),
      (e[8] = t[8]),
      this
    );
  }
  setUvTransform(e, t, n, r, s, o, u) {
    const h = Math.cos(s),
      d = Math.sin(s);
    return (
      this.set(
        n * h,
        n * d,
        -n * (h * o + d * u) + o + e,
        -r * d,
        r * h,
        -r * (-d * o + h * u) + u + t,
        0,
        0,
        1,
      ),
      this
    );
  }
  scale(e, t) {
    return (this.premultiply(V_.makeScale(e, t)), this);
  }
  rotate(e) {
    return (this.premultiply(V_.makeRotation(-e)), this);
  }
  translate(e, t) {
    return (this.premultiply(V_.makeTranslation(e, t)), this);
  }
  makeTranslation(e, t) {
    return (
      e.isVector2
        ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1)
        : this.set(1, 0, e, 0, 1, t, 0, 0, 1),
      this
    );
  }
  makeRotation(e) {
    const t = Math.cos(e),
      n = Math.sin(e);
    return (this.set(t, -n, 0, n, t, 0, 0, 0, 1), this);
  }
  makeScale(e, t) {
    return (this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this);
  }
  equals(e) {
    const t = this.elements,
      n = e.elements;
    for (let r = 0; r < 9; r++) if (t[r] !== n[r]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let n = 0; n < 9; n++) this.elements[n] = e[n + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.elements;
    return (
      (e[t] = n[0]),
      (e[t + 1] = n[1]),
      (e[t + 2] = n[2]),
      (e[t + 3] = n[3]),
      (e[t + 4] = n[4]),
      (e[t + 5] = n[5]),
      (e[t + 6] = n[6]),
      (e[t + 7] = n[7]),
      (e[t + 8] = n[8]),
      e
    );
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const V_ = new tn(),
  WA = new tn().set(
    0.4123908,
    0.3575843,
    0.1804808,
    0.212639,
    0.7151687,
    0.0721923,
    0.0193308,
    0.1191948,
    0.9505322,
  ),
  XA = new tn().set(
    3.2409699,
    -1.5373832,
    -0.4986108,
    -0.9692436,
    1.8759675,
    0.0415551,
    0.0556301,
    -0.203977,
    1.0569715,
  );
function $B() {
  const i = {
      enabled: !0,
      workingColorSpace: af,
      spaces: {},
      convert: function (r, s, o) {
        return (
          this.enabled === !1 ||
            s === o ||
            !s ||
            !o ||
            (this.spaces[s].transfer === Xn &&
              ((r.r = jc(r.r)), (r.g = jc(r.g)), (r.b = jc(r.b))),
            this.spaces[s].primaries !== this.spaces[o].primaries &&
              (r.applyMatrix3(this.spaces[s].toXYZ),
              r.applyMatrix3(this.spaces[o].fromXYZ)),
            this.spaces[o].transfer === Xn &&
              ((r.r = Sp(r.r)), (r.g = Sp(r.g)), (r.b = Sp(r.b)))),
          r
        );
      },
      workingToColorSpace: function (r, s) {
        return this.convert(r, this.workingColorSpace, s);
      },
      colorSpaceToWorking: function (r, s) {
        return this.convert(r, s, this.workingColorSpace);
      },
      getPrimaries: function (r) {
        return this.spaces[r].primaries;
      },
      getTransfer: function (r) {
        return r === Gc ? l0 : this.spaces[r].transfer;
      },
      getToneMappingMode: function (r) {
        return (
          this.spaces[r].outputColorSpaceConfig.toneMappingMode || "standard"
        );
      },
      getLuminanceCoefficients: function (r, s = this.workingColorSpace) {
        return r.fromArray(this.spaces[s].luminanceCoefficients);
      },
      define: function (r) {
        Object.assign(this.spaces, r);
      },
      _getMatrix: function (r, s, o) {
        return r.copy(this.spaces[s].toXYZ).multiply(this.spaces[o].fromXYZ);
      },
      _getDrawingBufferColorSpace: function (r) {
        return this.spaces[r].outputColorSpaceConfig.drawingBufferColorSpace;
      },
      _getUnpackColorSpace: function (r = this.workingColorSpace) {
        return this.spaces[r].workingColorSpaceConfig.unpackColorSpace;
      },
      fromWorkingColorSpace: function (r, s) {
        return (
          h0(
            "ColorManagement: .fromWorkingColorSpace() has been renamed to .workingToColorSpace().",
          ),
          i.workingToColorSpace(r, s)
        );
      },
      toWorkingColorSpace: function (r, s) {
        return (
          h0(
            "ColorManagement: .toWorkingColorSpace() has been renamed to .colorSpaceToWorking().",
          ),
          i.colorSpaceToWorking(r, s)
        );
      },
    },
    e = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06],
    t = [0.2126, 0.7152, 0.0722],
    n = [0.3127, 0.329];
  return (
    i.define({
      [af]: {
        primaries: e,
        whitePoint: n,
        transfer: l0,
        toXYZ: WA,
        fromXYZ: XA,
        luminanceCoefficients: t,
        workingColorSpaceConfig: { unpackColorSpace: vs },
        outputColorSpaceConfig: { drawingBufferColorSpace: vs },
      },
      [vs]: {
        primaries: e,
        whitePoint: n,
        transfer: Xn,
        toXYZ: WA,
        fromXYZ: XA,
        luminanceCoefficients: t,
        outputColorSpaceConfig: { drawingBufferColorSpace: vs },
      },
    }),
    i
  );
}
const Cn = $B();
function jc(i) {
  return i < 0.04045
    ? i * 0.0773993808
    : Math.pow(i * 0.9478672986 + 0.0521327014, 2.4);
}
function Sp(i) {
  return i < 0.0031308 ? i * 12.92 : 1.055 * Math.pow(i, 0.41666) - 0.055;
}
let kd;
class $L {
  static getDataURL(e, t = "image/png") {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src;
    let n;
    if (e instanceof HTMLCanvasElement) n = e;
    else {
      (kd === void 0 && (kd = u0("canvas")),
        (kd.width = e.width),
        (kd.height = e.height));
      const r = kd.getContext("2d");
      (e instanceof ImageData
        ? r.putImageData(e, 0, 0)
        : r.drawImage(e, 0, 0, e.width, e.height),
        (n = kd));
    }
    return n.toDataURL(t);
  }
  static sRGBToLinear(e) {
    if (
      (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement) ||
      (typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement) ||
      (typeof ImageBitmap < "u" && e instanceof ImageBitmap)
    ) {
      const t = u0("canvas");
      ((t.width = e.width), (t.height = e.height));
      const n = t.getContext("2d");
      n.drawImage(e, 0, 0, e.width, e.height);
      const r = n.getImageData(0, 0, e.width, e.height),
        s = r.data;
      for (let o = 0; o < s.length; o++) s[o] = jc(s[o] / 255) * 255;
      return (n.putImageData(r, 0, 0), t);
    } else if (e.data) {
      const t = e.data.slice(0);
      for (let n = 0; n < t.length; n++)
        t instanceof Uint8Array || t instanceof Uint8ClampedArray
          ? (t[n] = Math.floor(jc(t[n] / 255) * 255))
          : (t[n] = jc(t[n]));
      return { data: t, width: e.width, height: e.height };
    } else
      return (
        Tt(
          "ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.",
        ),
        e
      );
  }
}
let ek = 0;
class ef {
  constructor(e = null) {
    ((this.isSource = !0),
      Object.defineProperty(this, "id", { value: ek++ }),
      (this.uuid = Ia()),
      (this.data = e),
      (this.dataReady = !0),
      (this.version = 0));
  }
  getSize(e) {
    const t = this.data;
    return (
      typeof HTMLVideoElement < "u" && t instanceof HTMLVideoElement
        ? e.set(t.videoWidth, t.videoHeight, 0)
        : typeof VideoFrame < "u" && t instanceof VideoFrame
          ? e.set(t.displayHeight, t.displayWidth, 0)
          : t !== null
            ? e.set(t.width, t.height, t.depth || 0)
            : e.set(0, 0, 0),
      e
    );
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
    const n = { uuid: this.uuid, url: "" },
      r = this.data;
    if (r !== null) {
      let s;
      if (Array.isArray(r)) {
        s = [];
        for (let o = 0, u = r.length; o < u; o++)
          r[o].isDataTexture ? s.push(G_(r[o].image)) : s.push(G_(r[o]));
      } else s = G_(r);
      n.url = s;
    }
    return (t || (e.images[this.uuid] = n), n);
  }
}
function G_(i) {
  return (typeof HTMLImageElement < "u" && i instanceof HTMLImageElement) ||
    (typeof HTMLCanvasElement < "u" && i instanceof HTMLCanvasElement) ||
    (typeof ImageBitmap < "u" && i instanceof ImageBitmap)
    ? $L.getDataURL(i)
    : i.data
      ? {
          data: Array.from(i.data),
          width: i.width,
          height: i.height,
          type: i.data.constructor.name,
        }
      : (Tt("Texture: Unable to serialize Texture."), {});
}
let tk = 0;
const H_ = new te();
class Fi extends ec {
  constructor(
    e = Fi.DEFAULT_IMAGE,
    t = Fi.DEFAULT_MAPPING,
    n = xa,
    r = xa,
    s = ni,
    o = Hl,
    u = xs,
    h = Bs,
    d = Fi.DEFAULT_ANISOTROPY,
    m = Gc,
  ) {
    (super(),
      (this.isTexture = !0),
      Object.defineProperty(this, "id", { value: tk++ }),
      (this.uuid = Ia()),
      (this.name = ""),
      (this.source = new ef(e)),
      (this.mipmaps = []),
      (this.mapping = t),
      (this.channel = 0),
      (this.wrapS = n),
      (this.wrapT = r),
      (this.magFilter = s),
      (this.minFilter = o),
      (this.anisotropy = d),
      (this.format = u),
      (this.internalFormat = null),
      (this.type = h),
      (this.offset = new nt(0, 0)),
      (this.repeat = new nt(1, 1)),
      (this.center = new nt(0, 0)),
      (this.rotation = 0),
      (this.matrixAutoUpdate = !0),
      (this.matrix = new tn()),
      (this.generateMipmaps = !0),
      (this.premultiplyAlpha = !1),
      (this.flipY = !0),
      (this.unpackAlignment = 4),
      (this.colorSpace = m),
      (this.userData = {}),
      (this.updateRanges = []),
      (this.version = 0),
      (this.onUpdate = null),
      (this.renderTarget = null),
      (this.isRenderTargetTexture = !1),
      (this.isArrayTexture = !!(e && e.depth && e.depth > 1)),
      (this.pmremVersion = 0));
  }
  get width() {
    return this.source.getSize(H_).x;
  }
  get height() {
    return this.source.getSize(H_).y;
  }
  get depth() {
    return this.source.getSize(H_).z;
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(
      this.offset.x,
      this.offset.y,
      this.repeat.x,
      this.repeat.y,
      this.rotation,
      this.center.x,
      this.center.y,
    );
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.source = e.source),
      (this.mipmaps = e.mipmaps.slice(0)),
      (this.mapping = e.mapping),
      (this.channel = e.channel),
      (this.wrapS = e.wrapS),
      (this.wrapT = e.wrapT),
      (this.magFilter = e.magFilter),
      (this.minFilter = e.minFilter),
      (this.anisotropy = e.anisotropy),
      (this.format = e.format),
      (this.internalFormat = e.internalFormat),
      (this.type = e.type),
      this.offset.copy(e.offset),
      this.repeat.copy(e.repeat),
      this.center.copy(e.center),
      (this.rotation = e.rotation),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this.matrix.copy(e.matrix),
      (this.generateMipmaps = e.generateMipmaps),
      (this.premultiplyAlpha = e.premultiplyAlpha),
      (this.flipY = e.flipY),
      (this.unpackAlignment = e.unpackAlignment),
      (this.colorSpace = e.colorSpace),
      (this.renderTarget = e.renderTarget),
      (this.isRenderTargetTexture = e.isRenderTargetTexture),
      (this.isArrayTexture = e.isArrayTexture),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      (this.needsUpdate = !0),
      this
    );
  }
  setValues(e) {
    for (const t in e) {
      const n = e[t];
      if (n === void 0) {
        Tt(`Texture.setValues(): parameter '${t}' has value of undefined.`);
        continue;
      }
      const r = this[t];
      if (r === void 0) {
        Tt(`Texture.setValues(): property '${t}' does not exist.`);
        continue;
      }
      (r && n && r.isVector2 && n.isVector2) ||
      (r && n && r.isVector3 && n.isVector3) ||
      (r && n && r.isMatrix3 && n.isMatrix3)
        ? r.copy(n)
        : (this[t] = n);
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
    const n = {
      metadata: { version: 4.7, type: "Texture", generator: "Texture.toJSON" },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment,
    };
    return (
      Object.keys(this.userData).length > 0 && (n.userData = this.userData),
      t || (e.textures[this.uuid] = n),
      n
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== K1) return e;
    if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
      switch (this.wrapS) {
        case r0:
          e.x = e.x - Math.floor(e.x);
          break;
        case xa:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case s0:
          Math.abs(Math.floor(e.x) % 2) === 1
            ? (e.x = Math.ceil(e.x) - e.x)
            : (e.x = e.x - Math.floor(e.x));
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case r0:
          e.y = e.y - Math.floor(e.y);
          break;
        case xa:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case s0:
          Math.abs(Math.floor(e.y) % 2) === 1
            ? (e.y = Math.ceil(e.y) - e.y)
            : (e.y = e.y - Math.floor(e.y));
          break;
      }
    return (this.flipY && (e.y = 1 - e.y), e);
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, (this.source.needsUpdate = !0));
  }
  set needsPMREMUpdate(e) {
    e === !0 && this.pmremVersion++;
  }
}
Fi.DEFAULT_IMAGE = null;
Fi.DEFAULT_MAPPING = K1;
Fi.DEFAULT_ANISOTROPY = 1;
class Dn {
  constructor(e = 0, t = 0, n = 0, r = 1) {
    ((Dn.prototype.isVector4 = !0),
      (this.x = e),
      (this.y = t),
      (this.z = n),
      (this.w = r));
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, t, n, r) {
    return ((this.x = e), (this.y = t), (this.z = n), (this.w = r), this);
  }
  setScalar(e) {
    return ((this.x = e), (this.y = e), (this.z = e), (this.w = e), this);
  }
  setX(e) {
    return ((this.x = e), this);
  }
  setY(e) {
    return ((this.y = e), this);
  }
  setZ(e) {
    return ((this.z = e), this);
  }
  setW(e) {
    return ((this.w = e), this);
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return (
      (this.x = e.x),
      (this.y = e.y),
      (this.z = e.z),
      (this.w = e.w !== void 0 ? e.w : 1),
      this
    );
  }
  add(e) {
    return (
      (this.x += e.x),
      (this.y += e.y),
      (this.z += e.z),
      (this.w += e.w),
      this
    );
  }
  addScalar(e) {
    return ((this.x += e), (this.y += e), (this.z += e), (this.w += e), this);
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x),
      (this.y = e.y + t.y),
      (this.z = e.z + t.z),
      (this.w = e.w + t.w),
      this
    );
  }
  addScaledVector(e, t) {
    return (
      (this.x += e.x * t),
      (this.y += e.y * t),
      (this.z += e.z * t),
      (this.w += e.w * t),
      this
    );
  }
  sub(e) {
    return (
      (this.x -= e.x),
      (this.y -= e.y),
      (this.z -= e.z),
      (this.w -= e.w),
      this
    );
  }
  subScalar(e) {
    return ((this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this);
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x),
      (this.y = e.y - t.y),
      (this.z = e.z - t.z),
      (this.w = e.w - t.w),
      this
    );
  }
  multiply(e) {
    return (
      (this.x *= e.x),
      (this.y *= e.y),
      (this.z *= e.z),
      (this.w *= e.w),
      this
    );
  }
  multiplyScalar(e) {
    return ((this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this);
  }
  applyMatrix4(e) {
    const t = this.x,
      n = this.y,
      r = this.z,
      s = this.w,
      o = e.elements;
    return (
      (this.x = o[0] * t + o[4] * n + o[8] * r + o[12] * s),
      (this.y = o[1] * t + o[5] * n + o[9] * r + o[13] * s),
      (this.z = o[2] * t + o[6] * n + o[10] * r + o[14] * s),
      (this.w = o[3] * t + o[7] * n + o[11] * r + o[15] * s),
      this
    );
  }
  divide(e) {
    return (
      (this.x /= e.x),
      (this.y /= e.y),
      (this.z /= e.z),
      (this.w /= e.w),
      this
    );
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const t = Math.sqrt(1 - e.w * e.w);
    return (
      t < 1e-4
        ? ((this.x = 1), (this.y = 0), (this.z = 0))
        : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)),
      this
    );
  }
  setAxisAngleFromRotationMatrix(e) {
    let t, n, r, s;
    const h = e.elements,
      d = h[0],
      m = h[4],
      v = h[8],
      y = h[1],
      b = h[5],
      _ = h[9],
      w = h[2],
      E = h[6],
      T = h[10];
    if (
      Math.abs(m - y) < 0.01 &&
      Math.abs(v - w) < 0.01 &&
      Math.abs(_ - E) < 0.01
    ) {
      if (
        Math.abs(m + y) < 0.1 &&
        Math.abs(v + w) < 0.1 &&
        Math.abs(_ + E) < 0.1 &&
        Math.abs(d + b + T - 3) < 0.1
      )
        return (this.set(1, 0, 0, 0), this);
      t = Math.PI;
      const R = (d + 1) / 2,
        L = (b + 1) / 2,
        I = (T + 1) / 2,
        O = (m + y) / 4,
        B = (v + w) / 4,
        N = (_ + E) / 4;
      return (
        R > L && R > I
          ? R < 0.01
            ? ((n = 0), (r = 0.707106781), (s = 0.707106781))
            : ((n = Math.sqrt(R)), (r = O / n), (s = B / n))
          : L > I
            ? L < 0.01
              ? ((n = 0.707106781), (r = 0), (s = 0.707106781))
              : ((r = Math.sqrt(L)), (n = O / r), (s = N / r))
            : I < 0.01
              ? ((n = 0.707106781), (r = 0.707106781), (s = 0))
              : ((s = Math.sqrt(I)), (n = B / s), (r = N / s)),
        this.set(n, r, s, t),
        this
      );
    }
    let C = Math.sqrt(
      (E - _) * (E - _) + (v - w) * (v - w) + (y - m) * (y - m),
    );
    return (
      Math.abs(C) < 0.001 && (C = 1),
      (this.x = (E - _) / C),
      (this.y = (v - w) / C),
      (this.z = (y - m) / C),
      (this.w = Math.acos((d + b + T - 1) / 2)),
      this
    );
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return (
      (this.x = t[12]),
      (this.y = t[13]),
      (this.z = t[14]),
      (this.w = t[15]),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      (this.w = Math.min(this.w, e.w)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      (this.w = Math.max(this.w, e.w)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Yt(this.x, e.x, t.x)),
      (this.y = Yt(this.y, e.y, t.y)),
      (this.z = Yt(this.z, e.z, t.z)),
      (this.w = Yt(this.w, e.w, t.w)),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Yt(this.x, e, t)),
      (this.y = Yt(this.y, e, t)),
      (this.z = Yt(this.z, e, t)),
      (this.w = Yt(this.w, e, t)),
      this
    );
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Yt(n, e, t));
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      (this.w = Math.floor(this.w)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      (this.w = Math.ceil(this.w)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      (this.w = Math.round(this.w)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      (this.w = Math.trunc(this.w)),
      this
    );
  }
  negate() {
    return (
      (this.x = -this.x),
      (this.y = -this.y),
      (this.z = -this.z),
      (this.w = -this.w),
      this
    );
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return (
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  length() {
    return Math.sqrt(
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w,
    );
  }
  manhattanLength() {
    return (
      Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    );
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      (this.w += (e.w - this.w) * t),
      this
    );
  }
  lerpVectors(e, t, n) {
    return (
      (this.x = e.x + (t.x - e.x) * n),
      (this.y = e.y + (t.y - e.y) * n),
      (this.z = e.z + (t.z - e.z) * n),
      (this.w = e.w + (t.w - e.w) * n),
      this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, t = 0) {
    return (
      (this.x = e[t]),
      (this.y = e[t + 1]),
      (this.z = e[t + 2]),
      (this.w = e[t + 3]),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this.x),
      (e[t + 1] = this.y),
      (e[t + 2] = this.z),
      (e[t + 3] = this.w),
      e
    );
  }
  fromBufferAttribute(e, t) {
    return (
      (this.x = e.getX(t)),
      (this.y = e.getY(t)),
      (this.z = e.getZ(t)),
      (this.w = e.getW(t)),
      this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      (this.w = Math.random()),
      this
    );
  }
  *[Symbol.iterator]() {
    (yield this.x, yield this.y, yield this.z, yield this.w);
  }
}
class WT extends ec {
  constructor(e = 1, t = 1, n = {}) {
    (super(),
      (n = Object.assign(
        {
          generateMipmaps: !1,
          internalFormat: null,
          minFilter: ni,
          depthBuffer: !0,
          stencilBuffer: !1,
          resolveDepthBuffer: !0,
          resolveStencilBuffer: !0,
          depthTexture: null,
          samples: 0,
          count: 1,
          depth: 1,
          multiview: !1,
        },
        n,
      )),
      (this.isRenderTarget = !0),
      (this.width = e),
      (this.height = t),
      (this.depth = n.depth),
      (this.scissor = new Dn(0, 0, e, t)),
      (this.scissorTest = !1),
      (this.viewport = new Dn(0, 0, e, t)),
      (this.textures = []));
    const r = { width: e, height: t, depth: n.depth },
      s = new Fi(r),
      o = n.count;
    for (let u = 0; u < o; u++)
      ((this.textures[u] = s.clone()),
        (this.textures[u].isRenderTargetTexture = !0),
        (this.textures[u].renderTarget = this));
    (this._setTextureOptions(n),
      (this.depthBuffer = n.depthBuffer),
      (this.stencilBuffer = n.stencilBuffer),
      (this.resolveDepthBuffer = n.resolveDepthBuffer),
      (this.resolveStencilBuffer = n.resolveStencilBuffer),
      (this._depthTexture = null),
      (this.depthTexture = n.depthTexture),
      (this.samples = n.samples),
      (this.multiview = n.multiview));
  }
  _setTextureOptions(e = {}) {
    const t = {
      minFilter: ni,
      generateMipmaps: !1,
      flipY: !1,
      internalFormat: null,
    };
    (e.mapping !== void 0 && (t.mapping = e.mapping),
      e.wrapS !== void 0 && (t.wrapS = e.wrapS),
      e.wrapT !== void 0 && (t.wrapT = e.wrapT),
      e.wrapR !== void 0 && (t.wrapR = e.wrapR),
      e.magFilter !== void 0 && (t.magFilter = e.magFilter),
      e.minFilter !== void 0 && (t.minFilter = e.minFilter),
      e.format !== void 0 && (t.format = e.format),
      e.type !== void 0 && (t.type = e.type),
      e.anisotropy !== void 0 && (t.anisotropy = e.anisotropy),
      e.colorSpace !== void 0 && (t.colorSpace = e.colorSpace),
      e.flipY !== void 0 && (t.flipY = e.flipY),
      e.generateMipmaps !== void 0 && (t.generateMipmaps = e.generateMipmaps),
      e.internalFormat !== void 0 && (t.internalFormat = e.internalFormat));
    for (let n = 0; n < this.textures.length; n++)
      this.textures[n].setValues(t);
  }
  get texture() {
    return this.textures[0];
  }
  set texture(e) {
    this.textures[0] = e;
  }
  set depthTexture(e) {
    (this._depthTexture !== null && (this._depthTexture.renderTarget = null),
      e !== null && (e.renderTarget = this),
      (this._depthTexture = e));
  }
  get depthTexture() {
    return this._depthTexture;
  }
  setSize(e, t, n = 1) {
    if (this.width !== e || this.height !== t || this.depth !== n) {
      ((this.width = e), (this.height = t), (this.depth = n));
      for (let r = 0, s = this.textures.length; r < s; r++)
        ((this.textures[r].image.width = e),
          (this.textures[r].image.height = t),
          (this.textures[r].image.depth = n),
          this.textures[r].isData3DTexture !== !0 &&
            (this.textures[r].isArrayTexture =
              this.textures[r].image.depth > 1));
      this.dispose();
    }
    (this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t));
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    ((this.width = e.width),
      (this.height = e.height),
      (this.depth = e.depth),
      this.scissor.copy(e.scissor),
      (this.scissorTest = e.scissorTest),
      this.viewport.copy(e.viewport),
      (this.textures.length = 0));
    for (let t = 0, n = e.textures.length; t < n; t++) {
      ((this.textures[t] = e.textures[t].clone()),
        (this.textures[t].isRenderTargetTexture = !0),
        (this.textures[t].renderTarget = this));
      const r = Object.assign({}, e.textures[t].image);
      this.textures[t].source = new ef(r);
    }
    return (
      (this.depthBuffer = e.depthBuffer),
      (this.stencilBuffer = e.stencilBuffer),
      (this.resolveDepthBuffer = e.resolveDepthBuffer),
      (this.resolveStencilBuffer = e.resolveStencilBuffer),
      e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
      (this.samples = e.samples),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class Oa extends WT {
  constructor(e = 1, t = 1, n = {}) {
    (super(e, t, n), (this.isWebGLRenderTarget = !0));
  }
}
class ab extends Fi {
  constructor(e = null, t = 1, n = 1, r = 1) {
    (super(null),
      (this.isDataArrayTexture = !0),
      (this.image = { data: e, width: t, height: n, depth: r }),
      (this.magFilter = rr),
      (this.minFilter = rr),
      (this.wrapR = xa),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1),
      (this.layerUpdates = new Set()));
  }
  addLayerUpdate(e) {
    this.layerUpdates.add(e);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class nk extends Oa {
  constructor(e = 1, t = 1, n = 1, r = {}) {
    (super(e, t, r),
      (this.isWebGLArrayRenderTarget = !0),
      (this.depth = n),
      (this.texture = new ab(null, e, t, n)),
      this._setTextureOptions(r),
      (this.texture.isRenderTargetTexture = !0));
  }
}
class ob extends Fi {
  constructor(e = null, t = 1, n = 1, r = 1) {
    (super(null),
      (this.isData3DTexture = !0),
      (this.image = { data: e, width: t, height: n, depth: r }),
      (this.magFilter = rr),
      (this.minFilter = rr),
      (this.wrapR = xa),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1));
  }
}
class ik extends Oa {
  constructor(e = 1, t = 1, n = 1, r = {}) {
    (super(e, t, r),
      (this.isWebGL3DRenderTarget = !0),
      (this.depth = n),
      (this.texture = new ob(null, e, t, n)),
      this._setTextureOptions(r),
      (this.texture.isRenderTargetTexture = !0));
  }
}
class qt {
  constructor(e, t, n, r, s, o, u, h, d, m, v, y, b, _, w, E) {
    ((qt.prototype.isMatrix4 = !0),
      (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
      e !== void 0 && this.set(e, t, n, r, s, o, u, h, d, m, v, y, b, _, w, E));
  }
  set(e, t, n, r, s, o, u, h, d, m, v, y, b, _, w, E) {
    const T = this.elements;
    return (
      (T[0] = e),
      (T[4] = t),
      (T[8] = n),
      (T[12] = r),
      (T[1] = s),
      (T[5] = o),
      (T[9] = u),
      (T[13] = h),
      (T[2] = d),
      (T[6] = m),
      (T[10] = v),
      (T[14] = y),
      (T[3] = b),
      (T[7] = _),
      (T[11] = w),
      (T[15] = E),
      this
    );
  }
  identity() {
    return (this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this);
  }
  clone() {
    return new qt().fromArray(this.elements);
  }
  copy(e) {
    const t = this.elements,
      n = e.elements;
    return (
      (t[0] = n[0]),
      (t[1] = n[1]),
      (t[2] = n[2]),
      (t[3] = n[3]),
      (t[4] = n[4]),
      (t[5] = n[5]),
      (t[6] = n[6]),
      (t[7] = n[7]),
      (t[8] = n[8]),
      (t[9] = n[9]),
      (t[10] = n[10]),
      (t[11] = n[11]),
      (t[12] = n[12]),
      (t[13] = n[13]),
      (t[14] = n[14]),
      (t[15] = n[15]),
      this
    );
  }
  copyPosition(e) {
    const t = this.elements,
      n = e.elements;
    return ((t[12] = n[12]), (t[13] = n[13]), (t[14] = n[14]), this);
  }
  setFromMatrix3(e) {
    const t = e.elements;
    return (
      this.set(
        t[0],
        t[3],
        t[6],
        0,
        t[1],
        t[4],
        t[7],
        0,
        t[2],
        t[5],
        t[8],
        0,
        0,
        0,
        0,
        1,
      ),
      this
    );
  }
  extractBasis(e, t, n) {
    return this.determinant() === 0
      ? (e.set(1, 0, 0), t.set(0, 1, 0), n.set(0, 0, 1), this)
      : (e.setFromMatrixColumn(this, 0),
        t.setFromMatrixColumn(this, 1),
        n.setFromMatrixColumn(this, 2),
        this);
  }
  makeBasis(e, t, n) {
    return (
      this.set(
        e.x,
        t.x,
        n.x,
        0,
        e.y,
        t.y,
        n.y,
        0,
        e.z,
        t.z,
        n.z,
        0,
        0,
        0,
        0,
        1,
      ),
      this
    );
  }
  extractRotation(e) {
    if (e.determinant() === 0) return this.identity();
    const t = this.elements,
      n = e.elements,
      r = 1 / Vd.setFromMatrixColumn(e, 0).length(),
      s = 1 / Vd.setFromMatrixColumn(e, 1).length(),
      o = 1 / Vd.setFromMatrixColumn(e, 2).length();
    return (
      (t[0] = n[0] * r),
      (t[1] = n[1] * r),
      (t[2] = n[2] * r),
      (t[3] = 0),
      (t[4] = n[4] * s),
      (t[5] = n[5] * s),
      (t[6] = n[6] * s),
      (t[7] = 0),
      (t[8] = n[8] * o),
      (t[9] = n[9] * o),
      (t[10] = n[10] * o),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  makeRotationFromEuler(e) {
    const t = this.elements,
      n = e.x,
      r = e.y,
      s = e.z,
      o = Math.cos(n),
      u = Math.sin(n),
      h = Math.cos(r),
      d = Math.sin(r),
      m = Math.cos(s),
      v = Math.sin(s);
    if (e.order === "XYZ") {
      const y = o * m,
        b = o * v,
        _ = u * m,
        w = u * v;
      ((t[0] = h * m),
        (t[4] = -h * v),
        (t[8] = d),
        (t[1] = b + _ * d),
        (t[5] = y - w * d),
        (t[9] = -u * h),
        (t[2] = w - y * d),
        (t[6] = _ + b * d),
        (t[10] = o * h));
    } else if (e.order === "YXZ") {
      const y = h * m,
        b = h * v,
        _ = d * m,
        w = d * v;
      ((t[0] = y + w * u),
        (t[4] = _ * u - b),
        (t[8] = o * d),
        (t[1] = o * v),
        (t[5] = o * m),
        (t[9] = -u),
        (t[2] = b * u - _),
        (t[6] = w + y * u),
        (t[10] = o * h));
    } else if (e.order === "ZXY") {
      const y = h * m,
        b = h * v,
        _ = d * m,
        w = d * v;
      ((t[0] = y - w * u),
        (t[4] = -o * v),
        (t[8] = _ + b * u),
        (t[1] = b + _ * u),
        (t[5] = o * m),
        (t[9] = w - y * u),
        (t[2] = -o * d),
        (t[6] = u),
        (t[10] = o * h));
    } else if (e.order === "ZYX") {
      const y = o * m,
        b = o * v,
        _ = u * m,
        w = u * v;
      ((t[0] = h * m),
        (t[4] = _ * d - b),
        (t[8] = y * d + w),
        (t[1] = h * v),
        (t[5] = w * d + y),
        (t[9] = b * d - _),
        (t[2] = -d),
        (t[6] = u * h),
        (t[10] = o * h));
    } else if (e.order === "YZX") {
      const y = o * h,
        b = o * d,
        _ = u * h,
        w = u * d;
      ((t[0] = h * m),
        (t[4] = w - y * v),
        (t[8] = _ * v + b),
        (t[1] = v),
        (t[5] = o * m),
        (t[9] = -u * m),
        (t[2] = -d * m),
        (t[6] = b * v + _),
        (t[10] = y - w * v));
    } else if (e.order === "XZY") {
      const y = o * h,
        b = o * d,
        _ = u * h,
        w = u * d;
      ((t[0] = h * m),
        (t[4] = -v),
        (t[8] = d * m),
        (t[1] = y * v + w),
        (t[5] = o * m),
        (t[9] = b * v - _),
        (t[2] = _ * v - b),
        (t[6] = u * m),
        (t[10] = w * v + y));
    }
    return (
      (t[3] = 0),
      (t[7] = 0),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  makeRotationFromQuaternion(e) {
    return this.compose(rk, e, sk);
  }
  lookAt(e, t, n) {
    const r = this.elements;
    return (
      Da.subVectors(e, t),
      Da.lengthSq() === 0 && (Da.z = 1),
      Da.normalize(),
      Vu.crossVectors(n, Da),
      Vu.lengthSq() === 0 &&
        (Math.abs(n.z) === 1 ? (Da.x += 1e-4) : (Da.z += 1e-4),
        Da.normalize(),
        Vu.crossVectors(n, Da)),
      Vu.normalize(),
      xy.crossVectors(Da, Vu),
      (r[0] = Vu.x),
      (r[4] = xy.x),
      (r[8] = Da.x),
      (r[1] = Vu.y),
      (r[5] = xy.y),
      (r[9] = Da.y),
      (r[2] = Vu.z),
      (r[6] = xy.z),
      (r[10] = Da.z),
      this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const n = e.elements,
      r = t.elements,
      s = this.elements,
      o = n[0],
      u = n[4],
      h = n[8],
      d = n[12],
      m = n[1],
      v = n[5],
      y = n[9],
      b = n[13],
      _ = n[2],
      w = n[6],
      E = n[10],
      T = n[14],
      C = n[3],
      R = n[7],
      L = n[11],
      I = n[15],
      O = r[0],
      B = r[4],
      N = r[8],
      F = r[12],
      j = r[1],
      q = r[5],
      X = r[9],
      J = r[13],
      ee = r[2],
      ne = r[6],
      W = r[10],
      $ = r[14],
      de = r[3],
      le = r[7],
      fe = r[11],
      V = r[15];
    return (
      (s[0] = o * O + u * j + h * ee + d * de),
      (s[4] = o * B + u * q + h * ne + d * le),
      (s[8] = o * N + u * X + h * W + d * fe),
      (s[12] = o * F + u * J + h * $ + d * V),
      (s[1] = m * O + v * j + y * ee + b * de),
      (s[5] = m * B + v * q + y * ne + b * le),
      (s[9] = m * N + v * X + y * W + b * fe),
      (s[13] = m * F + v * J + y * $ + b * V),
      (s[2] = _ * O + w * j + E * ee + T * de),
      (s[6] = _ * B + w * q + E * ne + T * le),
      (s[10] = _ * N + w * X + E * W + T * fe),
      (s[14] = _ * F + w * J + E * $ + T * V),
      (s[3] = C * O + R * j + L * ee + I * de),
      (s[7] = C * B + R * q + L * ne + I * le),
      (s[11] = C * N + R * X + L * W + I * fe),
      (s[15] = C * F + R * J + L * $ + I * V),
      this
    );
  }
  multiplyScalar(e) {
    const t = this.elements;
    return (
      (t[0] *= e),
      (t[4] *= e),
      (t[8] *= e),
      (t[12] *= e),
      (t[1] *= e),
      (t[5] *= e),
      (t[9] *= e),
      (t[13] *= e),
      (t[2] *= e),
      (t[6] *= e),
      (t[10] *= e),
      (t[14] *= e),
      (t[3] *= e),
      (t[7] *= e),
      (t[11] *= e),
      (t[15] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      n = e[4],
      r = e[8],
      s = e[12],
      o = e[1],
      u = e[5],
      h = e[9],
      d = e[13],
      m = e[2],
      v = e[6],
      y = e[10],
      b = e[14],
      _ = e[3],
      w = e[7],
      E = e[11],
      T = e[15],
      C = h * b - d * y,
      R = u * b - d * v,
      L = u * y - h * v,
      I = o * b - d * m,
      O = o * y - h * m,
      B = o * v - u * m;
    return (
      t * (w * C - E * R + T * L) -
      n * (_ * C - E * I + T * O) +
      r * (_ * R - w * I + T * B) -
      s * (_ * L - w * O + E * B)
    );
  }
  transpose() {
    const e = this.elements;
    let t;
    return (
      (t = e[1]),
      (e[1] = e[4]),
      (e[4] = t),
      (t = e[2]),
      (e[2] = e[8]),
      (e[8] = t),
      (t = e[6]),
      (e[6] = e[9]),
      (e[9] = t),
      (t = e[3]),
      (e[3] = e[12]),
      (e[12] = t),
      (t = e[7]),
      (e[7] = e[13]),
      (e[13] = t),
      (t = e[11]),
      (e[11] = e[14]),
      (e[14] = t),
      this
    );
  }
  setPosition(e, t, n) {
    const r = this.elements;
    return (
      e.isVector3
        ? ((r[12] = e.x), (r[13] = e.y), (r[14] = e.z))
        : ((r[12] = e), (r[13] = t), (r[14] = n)),
      this
    );
  }
  invert() {
    const e = this.elements,
      t = e[0],
      n = e[1],
      r = e[2],
      s = e[3],
      o = e[4],
      u = e[5],
      h = e[6],
      d = e[7],
      m = e[8],
      v = e[9],
      y = e[10],
      b = e[11],
      _ = e[12],
      w = e[13],
      E = e[14],
      T = e[15],
      C = t * u - n * o,
      R = t * h - r * o,
      L = t * d - s * o,
      I = n * h - r * u,
      O = n * d - s * u,
      B = r * d - s * h,
      N = m * w - v * _,
      F = m * E - y * _,
      j = m * T - b * _,
      q = v * E - y * w,
      X = v * T - b * w,
      J = y * T - b * E,
      ee = C * J - R * X + L * q + I * j - O * F + B * N;
    if (ee === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const ne = 1 / ee;
    return (
      (e[0] = (u * J - h * X + d * q) * ne),
      (e[1] = (r * X - n * J - s * q) * ne),
      (e[2] = (w * B - E * O + T * I) * ne),
      (e[3] = (y * O - v * B - b * I) * ne),
      (e[4] = (h * j - o * J - d * F) * ne),
      (e[5] = (t * J - r * j + s * F) * ne),
      (e[6] = (E * L - _ * B - T * R) * ne),
      (e[7] = (m * B - y * L + b * R) * ne),
      (e[8] = (o * X - u * j + d * N) * ne),
      (e[9] = (n * j - t * X - s * N) * ne),
      (e[10] = (_ * O - w * L + T * C) * ne),
      (e[11] = (v * L - m * O - b * C) * ne),
      (e[12] = (u * F - o * q - h * N) * ne),
      (e[13] = (t * q - n * F + r * N) * ne),
      (e[14] = (w * R - _ * I - E * C) * ne),
      (e[15] = (m * I - v * R + y * C) * ne),
      this
    );
  }
  scale(e) {
    const t = this.elements,
      n = e.x,
      r = e.y,
      s = e.z;
    return (
      (t[0] *= n),
      (t[4] *= r),
      (t[8] *= s),
      (t[1] *= n),
      (t[5] *= r),
      (t[9] *= s),
      (t[2] *= n),
      (t[6] *= r),
      (t[10] *= s),
      (t[3] *= n),
      (t[7] *= r),
      (t[11] *= s),
      this
    );
  }
  getMaxScaleOnAxis() {
    const e = this.elements,
      t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
      n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
      r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, n, r));
  }
  makeTranslation(e, t, n) {
    return (
      e.isVector3
        ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1)
        : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1),
      this
    );
  }
  makeRotationX(e) {
    const t = Math.cos(e),
      n = Math.sin(e);
    return (this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this);
  }
  makeRotationY(e) {
    const t = Math.cos(e),
      n = Math.sin(e);
    return (this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this);
  }
  makeRotationZ(e) {
    const t = Math.cos(e),
      n = Math.sin(e);
    return (this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this);
  }
  makeRotationAxis(e, t) {
    const n = Math.cos(t),
      r = Math.sin(t),
      s = 1 - n,
      o = e.x,
      u = e.y,
      h = e.z,
      d = s * o,
      m = s * u;
    return (
      this.set(
        d * o + n,
        d * u - r * h,
        d * h + r * u,
        0,
        d * u + r * h,
        m * u + n,
        m * h - r * o,
        0,
        d * h - r * u,
        m * h + r * o,
        s * h * h + n,
        0,
        0,
        0,
        0,
        1,
      ),
      this
    );
  }
  makeScale(e, t, n) {
    return (this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this);
  }
  makeShear(e, t, n, r, s, o) {
    return (this.set(1, n, s, 0, e, 1, o, 0, t, r, 1, 0, 0, 0, 0, 1), this);
  }
  compose(e, t, n) {
    const r = this.elements,
      s = t._x,
      o = t._y,
      u = t._z,
      h = t._w,
      d = s + s,
      m = o + o,
      v = u + u,
      y = s * d,
      b = s * m,
      _ = s * v,
      w = o * m,
      E = o * v,
      T = u * v,
      C = h * d,
      R = h * m,
      L = h * v,
      I = n.x,
      O = n.y,
      B = n.z;
    return (
      (r[0] = (1 - (w + T)) * I),
      (r[1] = (b + L) * I),
      (r[2] = (_ - R) * I),
      (r[3] = 0),
      (r[4] = (b - L) * O),
      (r[5] = (1 - (y + T)) * O),
      (r[6] = (E + C) * O),
      (r[7] = 0),
      (r[8] = (_ + R) * B),
      (r[9] = (E - C) * B),
      (r[10] = (1 - (y + w)) * B),
      (r[11] = 0),
      (r[12] = e.x),
      (r[13] = e.y),
      (r[14] = e.z),
      (r[15] = 1),
      this
    );
  }
  decompose(e, t, n) {
    const r = this.elements;
    ((e.x = r[12]), (e.y = r[13]), (e.z = r[14]));
    const s = this.determinant();
    if (s === 0) return (n.set(1, 1, 1), t.identity(), this);
    let o = Vd.set(r[0], r[1], r[2]).length();
    const u = Vd.set(r[4], r[5], r[6]).length(),
      h = Vd.set(r[8], r[9], r[10]).length();
    (s < 0 && (o = -o), Vo.copy(this));
    const d = 1 / o,
      m = 1 / u,
      v = 1 / h;
    return (
      (Vo.elements[0] *= d),
      (Vo.elements[1] *= d),
      (Vo.elements[2] *= d),
      (Vo.elements[4] *= m),
      (Vo.elements[5] *= m),
      (Vo.elements[6] *= m),
      (Vo.elements[8] *= v),
      (Vo.elements[9] *= v),
      (Vo.elements[10] *= v),
      t.setFromRotationMatrix(Vo),
      (n.x = o),
      (n.y = u),
      (n.z = h),
      this
    );
  }
  makePerspective(e, t, n, r, s, o, u = Ua, h = !1) {
    const d = this.elements,
      m = (2 * s) / (t - e),
      v = (2 * s) / (n - r),
      y = (t + e) / (t - e),
      b = (n + r) / (n - r);
    let _, w;
    if (h) ((_ = s / (o - s)), (w = (o * s) / (o - s)));
    else if (u === Ua) ((_ = -(o + s) / (o - s)), (w = (-2 * o * s) / (o - s)));
    else if (u === Nh) ((_ = -o / (o - s)), (w = (-o * s) / (o - s)));
    else
      throw new Error(
        "THREE.Matrix4.makePerspective(): Invalid coordinate system: " + u,
      );
    return (
      (d[0] = m),
      (d[4] = 0),
      (d[8] = y),
      (d[12] = 0),
      (d[1] = 0),
      (d[5] = v),
      (d[9] = b),
      (d[13] = 0),
      (d[2] = 0),
      (d[6] = 0),
      (d[10] = _),
      (d[14] = w),
      (d[3] = 0),
      (d[7] = 0),
      (d[11] = -1),
      (d[15] = 0),
      this
    );
  }
  makeOrthographic(e, t, n, r, s, o, u = Ua, h = !1) {
    const d = this.elements,
      m = 2 / (t - e),
      v = 2 / (n - r),
      y = -(t + e) / (t - e),
      b = -(n + r) / (n - r);
    let _, w;
    if (h) ((_ = 1 / (o - s)), (w = o / (o - s)));
    else if (u === Ua) ((_ = -2 / (o - s)), (w = -(o + s) / (o - s)));
    else if (u === Nh) ((_ = -1 / (o - s)), (w = -s / (o - s)));
    else
      throw new Error(
        "THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + u,
      );
    return (
      (d[0] = m),
      (d[4] = 0),
      (d[8] = 0),
      (d[12] = y),
      (d[1] = 0),
      (d[5] = v),
      (d[9] = 0),
      (d[13] = b),
      (d[2] = 0),
      (d[6] = 0),
      (d[10] = _),
      (d[14] = w),
      (d[3] = 0),
      (d[7] = 0),
      (d[11] = 0),
      (d[15] = 1),
      this
    );
  }
  equals(e) {
    const t = this.elements,
      n = e.elements;
    for (let r = 0; r < 16; r++) if (t[r] !== n[r]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let n = 0; n < 16; n++) this.elements[n] = e[n + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.elements;
    return (
      (e[t] = n[0]),
      (e[t + 1] = n[1]),
      (e[t + 2] = n[2]),
      (e[t + 3] = n[3]),
      (e[t + 4] = n[4]),
      (e[t + 5] = n[5]),
      (e[t + 6] = n[6]),
      (e[t + 7] = n[7]),
      (e[t + 8] = n[8]),
      (e[t + 9] = n[9]),
      (e[t + 10] = n[10]),
      (e[t + 11] = n[11]),
      (e[t + 12] = n[12]),
      (e[t + 13] = n[13]),
      (e[t + 14] = n[14]),
      (e[t + 15] = n[15]),
      e
    );
  }
}
const Vd = new te(),
  Vo = new qt(),
  rk = new te(0, 0, 0),
  sk = new te(1, 1, 1),
  Vu = new te(),
  xy = new te(),
  Da = new te(),
  qA = new qt(),
  YA = new Jr();
class Fa {
  constructor(e = 0, t = 0, n = 0, r = Fa.DEFAULT_ORDER) {
    ((this.isEuler = !0),
      (this._x = e),
      (this._y = t),
      (this._z = n),
      (this._order = r));
  }
  get x() {
    return this._x;
  }
  set x(e) {
    ((this._x = e), this._onChangeCallback());
  }
  get y() {
    return this._y;
  }
  set y(e) {
    ((this._y = e), this._onChangeCallback());
  }
  get z() {
    return this._z;
  }
  set z(e) {
    ((this._z = e), this._onChangeCallback());
  }
  get order() {
    return this._order;
  }
  set order(e) {
    ((this._order = e), this._onChangeCallback());
  }
  set(e, t, n, r = this._order) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = n),
      (this._order = r),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return (
      (this._x = e._x),
      (this._y = e._y),
      (this._z = e._z),
      (this._order = e._order),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e, t = this._order, n = !0) {
    const r = e.elements,
      s = r[0],
      o = r[4],
      u = r[8],
      h = r[1],
      d = r[5],
      m = r[9],
      v = r[2],
      y = r[6],
      b = r[10];
    switch (t) {
      case "XYZ":
        ((this._y = Math.asin(Yt(u, -1, 1))),
          Math.abs(u) < 0.9999999
            ? ((this._x = Math.atan2(-m, b)), (this._z = Math.atan2(-o, s)))
            : ((this._x = Math.atan2(y, d)), (this._z = 0)));
        break;
      case "YXZ":
        ((this._x = Math.asin(-Yt(m, -1, 1))),
          Math.abs(m) < 0.9999999
            ? ((this._y = Math.atan2(u, b)), (this._z = Math.atan2(h, d)))
            : ((this._y = Math.atan2(-v, s)), (this._z = 0)));
        break;
      case "ZXY":
        ((this._x = Math.asin(Yt(y, -1, 1))),
          Math.abs(y) < 0.9999999
            ? ((this._y = Math.atan2(-v, b)), (this._z = Math.atan2(-o, d)))
            : ((this._y = 0), (this._z = Math.atan2(h, s))));
        break;
      case "ZYX":
        ((this._y = Math.asin(-Yt(v, -1, 1))),
          Math.abs(v) < 0.9999999
            ? ((this._x = Math.atan2(y, b)), (this._z = Math.atan2(h, s)))
            : ((this._x = 0), (this._z = Math.atan2(-o, d))));
        break;
      case "YZX":
        ((this._z = Math.asin(Yt(h, -1, 1))),
          Math.abs(h) < 0.9999999
            ? ((this._x = Math.atan2(-m, d)), (this._y = Math.atan2(-v, s)))
            : ((this._x = 0), (this._y = Math.atan2(u, b))));
        break;
      case "XZY":
        ((this._z = Math.asin(-Yt(o, -1, 1))),
          Math.abs(o) < 0.9999999
            ? ((this._x = Math.atan2(y, d)), (this._y = Math.atan2(u, s)))
            : ((this._x = Math.atan2(-m, b)), (this._y = 0)));
        break;
      default:
        Tt(
          "Euler: .setFromRotationMatrix() encountered an unknown order: " + t,
        );
    }
    return ((this._order = t), n === !0 && this._onChangeCallback(), this);
  }
  setFromQuaternion(e, t, n) {
    return (
      qA.makeRotationFromQuaternion(e),
      this.setFromRotationMatrix(qA, t, n)
    );
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  reorder(e) {
    return (YA.setFromEuler(this), this.setFromQuaternion(YA, e));
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._order === this._order
    );
  }
  fromArray(e) {
    return (
      (this._x = e[0]),
      (this._y = e[1]),
      (this._z = e[2]),
      e[3] !== void 0 && (this._order = e[3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._order),
      e
    );
  }
  _onChange(e) {
    return ((this._onChangeCallback = e), this);
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    (yield this._x, yield this._y, yield this._z, yield this._order);
  }
}
Fa.DEFAULT_ORDER = "XYZ";
class Ap {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = ((1 << e) | 0) >>> 0;
  }
  enable(e) {
    this.mask |= (1 << e) | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= (1 << e) | 0;
  }
  disable(e) {
    this.mask &= ~((1 << e) | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & ((1 << e) | 0)) !== 0;
  }
}
let ak = 0;
const ZA = new te(),
  Gd = new Jr(),
  Ic = new qt(),
  by = new te(),
  pg = new te(),
  ok = new te(),
  lk = new Jr(),
  KA = new te(1, 0, 0),
  QA = new te(0, 1, 0),
  JA = new te(0, 0, 1),
  $A = { type: "added" },
  ck = { type: "removed" },
  Hd = { type: "childadded", child: null },
  j_ = { type: "childremoved", child: null };
class In extends ec {
  constructor() {
    (super(),
      (this.isObject3D = !0),
      Object.defineProperty(this, "id", { value: ak++ }),
      (this.uuid = Ia()),
      (this.name = ""),
      (this.type = "Object3D"),
      (this.parent = null),
      (this.children = []),
      (this.up = In.DEFAULT_UP.clone()));
    const e = new te(),
      t = new Fa(),
      n = new Jr(),
      r = new te(1, 1, 1);
    function s() {
      n.setFromEuler(t, !1);
    }
    function o() {
      t.setFromQuaternion(n, void 0, !1);
    }
    (t._onChange(s),
      n._onChange(o),
      Object.defineProperties(this, {
        position: { configurable: !0, enumerable: !0, value: e },
        rotation: { configurable: !0, enumerable: !0, value: t },
        quaternion: { configurable: !0, enumerable: !0, value: n },
        scale: { configurable: !0, enumerable: !0, value: r },
        modelViewMatrix: { value: new qt() },
        normalMatrix: { value: new tn() },
      }),
      (this.matrix = new qt()),
      (this.matrixWorld = new qt()),
      (this.matrixAutoUpdate = In.DEFAULT_MATRIX_AUTO_UPDATE),
      (this.matrixWorldAutoUpdate = In.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
      (this.matrixWorldNeedsUpdate = !1),
      (this.layers = new Ap()),
      (this.visible = !0),
      (this.castShadow = !1),
      (this.receiveShadow = !1),
      (this.frustumCulled = !0),
      (this.renderOrder = 0),
      (this.animations = []),
      (this.customDepthMaterial = void 0),
      (this.customDistanceMaterial = void 0),
      (this.static = !1),
      (this.userData = {}),
      (this.pivot = null));
  }
  onBeforeShadow() {}
  onAfterShadow() {}
  onBeforeRender() {}
  onAfterRender() {}
  applyMatrix4(e) {
    (this.matrixAutoUpdate && this.updateMatrix(),
      this.matrix.premultiply(e),
      this.matrix.decompose(this.position, this.quaternion, this.scale));
  }
  applyQuaternion(e) {
    return (this.quaternion.premultiply(e), this);
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, t) {
    return (Gd.setFromAxisAngle(e, t), this.quaternion.multiply(Gd), this);
  }
  rotateOnWorldAxis(e, t) {
    return (Gd.setFromAxisAngle(e, t), this.quaternion.premultiply(Gd), this);
  }
  rotateX(e) {
    return this.rotateOnAxis(KA, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(QA, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(JA, e);
  }
  translateOnAxis(e, t) {
    return (
      ZA.copy(e).applyQuaternion(this.quaternion),
      this.position.add(ZA.multiplyScalar(t)),
      this
    );
  }
  translateX(e) {
    return this.translateOnAxis(KA, e);
  }
  translateY(e) {
    return this.translateOnAxis(QA, e);
  }
  translateZ(e) {
    return this.translateOnAxis(JA, e);
  }
  localToWorld(e) {
    return (this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld));
  }
  worldToLocal(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      e.applyMatrix4(Ic.copy(this.matrixWorld).invert())
    );
  }
  lookAt(e, t, n) {
    e.isVector3 ? by.copy(e) : by.set(e, t, n);
    const r = this.parent;
    (this.updateWorldMatrix(!0, !1),
      pg.setFromMatrixPosition(this.matrixWorld),
      this.isCamera || this.isLight
        ? Ic.lookAt(pg, by, this.up)
        : Ic.lookAt(by, pg, this.up),
      this.quaternion.setFromRotationMatrix(Ic),
      r &&
        (Ic.extractRotation(r.matrixWorld),
        Gd.setFromRotationMatrix(Ic),
        this.quaternion.premultiply(Gd.invert())));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
      return this;
    }
    return e === this
      ? (Ft("Object3D.add: object can't be added as a child of itself.", e),
        this)
      : (e && e.isObject3D
          ? (e.removeFromParent(),
            (e.parent = this),
            this.children.push(e),
            e.dispatchEvent($A),
            (Hd.child = e),
            this.dispatchEvent(Hd),
            (Hd.child = null))
          : Ft("Object3D.add: object not an instance of THREE.Object3D.", e),
        this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let n = 0; n < arguments.length; n++) this.remove(arguments[n]);
      return this;
    }
    const t = this.children.indexOf(e);
    return (
      t !== -1 &&
        ((e.parent = null),
        this.children.splice(t, 1),
        e.dispatchEvent(ck),
        (j_.child = e),
        this.dispatchEvent(j_),
        (j_.child = null)),
      this
    );
  }
  removeFromParent() {
    const e = this.parent;
    return (e !== null && e.remove(this), this);
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      Ic.copy(this.matrixWorld).invert(),
      e.parent !== null &&
        (e.parent.updateWorldMatrix(!0, !1), Ic.multiply(e.parent.matrixWorld)),
      e.applyMatrix4(Ic),
      e.removeFromParent(),
      (e.parent = this),
      this.children.push(e),
      e.updateWorldMatrix(!1, !0),
      e.dispatchEvent($A),
      (Hd.child = e),
      this.dispatchEvent(Hd),
      (Hd.child = null),
      this
    );
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, t) {
    if (this[e] === t) return this;
    for (let n = 0, r = this.children.length; n < r; n++) {
      const o = this.children[n].getObjectByProperty(e, t);
      if (o !== void 0) return o;
    }
  }
  getObjectsByProperty(e, t, n = []) {
    this[e] === t && n.push(this);
    const r = this.children;
    for (let s = 0, o = r.length; s < o; s++)
      r[s].getObjectsByProperty(e, t, n);
    return n;
  }
  getWorldPosition(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      e.setFromMatrixPosition(this.matrixWorld)
    );
  }
  getWorldQuaternion(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      this.matrixWorld.decompose(pg, e, ok),
      e
    );
  }
  getWorldScale(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      this.matrixWorld.decompose(pg, lk, e),
      e
    );
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  raycast() {}
  traverse(e) {
    e(this);
    const t = this.children;
    for (let n = 0, r = t.length; n < r; n++) t[n].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const t = this.children;
    for (let n = 0, r = t.length; n < r; n++) t[n].traverseVisible(e);
  }
  traverseAncestors(e) {
    const t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale);
    const e = this.pivot;
    if (e !== null) {
      const t = e.x,
        n = e.y,
        r = e.z,
        s = this.matrix.elements;
      ((s[12] += t - s[0] * t - s[4] * n - s[8] * r),
        (s[13] += n - s[1] * t - s[5] * n - s[9] * r),
        (s[14] += r - s[2] * t - s[6] * n - s[10] * r));
    }
    this.matrixWorldNeedsUpdate = !0;
  }
  updateMatrixWorld(e) {
    (this.matrixAutoUpdate && this.updateMatrix(),
      (this.matrixWorldNeedsUpdate || e) &&
        (this.matrixWorldAutoUpdate === !0 &&
          (this.parent === null
            ? this.matrixWorld.copy(this.matrix)
            : this.matrixWorld.multiplyMatrices(
                this.parent.matrixWorld,
                this.matrix,
              )),
        (this.matrixWorldNeedsUpdate = !1),
        (e = !0)));
    const t = this.children;
    for (let n = 0, r = t.length; n < r; n++) t[n].updateMatrixWorld(e);
  }
  updateWorldMatrix(e, t) {
    const n = this.parent;
    if (
      (e === !0 && n !== null && n.updateWorldMatrix(!0, !1),
      this.matrixAutoUpdate && this.updateMatrix(),
      this.matrixWorldAutoUpdate === !0 &&
        (this.parent === null
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(
              this.parent.matrixWorld,
              this.matrix,
            )),
      t === !0)
    ) {
      const r = this.children;
      for (let s = 0, o = r.length; s < o; s++) r[s].updateWorldMatrix(!1, !0);
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string",
      n = {};
    t &&
      ((e = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {},
      }),
      (n.metadata = {
        version: 4.7,
        type: "Object",
        generator: "Object3D.toJSON",
      }));
    const r = {};
    ((r.uuid = this.uuid),
      (r.type = this.type),
      this.name !== "" && (r.name = this.name),
      this.castShadow === !0 && (r.castShadow = !0),
      this.receiveShadow === !0 && (r.receiveShadow = !0),
      this.visible === !1 && (r.visible = !1),
      this.frustumCulled === !1 && (r.frustumCulled = !1),
      this.renderOrder !== 0 && (r.renderOrder = this.renderOrder),
      this.static !== !1 && (r.static = this.static),
      Object.keys(this.userData).length > 0 && (r.userData = this.userData),
      (r.layers = this.layers.mask),
      (r.matrix = this.matrix.toArray()),
      (r.up = this.up.toArray()),
      this.pivot !== null && (r.pivot = this.pivot.toArray()),
      this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1),
      this.morphTargetDictionary !== void 0 &&
        (r.morphTargetDictionary = Object.assign(
          {},
          this.morphTargetDictionary,
        )),
      this.morphTargetInfluences !== void 0 &&
        (r.morphTargetInfluences = this.morphTargetInfluences.slice()),
      this.isInstancedMesh &&
        ((r.type = "InstancedMesh"),
        (r.count = this.count),
        (r.instanceMatrix = this.instanceMatrix.toJSON()),
        this.instanceColor !== null &&
          (r.instanceColor = this.instanceColor.toJSON())),
      this.isBatchedMesh &&
        ((r.type = "BatchedMesh"),
        (r.perObjectFrustumCulled = this.perObjectFrustumCulled),
        (r.sortObjects = this.sortObjects),
        (r.drawRanges = this._drawRanges),
        (r.reservedRanges = this._reservedRanges),
        (r.geometryInfo = this._geometryInfo.map((u) => ({
          ...u,
          boundingBox: u.boundingBox ? u.boundingBox.toJSON() : void 0,
          boundingSphere: u.boundingSphere ? u.boundingSphere.toJSON() : void 0,
        }))),
        (r.instanceInfo = this._instanceInfo.map((u) => ({ ...u }))),
        (r.availableInstanceIds = this._availableInstanceIds.slice()),
        (r.availableGeometryIds = this._availableGeometryIds.slice()),
        (r.nextIndexStart = this._nextIndexStart),
        (r.nextVertexStart = this._nextVertexStart),
        (r.geometryCount = this._geometryCount),
        (r.maxInstanceCount = this._maxInstanceCount),
        (r.maxVertexCount = this._maxVertexCount),
        (r.maxIndexCount = this._maxIndexCount),
        (r.geometryInitialized = this._geometryInitialized),
        (r.matricesTexture = this._matricesTexture.toJSON(e)),
        (r.indirectTexture = this._indirectTexture.toJSON(e)),
        this._colorsTexture !== null &&
          (r.colorsTexture = this._colorsTexture.toJSON(e)),
        this.boundingSphere !== null &&
          (r.boundingSphere = this.boundingSphere.toJSON()),
        this.boundingBox !== null &&
          (r.boundingBox = this.boundingBox.toJSON())));
    function s(u, h) {
      return (u[h.uuid] === void 0 && (u[h.uuid] = h.toJSON(e)), h.uuid);
    }
    if (this.isScene)
      (this.background &&
        (this.background.isColor
          ? (r.background = this.background.toJSON())
          : this.background.isTexture &&
            (r.background = this.background.toJSON(e).uuid)),
        this.environment &&
          this.environment.isTexture &&
          this.environment.isRenderTargetTexture !== !0 &&
          (r.environment = this.environment.toJSON(e).uuid));
    else if (this.isMesh || this.isLine || this.isPoints) {
      r.geometry = s(e.geometries, this.geometry);
      const u = this.geometry.parameters;
      if (u !== void 0 && u.shapes !== void 0) {
        const h = u.shapes;
        if (Array.isArray(h))
          for (let d = 0, m = h.length; d < m; d++) {
            const v = h[d];
            s(e.shapes, v);
          }
        else s(e.shapes, h);
      }
    }
    if (
      (this.isSkinnedMesh &&
        ((r.bindMode = this.bindMode),
        (r.bindMatrix = this.bindMatrix.toArray()),
        this.skeleton !== void 0 &&
          (s(e.skeletons, this.skeleton), (r.skeleton = this.skeleton.uuid))),
      this.material !== void 0)
    )
      if (Array.isArray(this.material)) {
        const u = [];
        for (let h = 0, d = this.material.length; h < d; h++)
          u.push(s(e.materials, this.material[h]));
        r.material = u;
      } else r.material = s(e.materials, this.material);
    if (this.children.length > 0) {
      r.children = [];
      for (let u = 0; u < this.children.length; u++)
        r.children.push(this.children[u].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      r.animations = [];
      for (let u = 0; u < this.animations.length; u++) {
        const h = this.animations[u];
        r.animations.push(s(e.animations, h));
      }
    }
    if (t) {
      const u = o(e.geometries),
        h = o(e.materials),
        d = o(e.textures),
        m = o(e.images),
        v = o(e.shapes),
        y = o(e.skeletons),
        b = o(e.animations),
        _ = o(e.nodes);
      (u.length > 0 && (n.geometries = u),
        h.length > 0 && (n.materials = h),
        d.length > 0 && (n.textures = d),
        m.length > 0 && (n.images = m),
        v.length > 0 && (n.shapes = v),
        y.length > 0 && (n.skeletons = y),
        b.length > 0 && (n.animations = b),
        _.length > 0 && (n.nodes = _));
    }
    return ((n.object = r), n);
    function o(u) {
      const h = [];
      for (const d in u) {
        const m = u[d];
        (delete m.metadata, h.push(m));
      }
      return h;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, t = !0) {
    if (
      ((this.name = e.name),
      this.up.copy(e.up),
      this.position.copy(e.position),
      (this.rotation.order = e.rotation.order),
      this.quaternion.copy(e.quaternion),
      this.scale.copy(e.scale),
      e.pivot !== null && (this.pivot = e.pivot.clone()),
      this.matrix.copy(e.matrix),
      this.matrixWorld.copy(e.matrixWorld),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      (this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate),
      (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
      (this.layers.mask = e.layers.mask),
      (this.visible = e.visible),
      (this.castShadow = e.castShadow),
      (this.receiveShadow = e.receiveShadow),
      (this.frustumCulled = e.frustumCulled),
      (this.renderOrder = e.renderOrder),
      (this.static = e.static),
      (this.animations = e.animations.slice()),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      t === !0)
    )
      for (let n = 0; n < e.children.length; n++) {
        const r = e.children[n];
        this.add(r.clone());
      }
    return this;
  }
}
In.DEFAULT_UP = new te(0, 1, 0);
In.DEFAULT_MATRIX_AUTO_UPDATE = !0;
In.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
class xp extends In {
  constructor() {
    (super(), (this.isGroup = !0), (this.type = "Group"));
  }
}
const uk = { type: "move" };
class Rx {
  constructor() {
    ((this._targetRay = null), (this._grip = null), (this._hand = null));
  }
  getHandSpace() {
    return (
      this._hand === null &&
        ((this._hand = new xp()),
        (this._hand.matrixAutoUpdate = !1),
        (this._hand.visible = !1),
        (this._hand.joints = {}),
        (this._hand.inputState = { pinching: !1 })),
      this._hand
    );
  }
  getTargetRaySpace() {
    return (
      this._targetRay === null &&
        ((this._targetRay = new xp()),
        (this._targetRay.matrixAutoUpdate = !1),
        (this._targetRay.visible = !1),
        (this._targetRay.hasLinearVelocity = !1),
        (this._targetRay.linearVelocity = new te()),
        (this._targetRay.hasAngularVelocity = !1),
        (this._targetRay.angularVelocity = new te())),
      this._targetRay
    );
  }
  getGripSpace() {
    return (
      this._grip === null &&
        ((this._grip = new xp()),
        (this._grip.matrixAutoUpdate = !1),
        (this._grip.visible = !1),
        (this._grip.hasLinearVelocity = !1),
        (this._grip.linearVelocity = new te()),
        (this._grip.hasAngularVelocity = !1),
        (this._grip.angularVelocity = new te())),
      this._grip
    );
  }
  dispatchEvent(e) {
    return (
      this._targetRay !== null && this._targetRay.dispatchEvent(e),
      this._grip !== null && this._grip.dispatchEvent(e),
      this._hand !== null && this._hand.dispatchEvent(e),
      this
    );
  }
  connect(e) {
    if (e && e.hand) {
      const t = this._hand;
      if (t) for (const n of e.hand.values()) this._getHandJoint(t, n);
    }
    return (this.dispatchEvent({ type: "connected", data: e }), this);
  }
  disconnect(e) {
    return (
      this.dispatchEvent({ type: "disconnected", data: e }),
      this._targetRay !== null && (this._targetRay.visible = !1),
      this._grip !== null && (this._grip.visible = !1),
      this._hand !== null && (this._hand.visible = !1),
      this
    );
  }
  update(e, t, n) {
    let r = null,
      s = null,
      o = null;
    const u = this._targetRay,
      h = this._grip,
      d = this._hand;
    if (e && t.session.visibilityState !== "visible-blurred") {
      if (d && e.hand) {
        o = !0;
        for (const w of e.hand.values()) {
          const E = t.getJointPose(w, n),
            T = this._getHandJoint(d, w);
          (E !== null &&
            (T.matrix.fromArray(E.transform.matrix),
            T.matrix.decompose(T.position, T.rotation, T.scale),
            (T.matrixWorldNeedsUpdate = !0),
            (T.jointRadius = E.radius)),
            (T.visible = E !== null));
        }
        const m = d.joints["index-finger-tip"],
          v = d.joints["thumb-tip"],
          y = m.position.distanceTo(v.position),
          b = 0.02,
          _ = 0.005;
        d.inputState.pinching && y > b + _
          ? ((d.inputState.pinching = !1),
            this.dispatchEvent({
              type: "pinchend",
              handedness: e.handedness,
              target: this,
            }))
          : !d.inputState.pinching &&
            y <= b - _ &&
            ((d.inputState.pinching = !0),
            this.dispatchEvent({
              type: "pinchstart",
              handedness: e.handedness,
              target: this,
            }));
      } else
        h !== null &&
          e.gripSpace &&
          ((s = t.getPose(e.gripSpace, n)),
          s !== null &&
            (h.matrix.fromArray(s.transform.matrix),
            h.matrix.decompose(h.position, h.rotation, h.scale),
            (h.matrixWorldNeedsUpdate = !0),
            s.linearVelocity
              ? ((h.hasLinearVelocity = !0),
                h.linearVelocity.copy(s.linearVelocity))
              : (h.hasLinearVelocity = !1),
            s.angularVelocity
              ? ((h.hasAngularVelocity = !0),
                h.angularVelocity.copy(s.angularVelocity))
              : (h.hasAngularVelocity = !1)));
      u !== null &&
        ((r = t.getPose(e.targetRaySpace, n)),
        r === null && s !== null && (r = s),
        r !== null &&
          (u.matrix.fromArray(r.transform.matrix),
          u.matrix.decompose(u.position, u.rotation, u.scale),
          (u.matrixWorldNeedsUpdate = !0),
          r.linearVelocity
            ? ((u.hasLinearVelocity = !0),
              u.linearVelocity.copy(r.linearVelocity))
            : (u.hasLinearVelocity = !1),
          r.angularVelocity
            ? ((u.hasAngularVelocity = !0),
              u.angularVelocity.copy(r.angularVelocity))
            : (u.hasAngularVelocity = !1),
          this.dispatchEvent(uk)));
    }
    return (
      u !== null && (u.visible = r !== null),
      h !== null && (h.visible = s !== null),
      d !== null && (d.visible = o !== null),
      this
    );
  }
  _getHandJoint(e, t) {
    if (e.joints[t.jointName] === void 0) {
      const n = new xp();
      ((n.matrixAutoUpdate = !1),
        (n.visible = !1),
        (e.joints[t.jointName] = n),
        e.add(n));
    }
    return e.joints[t.jointName];
  }
}
const eN = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074,
  },
  Gu = { h: 0, s: 0, l: 0 },
  _y = { h: 0, s: 0, l: 0 };
function W_(i, e, t) {
  return (
    t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6
      ? i + (e - i) * 6 * t
      : t < 1 / 2
        ? e
        : t < 2 / 3
          ? i + (e - i) * 6 * (2 / 3 - t)
          : i
  );
}
class wt {
  constructor(e, t, n) {
    return (
      (this.isColor = !0),
      (this.r = 1),
      (this.g = 1),
      (this.b = 1),
      this.set(e, t, n)
    );
  }
  set(e, t, n) {
    if (t === void 0 && n === void 0) {
      const r = e;
      r && r.isColor
        ? this.copy(r)
        : typeof r == "number"
          ? this.setHex(r)
          : typeof r == "string" && this.setStyle(r);
    } else this.setRGB(e, t, n);
    return this;
  }
  setScalar(e) {
    return ((this.r = e), (this.g = e), (this.b = e), this);
  }
  setHex(e, t = vs) {
    return (
      (e = Math.floor(e)),
      (this.r = ((e >> 16) & 255) / 255),
      (this.g = ((e >> 8) & 255) / 255),
      (this.b = (e & 255) / 255),
      Cn.colorSpaceToWorking(this, t),
      this
    );
  }
  setRGB(e, t, n, r = Cn.workingColorSpace) {
    return (
      (this.r = e),
      (this.g = t),
      (this.b = n),
      Cn.colorSpaceToWorking(this, r),
      this
    );
  }
  setHSL(e, t, n, r = Cn.workingColorSpace) {
    if (((e = HT(e, 1)), (t = Yt(t, 0, 1)), (n = Yt(n, 0, 1)), t === 0))
      this.r = this.g = this.b = n;
    else {
      const s = n <= 0.5 ? n * (1 + t) : n + t - n * t,
        o = 2 * n - s;
      ((this.r = W_(o, s, e + 1 / 3)),
        (this.g = W_(o, s, e)),
        (this.b = W_(o, s, e - 1 / 3)));
    }
    return (Cn.colorSpaceToWorking(this, r), this);
  }
  setStyle(e, t = vs) {
    function n(s) {
      s !== void 0 &&
        parseFloat(s) < 1 &&
        Tt("Color: Alpha component of " + e + " will be ignored.");
    }
    let r;
    if ((r = /^(\w+)\(([^\)]*)\)/.exec(e))) {
      let s;
      const o = r[1],
        u = r[2];
      switch (o) {
        case "rgb":
        case "rgba":
          if (
            (s =
              /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                u,
              ))
          )
            return (
              n(s[4]),
              this.setRGB(
                Math.min(255, parseInt(s[1], 10)) / 255,
                Math.min(255, parseInt(s[2], 10)) / 255,
                Math.min(255, parseInt(s[3], 10)) / 255,
                t,
              )
            );
          if (
            (s =
              /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                u,
              ))
          )
            return (
              n(s[4]),
              this.setRGB(
                Math.min(100, parseInt(s[1], 10)) / 100,
                Math.min(100, parseInt(s[2], 10)) / 100,
                Math.min(100, parseInt(s[3], 10)) / 100,
                t,
              )
            );
          break;
        case "hsl":
        case "hsla":
          if (
            (s =
              /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                u,
              ))
          )
            return (
              n(s[4]),
              this.setHSL(
                parseFloat(s[1]) / 360,
                parseFloat(s[2]) / 100,
                parseFloat(s[3]) / 100,
                t,
              )
            );
          break;
        default:
          Tt("Color: Unknown color model " + e);
      }
    } else if ((r = /^\#([A-Fa-f\d]+)$/.exec(e))) {
      const s = r[1],
        o = s.length;
      if (o === 3)
        return this.setRGB(
          parseInt(s.charAt(0), 16) / 15,
          parseInt(s.charAt(1), 16) / 15,
          parseInt(s.charAt(2), 16) / 15,
          t,
        );
      if (o === 6) return this.setHex(parseInt(s, 16), t);
      Tt("Color: Invalid hex color " + e);
    } else if (e && e.length > 0) return this.setColorName(e, t);
    return this;
  }
  setColorName(e, t = vs) {
    const n = eN[e.toLowerCase()];
    return (
      n !== void 0 ? this.setHex(n, t) : Tt("Color: Unknown color " + e),
      this
    );
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return ((this.r = e.r), (this.g = e.g), (this.b = e.b), this);
  }
  copySRGBToLinear(e) {
    return ((this.r = jc(e.r)), (this.g = jc(e.g)), (this.b = jc(e.b)), this);
  }
  copyLinearToSRGB(e) {
    return ((this.r = Sp(e.r)), (this.g = Sp(e.g)), (this.b = Sp(e.b)), this);
  }
  convertSRGBToLinear() {
    return (this.copySRGBToLinear(this), this);
  }
  convertLinearToSRGB() {
    return (this.copyLinearToSRGB(this), this);
  }
  getHex(e = vs) {
    return (
      Cn.workingToColorSpace(ms.copy(this), e),
      Math.round(Yt(ms.r * 255, 0, 255)) * 65536 +
        Math.round(Yt(ms.g * 255, 0, 255)) * 256 +
        Math.round(Yt(ms.b * 255, 0, 255))
    );
  }
  getHexString(e = vs) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, t = Cn.workingColorSpace) {
    Cn.workingToColorSpace(ms.copy(this), t);
    const n = ms.r,
      r = ms.g,
      s = ms.b,
      o = Math.max(n, r, s),
      u = Math.min(n, r, s);
    let h, d;
    const m = (u + o) / 2;
    if (u === o) ((h = 0), (d = 0));
    else {
      const v = o - u;
      switch (((d = m <= 0.5 ? v / (o + u) : v / (2 - o - u)), o)) {
        case n:
          h = (r - s) / v + (r < s ? 6 : 0);
          break;
        case r:
          h = (s - n) / v + 2;
          break;
        case s:
          h = (n - r) / v + 4;
          break;
      }
      h /= 6;
    }
    return ((e.h = h), (e.s = d), (e.l = m), e);
  }
  getRGB(e, t = Cn.workingColorSpace) {
    return (
      Cn.workingToColorSpace(ms.copy(this), t),
      (e.r = ms.r),
      (e.g = ms.g),
      (e.b = ms.b),
      e
    );
  }
  getStyle(e = vs) {
    Cn.workingToColorSpace(ms.copy(this), e);
    const t = ms.r,
      n = ms.g,
      r = ms.b;
    return e !== vs
      ? `color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${r.toFixed(3)})`
      : `rgb(${Math.round(t * 255)},${Math.round(n * 255)},${Math.round(r * 255)})`;
  }
  offsetHSL(e, t, n) {
    return (this.getHSL(Gu), this.setHSL(Gu.h + e, Gu.s + t, Gu.l + n));
  }
  add(e) {
    return ((this.r += e.r), (this.g += e.g), (this.b += e.b), this);
  }
  addColors(e, t) {
    return (
      (this.r = e.r + t.r),
      (this.g = e.g + t.g),
      (this.b = e.b + t.b),
      this
    );
  }
  addScalar(e) {
    return ((this.r += e), (this.g += e), (this.b += e), this);
  }
  sub(e) {
    return (
      (this.r = Math.max(0, this.r - e.r)),
      (this.g = Math.max(0, this.g - e.g)),
      (this.b = Math.max(0, this.b - e.b)),
      this
    );
  }
  multiply(e) {
    return ((this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this);
  }
  multiplyScalar(e) {
    return ((this.r *= e), (this.g *= e), (this.b *= e), this);
  }
  lerp(e, t) {
    return (
      (this.r += (e.r - this.r) * t),
      (this.g += (e.g - this.g) * t),
      (this.b += (e.b - this.b) * t),
      this
    );
  }
  lerpColors(e, t, n) {
    return (
      (this.r = e.r + (t.r - e.r) * n),
      (this.g = e.g + (t.g - e.g) * n),
      (this.b = e.b + (t.b - e.b) * n),
      this
    );
  }
  lerpHSL(e, t) {
    (this.getHSL(Gu), e.getHSL(_y));
    const n = Wg(Gu.h, _y.h, t),
      r = Wg(Gu.s, _y.s, t),
      s = Wg(Gu.l, _y.l, t);
    return (this.setHSL(n, r, s), this);
  }
  setFromVector3(e) {
    return ((this.r = e.x), (this.g = e.y), (this.b = e.z), this);
  }
  applyMatrix3(e) {
    const t = this.r,
      n = this.g,
      r = this.b,
      s = e.elements;
    return (
      (this.r = s[0] * t + s[3] * n + s[6] * r),
      (this.g = s[1] * t + s[4] * n + s[7] * r),
      (this.b = s[2] * t + s[5] * n + s[8] * r),
      this
    );
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, t = 0) {
    return ((this.r = e[t]), (this.g = e[t + 1]), (this.b = e[t + 2]), this);
  }
  toArray(e = [], t = 0) {
    return ((e[t] = this.r), (e[t + 1] = this.g), (e[t + 2] = this.b), e);
  }
  fromBufferAttribute(e, t) {
    return (
      (this.r = e.getX(t)),
      (this.g = e.getY(t)),
      (this.b = e.getZ(t)),
      this
    );
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    (yield this.r, yield this.g, yield this.b);
  }
}
const ms = new wt();
wt.NAMES = eN;
class lb {
  constructor(e, t = 25e-5) {
    ((this.isFogExp2 = !0),
      (this.name = ""),
      (this.color = new wt(e)),
      (this.density = t));
  }
  clone() {
    return new lb(this.color, this.density);
  }
  toJSON() {
    return {
      type: "FogExp2",
      name: this.name,
      color: this.color.getHex(),
      density: this.density,
    };
  }
}
class cb {
  constructor(e, t = 1, n = 1e3) {
    ((this.isFog = !0),
      (this.name = ""),
      (this.color = new wt(e)),
      (this.near = t),
      (this.far = n));
  }
  clone() {
    return new cb(this.color, this.near, this.far);
  }
  toJSON() {
    return {
      type: "Fog",
      name: this.name,
      color: this.color.getHex(),
      near: this.near,
      far: this.far,
    };
  }
}
class XT extends In {
  constructor() {
    (super(),
      (this.isScene = !0),
      (this.type = "Scene"),
      (this.background = null),
      (this.environment = null),
      (this.fog = null),
      (this.backgroundBlurriness = 0),
      (this.backgroundIntensity = 1),
      (this.backgroundRotation = new Fa()),
      (this.environmentIntensity = 1),
      (this.environmentRotation = new Fa()),
      (this.overrideMaterial = null),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this }),
        ));
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.background !== null && (this.background = e.background.clone()),
      e.environment !== null && (this.environment = e.environment.clone()),
      e.fog !== null && (this.fog = e.fog.clone()),
      (this.backgroundBlurriness = e.backgroundBlurriness),
      (this.backgroundIntensity = e.backgroundIntensity),
      this.backgroundRotation.copy(e.backgroundRotation),
      (this.environmentIntensity = e.environmentIntensity),
      this.environmentRotation.copy(e.environmentRotation),
      e.overrideMaterial !== null &&
        (this.overrideMaterial = e.overrideMaterial.clone()),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      this.fog !== null && (t.object.fog = this.fog.toJSON()),
      this.backgroundBlurriness > 0 &&
        (t.object.backgroundBlurriness = this.backgroundBlurriness),
      this.backgroundIntensity !== 1 &&
        (t.object.backgroundIntensity = this.backgroundIntensity),
      (t.object.backgroundRotation = this.backgroundRotation.toArray()),
      this.environmentIntensity !== 1 &&
        (t.object.environmentIntensity = this.environmentIntensity),
      (t.object.environmentRotation = this.environmentRotation.toArray()),
      t
    );
  }
}
const Go = new te(),
  Oc = new te(),
  X_ = new te(),
  Fc = new te(),
  jd = new te(),
  Wd = new te(),
  eC = new te(),
  q_ = new te(),
  Y_ = new te(),
  Z_ = new te(),
  K_ = new Dn(),
  Q_ = new Dn(),
  J_ = new Dn();
class ya {
  constructor(e = new te(), t = new te(), n = new te()) {
    ((this.a = e), (this.b = t), (this.c = n));
  }
  static getNormal(e, t, n, r) {
    (r.subVectors(n, t), Go.subVectors(e, t), r.cross(Go));
    const s = r.lengthSq();
    return s > 0 ? r.multiplyScalar(1 / Math.sqrt(s)) : r.set(0, 0, 0);
  }
  static getBarycoord(e, t, n, r, s) {
    (Go.subVectors(r, t), Oc.subVectors(n, t), X_.subVectors(e, t));
    const o = Go.dot(Go),
      u = Go.dot(Oc),
      h = Go.dot(X_),
      d = Oc.dot(Oc),
      m = Oc.dot(X_),
      v = o * d - u * u;
    if (v === 0) return (s.set(0, 0, 0), null);
    const y = 1 / v,
      b = (d * h - u * m) * y,
      _ = (o * m - u * h) * y;
    return s.set(1 - b - _, _, b);
  }
  static containsPoint(e, t, n, r) {
    return this.getBarycoord(e, t, n, r, Fc) === null
      ? !1
      : Fc.x >= 0 && Fc.y >= 0 && Fc.x + Fc.y <= 1;
  }
  static getInterpolation(e, t, n, r, s, o, u, h) {
    return this.getBarycoord(e, t, n, r, Fc) === null
      ? ((h.x = 0),
        (h.y = 0),
        "z" in h && (h.z = 0),
        "w" in h && (h.w = 0),
        null)
      : (h.setScalar(0),
        h.addScaledVector(s, Fc.x),
        h.addScaledVector(o, Fc.y),
        h.addScaledVector(u, Fc.z),
        h);
  }
  static getInterpolatedAttribute(e, t, n, r, s, o) {
    return (
      K_.setScalar(0),
      Q_.setScalar(0),
      J_.setScalar(0),
      K_.fromBufferAttribute(e, t),
      Q_.fromBufferAttribute(e, n),
      J_.fromBufferAttribute(e, r),
      o.setScalar(0),
      o.addScaledVector(K_, s.x),
      o.addScaledVector(Q_, s.y),
      o.addScaledVector(J_, s.z),
      o
    );
  }
  static isFrontFacing(e, t, n, r) {
    return (Go.subVectors(n, t), Oc.subVectors(e, t), Go.cross(Oc).dot(r) < 0);
  }
  set(e, t, n) {
    return (this.a.copy(e), this.b.copy(t), this.c.copy(n), this);
  }
  setFromPointsAndIndices(e, t, n, r) {
    return (this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[r]), this);
  }
  setFromAttributeAndIndices(e, t, n, r) {
    return (
      this.a.fromBufferAttribute(e, t),
      this.b.fromBufferAttribute(e, n),
      this.c.fromBufferAttribute(e, r),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this);
  }
  getArea() {
    return (
      Go.subVectors(this.c, this.b),
      Oc.subVectors(this.a, this.b),
      Go.cross(Oc).length() * 0.5
    );
  }
  getMidpoint(e) {
    return e
      .addVectors(this.a, this.b)
      .add(this.c)
      .multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return ya.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, t) {
    return ya.getBarycoord(e, this.a, this.b, this.c, t);
  }
  getInterpolation(e, t, n, r, s) {
    return ya.getInterpolation(e, this.a, this.b, this.c, t, n, r, s);
  }
  containsPoint(e) {
    return ya.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return ya.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, t) {
    const n = this.a,
      r = this.b,
      s = this.c;
    let o, u;
    (jd.subVectors(r, n), Wd.subVectors(s, n), q_.subVectors(e, n));
    const h = jd.dot(q_),
      d = Wd.dot(q_);
    if (h <= 0 && d <= 0) return t.copy(n);
    Y_.subVectors(e, r);
    const m = jd.dot(Y_),
      v = Wd.dot(Y_);
    if (m >= 0 && v <= m) return t.copy(r);
    const y = h * v - m * d;
    if (y <= 0 && h >= 0 && m <= 0)
      return ((o = h / (h - m)), t.copy(n).addScaledVector(jd, o));
    Z_.subVectors(e, s);
    const b = jd.dot(Z_),
      _ = Wd.dot(Z_);
    if (_ >= 0 && b <= _) return t.copy(s);
    const w = b * d - h * _;
    if (w <= 0 && d >= 0 && _ <= 0)
      return ((u = d / (d - _)), t.copy(n).addScaledVector(Wd, u));
    const E = m * _ - b * v;
    if (E <= 0 && v - m >= 0 && b - _ >= 0)
      return (
        eC.subVectors(s, r),
        (u = (v - m) / (v - m + (b - _))),
        t.copy(r).addScaledVector(eC, u)
      );
    const T = 1 / (E + w + y);
    return (
      (o = w * T),
      (u = y * T),
      t.copy(n).addScaledVector(jd, o).addScaledVector(Wd, u)
    );
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
class sr {
  constructor(
    e = new te(1 / 0, 1 / 0, 1 / 0),
    t = new te(-1 / 0, -1 / 0, -1 / 0),
  ) {
    ((this.isBox3 = !0), (this.min = e), (this.max = t));
  }
  set(e, t) {
    return (this.min.copy(e), this.max.copy(t), this);
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let t = 0, n = e.length; t < n; t += 3)
      this.expandByPoint(Ho.fromArray(e, t));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let t = 0, n = e.count; t < n; t++)
      this.expandByPoint(Ho.fromBufferAttribute(e, t));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const n = Ho.copy(t).multiplyScalar(0.5);
    return (this.min.copy(e).sub(n), this.max.copy(e).add(n), this);
  }
  setFromObject(e, t = !1) {
    return (this.makeEmpty(), this.expandByObject(e, t));
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (this.min.copy(e.min), this.max.copy(e.max), this);
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = this.min.z = 1 / 0),
      (this.max.x = this.max.y = this.max.z = -1 / 0),
      this
    );
  }
  isEmpty() {
    return (
      this.max.x < this.min.x ||
      this.max.y < this.min.y ||
      this.max.z < this.min.z
    );
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return (this.min.min(e), this.max.max(e), this);
  }
  expandByVector(e) {
    return (this.min.sub(e), this.max.add(e), this);
  }
  expandByScalar(e) {
    return (this.min.addScalar(-e), this.max.addScalar(e), this);
  }
  expandByObject(e, t = !1) {
    e.updateWorldMatrix(!1, !1);
    const n = e.geometry;
    if (n !== void 0) {
      const s = n.getAttribute("position");
      if (t === !0 && s !== void 0 && e.isInstancedMesh !== !0)
        for (let o = 0, u = s.count; o < u; o++)
          (e.isMesh === !0
            ? e.getVertexPosition(o, Ho)
            : Ho.fromBufferAttribute(s, o),
            Ho.applyMatrix4(e.matrixWorld),
            this.expandByPoint(Ho));
      else
        (e.boundingBox !== void 0
          ? (e.boundingBox === null && e.computeBoundingBox(),
            Sy.copy(e.boundingBox))
          : (n.boundingBox === null && n.computeBoundingBox(),
            Sy.copy(n.boundingBox)),
          Sy.applyMatrix4(e.matrixWorld),
          this.union(Sy));
    }
    const r = e.children;
    for (let s = 0, o = r.length; s < o; s++) this.expandByObject(r[s], t);
    return this;
  }
  containsPoint(e) {
    return (
      e.x >= this.min.x &&
      e.x <= this.max.x &&
      e.y >= this.min.y &&
      e.y <= this.max.y &&
      e.z >= this.min.z &&
      e.z <= this.max.z
    );
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y &&
      this.min.z <= e.min.z &&
      e.max.z <= this.max.z
    );
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z),
    );
  }
  intersectsBox(e) {
    return (
      e.max.x >= this.min.x &&
      e.min.x <= this.max.x &&
      e.max.y >= this.min.y &&
      e.min.y <= this.max.y &&
      e.max.z >= this.min.z &&
      e.min.z <= this.max.z
    );
  }
  intersectsSphere(e) {
    return (
      this.clampPoint(e.center, Ho),
      Ho.distanceToSquared(e.center) <= e.radius * e.radius
    );
  }
  intersectsPlane(e) {
    let t, n;
    return (
      e.normal.x > 0
        ? ((t = e.normal.x * this.min.x), (n = e.normal.x * this.max.x))
        : ((t = e.normal.x * this.max.x), (n = e.normal.x * this.min.x)),
      e.normal.y > 0
        ? ((t += e.normal.y * this.min.y), (n += e.normal.y * this.max.y))
        : ((t += e.normal.y * this.max.y), (n += e.normal.y * this.min.y)),
      e.normal.z > 0
        ? ((t += e.normal.z * this.min.z), (n += e.normal.z * this.max.z))
        : ((t += e.normal.z * this.max.z), (n += e.normal.z * this.min.z)),
      t <= -e.constant && n >= -e.constant
    );
  }
  intersectsTriangle(e) {
    if (this.isEmpty()) return !1;
    (this.getCenter(mg),
      My.subVectors(this.max, mg),
      Xd.subVectors(e.a, mg),
      qd.subVectors(e.b, mg),
      Yd.subVectors(e.c, mg),
      Hu.subVectors(qd, Xd),
      ju.subVectors(Yd, qd),
      Jf.subVectors(Xd, Yd));
    let t = [
      0,
      -Hu.z,
      Hu.y,
      0,
      -ju.z,
      ju.y,
      0,
      -Jf.z,
      Jf.y,
      Hu.z,
      0,
      -Hu.x,
      ju.z,
      0,
      -ju.x,
      Jf.z,
      0,
      -Jf.x,
      -Hu.y,
      Hu.x,
      0,
      -ju.y,
      ju.x,
      0,
      -Jf.y,
      Jf.x,
      0,
    ];
    return !$_(t, Xd, qd, Yd, My) ||
      ((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]), !$_(t, Xd, qd, Yd, My))
      ? !1
      : (Ty.crossVectors(Hu, ju),
        (t = [Ty.x, Ty.y, Ty.z]),
        $_(t, Xd, qd, Yd, My));
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, Ho).distanceTo(e);
  }
  getBoundingSphere(e) {
    return (
      this.isEmpty()
        ? e.makeEmpty()
        : (this.getCenter(e.center),
          (e.radius = this.getSize(Ho).length() * 0.5)),
      e
    );
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(e) {
    return (this.min.min(e.min), this.max.max(e.max), this);
  }
  applyMatrix4(e) {
    return this.isEmpty()
      ? this
      : (zc[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        zc[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        zc[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        zc[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        zc[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        zc[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        zc[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        zc[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(zc),
        this);
  }
  translate(e) {
    return (this.min.add(e), this.max.add(e), this);
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
  toJSON() {
    return { min: this.min.toArray(), max: this.max.toArray() };
  }
  fromJSON(e) {
    return (this.min.fromArray(e.min), this.max.fromArray(e.max), this);
  }
}
const zc = [
    new te(),
    new te(),
    new te(),
    new te(),
    new te(),
    new te(),
    new te(),
    new te(),
  ],
  Ho = new te(),
  Sy = new sr(),
  Xd = new te(),
  qd = new te(),
  Yd = new te(),
  Hu = new te(),
  ju = new te(),
  Jf = new te(),
  mg = new te(),
  My = new te(),
  Ty = new te(),
  $f = new te();
function $_(i, e, t, n, r) {
  for (let s = 0, o = i.length - 3; s <= o; s += 3) {
    $f.fromArray(i, s);
    const u =
        r.x * Math.abs($f.x) + r.y * Math.abs($f.y) + r.z * Math.abs($f.z),
      h = e.dot($f),
      d = t.dot($f),
      m = n.dot($f);
    if (Math.max(-Math.max(h, d, m), Math.min(h, d, m)) > u) return !1;
  }
  return !0;
}
const Hc = fk();
function fk() {
  const i = new ArrayBuffer(4),
    e = new Float32Array(i),
    t = new Uint32Array(i),
    n = new Uint32Array(512),
    r = new Uint32Array(512);
  for (let h = 0; h < 256; ++h) {
    const d = h - 127;
    d < -27
      ? ((n[h] = 0), (n[h | 256] = 32768), (r[h] = 24), (r[h | 256] = 24))
      : d < -14
        ? ((n[h] = 1024 >> (-d - 14)),
          (n[h | 256] = (1024 >> (-d - 14)) | 32768),
          (r[h] = -d - 1),
          (r[h | 256] = -d - 1))
        : d <= 15
          ? ((n[h] = (d + 15) << 10),
            (n[h | 256] = ((d + 15) << 10) | 32768),
            (r[h] = 13),
            (r[h | 256] = 13))
          : d < 128
            ? ((n[h] = 31744),
              (n[h | 256] = 64512),
              (r[h] = 24),
              (r[h | 256] = 24))
            : ((n[h] = 31744),
              (n[h | 256] = 64512),
              (r[h] = 13),
              (r[h | 256] = 13));
  }
  const s = new Uint32Array(2048),
    o = new Uint32Array(64),
    u = new Uint32Array(64);
  for (let h = 1; h < 1024; ++h) {
    let d = h << 13,
      m = 0;
    for (; (d & 8388608) === 0; ) ((d <<= 1), (m -= 8388608));
    ((d &= -8388609), (m += 947912704), (s[h] = d | m));
  }
  for (let h = 1024; h < 2048; ++h) s[h] = 939524096 + ((h - 1024) << 13);
  for (let h = 1; h < 31; ++h) o[h] = h << 23;
  ((o[31] = 1199570944), (o[32] = 2147483648));
  for (let h = 33; h < 63; ++h) o[h] = 2147483648 + ((h - 32) << 23);
  o[63] = 3347054592;
  for (let h = 1; h < 64; ++h) h !== 32 && (u[h] = 1024);
  return {
    floatView: e,
    uint32View: t,
    baseTable: n,
    shiftTable: r,
    mantissaTable: s,
    exponentTable: o,
    offsetTable: u,
  };
}
function ga(i) {
  (Math.abs(i) > 65504 && Tt("DataUtils.toHalfFloat(): Value out of range."),
    (i = Yt(i, -65504, 65504)),
    (Hc.floatView[0] = i));
  const e = Hc.uint32View[0],
    t = (e >> 23) & 511;
  return Hc.baseTable[t] + ((e & 8388607) >> Hc.shiftTable[t]);
}
function Rg(i) {
  const e = i >> 10;
  return (
    (Hc.uint32View[0] =
      Hc.mantissaTable[Hc.offsetTable[e] + (i & 1023)] + Hc.exponentTable[e]),
    Hc.floatView[0]
  );
}
class hk {
  static toHalfFloat(e) {
    return ga(e);
  }
  static fromHalfFloat(e) {
    return Rg(e);
  }
}
const dr = new te(),
  Ey = new nt();
let dk = 0;
class $n {
  constructor(e, t, n = !1) {
    if (Array.isArray(e))
      throw new TypeError(
        "THREE.BufferAttribute: array should be a Typed Array.",
      );
    ((this.isBufferAttribute = !0),
      Object.defineProperty(this, "id", { value: dk++ }),
      (this.name = ""),
      (this.array = e),
      (this.itemSize = t),
      (this.count = e !== void 0 ? e.length / t : 0),
      (this.normalized = n),
      (this.usage = c0),
      (this.updateRanges = []),
      (this.gpuType = Hs),
      (this.version = 0));
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return ((this.usage = e), this);
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.array = new e.array.constructor(e.array)),
      (this.itemSize = e.itemSize),
      (this.count = e.count),
      (this.normalized = e.normalized),
      (this.usage = e.usage),
      (this.gpuType = e.gpuType),
      this
    );
  }
  copyAt(e, t, n) {
    ((e *= this.itemSize), (n *= t.itemSize));
    for (let r = 0, s = this.itemSize; r < s; r++)
      this.array[e + r] = t.array[n + r];
    return this;
  }
  copyArray(e) {
    return (this.array.set(e), this);
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let t = 0, n = this.count; t < n; t++)
        (Ey.fromBufferAttribute(this, t),
          Ey.applyMatrix3(e),
          this.setXY(t, Ey.x, Ey.y));
    else if (this.itemSize === 3)
      for (let t = 0, n = this.count; t < n; t++)
        (dr.fromBufferAttribute(this, t),
          dr.applyMatrix3(e),
          this.setXYZ(t, dr.x, dr.y, dr.z));
    return this;
  }
  applyMatrix4(e) {
    for (let t = 0, n = this.count; t < n; t++)
      (dr.fromBufferAttribute(this, t),
        dr.applyMatrix4(e),
        this.setXYZ(t, dr.x, dr.y, dr.z));
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, n = this.count; t < n; t++)
      (dr.fromBufferAttribute(this, t),
        dr.applyNormalMatrix(e),
        this.setXYZ(t, dr.x, dr.y, dr.z));
    return this;
  }
  transformDirection(e) {
    for (let t = 0, n = this.count; t < n; t++)
      (dr.fromBufferAttribute(this, t),
        dr.transformDirection(e),
        this.setXYZ(t, dr.x, dr.y, dr.z));
    return this;
  }
  set(e, t = 0) {
    return (this.array.set(e, t), this);
  }
  getComponent(e, t) {
    let n = this.array[e * this.itemSize + t];
    return (this.normalized && (n = ks(n, this.array)), n);
  }
  setComponent(e, t, n) {
    return (
      this.normalized && (n = un(n, this.array)),
      (this.array[e * this.itemSize + t] = n),
      this
    );
  }
  getX(e) {
    let t = this.array[e * this.itemSize];
    return (this.normalized && (t = ks(t, this.array)), t);
  }
  setX(e, t) {
    return (
      this.normalized && (t = un(t, this.array)),
      (this.array[e * this.itemSize] = t),
      this
    );
  }
  getY(e) {
    let t = this.array[e * this.itemSize + 1];
    return (this.normalized && (t = ks(t, this.array)), t);
  }
  setY(e, t) {
    return (
      this.normalized && (t = un(t, this.array)),
      (this.array[e * this.itemSize + 1] = t),
      this
    );
  }
  getZ(e) {
    let t = this.array[e * this.itemSize + 2];
    return (this.normalized && (t = ks(t, this.array)), t);
  }
  setZ(e, t) {
    return (
      this.normalized && (t = un(t, this.array)),
      (this.array[e * this.itemSize + 2] = t),
      this
    );
  }
  getW(e) {
    let t = this.array[e * this.itemSize + 3];
    return (this.normalized && (t = ks(t, this.array)), t);
  }
  setW(e, t) {
    return (
      this.normalized && (t = un(t, this.array)),
      (this.array[e * this.itemSize + 3] = t),
      this
    );
  }
  setXY(e, t, n) {
    return (
      (e *= this.itemSize),
      this.normalized && ((t = un(t, this.array)), (n = un(n, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = n),
      this
    );
  }
  setXYZ(e, t, n, r) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = un(t, this.array)),
        (n = un(n, this.array)),
        (r = un(r, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = n),
      (this.array[e + 2] = r),
      this
    );
  }
  setXYZW(e, t, n, r, s) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = un(t, this.array)),
        (n = un(n, this.array)),
        (r = un(r, this.array)),
        (s = un(s, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = n),
      (this.array[e + 2] = r),
      (this.array[e + 3] = s),
      this
    );
  }
  onUpload(e) {
    return ((this.onUploadCallback = e), this);
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized,
    };
    return (
      this.name !== "" && (e.name = this.name),
      this.usage !== c0 && (e.usage = this.usage),
      e
    );
  }
}
class pk extends $n {
  constructor(e, t, n) {
    super(new Int8Array(e), t, n);
  }
}
class mk extends $n {
  constructor(e, t, n) {
    super(new Uint8Array(e), t, n);
  }
}
class gk extends $n {
  constructor(e, t, n) {
    super(new Uint8ClampedArray(e), t, n);
  }
}
class vk extends $n {
  constructor(e, t, n) {
    super(new Int16Array(e), t, n);
  }
}
class qT extends $n {
  constructor(e, t, n) {
    super(new Uint16Array(e), t, n);
  }
}
class yk extends $n {
  constructor(e, t, n) {
    super(new Int32Array(e), t, n);
  }
}
class YT extends $n {
  constructor(e, t, n) {
    super(new Uint32Array(e), t, n);
  }
}
class xk extends $n {
  constructor(e, t, n) {
    (super(new Uint16Array(e), t, n), (this.isFloat16BufferAttribute = !0));
  }
  getX(e) {
    let t = Rg(this.array[e * this.itemSize]);
    return (this.normalized && (t = ks(t, this.array)), t);
  }
  setX(e, t) {
    return (
      this.normalized && (t = un(t, this.array)),
      (this.array[e * this.itemSize] = ga(t)),
      this
    );
  }
  getY(e) {
    let t = Rg(this.array[e * this.itemSize + 1]);
    return (this.normalized && (t = ks(t, this.array)), t);
  }
  setY(e, t) {
    return (
      this.normalized && (t = un(t, this.array)),
      (this.array[e * this.itemSize + 1] = ga(t)),
      this
    );
  }
  getZ(e) {
    let t = Rg(this.array[e * this.itemSize + 2]);
    return (this.normalized && (t = ks(t, this.array)), t);
  }
  setZ(e, t) {
    return (
      this.normalized && (t = un(t, this.array)),
      (this.array[e * this.itemSize + 2] = ga(t)),
      this
    );
  }
  getW(e) {
    let t = Rg(this.array[e * this.itemSize + 3]);
    return (this.normalized && (t = ks(t, this.array)), t);
  }
  setW(e, t) {
    return (
      this.normalized && (t = un(t, this.array)),
      (this.array[e * this.itemSize + 3] = ga(t)),
      this
    );
  }
  setXY(e, t, n) {
    return (
      (e *= this.itemSize),
      this.normalized && ((t = un(t, this.array)), (n = un(n, this.array))),
      (this.array[e + 0] = ga(t)),
      (this.array[e + 1] = ga(n)),
      this
    );
  }
  setXYZ(e, t, n, r) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = un(t, this.array)),
        (n = un(n, this.array)),
        (r = un(r, this.array))),
      (this.array[e + 0] = ga(t)),
      (this.array[e + 1] = ga(n)),
      (this.array[e + 2] = ga(r)),
      this
    );
  }
  setXYZW(e, t, n, r, s) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = un(t, this.array)),
        (n = un(n, this.array)),
        (r = un(r, this.array)),
        (s = un(s, this.array))),
      (this.array[e + 0] = ga(t)),
      (this.array[e + 1] = ga(n)),
      (this.array[e + 2] = ga(r)),
      (this.array[e + 3] = ga(s)),
      this
    );
  }
}
class Rt extends $n {
  constructor(e, t, n) {
    super(new Float32Array(e), t, n);
  }
}
const bk = new sr(),
  gg = new te(),
  eS = new te();
let mr = class {
    constructor(e = new te(), t = -1) {
      ((this.isSphere = !0), (this.center = e), (this.radius = t));
    }
    set(e, t) {
      return (this.center.copy(e), (this.radius = t), this);
    }
    setFromPoints(e, t) {
      const n = this.center;
      t !== void 0 ? n.copy(t) : bk.setFromPoints(e).getCenter(n);
      let r = 0;
      for (let s = 0, o = e.length; s < o; s++)
        r = Math.max(r, n.distanceToSquared(e[s]));
      return ((this.radius = Math.sqrt(r)), this);
    }
    copy(e) {
      return (this.center.copy(e.center), (this.radius = e.radius), this);
    }
    isEmpty() {
      return this.radius < 0;
    }
    makeEmpty() {
      return (this.center.set(0, 0, 0), (this.radius = -1), this);
    }
    containsPoint(e) {
      return e.distanceToSquared(this.center) <= this.radius * this.radius;
    }
    distanceToPoint(e) {
      return e.distanceTo(this.center) - this.radius;
    }
    intersectsSphere(e) {
      const t = this.radius + e.radius;
      return e.center.distanceToSquared(this.center) <= t * t;
    }
    intersectsBox(e) {
      return e.intersectsSphere(this);
    }
    intersectsPlane(e) {
      return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
    }
    clampPoint(e, t) {
      const n = this.center.distanceToSquared(e);
      return (
        t.copy(e),
        n > this.radius * this.radius &&
          (t.sub(this.center).normalize(),
          t.multiplyScalar(this.radius).add(this.center)),
        t
      );
    }
    getBoundingBox(e) {
      return this.isEmpty()
        ? (e.makeEmpty(), e)
        : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
    }
    applyMatrix4(e) {
      return (
        this.center.applyMatrix4(e),
        (this.radius = this.radius * e.getMaxScaleOnAxis()),
        this
      );
    }
    translate(e) {
      return (this.center.add(e), this);
    }
    expandByPoint(e) {
      if (this.isEmpty()) return (this.center.copy(e), (this.radius = 0), this);
      gg.subVectors(e, this.center);
      const t = gg.lengthSq();
      if (t > this.radius * this.radius) {
        const n = Math.sqrt(t),
          r = (n - this.radius) * 0.5;
        (this.center.addScaledVector(gg, r / n), (this.radius += r));
      }
      return this;
    }
    union(e) {
      return e.isEmpty()
        ? this
        : this.isEmpty()
          ? (this.copy(e), this)
          : (this.center.equals(e.center) === !0
              ? (this.radius = Math.max(this.radius, e.radius))
              : (eS.subVectors(e.center, this.center).setLength(e.radius),
                this.expandByPoint(gg.copy(e.center).add(eS)),
                this.expandByPoint(gg.copy(e.center).sub(eS))),
            this);
    }
    equals(e) {
      return e.center.equals(this.center) && e.radius === this.radius;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    toJSON() {
      return { radius: this.radius, center: this.center.toArray() };
    }
    fromJSON(e) {
      return ((this.radius = e.radius), this.center.fromArray(e.center), this);
    }
  },
  _k = 0;
const go = new qt(),
  tS = new In(),
  Zd = new te(),
  La = new sr(),
  vg = new sr(),
  Ur = new te();
class nn extends ec {
  constructor() {
    (super(),
      (this.isBufferGeometry = !0),
      Object.defineProperty(this, "id", { value: _k++ }),
      (this.uuid = Ia()),
      (this.name = ""),
      (this.type = "BufferGeometry"),
      (this.index = null),
      (this.indirect = null),
      (this.indirectOffset = 0),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.morphTargetsRelative = !1),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.drawRange = { start: 0, count: 1 / 0 }),
      (this.userData = {}));
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return (
      Array.isArray(e)
        ? (this.index = new (LB(e) ? YT : qT)(e, 1))
        : (this.index = e),
      this
    );
  }
  setIndirect(e, t = 0) {
    return ((this.indirect = e), (this.indirectOffset = t), this);
  }
  getIndirect() {
    return this.indirect;
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, t) {
    return ((this.attributes[e] = t), this);
  }
  deleteAttribute(e) {
    return (delete this.attributes[e], this);
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, t, n = 0) {
    this.groups.push({ start: e, count: t, materialIndex: n });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, t) {
    ((this.drawRange.start = e), (this.drawRange.count = t));
  }
  applyMatrix4(e) {
    const t = this.attributes.position;
    t !== void 0 && (t.applyMatrix4(e), (t.needsUpdate = !0));
    const n = this.attributes.normal;
    if (n !== void 0) {
      const s = new tn().getNormalMatrix(e);
      (n.applyNormalMatrix(s), (n.needsUpdate = !0));
    }
    const r = this.attributes.tangent;
    return (
      r !== void 0 && (r.transformDirection(e), (r.needsUpdate = !0)),
      this.boundingBox !== null && this.computeBoundingBox(),
      this.boundingSphere !== null && this.computeBoundingSphere(),
      this
    );
  }
  applyQuaternion(e) {
    return (go.makeRotationFromQuaternion(e), this.applyMatrix4(go), this);
  }
  rotateX(e) {
    return (go.makeRotationX(e), this.applyMatrix4(go), this);
  }
  rotateY(e) {
    return (go.makeRotationY(e), this.applyMatrix4(go), this);
  }
  rotateZ(e) {
    return (go.makeRotationZ(e), this.applyMatrix4(go), this);
  }
  translate(e, t, n) {
    return (go.makeTranslation(e, t, n), this.applyMatrix4(go), this);
  }
  scale(e, t, n) {
    return (go.makeScale(e, t, n), this.applyMatrix4(go), this);
  }
  lookAt(e) {
    return (
      tS.lookAt(e),
      tS.updateMatrix(),
      this.applyMatrix4(tS.matrix),
      this
    );
  }
  center() {
    return (
      this.computeBoundingBox(),
      this.boundingBox.getCenter(Zd).negate(),
      this.translate(Zd.x, Zd.y, Zd.z),
      this
    );
  }
  setFromPoints(e) {
    const t = this.getAttribute("position");
    if (t === void 0) {
      const n = [];
      for (let r = 0, s = e.length; r < s; r++) {
        const o = e[r];
        n.push(o.x, o.y, o.z || 0);
      }
      this.setAttribute("position", new Rt(n, 3));
    } else {
      const n = Math.min(e.length, t.count);
      for (let r = 0; r < n; r++) {
        const s = e[r];
        t.setXYZ(r, s.x, s.y, s.z || 0);
      }
      (e.length > t.count &&
        Tt(
          "BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry.",
        ),
        (t.needsUpdate = !0));
    }
    return this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new sr());
    const e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      (Ft(
        "BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",
        this,
      ),
        this.boundingBox.set(
          new te(-1 / 0, -1 / 0, -1 / 0),
          new te(1 / 0, 1 / 0, 1 / 0),
        ));
      return;
    }
    if (e !== void 0) {
      if ((this.boundingBox.setFromBufferAttribute(e), t))
        for (let n = 0, r = t.length; n < r; n++) {
          const s = t[n];
          (La.setFromBufferAttribute(s),
            this.morphTargetsRelative
              ? (Ur.addVectors(this.boundingBox.min, La.min),
                this.boundingBox.expandByPoint(Ur),
                Ur.addVectors(this.boundingBox.max, La.max),
                this.boundingBox.expandByPoint(Ur))
              : (this.boundingBox.expandByPoint(La.min),
                this.boundingBox.expandByPoint(La.max)));
        }
    } else this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) ||
      isNaN(this.boundingBox.min.y) ||
      isNaN(this.boundingBox.min.z)) &&
      Ft(
        'BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
        this,
      );
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new mr());
    const e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      (Ft(
        "BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",
        this,
      ),
        this.boundingSphere.set(new te(), 1 / 0));
      return;
    }
    if (e) {
      const n = this.boundingSphere.center;
      if ((La.setFromBufferAttribute(e), t))
        for (let s = 0, o = t.length; s < o; s++) {
          const u = t[s];
          (vg.setFromBufferAttribute(u),
            this.morphTargetsRelative
              ? (Ur.addVectors(La.min, vg.min),
                La.expandByPoint(Ur),
                Ur.addVectors(La.max, vg.max),
                La.expandByPoint(Ur))
              : (La.expandByPoint(vg.min), La.expandByPoint(vg.max)));
        }
      La.getCenter(n);
      let r = 0;
      for (let s = 0, o = e.count; s < o; s++)
        (Ur.fromBufferAttribute(e, s),
          (r = Math.max(r, n.distanceToSquared(Ur))));
      if (t)
        for (let s = 0, o = t.length; s < o; s++) {
          const u = t[s],
            h = this.morphTargetsRelative;
          for (let d = 0, m = u.count; d < m; d++)
            (Ur.fromBufferAttribute(u, d),
              h && (Zd.fromBufferAttribute(e, d), Ur.add(Zd)),
              (r = Math.max(r, n.distanceToSquared(Ur))));
        }
      ((this.boundingSphere.radius = Math.sqrt(r)),
        isNaN(this.boundingSphere.radius) &&
          Ft(
            'BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
            this,
          ));
    }
  }
  computeTangents() {
    const e = this.index,
      t = this.attributes;
    if (
      e === null ||
      t.position === void 0 ||
      t.normal === void 0 ||
      t.uv === void 0
    ) {
      Ft(
        "BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)",
      );
      return;
    }
    const n = t.position,
      r = t.normal,
      s = t.uv;
    this.hasAttribute("tangent") === !1 &&
      this.setAttribute("tangent", new $n(new Float32Array(4 * n.count), 4));
    const o = this.getAttribute("tangent"),
      u = [],
      h = [];
    for (let N = 0; N < n.count; N++) ((u[N] = new te()), (h[N] = new te()));
    const d = new te(),
      m = new te(),
      v = new te(),
      y = new nt(),
      b = new nt(),
      _ = new nt(),
      w = new te(),
      E = new te();
    function T(N, F, j) {
      (d.fromBufferAttribute(n, N),
        m.fromBufferAttribute(n, F),
        v.fromBufferAttribute(n, j),
        y.fromBufferAttribute(s, N),
        b.fromBufferAttribute(s, F),
        _.fromBufferAttribute(s, j),
        m.sub(d),
        v.sub(d),
        b.sub(y),
        _.sub(y));
      const q = 1 / (b.x * _.y - _.x * b.y);
      isFinite(q) &&
        (w
          .copy(m)
          .multiplyScalar(_.y)
          .addScaledVector(v, -b.y)
          .multiplyScalar(q),
        E.copy(v)
          .multiplyScalar(b.x)
          .addScaledVector(m, -_.x)
          .multiplyScalar(q),
        u[N].add(w),
        u[F].add(w),
        u[j].add(w),
        h[N].add(E),
        h[F].add(E),
        h[j].add(E));
    }
    let C = this.groups;
    C.length === 0 && (C = [{ start: 0, count: e.count }]);
    for (let N = 0, F = C.length; N < F; ++N) {
      const j = C[N],
        q = j.start,
        X = j.count;
      for (let J = q, ee = q + X; J < ee; J += 3)
        T(e.getX(J + 0), e.getX(J + 1), e.getX(J + 2));
    }
    const R = new te(),
      L = new te(),
      I = new te(),
      O = new te();
    function B(N) {
      (I.fromBufferAttribute(r, N), O.copy(I));
      const F = u[N];
      (R.copy(F),
        R.sub(I.multiplyScalar(I.dot(F))).normalize(),
        L.crossVectors(O, F));
      const q = L.dot(h[N]) < 0 ? -1 : 1;
      o.setXYZW(N, R.x, R.y, R.z, q);
    }
    for (let N = 0, F = C.length; N < F; ++N) {
      const j = C[N],
        q = j.start,
        X = j.count;
      for (let J = q, ee = q + X; J < ee; J += 3)
        (B(e.getX(J + 0)), B(e.getX(J + 1)), B(e.getX(J + 2)));
    }
  }
  computeVertexNormals() {
    const e = this.index,
      t = this.getAttribute("position");
    if (t !== void 0) {
      let n = this.getAttribute("normal");
      if (n === void 0)
        ((n = new $n(new Float32Array(t.count * 3), 3)),
          this.setAttribute("normal", n));
      else for (let y = 0, b = n.count; y < b; y++) n.setXYZ(y, 0, 0, 0);
      const r = new te(),
        s = new te(),
        o = new te(),
        u = new te(),
        h = new te(),
        d = new te(),
        m = new te(),
        v = new te();
      if (e)
        for (let y = 0, b = e.count; y < b; y += 3) {
          const _ = e.getX(y + 0),
            w = e.getX(y + 1),
            E = e.getX(y + 2);
          (r.fromBufferAttribute(t, _),
            s.fromBufferAttribute(t, w),
            o.fromBufferAttribute(t, E),
            m.subVectors(o, s),
            v.subVectors(r, s),
            m.cross(v),
            u.fromBufferAttribute(n, _),
            h.fromBufferAttribute(n, w),
            d.fromBufferAttribute(n, E),
            u.add(m),
            h.add(m),
            d.add(m),
            n.setXYZ(_, u.x, u.y, u.z),
            n.setXYZ(w, h.x, h.y, h.z),
            n.setXYZ(E, d.x, d.y, d.z));
        }
      else
        for (let y = 0, b = t.count; y < b; y += 3)
          (r.fromBufferAttribute(t, y + 0),
            s.fromBufferAttribute(t, y + 1),
            o.fromBufferAttribute(t, y + 2),
            m.subVectors(o, s),
            v.subVectors(r, s),
            m.cross(v),
            n.setXYZ(y + 0, m.x, m.y, m.z),
            n.setXYZ(y + 1, m.x, m.y, m.z),
            n.setXYZ(y + 2, m.x, m.y, m.z));
      (this.normalizeNormals(), (n.needsUpdate = !0));
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, n = e.count; t < n; t++)
      (Ur.fromBufferAttribute(e, t),
        Ur.normalize(),
        e.setXYZ(t, Ur.x, Ur.y, Ur.z));
  }
  toNonIndexed() {
    function e(u, h) {
      const d = u.array,
        m = u.itemSize,
        v = u.normalized,
        y = new d.constructor(h.length * m);
      let b = 0,
        _ = 0;
      for (let w = 0, E = h.length; w < E; w++) {
        u.isInterleavedBufferAttribute
          ? (b = h[w] * u.data.stride + u.offset)
          : (b = h[w] * m);
        for (let T = 0; T < m; T++) y[_++] = d[b++];
      }
      return new $n(y, m, v);
    }
    if (this.index === null)
      return (
        Tt(
          "BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.",
        ),
        this
      );
    const t = new nn(),
      n = this.index.array,
      r = this.attributes;
    for (const u in r) {
      const h = r[u],
        d = e(h, n);
      t.setAttribute(u, d);
    }
    const s = this.morphAttributes;
    for (const u in s) {
      const h = [],
        d = s[u];
      for (let m = 0, v = d.length; m < v; m++) {
        const y = d[m],
          b = e(y, n);
        h.push(b);
      }
      t.morphAttributes[u] = h;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const o = this.groups;
    for (let u = 0, h = o.length; u < h; u++) {
      const d = o[u];
      t.addGroup(d.start, d.count, d.materialIndex);
    }
    return t;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.7,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON",
      },
    };
    if (
      ((e.uuid = this.uuid),
      (e.type = this.type),
      this.name !== "" && (e.name = this.name),
      Object.keys(this.userData).length > 0 && (e.userData = this.userData),
      this.parameters !== void 0)
    ) {
      const h = this.parameters;
      for (const d in h) h[d] !== void 0 && (e[d] = h[d]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    t !== null &&
      (e.data.index = {
        type: t.array.constructor.name,
        array: Array.prototype.slice.call(t.array),
      });
    const n = this.attributes;
    for (const h in n) {
      const d = n[h];
      e.data.attributes[h] = d.toJSON(e.data);
    }
    const r = {};
    let s = !1;
    for (const h in this.morphAttributes) {
      const d = this.morphAttributes[h],
        m = [];
      for (let v = 0, y = d.length; v < y; v++) {
        const b = d[v];
        m.push(b.toJSON(e.data));
      }
      m.length > 0 && ((r[h] = m), (s = !0));
    }
    s &&
      ((e.data.morphAttributes = r),
      (e.data.morphTargetsRelative = this.morphTargetsRelative));
    const o = this.groups;
    o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
    const u = this.boundingSphere;
    return (u !== null && (e.data.boundingSphere = u.toJSON()), e);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    ((this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null));
    const t = {};
    this.name = e.name;
    const n = e.index;
    n !== null && this.setIndex(n.clone());
    const r = e.attributes;
    for (const d in r) {
      const m = r[d];
      this.setAttribute(d, m.clone(t));
    }
    const s = e.morphAttributes;
    for (const d in s) {
      const m = [],
        v = s[d];
      for (let y = 0, b = v.length; y < b; y++) m.push(v[y].clone(t));
      this.morphAttributes[d] = m;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const o = e.groups;
    for (let d = 0, m = o.length; d < m; d++) {
      const v = o[d];
      this.addGroup(v.start, v.count, v.materialIndex);
    }
    const u = e.boundingBox;
    u !== null && (this.boundingBox = u.clone());
    const h = e.boundingSphere;
    return (
      h !== null && (this.boundingSphere = h.clone()),
      (this.drawRange.start = e.drawRange.start),
      (this.drawRange.count = e.drawRange.count),
      (this.userData = e.userData),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class ub {
  constructor(e, t) {
    ((this.isInterleavedBuffer = !0),
      (this.array = e),
      (this.stride = t),
      (this.count = e !== void 0 ? e.length / t : 0),
      (this.usage = c0),
      (this.updateRanges = []),
      (this.version = 0),
      (this.uuid = Ia()));
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return ((this.usage = e), this);
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return (
      (this.array = new e.array.constructor(e.array)),
      (this.count = e.count),
      (this.stride = e.stride),
      (this.usage = e.usage),
      this
    );
  }
  copyAt(e, t, n) {
    ((e *= this.stride), (n *= t.stride));
    for (let r = 0, s = this.stride; r < s; r++)
      this.array[e + r] = t.array[n + r];
    return this;
  }
  set(e, t = 0) {
    return (this.array.set(e, t), this);
  }
  clone(e) {
    (e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Ia()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer));
    const t = new this.array.constructor(
        e.arrayBuffers[this.array.buffer._uuid],
      ),
      n = new this.constructor(t, this.stride);
    return (n.setUsage(this.usage), n);
  }
  onUpload(e) {
    return ((this.onUploadCallback = e), this);
  }
  toJSON(e) {
    return (
      e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Ia()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = Array.from(
          new Uint32Array(this.array.buffer),
        )),
      {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride,
      }
    );
  }
}
const Fs = new te();
class Pa {
  constructor(e, t, n, r = !1) {
    ((this.isInterleavedBufferAttribute = !0),
      (this.name = ""),
      (this.data = e),
      (this.itemSize = t),
      (this.offset = n),
      (this.normalized = r));
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let t = 0, n = this.data.count; t < n; t++)
      (Fs.fromBufferAttribute(this, t),
        Fs.applyMatrix4(e),
        this.setXYZ(t, Fs.x, Fs.y, Fs.z));
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, n = this.count; t < n; t++)
      (Fs.fromBufferAttribute(this, t),
        Fs.applyNormalMatrix(e),
        this.setXYZ(t, Fs.x, Fs.y, Fs.z));
    return this;
  }
  transformDirection(e) {
    for (let t = 0, n = this.count; t < n; t++)
      (Fs.fromBufferAttribute(this, t),
        Fs.transformDirection(e),
        this.setXYZ(t, Fs.x, Fs.y, Fs.z));
    return this;
  }
  getComponent(e, t) {
    let n = this.array[e * this.data.stride + this.offset + t];
    return (this.normalized && (n = ks(n, this.array)), n);
  }
  setComponent(e, t, n) {
    return (
      this.normalized && (n = un(n, this.array)),
      (this.data.array[e * this.data.stride + this.offset + t] = n),
      this
    );
  }
  setX(e, t) {
    return (
      this.normalized && (t = un(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset] = t),
      this
    );
  }
  setY(e, t) {
    return (
      this.normalized && (t = un(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 1] = t),
      this
    );
  }
  setZ(e, t) {
    return (
      this.normalized && (t = un(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 2] = t),
      this
    );
  }
  setW(e, t) {
    return (
      this.normalized && (t = un(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 3] = t),
      this
    );
  }
  getX(e) {
    let t = this.data.array[e * this.data.stride + this.offset];
    return (this.normalized && (t = ks(t, this.array)), t);
  }
  getY(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 1];
    return (this.normalized && (t = ks(t, this.array)), t);
  }
  getZ(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 2];
    return (this.normalized && (t = ks(t, this.array)), t);
  }
  getW(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 3];
    return (this.normalized && (t = ks(t, this.array)), t);
  }
  setXY(e, t, n) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized && ((t = un(t, this.array)), (n = un(n, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = n),
      this
    );
  }
  setXYZ(e, t, n, r) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((t = un(t, this.array)),
        (n = un(n, this.array)),
        (r = un(r, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = n),
      (this.data.array[e + 2] = r),
      this
    );
  }
  setXYZW(e, t, n, r, s) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((t = un(t, this.array)),
        (n = un(n, this.array)),
        (r = un(r, this.array)),
        (s = un(s, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = n),
      (this.data.array[e + 2] = r),
      (this.data.array[e + 3] = s),
      this
    );
  }
  clone(e) {
    if (e === void 0) {
      f0(
        "InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.",
      );
      const t = [];
      for (let n = 0; n < this.count; n++) {
        const r = n * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[r + s]);
      }
      return new $n(
        new this.array.constructor(t),
        this.itemSize,
        this.normalized,
      );
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
        new Pa(
          e.interleavedBuffers[this.data.uuid],
          this.itemSize,
          this.offset,
          this.normalized,
        )
      );
  }
  toJSON(e) {
    if (e === void 0) {
      f0(
        "InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.",
      );
      const t = [];
      for (let n = 0; n < this.count; n++) {
        const r = n * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[r + s]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: t,
        normalized: this.normalized,
      };
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
        {
          isInterleavedBufferAttribute: !0,
          itemSize: this.itemSize,
          data: this.data.uuid,
          offset: this.offset,
          normalized: this.normalized,
        }
      );
  }
}
let Sk = 0;
class bs extends ec {
  constructor() {
    (super(),
      (this.isMaterial = !0),
      Object.defineProperty(this, "id", { value: Sk++ }),
      (this.uuid = Ia()),
      (this.name = ""),
      (this.type = "Material"),
      (this.blending = Eh),
      (this.side = Zc),
      (this.vertexColors = !1),
      (this.opacity = 1),
      (this.transparent = !1),
      (this.alphaHash = !1),
      (this.blendSrc = jx),
      (this.blendDst = Wx),
      (this.blendEquation = Ku),
      (this.blendSrcAlpha = null),
      (this.blendDstAlpha = null),
      (this.blendEquationAlpha = null),
      (this.blendColor = new wt(0, 0, 0)),
      (this.blendAlpha = 0),
      (this.depthFunc = Dh),
      (this.depthTest = !0),
      (this.depthWrite = !0),
      (this.stencilWriteMask = 255),
      (this.stencilFunc = TM),
      (this.stencilRef = 0),
      (this.stencilFuncMask = 255),
      (this.stencilFail = gh),
      (this.stencilZFail = gh),
      (this.stencilZPass = gh),
      (this.stencilWrite = !1),
      (this.clippingPlanes = null),
      (this.clipIntersection = !1),
      (this.clipShadows = !1),
      (this.shadowSide = null),
      (this.colorWrite = !0),
      (this.precision = null),
      (this.polygonOffset = !1),
      (this.polygonOffsetFactor = 0),
      (this.polygonOffsetUnits = 0),
      (this.dithering = !1),
      (this.alphaToCoverage = !1),
      (this.premultipliedAlpha = !1),
      (this.forceSinglePass = !1),
      (this.allowOverride = !0),
      (this.visible = !0),
      (this.toneMapped = !0),
      (this.userData = {}),
      (this.version = 0),
      (this._alphaTest = 0));
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    (this._alphaTest > 0 != e > 0 && this.version++, (this._alphaTest = e));
  }
  onBeforeRender() {}
  onBeforeCompile() {}
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const t in e) {
        const n = e[t];
        if (n === void 0) {
          Tt(`Material: parameter '${t}' has value of undefined.`);
          continue;
        }
        const r = this[t];
        if (r === void 0) {
          Tt(`Material: '${t}' is not a property of THREE.${this.type}.`);
          continue;
        }
        r && r.isColor
          ? r.set(n)
          : r && r.isVector3 && n && n.isVector3
            ? r.copy(n)
            : (this[t] = n);
      }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    t && (e = { textures: {}, images: {} });
    const n = {
      metadata: {
        version: 4.7,
        type: "Material",
        generator: "Material.toJSON",
      },
    };
    ((n.uuid = this.uuid),
      (n.type = this.type),
      this.name !== "" && (n.name = this.name),
      this.color && this.color.isColor && (n.color = this.color.getHex()),
      this.roughness !== void 0 && (n.roughness = this.roughness),
      this.metalness !== void 0 && (n.metalness = this.metalness),
      this.sheen !== void 0 && (n.sheen = this.sheen),
      this.sheenColor &&
        this.sheenColor.isColor &&
        (n.sheenColor = this.sheenColor.getHex()),
      this.sheenRoughness !== void 0 &&
        (n.sheenRoughness = this.sheenRoughness),
      this.emissive &&
        this.emissive.isColor &&
        (n.emissive = this.emissive.getHex()),
      this.emissiveIntensity !== void 0 &&
        this.emissiveIntensity !== 1 &&
        (n.emissiveIntensity = this.emissiveIntensity),
      this.specular &&
        this.specular.isColor &&
        (n.specular = this.specular.getHex()),
      this.specularIntensity !== void 0 &&
        (n.specularIntensity = this.specularIntensity),
      this.specularColor &&
        this.specularColor.isColor &&
        (n.specularColor = this.specularColor.getHex()),
      this.shininess !== void 0 && (n.shininess = this.shininess),
      this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat),
      this.clearcoatRoughness !== void 0 &&
        (n.clearcoatRoughness = this.clearcoatRoughness),
      this.clearcoatMap &&
        this.clearcoatMap.isTexture &&
        (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
      this.clearcoatRoughnessMap &&
        this.clearcoatRoughnessMap.isTexture &&
        (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
      this.clearcoatNormalMap &&
        this.clearcoatNormalMap.isTexture &&
        ((n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
        (n.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
      this.sheenColorMap &&
        this.sheenColorMap.isTexture &&
        (n.sheenColorMap = this.sheenColorMap.toJSON(e).uuid),
      this.sheenRoughnessMap &&
        this.sheenRoughnessMap.isTexture &&
        (n.sheenRoughnessMap = this.sheenRoughnessMap.toJSON(e).uuid),
      this.dispersion !== void 0 && (n.dispersion = this.dispersion),
      this.iridescence !== void 0 && (n.iridescence = this.iridescence),
      this.iridescenceIOR !== void 0 &&
        (n.iridescenceIOR = this.iridescenceIOR),
      this.iridescenceThicknessRange !== void 0 &&
        (n.iridescenceThicknessRange = this.iridescenceThicknessRange),
      this.iridescenceMap &&
        this.iridescenceMap.isTexture &&
        (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
      this.iridescenceThicknessMap &&
        this.iridescenceThicknessMap.isTexture &&
        (n.iridescenceThicknessMap =
          this.iridescenceThicknessMap.toJSON(e).uuid),
      this.anisotropy !== void 0 && (n.anisotropy = this.anisotropy),
      this.anisotropyRotation !== void 0 &&
        (n.anisotropyRotation = this.anisotropyRotation),
      this.anisotropyMap &&
        this.anisotropyMap.isTexture &&
        (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
      this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid),
      this.matcap &&
        this.matcap.isTexture &&
        (n.matcap = this.matcap.toJSON(e).uuid),
      this.alphaMap &&
        this.alphaMap.isTexture &&
        (n.alphaMap = this.alphaMap.toJSON(e).uuid),
      this.lightMap &&
        this.lightMap.isTexture &&
        ((n.lightMap = this.lightMap.toJSON(e).uuid),
        (n.lightMapIntensity = this.lightMapIntensity)),
      this.aoMap &&
        this.aoMap.isTexture &&
        ((n.aoMap = this.aoMap.toJSON(e).uuid),
        (n.aoMapIntensity = this.aoMapIntensity)),
      this.bumpMap &&
        this.bumpMap.isTexture &&
        ((n.bumpMap = this.bumpMap.toJSON(e).uuid),
        (n.bumpScale = this.bumpScale)),
      this.normalMap &&
        this.normalMap.isTexture &&
        ((n.normalMap = this.normalMap.toJSON(e).uuid),
        (n.normalMapType = this.normalMapType),
        (n.normalScale = this.normalScale.toArray())),
      this.displacementMap &&
        this.displacementMap.isTexture &&
        ((n.displacementMap = this.displacementMap.toJSON(e).uuid),
        (n.displacementScale = this.displacementScale),
        (n.displacementBias = this.displacementBias)),
      this.roughnessMap &&
        this.roughnessMap.isTexture &&
        (n.roughnessMap = this.roughnessMap.toJSON(e).uuid),
      this.metalnessMap &&
        this.metalnessMap.isTexture &&
        (n.metalnessMap = this.metalnessMap.toJSON(e).uuid),
      this.emissiveMap &&
        this.emissiveMap.isTexture &&
        (n.emissiveMap = this.emissiveMap.toJSON(e).uuid),
      this.specularMap &&
        this.specularMap.isTexture &&
        (n.specularMap = this.specularMap.toJSON(e).uuid),
      this.specularIntensityMap &&
        this.specularIntensityMap.isTexture &&
        (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
      this.specularColorMap &&
        this.specularColorMap.isTexture &&
        (n.specularColorMap = this.specularColorMap.toJSON(e).uuid),
      this.envMap &&
        this.envMap.isTexture &&
        ((n.envMap = this.envMap.toJSON(e).uuid),
        this.combine !== void 0 && (n.combine = this.combine)),
      this.envMapRotation !== void 0 &&
        (n.envMapRotation = this.envMapRotation.toArray()),
      this.envMapIntensity !== void 0 &&
        (n.envMapIntensity = this.envMapIntensity),
      this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity),
      this.refractionRatio !== void 0 &&
        (n.refractionRatio = this.refractionRatio),
      this.gradientMap &&
        this.gradientMap.isTexture &&
        (n.gradientMap = this.gradientMap.toJSON(e).uuid),
      this.transmission !== void 0 && (n.transmission = this.transmission),
      this.transmissionMap &&
        this.transmissionMap.isTexture &&
        (n.transmissionMap = this.transmissionMap.toJSON(e).uuid),
      this.thickness !== void 0 && (n.thickness = this.thickness),
      this.thicknessMap &&
        this.thicknessMap.isTexture &&
        (n.thicknessMap = this.thicknessMap.toJSON(e).uuid),
      this.attenuationDistance !== void 0 &&
        this.attenuationDistance !== 1 / 0 &&
        (n.attenuationDistance = this.attenuationDistance),
      this.attenuationColor !== void 0 &&
        (n.attenuationColor = this.attenuationColor.getHex()),
      this.size !== void 0 && (n.size = this.size),
      this.shadowSide !== null && (n.shadowSide = this.shadowSide),
      this.sizeAttenuation !== void 0 &&
        (n.sizeAttenuation = this.sizeAttenuation),
      this.blending !== Eh && (n.blending = this.blending),
      this.side !== Zc && (n.side = this.side),
      this.vertexColors === !0 && (n.vertexColors = !0),
      this.opacity < 1 && (n.opacity = this.opacity),
      this.transparent === !0 && (n.transparent = !0),
      this.blendSrc !== jx && (n.blendSrc = this.blendSrc),
      this.blendDst !== Wx && (n.blendDst = this.blendDst),
      this.blendEquation !== Ku && (n.blendEquation = this.blendEquation),
      this.blendSrcAlpha !== null && (n.blendSrcAlpha = this.blendSrcAlpha),
      this.blendDstAlpha !== null && (n.blendDstAlpha = this.blendDstAlpha),
      this.blendEquationAlpha !== null &&
        (n.blendEquationAlpha = this.blendEquationAlpha),
      this.blendColor &&
        this.blendColor.isColor &&
        (n.blendColor = this.blendColor.getHex()),
      this.blendAlpha !== 0 && (n.blendAlpha = this.blendAlpha),
      this.depthFunc !== Dh && (n.depthFunc = this.depthFunc),
      this.depthTest === !1 && (n.depthTest = this.depthTest),
      this.depthWrite === !1 && (n.depthWrite = this.depthWrite),
      this.colorWrite === !1 && (n.colorWrite = this.colorWrite),
      this.stencilWriteMask !== 255 &&
        (n.stencilWriteMask = this.stencilWriteMask),
      this.stencilFunc !== TM && (n.stencilFunc = this.stencilFunc),
      this.stencilRef !== 0 && (n.stencilRef = this.stencilRef),
      this.stencilFuncMask !== 255 &&
        (n.stencilFuncMask = this.stencilFuncMask),
      this.stencilFail !== gh && (n.stencilFail = this.stencilFail),
      this.stencilZFail !== gh && (n.stencilZFail = this.stencilZFail),
      this.stencilZPass !== gh && (n.stencilZPass = this.stencilZPass),
      this.stencilWrite === !0 && (n.stencilWrite = this.stencilWrite),
      this.rotation !== void 0 &&
        this.rotation !== 0 &&
        (n.rotation = this.rotation),
      this.polygonOffset === !0 && (n.polygonOffset = !0),
      this.polygonOffsetFactor !== 0 &&
        (n.polygonOffsetFactor = this.polygonOffsetFactor),
      this.polygonOffsetUnits !== 0 &&
        (n.polygonOffsetUnits = this.polygonOffsetUnits),
      this.linewidth !== void 0 &&
        this.linewidth !== 1 &&
        (n.linewidth = this.linewidth),
      this.dashSize !== void 0 && (n.dashSize = this.dashSize),
      this.gapSize !== void 0 && (n.gapSize = this.gapSize),
      this.scale !== void 0 && (n.scale = this.scale),
      this.dithering === !0 && (n.dithering = !0),
      this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
      this.alphaHash === !0 && (n.alphaHash = !0),
      this.alphaToCoverage === !0 && (n.alphaToCoverage = !0),
      this.premultipliedAlpha === !0 && (n.premultipliedAlpha = !0),
      this.forceSinglePass === !0 && (n.forceSinglePass = !0),
      this.allowOverride === !1 && (n.allowOverride = !1),
      this.wireframe === !0 && (n.wireframe = !0),
      this.wireframeLinewidth > 1 &&
        (n.wireframeLinewidth = this.wireframeLinewidth),
      this.wireframeLinecap !== "round" &&
        (n.wireframeLinecap = this.wireframeLinecap),
      this.wireframeLinejoin !== "round" &&
        (n.wireframeLinejoin = this.wireframeLinejoin),
      this.flatShading === !0 && (n.flatShading = !0),
      this.visible === !1 && (n.visible = !1),
      this.toneMapped === !1 && (n.toneMapped = !1),
      this.fog === !1 && (n.fog = !1),
      Object.keys(this.userData).length > 0 && (n.userData = this.userData));
    function r(s) {
      const o = [];
      for (const u in s) {
        const h = s[u];
        (delete h.metadata, o.push(h));
      }
      return o;
    }
    if (t) {
      const s = r(e.textures),
        o = r(e.images);
      (s.length > 0 && (n.textures = s), o.length > 0 && (n.images = o));
    }
    return n;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    ((this.name = e.name),
      (this.blending = e.blending),
      (this.side = e.side),
      (this.vertexColors = e.vertexColors),
      (this.opacity = e.opacity),
      (this.transparent = e.transparent),
      (this.blendSrc = e.blendSrc),
      (this.blendDst = e.blendDst),
      (this.blendEquation = e.blendEquation),
      (this.blendSrcAlpha = e.blendSrcAlpha),
      (this.blendDstAlpha = e.blendDstAlpha),
      (this.blendEquationAlpha = e.blendEquationAlpha),
      this.blendColor.copy(e.blendColor),
      (this.blendAlpha = e.blendAlpha),
      (this.depthFunc = e.depthFunc),
      (this.depthTest = e.depthTest),
      (this.depthWrite = e.depthWrite),
      (this.stencilWriteMask = e.stencilWriteMask),
      (this.stencilFunc = e.stencilFunc),
      (this.stencilRef = e.stencilRef),
      (this.stencilFuncMask = e.stencilFuncMask),
      (this.stencilFail = e.stencilFail),
      (this.stencilZFail = e.stencilZFail),
      (this.stencilZPass = e.stencilZPass),
      (this.stencilWrite = e.stencilWrite));
    const t = e.clippingPlanes;
    let n = null;
    if (t !== null) {
      const r = t.length;
      n = new Array(r);
      for (let s = 0; s !== r; ++s) n[s] = t[s].clone();
    }
    return (
      (this.clippingPlanes = n),
      (this.clipIntersection = e.clipIntersection),
      (this.clipShadows = e.clipShadows),
      (this.shadowSide = e.shadowSide),
      (this.colorWrite = e.colorWrite),
      (this.precision = e.precision),
      (this.polygonOffset = e.polygonOffset),
      (this.polygonOffsetFactor = e.polygonOffsetFactor),
      (this.polygonOffsetUnits = e.polygonOffsetUnits),
      (this.dithering = e.dithering),
      (this.alphaTest = e.alphaTest),
      (this.alphaHash = e.alphaHash),
      (this.alphaToCoverage = e.alphaToCoverage),
      (this.premultipliedAlpha = e.premultipliedAlpha),
      (this.forceSinglePass = e.forceSinglePass),
      (this.allowOverride = e.allowOverride),
      (this.visible = e.visible),
      (this.toneMapped = e.toneMapped),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
}
class ZT extends bs {
  constructor(e) {
    (super(),
      (this.isSpriteMaterial = !0),
      (this.type = "SpriteMaterial"),
      (this.color = new wt(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.rotation = 0),
      (this.sizeAttenuation = !0),
      (this.transparent = !0),
      (this.fog = !0),
      this.setValues(e));
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.rotation = e.rotation),
      (this.sizeAttenuation = e.sizeAttenuation),
      (this.fog = e.fog),
      this
    );
  }
}
let Kd;
const yg = new te(),
  Qd = new te(),
  Jd = new te(),
  $d = new nt(),
  xg = new nt(),
  tN = new qt(),
  wy = new te(),
  bg = new te(),
  Ay = new te(),
  tC = new nt(),
  nS = new nt(),
  nC = new nt();
class nN extends In {
  constructor(e = new ZT()) {
    if (
      (super(), (this.isSprite = !0), (this.type = "Sprite"), Kd === void 0)
    ) {
      Kd = new nn();
      const t = new Float32Array([
          -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5,
          0, 0, 1,
        ]),
        n = new ub(t, 5);
      (Kd.setIndex([0, 1, 2, 0, 2, 3]),
        Kd.setAttribute("position", new Pa(n, 3, 0, !1)),
        Kd.setAttribute("uv", new Pa(n, 2, 3, !1)));
    }
    ((this.geometry = Kd),
      (this.material = e),
      (this.center = new nt(0.5, 0.5)),
      (this.count = 1));
  }
  raycast(e, t) {
    (e.camera === null &&
      Ft(
        'Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.',
      ),
      Qd.setFromMatrixScale(this.matrixWorld),
      tN.copy(e.camera.matrixWorld),
      this.modelViewMatrix.multiplyMatrices(
        e.camera.matrixWorldInverse,
        this.matrixWorld,
      ),
      Jd.setFromMatrixPosition(this.modelViewMatrix),
      e.camera.isPerspectiveCamera &&
        this.material.sizeAttenuation === !1 &&
        Qd.multiplyScalar(-Jd.z));
    const n = this.material.rotation;
    let r, s;
    n !== 0 && ((s = Math.cos(n)), (r = Math.sin(n)));
    const o = this.center;
    (Cy(wy.set(-0.5, -0.5, 0), Jd, o, Qd, r, s),
      Cy(bg.set(0.5, -0.5, 0), Jd, o, Qd, r, s),
      Cy(Ay.set(0.5, 0.5, 0), Jd, o, Qd, r, s),
      tC.set(0, 0),
      nS.set(1, 0),
      nC.set(1, 1));
    let u = e.ray.intersectTriangle(wy, bg, Ay, !1, yg);
    if (
      u === null &&
      (Cy(bg.set(-0.5, 0.5, 0), Jd, o, Qd, r, s),
      nS.set(0, 1),
      (u = e.ray.intersectTriangle(wy, Ay, bg, !1, yg)),
      u === null)
    )
      return;
    const h = e.ray.origin.distanceTo(yg);
    h < e.near ||
      h > e.far ||
      t.push({
        distance: h,
        point: yg.clone(),
        uv: ya.getInterpolation(yg, wy, bg, Ay, tC, nS, nC, new nt()),
        face: null,
        object: this,
      });
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.center !== void 0 && this.center.copy(e.center),
      (this.material = e.material),
      this
    );
  }
}
function Cy(i, e, t, n, r, s) {
  ($d.subVectors(i, t).addScalar(0.5).multiply(n),
    r !== void 0
      ? ((xg.x = s * $d.x - r * $d.y), (xg.y = r * $d.x + s * $d.y))
      : xg.copy($d),
    i.copy(e),
    (i.x += xg.x),
    (i.y += xg.y),
    i.applyMatrix4(tN));
}
const Ry = new te(),
  iC = new te();
class iN extends In {
  constructor() {
    (super(),
      (this.isLOD = !0),
      (this._currentLevel = 0),
      (this.type = "LOD"),
      Object.defineProperties(this, { levels: { enumerable: !0, value: [] } }),
      (this.autoUpdate = !0));
  }
  copy(e) {
    super.copy(e, !1);
    const t = e.levels;
    for (let n = 0, r = t.length; n < r; n++) {
      const s = t[n];
      this.addLevel(s.object.clone(), s.distance, s.hysteresis);
    }
    return ((this.autoUpdate = e.autoUpdate), this);
  }
  addLevel(e, t = 0, n = 0) {
    t = Math.abs(t);
    const r = this.levels;
    let s;
    for (s = 0; s < r.length && !(t < r[s].distance); s++);
    return (
      r.splice(s, 0, { distance: t, hysteresis: n, object: e }),
      this.add(e),
      this
    );
  }
  removeLevel(e) {
    const t = this.levels;
    for (let n = 0; n < t.length; n++)
      if (t[n].distance === e) {
        const r = t.splice(n, 1);
        return (this.remove(r[0].object), !0);
      }
    return !1;
  }
  getCurrentLevel() {
    return this._currentLevel;
  }
  getObjectForDistance(e) {
    const t = this.levels;
    if (t.length > 0) {
      let n, r;
      for (n = 1, r = t.length; n < r; n++) {
        let s = t[n].distance;
        if ((t[n].object.visible && (s -= s * t[n].hysteresis), e < s)) break;
      }
      return t[n - 1].object;
    }
    return null;
  }
  raycast(e, t) {
    if (this.levels.length > 0) {
      Ry.setFromMatrixPosition(this.matrixWorld);
      const r = e.ray.origin.distanceTo(Ry);
      this.getObjectForDistance(r).raycast(e, t);
    }
  }
  update(e) {
    const t = this.levels;
    if (t.length > 1) {
      (Ry.setFromMatrixPosition(e.matrixWorld),
        iC.setFromMatrixPosition(this.matrixWorld));
      const n = Ry.distanceTo(iC) / e.zoom;
      t[0].object.visible = !0;
      let r, s;
      for (r = 1, s = t.length; r < s; r++) {
        let o = t[r].distance;
        if ((t[r].object.visible && (o -= o * t[r].hysteresis), n >= o))
          ((t[r - 1].object.visible = !1), (t[r].object.visible = !0));
        else break;
      }
      for (this._currentLevel = r - 1; r < s; r++) t[r].object.visible = !1;
    }
  }
  toJSON(e) {
    const t = super.toJSON(e);
    (this.autoUpdate === !1 && (t.object.autoUpdate = !1),
      (t.object.levels = []));
    const n = this.levels;
    for (let r = 0, s = n.length; r < s; r++) {
      const o = n[r];
      t.object.levels.push({
        object: o.object.uuid,
        distance: o.distance,
        hysteresis: o.hysteresis,
      });
    }
    return t;
  }
}
const Bc = new te(),
  iS = new te(),
  Dy = new te(),
  Wu = new te(),
  rS = new te(),
  Ly = new te(),
  sS = new te();
class Oh {
  constructor(e = new te(), t = new te(0, 0, -1)) {
    ((this.origin = e), (this.direction = t));
  }
  set(e, t) {
    return (this.origin.copy(e), this.direction.copy(t), this);
  }
  copy(e) {
    return (this.origin.copy(e.origin), this.direction.copy(e.direction), this);
  }
  at(e, t) {
    return t.copy(this.origin).addScaledVector(this.direction, e);
  }
  lookAt(e) {
    return (this.direction.copy(e).sub(this.origin).normalize(), this);
  }
  recast(e) {
    return (this.origin.copy(this.at(e, Bc)), this);
  }
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin);
    const n = t.dot(this.direction);
    return n < 0
      ? t.copy(this.origin)
      : t.copy(this.origin).addScaledVector(this.direction, n);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const t = Bc.subVectors(e, this.origin).dot(this.direction);
    return t < 0
      ? this.origin.distanceToSquared(e)
      : (Bc.copy(this.origin).addScaledVector(this.direction, t),
        Bc.distanceToSquared(e));
  }
  distanceSqToSegment(e, t, n, r) {
    (iS.copy(e).add(t).multiplyScalar(0.5),
      Dy.copy(t).sub(e).normalize(),
      Wu.copy(this.origin).sub(iS));
    const s = e.distanceTo(t) * 0.5,
      o = -this.direction.dot(Dy),
      u = Wu.dot(this.direction),
      h = -Wu.dot(Dy),
      d = Wu.lengthSq(),
      m = Math.abs(1 - o * o);
    let v, y, b, _;
    if (m > 0)
      if (((v = o * h - u), (y = o * u - h), (_ = s * m), v >= 0))
        if (y >= -_)
          if (y <= _) {
            const w = 1 / m;
            ((v *= w),
              (y *= w),
              (b = v * (v + o * y + 2 * u) + y * (o * v + y + 2 * h) + d));
          } else
            ((y = s),
              (v = Math.max(0, -(o * y + u))),
              (b = -v * v + y * (y + 2 * h) + d));
        else
          ((y = -s),
            (v = Math.max(0, -(o * y + u))),
            (b = -v * v + y * (y + 2 * h) + d));
      else
        y <= -_
          ? ((v = Math.max(0, -(-o * s + u))),
            (y = v > 0 ? -s : Math.min(Math.max(-s, -h), s)),
            (b = -v * v + y * (y + 2 * h) + d))
          : y <= _
            ? ((v = 0),
              (y = Math.min(Math.max(-s, -h), s)),
              (b = y * (y + 2 * h) + d))
            : ((v = Math.max(0, -(o * s + u))),
              (y = v > 0 ? s : Math.min(Math.max(-s, -h), s)),
              (b = -v * v + y * (y + 2 * h) + d));
    else
      ((y = o > 0 ? -s : s),
        (v = Math.max(0, -(o * y + u))),
        (b = -v * v + y * (y + 2 * h) + d));
    return (
      n && n.copy(this.origin).addScaledVector(this.direction, v),
      r && r.copy(iS).addScaledVector(Dy, y),
      b
    );
  }
  intersectSphere(e, t) {
    Bc.subVectors(e.center, this.origin);
    const n = Bc.dot(this.direction),
      r = Bc.dot(Bc) - n * n,
      s = e.radius * e.radius;
    if (r > s) return null;
    const o = Math.sqrt(s - r),
      u = n - o,
      h = n + o;
    return h < 0 ? null : u < 0 ? this.at(h, t) : this.at(u, t);
  }
  intersectsSphere(e) {
    return e.radius < 0
      ? !1
      : this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction);
    if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const n = -(this.origin.dot(e.normal) + e.constant) / t;
    return n >= 0 ? n : null;
  }
  intersectPlane(e, t) {
    const n = this.distanceToPlane(e);
    return n === null ? null : this.at(n, t);
  }
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin);
    return t === 0 || e.normal.dot(this.direction) * t < 0;
  }
  intersectBox(e, t) {
    let n, r, s, o, u, h;
    const d = 1 / this.direction.x,
      m = 1 / this.direction.y,
      v = 1 / this.direction.z,
      y = this.origin;
    return (
      d >= 0
        ? ((n = (e.min.x - y.x) * d), (r = (e.max.x - y.x) * d))
        : ((n = (e.max.x - y.x) * d), (r = (e.min.x - y.x) * d)),
      m >= 0
        ? ((s = (e.min.y - y.y) * m), (o = (e.max.y - y.y) * m))
        : ((s = (e.max.y - y.y) * m), (o = (e.min.y - y.y) * m)),
      n > o ||
      s > r ||
      ((s > n || isNaN(n)) && (n = s),
      (o < r || isNaN(r)) && (r = o),
      v >= 0
        ? ((u = (e.min.z - y.z) * v), (h = (e.max.z - y.z) * v))
        : ((u = (e.max.z - y.z) * v), (h = (e.min.z - y.z) * v)),
      n > h || u > r) ||
      ((u > n || n !== n) && (n = u), (h < r || r !== r) && (r = h), r < 0)
        ? null
        : this.at(n >= 0 ? n : r, t)
    );
  }
  intersectsBox(e) {
    return this.intersectBox(e, Bc) !== null;
  }
  intersectTriangle(e, t, n, r, s) {
    (rS.subVectors(t, e), Ly.subVectors(n, e), sS.crossVectors(rS, Ly));
    let o = this.direction.dot(sS),
      u;
    if (o > 0) {
      if (r) return null;
      u = 1;
    } else if (o < 0) ((u = -1), (o = -o));
    else return null;
    Wu.subVectors(this.origin, e);
    const h = u * this.direction.dot(Ly.crossVectors(Wu, Ly));
    if (h < 0) return null;
    const d = u * this.direction.dot(rS.cross(Wu));
    if (d < 0 || h + d > o) return null;
    const m = -u * Wu.dot(sS);
    return m < 0 ? null : this.at(m / o, s);
  }
  applyMatrix4(e) {
    return (
      this.origin.applyMatrix4(e),
      this.direction.transformDirection(e),
      this
    );
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Jc extends bs {
  constructor(e) {
    (super(),
      (this.isMeshBasicMaterial = !0),
      (this.type = "MeshBasicMaterial"),
      (this.color = new wt(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new Fa()),
      (this.combine = D0),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.fog = !0),
      this.setValues(e));
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const rC = new qt(),
  eh = new Oh(),
  Ny = new mr(),
  sC = new te(),
  Uy = new te(),
  Py = new te(),
  Iy = new te(),
  aS = new te(),
  Oy = new te(),
  aC = new te(),
  Fy = new te();
class wi extends In {
  constructor(e = new nn(), t = new Jc()) {
    (super(),
      (this.isMesh = !0),
      (this.type = "Mesh"),
      (this.geometry = e),
      (this.material = t),
      (this.morphTargetDictionary = void 0),
      (this.morphTargetInfluences = void 0),
      (this.count = 1),
      this.updateMorphTargets());
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.morphTargetInfluences !== void 0 &&
        (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
      e.morphTargetDictionary !== void 0 &&
        (this.morphTargetDictionary = Object.assign(
          {},
          e.morphTargetDictionary,
        )),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      n = Object.keys(t);
    if (n.length > 0) {
      const r = t[n[0]];
      if (r !== void 0) {
        ((this.morphTargetInfluences = []), (this.morphTargetDictionary = {}));
        for (let s = 0, o = r.length; s < o; s++) {
          const u = r[s].name || String(s);
          (this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[u] = s));
        }
      }
    }
  }
  getVertexPosition(e, t) {
    const n = this.geometry,
      r = n.attributes.position,
      s = n.morphAttributes.position,
      o = n.morphTargetsRelative;
    t.fromBufferAttribute(r, e);
    const u = this.morphTargetInfluences;
    if (s && u) {
      Oy.set(0, 0, 0);
      for (let h = 0, d = s.length; h < d; h++) {
        const m = u[h],
          v = s[h];
        m !== 0 &&
          (aS.fromBufferAttribute(v, e),
          o ? Oy.addScaledVector(aS, m) : Oy.addScaledVector(aS.sub(t), m));
      }
      t.add(Oy);
    }
    return t;
  }
  raycast(e, t) {
    const n = this.geometry,
      r = this.material,
      s = this.matrixWorld;
    r !== void 0 &&
      (n.boundingSphere === null && n.computeBoundingSphere(),
      Ny.copy(n.boundingSphere),
      Ny.applyMatrix4(s),
      eh.copy(e.ray).recast(e.near),
      !(
        Ny.containsPoint(eh.origin) === !1 &&
        (eh.intersectSphere(Ny, sC) === null ||
          eh.origin.distanceToSquared(sC) > (e.far - e.near) ** 2)
      ) &&
        (rC.copy(s).invert(),
        eh.copy(e.ray).applyMatrix4(rC),
        !(n.boundingBox !== null && eh.intersectsBox(n.boundingBox) === !1) &&
          this._computeIntersections(e, t, eh)));
  }
  _computeIntersections(e, t, n) {
    let r;
    const s = this.geometry,
      o = this.material,
      u = s.index,
      h = s.attributes.position,
      d = s.attributes.uv,
      m = s.attributes.uv1,
      v = s.attributes.normal,
      y = s.groups,
      b = s.drawRange;
    if (u !== null)
      if (Array.isArray(o))
        for (let _ = 0, w = y.length; _ < w; _++) {
          const E = y[_],
            T = o[E.materialIndex],
            C = Math.max(E.start, b.start),
            R = Math.min(
              u.count,
              Math.min(E.start + E.count, b.start + b.count),
            );
          for (let L = C, I = R; L < I; L += 3) {
            const O = u.getX(L),
              B = u.getX(L + 1),
              N = u.getX(L + 2);
            ((r = zy(this, T, e, n, d, m, v, O, B, N)),
              r &&
                ((r.faceIndex = Math.floor(L / 3)),
                (r.face.materialIndex = E.materialIndex),
                t.push(r)));
          }
        }
      else {
        const _ = Math.max(0, b.start),
          w = Math.min(u.count, b.start + b.count);
        for (let E = _, T = w; E < T; E += 3) {
          const C = u.getX(E),
            R = u.getX(E + 1),
            L = u.getX(E + 2);
          ((r = zy(this, o, e, n, d, m, v, C, R, L)),
            r && ((r.faceIndex = Math.floor(E / 3)), t.push(r)));
        }
      }
    else if (h !== void 0)
      if (Array.isArray(o))
        for (let _ = 0, w = y.length; _ < w; _++) {
          const E = y[_],
            T = o[E.materialIndex],
            C = Math.max(E.start, b.start),
            R = Math.min(
              h.count,
              Math.min(E.start + E.count, b.start + b.count),
            );
          for (let L = C, I = R; L < I; L += 3) {
            const O = L,
              B = L + 1,
              N = L + 2;
            ((r = zy(this, T, e, n, d, m, v, O, B, N)),
              r &&
                ((r.faceIndex = Math.floor(L / 3)),
                (r.face.materialIndex = E.materialIndex),
                t.push(r)));
          }
        }
      else {
        const _ = Math.max(0, b.start),
          w = Math.min(h.count, b.start + b.count);
        for (let E = _, T = w; E < T; E += 3) {
          const C = E,
            R = E + 1,
            L = E + 2;
          ((r = zy(this, o, e, n, d, m, v, C, R, L)),
            r && ((r.faceIndex = Math.floor(E / 3)), t.push(r)));
        }
      }
  }
}
function Mk(i, e, t, n, r, s, o, u) {
  let h;
  if (
    (e.side === js
      ? (h = n.intersectTriangle(o, s, r, !0, u))
      : (h = n.intersectTriangle(r, s, o, e.side === Zc, u)),
    h === null)
  )
    return null;
  (Fy.copy(u), Fy.applyMatrix4(i.matrixWorld));
  const d = t.ray.origin.distanceTo(Fy);
  return d < t.near || d > t.far
    ? null
    : { distance: d, point: Fy.clone(), object: i };
}
function zy(i, e, t, n, r, s, o, u, h, d) {
  (i.getVertexPosition(u, Uy),
    i.getVertexPosition(h, Py),
    i.getVertexPosition(d, Iy));
  const m = Mk(i, e, t, n, Uy, Py, Iy, aC);
  if (m) {
    const v = new te();
    (ya.getBarycoord(aC, Uy, Py, Iy, v),
      r && (m.uv = ya.getInterpolatedAttribute(r, u, h, d, v, new nt())),
      s && (m.uv1 = ya.getInterpolatedAttribute(s, u, h, d, v, new nt())),
      o &&
        ((m.normal = ya.getInterpolatedAttribute(o, u, h, d, v, new te())),
        m.normal.dot(n.direction) > 0 && m.normal.multiplyScalar(-1)));
    const y = { a: u, b: h, c: d, normal: new te(), materialIndex: 0 };
    (ya.getNormal(Uy, Py, Iy, y.normal), (m.face = y), (m.barycoord = v));
  }
  return m;
}
const oC = new te(),
  lC = new Dn(),
  cC = new Dn(),
  Tk = new te(),
  uC = new qt(),
  By = new te(),
  oS = new mr(),
  fC = new qt(),
  lS = new Oh();
class rN extends wi {
  constructor(e, t) {
    (super(e, t),
      (this.isSkinnedMesh = !0),
      (this.type = "SkinnedMesh"),
      (this.bindMode = SM),
      (this.bindMatrix = new qt()),
      (this.bindMatrixInverse = new qt()),
      (this.boundingBox = null),
      (this.boundingSphere = null));
  }
  computeBoundingBox() {
    const e = this.geometry;
    (this.boundingBox === null && (this.boundingBox = new sr()),
      this.boundingBox.makeEmpty());
    const t = e.getAttribute("position");
    for (let n = 0; n < t.count; n++)
      (this.getVertexPosition(n, By), this.boundingBox.expandByPoint(By));
  }
  computeBoundingSphere() {
    const e = this.geometry;
    (this.boundingSphere === null && (this.boundingSphere = new mr()),
      this.boundingSphere.makeEmpty());
    const t = e.getAttribute("position");
    for (let n = 0; n < t.count; n++)
      (this.getVertexPosition(n, By), this.boundingSphere.expandByPoint(By));
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.bindMode = e.bindMode),
      this.bindMatrix.copy(e.bindMatrix),
      this.bindMatrixInverse.copy(e.bindMatrixInverse),
      (this.skeleton = e.skeleton),
      e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
      e.boundingSphere !== null &&
        (this.boundingSphere = e.boundingSphere.clone()),
      this
    );
  }
  raycast(e, t) {
    const n = this.material,
      r = this.matrixWorld;
    n !== void 0 &&
      (this.boundingSphere === null && this.computeBoundingSphere(),
      oS.copy(this.boundingSphere),
      oS.applyMatrix4(r),
      e.ray.intersectsSphere(oS) !== !1 &&
        (fC.copy(r).invert(),
        lS.copy(e.ray).applyMatrix4(fC),
        !(
          this.boundingBox !== null && lS.intersectsBox(this.boundingBox) === !1
        ) && this._computeIntersections(e, t, lS)));
  }
  getVertexPosition(e, t) {
    return (super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t);
  }
  bind(e, t) {
    ((this.skeleton = e),
      t === void 0 &&
        (this.updateMatrixWorld(!0),
        this.skeleton.calculateInverses(),
        (t = this.matrixWorld)),
      this.bindMatrix.copy(t),
      this.bindMatrixInverse.copy(t).invert());
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const e = new Dn(),
      t = this.geometry.attributes.skinWeight;
    for (let n = 0, r = t.count; n < r; n++) {
      e.fromBufferAttribute(t, n);
      const s = 1 / e.manhattanLength();
      (s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0),
        t.setXYZW(n, e.x, e.y, e.z, e.w));
    }
  }
  updateMatrixWorld(e) {
    (super.updateMatrixWorld(e),
      this.bindMode === SM
        ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
        : this.bindMode === FL
          ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
          : Tt("SkinnedMesh: Unrecognized bindMode: " + this.bindMode));
  }
  applyBoneTransform(e, t) {
    const n = this.skeleton,
      r = this.geometry;
    (lC.fromBufferAttribute(r.attributes.skinIndex, e),
      cC.fromBufferAttribute(r.attributes.skinWeight, e),
      oC.copy(t).applyMatrix4(this.bindMatrix),
      t.set(0, 0, 0));
    for (let s = 0; s < 4; s++) {
      const o = cC.getComponent(s);
      if (o !== 0) {
        const u = lC.getComponent(s);
        (uC.multiplyMatrices(n.bones[u].matrixWorld, n.boneInverses[u]),
          t.addScaledVector(Tk.copy(oC).applyMatrix4(uC), o));
      }
    }
    return t.applyMatrix4(this.bindMatrixInverse);
  }
}
class KT extends In {
  constructor() {
    (super(), (this.isBone = !0), (this.type = "Bone"));
  }
}
class Ko extends Fi {
  constructor(e = null, t = 1, n = 1, r, s, o, u, h, d = rr, m = rr, v, y) {
    (super(null, o, u, h, d, m, r, s, v, y),
      (this.isDataTexture = !0),
      (this.image = { data: e, width: t, height: n }),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1));
  }
}
const hC = new qt(),
  Ek = new qt();
class fb {
  constructor(e = [], t = []) {
    ((this.uuid = Ia()),
      (this.bones = e.slice(0)),
      (this.boneInverses = t),
      (this.boneMatrices = null),
      (this.previousBoneMatrices = null),
      (this.boneTexture = null),
      this.init());
  }
  init() {
    const e = this.bones,
      t = this.boneInverses;
    if (((this.boneMatrices = new Float32Array(e.length * 16)), t.length === 0))
      this.calculateInverses();
    else if (e.length !== t.length) {
      (Tt(
        "Skeleton: Number of inverse bone matrices does not match amount of bones.",
      ),
        (this.boneInverses = []));
      for (let n = 0, r = this.bones.length; n < r; n++)
        this.boneInverses.push(new qt());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = new qt();
      (this.bones[e] && n.copy(this.bones[e].matrixWorld).invert(),
        this.boneInverses.push(n));
    }
  }
  pose() {
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = this.bones[e];
      n && n.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = this.bones[e];
      n &&
        (n.parent && n.parent.isBone
          ? (n.matrix.copy(n.parent.matrixWorld).invert(),
            n.matrix.multiply(n.matrixWorld))
          : n.matrix.copy(n.matrixWorld),
        n.matrix.decompose(n.position, n.quaternion, n.scale));
    }
  }
  update() {
    const e = this.bones,
      t = this.boneInverses,
      n = this.boneMatrices,
      r = this.boneTexture;
    for (let s = 0, o = e.length; s < o; s++) {
      const u = e[s] ? e[s].matrixWorld : Ek;
      (hC.multiplyMatrices(u, t[s]), hC.toArray(n, s * 16));
    }
    r !== null && (r.needsUpdate = !0);
  }
  clone() {
    return new fb(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let e = Math.sqrt(this.bones.length * 4);
    ((e = Math.ceil(e / 4) * 4), (e = Math.max(e, 4)));
    const t = new Float32Array(e * e * 4);
    t.set(this.boneMatrices);
    const n = new Ko(t, e, e, xs, Hs);
    return (
      (n.needsUpdate = !0),
      (this.boneMatrices = t),
      (this.boneTexture = n),
      this
    );
  }
  getBoneByName(e) {
    for (let t = 0, n = this.bones.length; t < n; t++) {
      const r = this.bones[t];
      if (r.name === e) return r;
    }
  }
  dispose() {
    this.boneTexture !== null &&
      (this.boneTexture.dispose(), (this.boneTexture = null));
  }
  fromJSON(e, t) {
    this.uuid = e.uuid;
    for (let n = 0, r = e.bones.length; n < r; n++) {
      const s = e.bones[n];
      let o = t[s];
      (o === void 0 &&
        (Tt("Skeleton: No bone found with UUID:", s), (o = new KT())),
        this.bones.push(o),
        this.boneInverses.push(new qt().fromArray(e.boneInverses[n])));
    }
    return (this.init(), this);
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.7,
        type: "Skeleton",
        generator: "Skeleton.toJSON",
      },
      bones: [],
      boneInverses: [],
    };
    e.uuid = this.uuid;
    const t = this.bones,
      n = this.boneInverses;
    for (let r = 0, s = t.length; r < s; r++) {
      const o = t[r];
      e.bones.push(o.uuid);
      const u = n[r];
      e.boneInverses.push(u.toArray());
    }
    return e;
  }
}
class Uh extends $n {
  constructor(e, t, n, r = 1) {
    (super(e, t, n),
      (this.isInstancedBufferAttribute = !0),
      (this.meshPerAttribute = r));
  }
  copy(e) {
    return (super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this);
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.meshPerAttribute = this.meshPerAttribute),
      (e.isInstancedBufferAttribute = !0),
      e
    );
  }
}
const ep = new qt(),
  dC = new qt(),
  ky = [],
  pC = new sr(),
  wk = new qt(),
  _g = new wi(),
  Sg = new mr();
class sN extends wi {
  constructor(e, t, n) {
    (super(e, t),
      (this.isInstancedMesh = !0),
      (this.instanceMatrix = new Uh(new Float32Array(n * 16), 16)),
      (this.previousInstanceMatrix = null),
      (this.instanceColor = null),
      (this.morphTexture = null),
      (this.count = n),
      (this.boundingBox = null),
      (this.boundingSphere = null));
    for (let r = 0; r < n; r++) this.setMatrixAt(r, wk);
  }
  computeBoundingBox() {
    const e = this.geometry,
      t = this.count;
    (this.boundingBox === null && (this.boundingBox = new sr()),
      e.boundingBox === null && e.computeBoundingBox(),
      this.boundingBox.makeEmpty());
    for (let n = 0; n < t; n++)
      (this.getMatrixAt(n, ep),
        pC.copy(e.boundingBox).applyMatrix4(ep),
        this.boundingBox.union(pC));
  }
  computeBoundingSphere() {
    const e = this.geometry,
      t = this.count;
    (this.boundingSphere === null && (this.boundingSphere = new mr()),
      e.boundingSphere === null && e.computeBoundingSphere(),
      this.boundingSphere.makeEmpty());
    for (let n = 0; n < t; n++)
      (this.getMatrixAt(n, ep),
        Sg.copy(e.boundingSphere).applyMatrix4(ep),
        this.boundingSphere.union(Sg));
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.instanceMatrix.copy(e.instanceMatrix),
      e.previousInstanceMatrix !== null &&
        (this.previousInstanceMatrix = e.previousInstanceMatrix.clone()),
      e.morphTexture !== null && (this.morphTexture = e.morphTexture.clone()),
      e.instanceColor !== null &&
        (this.instanceColor = e.instanceColor.clone()),
      (this.count = e.count),
      e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
      e.boundingSphere !== null &&
        (this.boundingSphere = e.boundingSphere.clone()),
      this
    );
  }
  getColorAt(e, t) {
    t.fromArray(this.instanceColor.array, e * 3);
  }
  getMatrixAt(e, t) {
    t.fromArray(this.instanceMatrix.array, e * 16);
  }
  getMorphAt(e, t) {
    const n = t.morphTargetInfluences,
      r = this.morphTexture.source.data.data,
      s = n.length + 1,
      o = e * s + 1;
    for (let u = 0; u < n.length; u++) n[u] = r[o + u];
  }
  raycast(e, t) {
    const n = this.matrixWorld,
      r = this.count;
    if (
      ((_g.geometry = this.geometry),
      (_g.material = this.material),
      _g.material !== void 0 &&
        (this.boundingSphere === null && this.computeBoundingSphere(),
        Sg.copy(this.boundingSphere),
        Sg.applyMatrix4(n),
        e.ray.intersectsSphere(Sg) !== !1))
    )
      for (let s = 0; s < r; s++) {
        (this.getMatrixAt(s, ep),
          dC.multiplyMatrices(n, ep),
          (_g.matrixWorld = dC),
          _g.raycast(e, ky));
        for (let o = 0, u = ky.length; o < u; o++) {
          const h = ky[o];
          ((h.instanceId = s), (h.object = this), t.push(h));
        }
        ky.length = 0;
      }
  }
  setColorAt(e, t) {
    (this.instanceColor === null &&
      (this.instanceColor = new Uh(
        new Float32Array(this.instanceMatrix.count * 3).fill(1),
        3,
      )),
      t.toArray(this.instanceColor.array, e * 3));
  }
  setMatrixAt(e, t) {
    t.toArray(this.instanceMatrix.array, e * 16);
  }
  setMorphAt(e, t) {
    const n = t.morphTargetInfluences,
      r = n.length + 1;
    this.morphTexture === null &&
      (this.morphTexture = new Ko(
        new Float32Array(r * this.count),
        r,
        this.count,
        eb,
        Hs,
      ));
    const s = this.morphTexture.source.data.data;
    let o = 0;
    for (let d = 0; d < n.length; d++) o += n[d];
    const u = this.geometry.morphTargetsRelative ? 1 : 1 - o,
      h = r * e;
    ((s[h] = u), s.set(n, h + 1));
  }
  updateMorphTargets() {}
  dispose() {
    (this.dispatchEvent({ type: "dispose" }),
      this.morphTexture !== null &&
        (this.morphTexture.dispose(), (this.morphTexture = null)));
  }
}
const cS = new te(),
  Ak = new te(),
  Ck = new tn();
class Vc {
  constructor(e = new te(1, 0, 0), t = 0) {
    ((this.isPlane = !0), (this.normal = e), (this.constant = t));
  }
  set(e, t) {
    return (this.normal.copy(e), (this.constant = t), this);
  }
  setComponents(e, t, n, r) {
    return (this.normal.set(e, t, n), (this.constant = r), this);
  }
  setFromNormalAndCoplanarPoint(e, t) {
    return (this.normal.copy(e), (this.constant = -t.dot(this.normal)), this);
  }
  setFromCoplanarPoints(e, t, n) {
    const r = cS.subVectors(n, t).cross(Ak.subVectors(e, t)).normalize();
    return (this.setFromNormalAndCoplanarPoint(r, e), this);
  }
  copy(e) {
    return (this.normal.copy(e.normal), (this.constant = e.constant), this);
  }
  normalize() {
    const e = 1 / this.normal.length();
    return (this.normal.multiplyScalar(e), (this.constant *= e), this);
  }
  negate() {
    return ((this.constant *= -1), this.normal.negate(), this);
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, t) {
    return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  intersectLine(e, t) {
    const n = e.delta(cS),
      r = this.normal.dot(n);
    if (r === 0)
      return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
    const s = -(e.start.dot(this.normal) + this.constant) / r;
    return s < 0 || s > 1 ? null : t.copy(e.start).addScaledVector(n, s);
  }
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start),
      n = this.distanceToPoint(e.end);
    return (t < 0 && n > 0) || (n < 0 && t > 0);
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, t) {
    const n = t || Ck.getNormalMatrix(e),
      r = this.coplanarPoint(cS).applyMatrix4(e),
      s = this.normal.applyMatrix3(n).normalize();
    return ((this.constant = -r.dot(s)), this);
  }
  translate(e) {
    return ((this.constant -= e.dot(this.normal)), this);
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const th = new mr(),
  Rk = new nt(0.5, 0.5),
  Vy = new te();
class kp {
  constructor(
    e = new Vc(),
    t = new Vc(),
    n = new Vc(),
    r = new Vc(),
    s = new Vc(),
    o = new Vc(),
  ) {
    this.planes = [e, t, n, r, s, o];
  }
  set(e, t, n, r, s, o) {
    const u = this.planes;
    return (
      u[0].copy(e),
      u[1].copy(t),
      u[2].copy(n),
      u[3].copy(r),
      u[4].copy(s),
      u[5].copy(o),
      this
    );
  }
  copy(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++) t[n].copy(e.planes[n]);
    return this;
  }
  setFromProjectionMatrix(e, t = Ua, n = !1) {
    const r = this.planes,
      s = e.elements,
      o = s[0],
      u = s[1],
      h = s[2],
      d = s[3],
      m = s[4],
      v = s[5],
      y = s[6],
      b = s[7],
      _ = s[8],
      w = s[9],
      E = s[10],
      T = s[11],
      C = s[12],
      R = s[13],
      L = s[14],
      I = s[15];
    if (
      (r[0].setComponents(d - o, b - m, T - _, I - C).normalize(),
      r[1].setComponents(d + o, b + m, T + _, I + C).normalize(),
      r[2].setComponents(d + u, b + v, T + w, I + R).normalize(),
      r[3].setComponents(d - u, b - v, T - w, I - R).normalize(),
      n)
    )
      (r[4].setComponents(h, y, E, L).normalize(),
        r[5].setComponents(d - h, b - y, T - E, I - L).normalize());
    else if (
      (r[4].setComponents(d - h, b - y, T - E, I - L).normalize(), t === Ua)
    )
      r[5].setComponents(d + h, b + y, T + E, I + L).normalize();
    else if (t === Nh) r[5].setComponents(h, y, E, L).normalize();
    else
      throw new Error(
        "THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " +
          t,
      );
    return this;
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      (e.boundingSphere === null && e.computeBoundingSphere(),
        th.copy(e.boundingSphere).applyMatrix4(e.matrixWorld));
    else {
      const t = e.geometry;
      (t.boundingSphere === null && t.computeBoundingSphere(),
        th.copy(t.boundingSphere).applyMatrix4(e.matrixWorld));
    }
    return this.intersectsSphere(th);
  }
  intersectsSprite(e) {
    th.center.set(0, 0, 0);
    const t = Rk.distanceTo(e.center);
    return (
      (th.radius = 0.7071067811865476 + t),
      th.applyMatrix4(e.matrixWorld),
      this.intersectsSphere(th)
    );
  }
  intersectsSphere(e) {
    const t = this.planes,
      n = e.center,
      r = -e.radius;
    for (let s = 0; s < 6; s++) if (t[s].distanceToPoint(n) < r) return !1;
    return !0;
  }
  intersectsBox(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++) {
      const r = t[n];
      if (
        ((Vy.x = r.normal.x > 0 ? e.max.x : e.min.x),
        (Vy.y = r.normal.y > 0 ? e.max.y : e.min.y),
        (Vy.z = r.normal.z > 0 ? e.max.z : e.min.z),
        r.distanceToPoint(Vy) < 0)
      )
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++) if (t[n].distanceToPoint(e) < 0) return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Pl = new qt(),
  Il = new kp();
class hb {
  constructor() {
    this.coordinateSystem = Ua;
  }
  intersectsObject(e, t) {
    if (!t.isArrayCamera || t.cameras.length === 0) return !1;
    for (let n = 0; n < t.cameras.length; n++) {
      const r = t.cameras[n];
      if (
        (Pl.multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse),
        Il.setFromProjectionMatrix(Pl, r.coordinateSystem, r.reversedDepth),
        Il.intersectsObject(e))
      )
        return !0;
    }
    return !1;
  }
  intersectsSprite(e, t) {
    if (!t || !t.cameras || t.cameras.length === 0) return !1;
    for (let n = 0; n < t.cameras.length; n++) {
      const r = t.cameras[n];
      if (
        (Pl.multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse),
        Il.setFromProjectionMatrix(Pl, r.coordinateSystem, r.reversedDepth),
        Il.intersectsSprite(e))
      )
        return !0;
    }
    return !1;
  }
  intersectsSphere(e, t) {
    if (!t || !t.cameras || t.cameras.length === 0) return !1;
    for (let n = 0; n < t.cameras.length; n++) {
      const r = t.cameras[n];
      if (
        (Pl.multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse),
        Il.setFromProjectionMatrix(Pl, r.coordinateSystem, r.reversedDepth),
        Il.intersectsSphere(e))
      )
        return !0;
    }
    return !1;
  }
  intersectsBox(e, t) {
    if (!t || !t.cameras || t.cameras.length === 0) return !1;
    for (let n = 0; n < t.cameras.length; n++) {
      const r = t.cameras[n];
      if (
        (Pl.multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse),
        Il.setFromProjectionMatrix(Pl, r.coordinateSystem, r.reversedDepth),
        Il.intersectsBox(e))
      )
        return !0;
    }
    return !1;
  }
  containsPoint(e, t) {
    if (!t || !t.cameras || t.cameras.length === 0) return !1;
    for (let n = 0; n < t.cameras.length; n++) {
      const r = t.cameras[n];
      if (
        (Pl.multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse),
        Il.setFromProjectionMatrix(Pl, r.coordinateSystem, r.reversedDepth),
        Il.containsPoint(e))
      )
        return !0;
    }
    return !1;
  }
  clone() {
    return new hb();
  }
}
function uS(i, e) {
  return i - e;
}
function Dk(i, e) {
  return i.z - e.z;
}
function Lk(i, e) {
  return e.z - i.z;
}
class Nk {
  constructor() {
    ((this.index = 0), (this.pool = []), (this.list = []));
  }
  push(e, t, n, r) {
    const s = this.pool,
      o = this.list;
    this.index >= s.length &&
      s.push({ start: -1, count: -1, z: -1, index: -1 });
    const u = s[this.index];
    (o.push(u),
      this.index++,
      (u.start = e),
      (u.count = t),
      (u.z = n),
      (u.index = r));
  }
  reset() {
    ((this.list.length = 0), (this.index = 0));
  }
}
const ma = new qt(),
  Uk = new wt(1, 1, 1),
  mC = new kp(),
  Pk = new hb(),
  Gy = new sr(),
  nh = new mr(),
  Mg = new te(),
  gC = new te(),
  Ik = new te(),
  fS = new Nk(),
  gs = new wi(),
  Hy = [];
function Ok(i, e, t = 0) {
  const n = e.itemSize;
  if (
    i.isInterleavedBufferAttribute ||
    i.array.constructor !== e.array.constructor
  ) {
    const r = i.count;
    for (let s = 0; s < r; s++)
      for (let o = 0; o < n; o++)
        e.setComponent(s + t, o, i.getComponent(s, o));
  } else e.array.set(i.array, t * n);
  e.needsUpdate = !0;
}
function ih(i, e) {
  if (i.constructor !== e.constructor) {
    const t = Math.min(i.length, e.length);
    for (let n = 0; n < t; n++) e[n] = i[n];
  } else {
    const t = Math.min(i.length, e.length);
    e.set(new i.constructor(i.buffer, 0, t));
  }
}
class aN extends wi {
  constructor(e, t, n = t * 2, r) {
    (super(new nn(), r),
      (this.isBatchedMesh = !0),
      (this.perObjectFrustumCulled = !0),
      (this.sortObjects = !0),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.customSort = null),
      (this._instanceInfo = []),
      (this._geometryInfo = []),
      (this._availableInstanceIds = []),
      (this._availableGeometryIds = []),
      (this._nextIndexStart = 0),
      (this._nextVertexStart = 0),
      (this._geometryCount = 0),
      (this._visibilityChanged = !0),
      (this._geometryInitialized = !1),
      (this._maxInstanceCount = e),
      (this._maxVertexCount = t),
      (this._maxIndexCount = n),
      (this._multiDrawCounts = new Int32Array(e)),
      (this._multiDrawStarts = new Int32Array(e)),
      (this._multiDrawCount = 0),
      (this._multiDrawInstances = null),
      (this._matricesTexture = null),
      (this._indirectTexture = null),
      (this._colorsTexture = null),
      this._initMatricesTexture(),
      this._initIndirectTexture());
  }
  get maxInstanceCount() {
    return this._maxInstanceCount;
  }
  get instanceCount() {
    return this._instanceInfo.length - this._availableInstanceIds.length;
  }
  get unusedVertexCount() {
    return this._maxVertexCount - this._nextVertexStart;
  }
  get unusedIndexCount() {
    return this._maxIndexCount - this._nextIndexStart;
  }
  _initMatricesTexture() {
    let e = Math.sqrt(this._maxInstanceCount * 4);
    ((e = Math.ceil(e / 4) * 4), (e = Math.max(e, 4)));
    const t = new Float32Array(e * e * 4),
      n = new Ko(t, e, e, xs, Hs);
    this._matricesTexture = n;
  }
  _initIndirectTexture() {
    let e = Math.sqrt(this._maxInstanceCount);
    e = Math.ceil(e);
    const t = new Uint32Array(e * e),
      n = new Ko(t, e, e, L0, bo);
    this._indirectTexture = n;
  }
  _initColorsTexture() {
    let e = Math.sqrt(this._maxInstanceCount);
    e = Math.ceil(e);
    const t = new Float32Array(e * e * 4).fill(1),
      n = new Ko(t, e, e, xs, Hs);
    ((n.colorSpace = Cn.workingColorSpace), (this._colorsTexture = n));
  }
  _initializeGeometry(e) {
    const t = this.geometry,
      n = this._maxVertexCount,
      r = this._maxIndexCount;
    if (this._geometryInitialized === !1) {
      for (const s in e.attributes) {
        const o = e.getAttribute(s),
          { array: u, itemSize: h, normalized: d } = o,
          m = new u.constructor(n * h),
          v = new $n(m, h, d);
        t.setAttribute(s, v);
      }
      if (e.getIndex() !== null) {
        const s = n > 65535 ? new Uint32Array(r) : new Uint16Array(r);
        t.setIndex(new $n(s, 1));
      }
      this._geometryInitialized = !0;
    }
  }
  _validateGeometry(e) {
    const t = this.geometry;
    if (!!e.getIndex() != !!t.getIndex())
      throw new Error(
        'THREE.BatchedMesh: All geometries must consistently have "index".',
      );
    for (const n in t.attributes) {
      if (!e.hasAttribute(n))
        throw new Error(
          `THREE.BatchedMesh: Added geometry missing "${n}". All geometries must have consistent attributes.`,
        );
      const r = e.getAttribute(n),
        s = t.getAttribute(n);
      if (r.itemSize !== s.itemSize || r.normalized !== s.normalized)
        throw new Error(
          "THREE.BatchedMesh: All attributes must have a consistent itemSize and normalized value.",
        );
    }
  }
  validateInstanceId(e) {
    const t = this._instanceInfo;
    if (e < 0 || e >= t.length || t[e].active === !1)
      throw new Error(
        `THREE.BatchedMesh: Invalid instanceId ${e}. Instance is either out of range or has been deleted.`,
      );
  }
  validateGeometryId(e) {
    const t = this._geometryInfo;
    if (e < 0 || e >= t.length || t[e].active === !1)
      throw new Error(
        `THREE.BatchedMesh: Invalid geometryId ${e}. Geometry is either out of range or has been deleted.`,
      );
  }
  setCustomSort(e) {
    return ((this.customSort = e), this);
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new sr());
    const e = this.boundingBox,
      t = this._instanceInfo;
    e.makeEmpty();
    for (let n = 0, r = t.length; n < r; n++) {
      if (t[n].active === !1) continue;
      const s = t[n].geometryIndex;
      (this.getMatrixAt(n, ma),
        this.getBoundingBoxAt(s, Gy).applyMatrix4(ma),
        e.union(Gy));
    }
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new mr());
    const e = this.boundingSphere,
      t = this._instanceInfo;
    e.makeEmpty();
    for (let n = 0, r = t.length; n < r; n++) {
      if (t[n].active === !1) continue;
      const s = t[n].geometryIndex;
      (this.getMatrixAt(n, ma),
        this.getBoundingSphereAt(s, nh).applyMatrix4(ma),
        e.union(nh));
    }
  }
  addInstance(e) {
    if (
      this._instanceInfo.length >= this.maxInstanceCount &&
      this._availableInstanceIds.length === 0
    )
      throw new Error("THREE.BatchedMesh: Maximum item count reached.");
    const n = { visible: !0, active: !0, geometryIndex: e };
    let r = null;
    this._availableInstanceIds.length > 0
      ? (this._availableInstanceIds.sort(uS),
        (r = this._availableInstanceIds.shift()),
        (this._instanceInfo[r] = n))
      : ((r = this._instanceInfo.length), this._instanceInfo.push(n));
    const s = this._matricesTexture;
    (ma.identity().toArray(s.image.data, r * 16), (s.needsUpdate = !0));
    const o = this._colorsTexture;
    return (
      o && (Uk.toArray(o.image.data, r * 4), (o.needsUpdate = !0)),
      (this._visibilityChanged = !0),
      r
    );
  }
  addGeometry(e, t = -1, n = -1) {
    (this._initializeGeometry(e), this._validateGeometry(e));
    const r = {
        vertexStart: -1,
        vertexCount: -1,
        reservedVertexCount: -1,
        indexStart: -1,
        indexCount: -1,
        reservedIndexCount: -1,
        start: -1,
        count: -1,
        boundingBox: null,
        boundingSphere: null,
        active: !0,
      },
      s = this._geometryInfo;
    ((r.vertexStart = this._nextVertexStart),
      (r.reservedVertexCount =
        t === -1 ? e.getAttribute("position").count : t));
    const o = e.getIndex();
    if (
      (o !== null &&
        ((r.indexStart = this._nextIndexStart),
        (r.reservedIndexCount = n === -1 ? o.count : n)),
      (r.indexStart !== -1 &&
        r.indexStart + r.reservedIndexCount > this._maxIndexCount) ||
        r.vertexStart + r.reservedVertexCount > this._maxVertexCount)
    )
      throw new Error(
        "THREE.BatchedMesh: Reserved space request exceeds the maximum buffer size.",
      );
    let h;
    return (
      this._availableGeometryIds.length > 0
        ? (this._availableGeometryIds.sort(uS),
          (h = this._availableGeometryIds.shift()),
          (s[h] = r))
        : ((h = this._geometryCount), this._geometryCount++, s.push(r)),
      this.setGeometryAt(h, e),
      (this._nextIndexStart = r.indexStart + r.reservedIndexCount),
      (this._nextVertexStart = r.vertexStart + r.reservedVertexCount),
      h
    );
  }
  setGeometryAt(e, t) {
    if (e >= this._geometryCount)
      throw new Error("THREE.BatchedMesh: Maximum geometry count reached.");
    this._validateGeometry(t);
    const n = this.geometry,
      r = n.getIndex() !== null,
      s = n.getIndex(),
      o = t.getIndex(),
      u = this._geometryInfo[e];
    if (
      (r && o.count > u.reservedIndexCount) ||
      t.attributes.position.count > u.reservedVertexCount
    )
      throw new Error(
        "THREE.BatchedMesh: Reserved space not large enough for provided geometry.",
      );
    const h = u.vertexStart,
      d = u.reservedVertexCount;
    u.vertexCount = t.getAttribute("position").count;
    for (const m in n.attributes) {
      const v = t.getAttribute(m),
        y = n.getAttribute(m);
      Ok(v, y, h);
      const b = v.itemSize;
      for (let _ = v.count, w = d; _ < w; _++) {
        const E = h + _;
        for (let T = 0; T < b; T++) y.setComponent(E, T, 0);
      }
      ((y.needsUpdate = !0), y.addUpdateRange(h * b, d * b));
    }
    if (r) {
      const m = u.indexStart,
        v = u.reservedIndexCount;
      u.indexCount = t.getIndex().count;
      for (let y = 0; y < o.count; y++) s.setX(m + y, h + o.getX(y));
      for (let y = o.count, b = v; y < b; y++) s.setX(m + y, h);
      ((s.needsUpdate = !0), s.addUpdateRange(m, u.reservedIndexCount));
    }
    return (
      (u.start = r ? u.indexStart : u.vertexStart),
      (u.count = r ? u.indexCount : u.vertexCount),
      (u.boundingBox = null),
      t.boundingBox !== null && (u.boundingBox = t.boundingBox.clone()),
      (u.boundingSphere = null),
      t.boundingSphere !== null &&
        (u.boundingSphere = t.boundingSphere.clone()),
      (this._visibilityChanged = !0),
      e
    );
  }
  deleteGeometry(e) {
    const t = this._geometryInfo;
    if (e >= t.length || t[e].active === !1) return this;
    const n = this._instanceInfo;
    for (let r = 0, s = n.length; r < s; r++)
      n[r].active && n[r].geometryIndex === e && this.deleteInstance(r);
    return (
      (t[e].active = !1),
      this._availableGeometryIds.push(e),
      (this._visibilityChanged = !0),
      this
    );
  }
  deleteInstance(e) {
    return (
      this.validateInstanceId(e),
      (this._instanceInfo[e].active = !1),
      this._availableInstanceIds.push(e),
      (this._visibilityChanged = !0),
      this
    );
  }
  optimize() {
    let e = 0,
      t = 0;
    const n = this._geometryInfo,
      r = n
        .map((o, u) => u)
        .sort((o, u) => n[o].vertexStart - n[u].vertexStart),
      s = this.geometry;
    for (let o = 0, u = n.length; o < u; o++) {
      const h = r[o],
        d = n[h];
      if (d.active !== !1) {
        if (s.index !== null) {
          if (d.indexStart !== t) {
            const { indexStart: m, vertexStart: v, reservedIndexCount: y } = d,
              b = s.index,
              _ = b.array,
              w = e - v;
            for (let E = m; E < m + y; E++) _[E] = _[E] + w;
            (b.array.copyWithin(t, m, m + y),
              b.addUpdateRange(t, y),
              (b.needsUpdate = !0),
              (d.indexStart = t));
          }
          t += d.reservedIndexCount;
        }
        if (d.vertexStart !== e) {
          const { vertexStart: m, reservedVertexCount: v } = d,
            y = s.attributes;
          for (const b in y) {
            const _ = y[b],
              { array: w, itemSize: E } = _;
            (w.copyWithin(e * E, m * E, (m + v) * E),
              _.addUpdateRange(e * E, v * E),
              (_.needsUpdate = !0));
          }
          d.vertexStart = e;
        }
        ((e += d.reservedVertexCount),
          (d.start = s.index ? d.indexStart : d.vertexStart));
      }
    }
    return (
      (this._nextIndexStart = t),
      (this._nextVertexStart = e),
      (this._visibilityChanged = !0),
      this
    );
  }
  getBoundingBoxAt(e, t) {
    if (e >= this._geometryCount) return null;
    const n = this.geometry,
      r = this._geometryInfo[e];
    if (r.boundingBox === null) {
      const s = new sr(),
        o = n.index,
        u = n.attributes.position;
      for (let h = r.start, d = r.start + r.count; h < d; h++) {
        let m = h;
        (o && (m = o.getX(m)), s.expandByPoint(Mg.fromBufferAttribute(u, m)));
      }
      r.boundingBox = s;
    }
    return (t.copy(r.boundingBox), t);
  }
  getBoundingSphereAt(e, t) {
    if (e >= this._geometryCount) return null;
    const n = this.geometry,
      r = this._geometryInfo[e];
    if (r.boundingSphere === null) {
      const s = new mr();
      (this.getBoundingBoxAt(e, Gy), Gy.getCenter(s.center));
      const o = n.index,
        u = n.attributes.position;
      let h = 0;
      for (let d = r.start, m = r.start + r.count; d < m; d++) {
        let v = d;
        (o && (v = o.getX(v)),
          Mg.fromBufferAttribute(u, v),
          (h = Math.max(h, s.center.distanceToSquared(Mg))));
      }
      ((s.radius = Math.sqrt(h)), (r.boundingSphere = s));
    }
    return (t.copy(r.boundingSphere), t);
  }
  setMatrixAt(e, t) {
    this.validateInstanceId(e);
    const n = this._matricesTexture,
      r = this._matricesTexture.image.data;
    return (t.toArray(r, e * 16), (n.needsUpdate = !0), this);
  }
  getMatrixAt(e, t) {
    return (
      this.validateInstanceId(e),
      t.fromArray(this._matricesTexture.image.data, e * 16)
    );
  }
  setColorAt(e, t) {
    return (
      this.validateInstanceId(e),
      this._colorsTexture === null && this._initColorsTexture(),
      t.toArray(this._colorsTexture.image.data, e * 4),
      (this._colorsTexture.needsUpdate = !0),
      this
    );
  }
  getColorAt(e, t) {
    return (
      this.validateInstanceId(e),
      t.fromArray(this._colorsTexture.image.data, e * 4)
    );
  }
  setVisibleAt(e, t) {
    return (
      this.validateInstanceId(e),
      this._instanceInfo[e].visible === t
        ? this
        : ((this._instanceInfo[e].visible = t),
          (this._visibilityChanged = !0),
          this)
    );
  }
  getVisibleAt(e) {
    return (this.validateInstanceId(e), this._instanceInfo[e].visible);
  }
  setGeometryIdAt(e, t) {
    return (
      this.validateInstanceId(e),
      this.validateGeometryId(t),
      (this._instanceInfo[e].geometryIndex = t),
      this
    );
  }
  getGeometryIdAt(e) {
    return (this.validateInstanceId(e), this._instanceInfo[e].geometryIndex);
  }
  getGeometryRangeAt(e, t = {}) {
    this.validateGeometryId(e);
    const n = this._geometryInfo[e];
    return (
      (t.vertexStart = n.vertexStart),
      (t.vertexCount = n.vertexCount),
      (t.reservedVertexCount = n.reservedVertexCount),
      (t.indexStart = n.indexStart),
      (t.indexCount = n.indexCount),
      (t.reservedIndexCount = n.reservedIndexCount),
      (t.start = n.start),
      (t.count = n.count),
      t
    );
  }
  setInstanceCount(e) {
    const t = this._availableInstanceIds,
      n = this._instanceInfo;
    for (t.sort(uS); t[t.length - 1] === n.length - 1; ) (n.pop(), t.pop());
    if (e < n.length)
      throw new Error(
        `BatchedMesh: Instance ids outside the range ${e} are being used. Cannot shrink instance count.`,
      );
    const r = new Int32Array(e),
      s = new Int32Array(e);
    (ih(this._multiDrawCounts, r),
      ih(this._multiDrawStarts, s),
      (this._multiDrawCounts = r),
      (this._multiDrawStarts = s),
      (this._maxInstanceCount = e));
    const o = this._indirectTexture,
      u = this._matricesTexture,
      h = this._colorsTexture;
    (o.dispose(),
      this._initIndirectTexture(),
      ih(o.image.data, this._indirectTexture.image.data),
      u.dispose(),
      this._initMatricesTexture(),
      ih(u.image.data, this._matricesTexture.image.data),
      h &&
        (h.dispose(),
        this._initColorsTexture(),
        ih(h.image.data, this._colorsTexture.image.data)));
  }
  setGeometrySize(e, t) {
    const n = [...this._geometryInfo].filter((u) => u.active);
    if (Math.max(...n.map((u) => u.vertexStart + u.reservedVertexCount)) > e)
      throw new Error(
        `BatchedMesh: Geometry vertex values are being used outside the range ${t}. Cannot shrink further.`,
      );
    if (
      this.geometry.index &&
      Math.max(...n.map((h) => h.indexStart + h.reservedIndexCount)) > t
    )
      throw new Error(
        `BatchedMesh: Geometry index values are being used outside the range ${t}. Cannot shrink further.`,
      );
    const s = this.geometry;
    (s.dispose(),
      (this._maxVertexCount = e),
      (this._maxIndexCount = t),
      this._geometryInitialized &&
        ((this._geometryInitialized = !1),
        (this.geometry = new nn()),
        this._initializeGeometry(s)));
    const o = this.geometry;
    s.index && ih(s.index.array, o.index.array);
    for (const u in s.attributes)
      ih(s.attributes[u].array, o.attributes[u].array);
  }
  raycast(e, t) {
    const n = this._instanceInfo,
      r = this._geometryInfo,
      s = this.matrixWorld,
      o = this.geometry;
    ((gs.material = this.material),
      (gs.geometry.index = o.index),
      (gs.geometry.attributes = o.attributes),
      gs.geometry.boundingBox === null && (gs.geometry.boundingBox = new sr()),
      gs.geometry.boundingSphere === null &&
        (gs.geometry.boundingSphere = new mr()));
    for (let u = 0, h = n.length; u < h; u++) {
      if (!n[u].visible || !n[u].active) continue;
      const d = n[u].geometryIndex,
        m = r[d];
      (gs.geometry.setDrawRange(m.start, m.count),
        this.getMatrixAt(u, gs.matrixWorld).premultiply(s),
        this.getBoundingBoxAt(d, gs.geometry.boundingBox),
        this.getBoundingSphereAt(d, gs.geometry.boundingSphere),
        gs.raycast(e, Hy));
      for (let v = 0, y = Hy.length; v < y; v++) {
        const b = Hy[v];
        ((b.object = this), (b.batchId = u), t.push(b));
      }
      Hy.length = 0;
    }
    ((gs.material = null),
      (gs.geometry.index = null),
      (gs.geometry.attributes = {}),
      gs.geometry.setDrawRange(0, 1 / 0));
  }
  copy(e) {
    return (
      super.copy(e),
      (this.geometry = e.geometry.clone()),
      (this.perObjectFrustumCulled = e.perObjectFrustumCulled),
      (this.sortObjects = e.sortObjects),
      (this.boundingBox =
        e.boundingBox !== null ? e.boundingBox.clone() : null),
      (this.boundingSphere =
        e.boundingSphere !== null ? e.boundingSphere.clone() : null),
      (this._geometryInfo = e._geometryInfo.map((t) => ({
        ...t,
        boundingBox: t.boundingBox !== null ? t.boundingBox.clone() : null,
        boundingSphere:
          t.boundingSphere !== null ? t.boundingSphere.clone() : null,
      }))),
      (this._instanceInfo = e._instanceInfo.map((t) => ({ ...t }))),
      (this._availableInstanceIds = e._availableInstanceIds.slice()),
      (this._availableGeometryIds = e._availableGeometryIds.slice()),
      (this._nextIndexStart = e._nextIndexStart),
      (this._nextVertexStart = e._nextVertexStart),
      (this._geometryCount = e._geometryCount),
      (this._maxInstanceCount = e._maxInstanceCount),
      (this._maxVertexCount = e._maxVertexCount),
      (this._maxIndexCount = e._maxIndexCount),
      (this._geometryInitialized = e._geometryInitialized),
      (this._multiDrawCounts = e._multiDrawCounts.slice()),
      (this._multiDrawStarts = e._multiDrawStarts.slice()),
      (this._indirectTexture = e._indirectTexture.clone()),
      (this._indirectTexture.image.data =
        this._indirectTexture.image.data.slice()),
      (this._matricesTexture = e._matricesTexture.clone()),
      (this._matricesTexture.image.data =
        this._matricesTexture.image.data.slice()),
      this._colorsTexture !== null &&
        ((this._colorsTexture = e._colorsTexture.clone()),
        (this._colorsTexture.image.data =
          this._colorsTexture.image.data.slice())),
      this
    );
  }
  dispose() {
    (this.geometry.dispose(),
      this._matricesTexture.dispose(),
      (this._matricesTexture = null),
      this._indirectTexture.dispose(),
      (this._indirectTexture = null),
      this._colorsTexture !== null &&
        (this._colorsTexture.dispose(), (this._colorsTexture = null)));
  }
  onBeforeRender(e, t, n, r, s) {
    if (
      !this._visibilityChanged &&
      !this.perObjectFrustumCulled &&
      !this.sortObjects
    )
      return;
    const o = r.getIndex();
    let u = o === null ? 1 : o.array.BYTES_PER_ELEMENT,
      h = 1;
    s.wireframe && ((h = 2), (u = r.attributes.position.count > 65535 ? 4 : 2));
    const d = this._instanceInfo,
      m = this._multiDrawStarts,
      v = this._multiDrawCounts,
      y = this._geometryInfo,
      b = this.perObjectFrustumCulled,
      _ = this._indirectTexture,
      w = _.image.data,
      E = n.isArrayCamera ? Pk : mC;
    b &&
      !n.isArrayCamera &&
      (ma
        .multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse)
        .multiply(this.matrixWorld),
      mC.setFromProjectionMatrix(ma, n.coordinateSystem, n.reversedDepth));
    let T = 0;
    if (this.sortObjects) {
      (ma.copy(this.matrixWorld).invert(),
        Mg.setFromMatrixPosition(n.matrixWorld).applyMatrix4(ma),
        gC
          .set(0, 0, -1)
          .transformDirection(n.matrixWorld)
          .transformDirection(ma));
      for (let L = 0, I = d.length; L < I; L++)
        if (d[L].visible && d[L].active) {
          const O = d[L].geometryIndex;
          (this.getMatrixAt(L, ma),
            this.getBoundingSphereAt(O, nh).applyMatrix4(ma));
          let B = !1;
          if ((b && (B = !E.intersectsSphere(nh, n)), !B)) {
            const N = y[O],
              F = Ik.subVectors(nh.center, Mg).dot(gC);
            fS.push(N.start, N.count, F, L);
          }
        }
      const C = fS.list,
        R = this.customSort;
      R === null ? C.sort(s.transparent ? Lk : Dk) : R.call(this, C, n);
      for (let L = 0, I = C.length; L < I; L++) {
        const O = C[L];
        ((m[T] = O.start * u * h), (v[T] = O.count * h), (w[T] = O.index), T++);
      }
      fS.reset();
    } else
      for (let C = 0, R = d.length; C < R; C++)
        if (d[C].visible && d[C].active) {
          const L = d[C].geometryIndex;
          let I = !1;
          if (
            (b &&
              (this.getMatrixAt(C, ma),
              this.getBoundingSphereAt(L, nh).applyMatrix4(ma),
              (I = !E.intersectsSphere(nh, n))),
            !I)
          ) {
            const O = y[L];
            ((m[T] = O.start * u * h), (v[T] = O.count * h), (w[T] = C), T++);
          }
        }
    ((_.needsUpdate = !0),
      (this._multiDrawCount = T),
      (this._visibilityChanged = !1));
  }
  onBeforeShadow(e, t, n, r, s, o) {
    this.onBeforeRender(e, null, r, s, o);
  }
}
class Ws extends bs {
  constructor(e) {
    (super(),
      (this.isLineBasicMaterial = !0),
      (this.type = "LineBasicMaterial"),
      (this.color = new wt(16777215)),
      (this.map = null),
      (this.linewidth = 1),
      (this.linecap = "round"),
      (this.linejoin = "round"),
      (this.fog = !0),
      this.setValues(e));
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.linewidth = e.linewidth),
      (this.linecap = e.linecap),
      (this.linejoin = e.linejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const N1 = new te(),
  U1 = new te(),
  vC = new qt(),
  Tg = new Oh(),
  jy = new mr(),
  hS = new te(),
  yC = new te();
let lf = class extends In {
  constructor(e = new nn(), t = new Ws()) {
    (super(),
      (this.isLine = !0),
      (this.type = "Line"),
      (this.geometry = e),
      (this.material = t),
      (this.morphTargetDictionary = void 0),
      (this.morphTargetInfluences = void 0),
      this.updateMorphTargets());
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position,
        n = [0];
      for (let r = 1, s = t.count; r < s; r++)
        (N1.fromBufferAttribute(t, r - 1),
          U1.fromBufferAttribute(t, r),
          (n[r] = n[r - 1]),
          (n[r] += N1.distanceTo(U1)));
      e.setAttribute("lineDistance", new Rt(n, 1));
    } else
      Tt(
        "Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.",
      );
    return this;
  }
  raycast(e, t) {
    const n = this.geometry,
      r = this.matrixWorld,
      s = e.params.Line.threshold,
      o = n.drawRange;
    if (
      (n.boundingSphere === null && n.computeBoundingSphere(),
      jy.copy(n.boundingSphere),
      jy.applyMatrix4(r),
      (jy.radius += s),
      e.ray.intersectsSphere(jy) === !1)
    )
      return;
    (vC.copy(r).invert(), Tg.copy(e.ray).applyMatrix4(vC));
    const u = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      h = u * u,
      d = this.isLineSegments ? 2 : 1,
      m = n.index,
      y = n.attributes.position;
    if (m !== null) {
      const b = Math.max(0, o.start),
        _ = Math.min(m.count, o.start + o.count);
      for (let w = b, E = _ - 1; w < E; w += d) {
        const T = m.getX(w),
          C = m.getX(w + 1),
          R = Wy(this, e, Tg, h, T, C, w);
        R && t.push(R);
      }
      if (this.isLineLoop) {
        const w = m.getX(_ - 1),
          E = m.getX(b),
          T = Wy(this, e, Tg, h, w, E, _ - 1);
        T && t.push(T);
      }
    } else {
      const b = Math.max(0, o.start),
        _ = Math.min(y.count, o.start + o.count);
      for (let w = b, E = _ - 1; w < E; w += d) {
        const T = Wy(this, e, Tg, h, w, w + 1, w);
        T && t.push(T);
      }
      if (this.isLineLoop) {
        const w = Wy(this, e, Tg, h, _ - 1, b, _ - 1);
        w && t.push(w);
      }
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      n = Object.keys(t);
    if (n.length > 0) {
      const r = t[n[0]];
      if (r !== void 0) {
        ((this.morphTargetInfluences = []), (this.morphTargetDictionary = {}));
        for (let s = 0, o = r.length; s < o; s++) {
          const u = r[s].name || String(s);
          (this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[u] = s));
        }
      }
    }
  }
};
function Wy(i, e, t, n, r, s, o) {
  const u = i.geometry.attributes.position;
  if (
    (N1.fromBufferAttribute(u, r),
    U1.fromBufferAttribute(u, s),
    t.distanceSqToSegment(N1, U1, hS, yC) > n)
  )
    return;
  hS.applyMatrix4(i.matrixWorld);
  const d = e.ray.origin.distanceTo(hS);
  if (!(d < e.near || d > e.far))
    return {
      distance: d,
      point: yC.clone().applyMatrix4(i.matrixWorld),
      index: o,
      face: null,
      faceIndex: null,
      barycoord: null,
      object: i,
    };
}
const xC = new te(),
  bC = new te();
class tc extends lf {
  constructor(e, t) {
    (super(e, t), (this.isLineSegments = !0), (this.type = "LineSegments"));
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position,
        n = [];
      for (let r = 0, s = t.count; r < s; r += 2)
        (xC.fromBufferAttribute(t, r),
          bC.fromBufferAttribute(t, r + 1),
          (n[r] = r === 0 ? 0 : n[r - 1]),
          (n[r + 1] = n[r] + xC.distanceTo(bC)));
      e.setAttribute("lineDistance", new Rt(n, 1));
    } else
      Tt(
        "LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.",
      );
    return this;
  }
}
class oN extends lf {
  constructor(e, t) {
    (super(e, t), (this.isLineLoop = !0), (this.type = "LineLoop"));
  }
}
class QT extends bs {
  constructor(e) {
    (super(),
      (this.isPointsMaterial = !0),
      (this.type = "PointsMaterial"),
      (this.color = new wt(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.size = 1),
      (this.sizeAttenuation = !0),
      (this.fog = !0),
      this.setValues(e));
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.size = e.size),
      (this.sizeAttenuation = e.sizeAttenuation),
      (this.fog = e.fog),
      this
    );
  }
}
const _C = new qt(),
  wM = new Oh(),
  Xy = new mr(),
  qy = new te();
class lN extends In {
  constructor(e = new nn(), t = new QT()) {
    (super(),
      (this.isPoints = !0),
      (this.type = "Points"),
      (this.geometry = e),
      (this.material = t),
      (this.morphTargetDictionary = void 0),
      (this.morphTargetInfluences = void 0),
      this.updateMorphTargets());
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  raycast(e, t) {
    const n = this.geometry,
      r = this.matrixWorld,
      s = e.params.Points.threshold,
      o = n.drawRange;
    if (
      (n.boundingSphere === null && n.computeBoundingSphere(),
      Xy.copy(n.boundingSphere),
      Xy.applyMatrix4(r),
      (Xy.radius += s),
      e.ray.intersectsSphere(Xy) === !1)
    )
      return;
    (_C.copy(r).invert(), wM.copy(e.ray).applyMatrix4(_C));
    const u = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      h = u * u,
      d = n.index,
      v = n.attributes.position;
    if (d !== null) {
      const y = Math.max(0, o.start),
        b = Math.min(d.count, o.start + o.count);
      for (let _ = y, w = b; _ < w; _++) {
        const E = d.getX(_);
        (qy.fromBufferAttribute(v, E), SC(qy, E, h, r, e, t, this));
      }
    } else {
      const y = Math.max(0, o.start),
        b = Math.min(v.count, o.start + o.count);
      for (let _ = y, w = b; _ < w; _++)
        (qy.fromBufferAttribute(v, _), SC(qy, _, h, r, e, t, this));
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      n = Object.keys(t);
    if (n.length > 0) {
      const r = t[n[0]];
      if (r !== void 0) {
        ((this.morphTargetInfluences = []), (this.morphTargetDictionary = {}));
        for (let s = 0, o = r.length; s < o; s++) {
          const u = r[s].name || String(s);
          (this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[u] = s));
        }
      }
    }
  }
}
function SC(i, e, t, n, r, s, o) {
  const u = wM.distanceSqToPoint(i);
  if (u < t) {
    const h = new te();
    (wM.closestPointToPoint(i, h), h.applyMatrix4(n));
    const d = r.ray.origin.distanceTo(h);
    if (d < r.near || d > r.far) return;
    s.push({
      distance: d,
      distanceToRay: Math.sqrt(u),
      point: h,
      index: e,
      face: null,
      faceIndex: null,
      barycoord: null,
      object: o,
    });
  }
}
class cN extends Fi {
  constructor(e, t, n, r, s = ni, o = ni, u, h, d) {
    (super(e, t, n, r, s, o, u, h, d),
      (this.isVideoTexture = !0),
      (this.generateMipmaps = !1),
      (this._requestVideoFrameCallbackId = 0));
    const m = this;
    function v() {
      ((m.needsUpdate = !0),
        (m._requestVideoFrameCallbackId = e.requestVideoFrameCallback(v)));
    }
    "requestVideoFrameCallback" in e &&
      (this._requestVideoFrameCallbackId = e.requestVideoFrameCallback(v));
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const e = this.image;
    "requestVideoFrameCallback" in e === !1 &&
      e.readyState >= e.HAVE_CURRENT_DATA &&
      (this.needsUpdate = !0);
  }
  dispose() {
    (this._requestVideoFrameCallbackId !== 0 &&
      (this.source.data.cancelVideoFrameCallback(
        this._requestVideoFrameCallbackId,
      ),
      (this._requestVideoFrameCallbackId = 0)),
      super.dispose());
  }
}
class Fk extends cN {
  constructor(e, t, n, r, s, o, u, h) {
    (super({}, e, t, n, r, s, o, u, h), (this.isVideoFrameTexture = !0));
  }
  update() {}
  clone() {
    return new this.constructor().copy(this);
  }
  setFrame(e) {
    ((this.image = e), (this.needsUpdate = !0));
  }
}
class zk extends Fi {
  constructor(e, t) {
    (super({ width: e, height: t }),
      (this.isFramebufferTexture = !0),
      (this.magFilter = rr),
      (this.minFilter = rr),
      (this.generateMipmaps = !1),
      (this.needsUpdate = !0));
  }
}
class db extends Fi {
  constructor(e, t, n, r, s, o, u, h, d, m, v, y) {
    (super(null, o, u, h, d, m, r, s, v, y),
      (this.isCompressedTexture = !0),
      (this.image = { width: t, height: n }),
      (this.mipmaps = e),
      (this.flipY = !1),
      (this.generateMipmaps = !1));
  }
}
class Bk extends db {
  constructor(e, t, n, r, s, o) {
    (super(e, t, n, s, o),
      (this.isCompressedArrayTexture = !0),
      (this.image.depth = r),
      (this.wrapR = xa),
      (this.layerUpdates = new Set()));
  }
  addLayerUpdate(e) {
    this.layerUpdates.add(e);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class kk extends db {
  constructor(e, t, n) {
    (super(void 0, e[0].width, e[0].height, t, n, Zl),
      (this.isCompressedCubeTexture = !0),
      (this.isCubeTexture = !0),
      (this.image = e));
  }
}
class N0 extends Fi {
  constructor(e = [], t = Zl, n, r, s, o, u, h, d, m) {
    (super(e, t, n, r, s, o, u, h, d, m),
      (this.isCubeTexture = !0),
      (this.flipY = !1));
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class Vk extends Fi {
  constructor(e, t, n, r, s, o, u, h, d) {
    (super(e, t, n, r, s, o, u, h, d),
      (this.isCanvasTexture = !0),
      (this.needsUpdate = !0));
  }
}
class Cp extends Fi {
  constructor(e, t, n = bo, r, s, o, u = rr, h = rr, d, m = Ql, v = 1) {
    if (m !== Ql && m !== $u)
      throw new Error(
        "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat",
      );
    const y = { width: e, height: t, depth: v };
    (super(y, r, s, o, u, h, m, n, d),
      (this.isDepthTexture = !0),
      (this.flipY = !1),
      (this.generateMipmaps = !1),
      (this.compareFunction = null));
  }
  copy(e) {
    return (
      super.copy(e),
      (this.source = new ef(Object.assign({}, e.image))),
      (this.compareFunction = e.compareFunction),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      this.compareFunction !== null &&
        (t.compareFunction = this.compareFunction),
      t
    );
  }
}
class uN extends Cp {
  constructor(e, t = bo, n = Zl, r, s, o = rr, u = rr, h, d = Ql) {
    const m = { width: e, height: e, depth: 1 },
      v = [m, m, m, m, m, m];
    (super(e, e, t, n, r, s, o, u, h, d),
      (this.image = v),
      (this.isCubeDepthTexture = !0),
      (this.isCubeTexture = !0));
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class JT extends Fi {
  constructor(e = null) {
    (super(), (this.sourceTexture = e), (this.isExternalTexture = !0));
  }
  copy(e) {
    return (super.copy(e), (this.sourceTexture = e.sourceTexture), this);
  }
}
class Fh extends nn {
  constructor(e = 1, t = 1, n = 1, r = 1, s = 1, o = 1) {
    (super(),
      (this.type = "BoxGeometry"),
      (this.parameters = {
        width: e,
        height: t,
        depth: n,
        widthSegments: r,
        heightSegments: s,
        depthSegments: o,
      }));
    const u = this;
    ((r = Math.floor(r)), (s = Math.floor(s)), (o = Math.floor(o)));
    const h = [],
      d = [],
      m = [],
      v = [];
    let y = 0,
      b = 0;
    (_("z", "y", "x", -1, -1, n, t, e, o, s, 0),
      _("z", "y", "x", 1, -1, n, t, -e, o, s, 1),
      _("x", "z", "y", 1, 1, e, n, t, r, o, 2),
      _("x", "z", "y", 1, -1, e, n, -t, r, o, 3),
      _("x", "y", "z", 1, -1, e, t, n, r, s, 4),
      _("x", "y", "z", -1, -1, e, t, -n, r, s, 5),
      this.setIndex(h),
      this.setAttribute("position", new Rt(d, 3)),
      this.setAttribute("normal", new Rt(m, 3)),
      this.setAttribute("uv", new Rt(v, 2)));
    function _(w, E, T, C, R, L, I, O, B, N, F) {
      const j = L / B,
        q = I / N,
        X = L / 2,
        J = I / 2,
        ee = O / 2,
        ne = B + 1,
        W = N + 1;
      let $ = 0,
        de = 0;
      const le = new te();
      for (let fe = 0; fe < W; fe++) {
        const V = fe * q - J;
        for (let Z = 0; Z < ne; Z++) {
          const se = Z * j - X;
          ((le[w] = se * C),
            (le[E] = V * R),
            (le[T] = ee),
            d.push(le.x, le.y, le.z),
            (le[w] = 0),
            (le[E] = 0),
            (le[T] = O > 0 ? 1 : -1),
            m.push(le.x, le.y, le.z),
            v.push(Z / B),
            v.push(1 - fe / N),
            ($ += 1));
        }
      }
      for (let fe = 0; fe < N; fe++)
        for (let V = 0; V < B; V++) {
          const Z = y + V + ne * fe,
            se = y + V + ne * (fe + 1),
            ue = y + (V + 1) + ne * (fe + 1),
            ge = y + (V + 1) + ne * fe;
          (h.push(Z, se, ge), h.push(se, ue, ge), (de += 6));
        }
      (u.addGroup(b, de, F), (b += de), (y += $));
    }
  }
  copy(e) {
    return (
      super.copy(e),
      (this.parameters = Object.assign({}, e.parameters)),
      this
    );
  }
  static fromJSON(e) {
    return new Fh(
      e.width,
      e.height,
      e.depth,
      e.widthSegments,
      e.heightSegments,
      e.depthSegments,
    );
  }
}
class pb extends nn {
  constructor(e = 1, t = 1, n = 4, r = 8, s = 1) {
    (super(),
      (this.type = "CapsuleGeometry"),
      (this.parameters = {
        radius: e,
        height: t,
        capSegments: n,
        radialSegments: r,
        heightSegments: s,
      }),
      (t = Math.max(0, t)),
      (n = Math.max(1, Math.floor(n))),
      (r = Math.max(3, Math.floor(r))),
      (s = Math.max(1, Math.floor(s))));
    const o = [],
      u = [],
      h = [],
      d = [],
      m = t / 2,
      v = (Math.PI / 2) * e,
      y = t,
      b = 2 * v + y,
      _ = n * 2 + s,
      w = r + 1,
      E = new te(),
      T = new te();
    for (let C = 0; C <= _; C++) {
      let R = 0,
        L = 0,
        I = 0,
        O = 0;
      if (C <= n) {
        const F = C / n,
          j = (F * Math.PI) / 2;
        ((L = -m - e * Math.cos(j)),
          (I = e * Math.sin(j)),
          (O = -e * Math.cos(j)),
          (R = F * v));
      } else if (C <= n + s) {
        const F = (C - n) / s;
        ((L = -m + F * t), (I = e), (O = 0), (R = v + F * y));
      } else {
        const F = (C - n - s) / n,
          j = (F * Math.PI) / 2;
        ((L = m + e * Math.sin(j)),
          (I = e * Math.cos(j)),
          (O = e * Math.sin(j)),
          (R = v + y + F * v));
      }
      const B = Math.max(0, Math.min(1, R / b));
      let N = 0;
      C === 0 ? (N = 0.5 / r) : C === _ && (N = -0.5 / r);
      for (let F = 0; F <= r; F++) {
        const j = F / r,
          q = j * Math.PI * 2,
          X = Math.sin(q),
          J = Math.cos(q);
        ((T.x = -I * J),
          (T.y = L),
          (T.z = I * X),
          u.push(T.x, T.y, T.z),
          E.set(-I * J, O, I * X),
          E.normalize(),
          h.push(E.x, E.y, E.z),
          d.push(j + N, B));
      }
      if (C > 0) {
        const F = (C - 1) * w;
        for (let j = 0; j < r; j++) {
          const q = F + j,
            X = F + j + 1,
            J = C * w + j,
            ee = C * w + j + 1;
          (o.push(q, X, J), o.push(X, ee, J));
        }
      }
    }
    (this.setIndex(o),
      this.setAttribute("position", new Rt(u, 3)),
      this.setAttribute("normal", new Rt(h, 3)),
      this.setAttribute("uv", new Rt(d, 2)));
  }
  copy(e) {
    return (
      super.copy(e),
      (this.parameters = Object.assign({}, e.parameters)),
      this
    );
  }
  static fromJSON(e) {
    return new pb(
      e.radius,
      e.height,
      e.capSegments,
      e.radialSegments,
      e.heightSegments,
    );
  }
}
class mb extends nn {
  constructor(e = 1, t = 32, n = 0, r = Math.PI * 2) {
    (super(),
      (this.type = "CircleGeometry"),
      (this.parameters = {
        radius: e,
        segments: t,
        thetaStart: n,
        thetaLength: r,
      }),
      (t = Math.max(3, t)));
    const s = [],
      o = [],
      u = [],
      h = [],
      d = new te(),
      m = new nt();
    (o.push(0, 0, 0), u.push(0, 0, 1), h.push(0.5, 0.5));
    for (let v = 0, y = 3; v <= t; v++, y += 3) {
      const b = n + (v / t) * r;
      ((d.x = e * Math.cos(b)),
        (d.y = e * Math.sin(b)),
        o.push(d.x, d.y, d.z),
        u.push(0, 0, 1),
        (m.x = (o[y] / e + 1) / 2),
        (m.y = (o[y + 1] / e + 1) / 2),
        h.push(m.x, m.y));
    }
    for (let v = 1; v <= t; v++) s.push(v, v + 1, 0);
    (this.setIndex(s),
      this.setAttribute("position", new Rt(o, 3)),
      this.setAttribute("normal", new Rt(u, 3)),
      this.setAttribute("uv", new Rt(h, 2)));
  }
  copy(e) {
    return (
      super.copy(e),
      (this.parameters = Object.assign({}, e.parameters)),
      this
    );
  }
  static fromJSON(e) {
    return new mb(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class U0 extends nn {
  constructor(
    e = 1,
    t = 1,
    n = 1,
    r = 32,
    s = 1,
    o = !1,
    u = 0,
    h = Math.PI * 2,
  ) {
    (super(),
      (this.type = "CylinderGeometry"),
      (this.parameters = {
        radiusTop: e,
        radiusBottom: t,
        height: n,
        radialSegments: r,
        heightSegments: s,
        openEnded: o,
        thetaStart: u,
        thetaLength: h,
      }));
    const d = this;
    ((r = Math.floor(r)), (s = Math.floor(s)));
    const m = [],
      v = [],
      y = [],
      b = [];
    let _ = 0;
    const w = [],
      E = n / 2;
    let T = 0;
    (C(),
      o === !1 && (e > 0 && R(!0), t > 0 && R(!1)),
      this.setIndex(m),
      this.setAttribute("position", new Rt(v, 3)),
      this.setAttribute("normal", new Rt(y, 3)),
      this.setAttribute("uv", new Rt(b, 2)));
    function C() {
      const L = new te(),
        I = new te();
      let O = 0;
      const B = (t - e) / n;
      for (let N = 0; N <= s; N++) {
        const F = [],
          j = N / s,
          q = j * (t - e) + e;
        for (let X = 0; X <= r; X++) {
          const J = X / r,
            ee = J * h + u,
            ne = Math.sin(ee),
            W = Math.cos(ee);
          ((I.x = q * ne),
            (I.y = -j * n + E),
            (I.z = q * W),
            v.push(I.x, I.y, I.z),
            L.set(ne, B, W).normalize(),
            y.push(L.x, L.y, L.z),
            b.push(J, 1 - j),
            F.push(_++));
        }
        w.push(F);
      }
      for (let N = 0; N < r; N++)
        for (let F = 0; F < s; F++) {
          const j = w[F][N],
            q = w[F + 1][N],
            X = w[F + 1][N + 1],
            J = w[F][N + 1];
          ((e > 0 || F !== 0) && (m.push(j, q, J), (O += 3)),
            (t > 0 || F !== s - 1) && (m.push(q, X, J), (O += 3)));
        }
      (d.addGroup(T, O, 0), (T += O));
    }
    function R(L) {
      const I = _,
        O = new nt(),
        B = new te();
      let N = 0;
      const F = L === !0 ? e : t,
        j = L === !0 ? 1 : -1;
      for (let X = 1; X <= r; X++)
        (v.push(0, E * j, 0), y.push(0, j, 0), b.push(0.5, 0.5), _++);
      const q = _;
      for (let X = 0; X <= r; X++) {
        const ee = (X / r) * h + u,
          ne = Math.cos(ee),
          W = Math.sin(ee);
        ((B.x = F * W),
          (B.y = E * j),
          (B.z = F * ne),
          v.push(B.x, B.y, B.z),
          y.push(0, j, 0),
          (O.x = ne * 0.5 + 0.5),
          (O.y = W * 0.5 * j + 0.5),
          b.push(O.x, O.y),
          _++);
      }
      for (let X = 0; X < r; X++) {
        const J = I + X,
          ee = q + X;
        (L === !0 ? m.push(ee, ee + 1, J) : m.push(ee + 1, ee, J), (N += 3));
      }
      (d.addGroup(T, N, L === !0 ? 1 : 2), (T += N));
    }
  }
  copy(e) {
    return (
      super.copy(e),
      (this.parameters = Object.assign({}, e.parameters)),
      this
    );
  }
  static fromJSON(e) {
    return new U0(
      e.radiusTop,
      e.radiusBottom,
      e.height,
      e.radialSegments,
      e.heightSegments,
      e.openEnded,
      e.thetaStart,
      e.thetaLength,
    );
  }
}
class P0 extends U0 {
  constructor(e = 1, t = 1, n = 32, r = 1, s = !1, o = 0, u = Math.PI * 2) {
    (super(0, e, t, n, r, s, o, u),
      (this.type = "ConeGeometry"),
      (this.parameters = {
        radius: e,
        height: t,
        radialSegments: n,
        heightSegments: r,
        openEnded: s,
        thetaStart: o,
        thetaLength: u,
      }));
  }
  static fromJSON(e) {
    return new P0(
      e.radius,
      e.height,
      e.radialSegments,
      e.heightSegments,
      e.openEnded,
      e.thetaStart,
      e.thetaLength,
    );
  }
}
class df extends nn {
  constructor(e = [], t = [], n = 1, r = 0) {
    (super(),
      (this.type = "PolyhedronGeometry"),
      (this.parameters = { vertices: e, indices: t, radius: n, detail: r }));
    const s = [],
      o = [];
    (u(r),
      d(n),
      m(),
      this.setAttribute("position", new Rt(s, 3)),
      this.setAttribute("normal", new Rt(s.slice(), 3)),
      this.setAttribute("uv", new Rt(o, 2)),
      r === 0 ? this.computeVertexNormals() : this.normalizeNormals());
    function u(C) {
      const R = new te(),
        L = new te(),
        I = new te();
      for (let O = 0; O < t.length; O += 3)
        (b(t[O + 0], R), b(t[O + 1], L), b(t[O + 2], I), h(R, L, I, C));
    }
    function h(C, R, L, I) {
      const O = I + 1,
        B = [];
      for (let N = 0; N <= O; N++) {
        B[N] = [];
        const F = C.clone().lerp(L, N / O),
          j = R.clone().lerp(L, N / O),
          q = O - N;
        for (let X = 0; X <= q; X++)
          X === 0 && N === O
            ? (B[N][X] = F)
            : (B[N][X] = F.clone().lerp(j, X / q));
      }
      for (let N = 0; N < O; N++)
        for (let F = 0; F < 2 * (O - N) - 1; F++) {
          const j = Math.floor(F / 2);
          F % 2 === 0
            ? (y(B[N][j + 1]), y(B[N + 1][j]), y(B[N][j]))
            : (y(B[N][j + 1]), y(B[N + 1][j + 1]), y(B[N + 1][j]));
        }
    }
    function d(C) {
      const R = new te();
      for (let L = 0; L < s.length; L += 3)
        ((R.x = s[L + 0]),
          (R.y = s[L + 1]),
          (R.z = s[L + 2]),
          R.normalize().multiplyScalar(C),
          (s[L + 0] = R.x),
          (s[L + 1] = R.y),
          (s[L + 2] = R.z));
    }
    function m() {
      const C = new te();
      for (let R = 0; R < s.length; R += 3) {
        ((C.x = s[R + 0]), (C.y = s[R + 1]), (C.z = s[R + 2]));
        const L = E(C) / 2 / Math.PI + 0.5,
          I = T(C) / Math.PI + 0.5;
        o.push(L, 1 - I);
      }
      (_(), v());
    }
    function v() {
      for (let C = 0; C < o.length; C += 6) {
        const R = o[C + 0],
          L = o[C + 2],
          I = o[C + 4],
          O = Math.max(R, L, I),
          B = Math.min(R, L, I);
        O > 0.9 &&
          B < 0.1 &&
          (R < 0.2 && (o[C + 0] += 1),
          L < 0.2 && (o[C + 2] += 1),
          I < 0.2 && (o[C + 4] += 1));
      }
    }
    function y(C) {
      s.push(C.x, C.y, C.z);
    }
    function b(C, R) {
      const L = C * 3;
      ((R.x = e[L + 0]), (R.y = e[L + 1]), (R.z = e[L + 2]));
    }
    function _() {
      const C = new te(),
        R = new te(),
        L = new te(),
        I = new te(),
        O = new nt(),
        B = new nt(),
        N = new nt();
      for (let F = 0, j = 0; F < s.length; F += 9, j += 6) {
        (C.set(s[F + 0], s[F + 1], s[F + 2]),
          R.set(s[F + 3], s[F + 4], s[F + 5]),
          L.set(s[F + 6], s[F + 7], s[F + 8]),
          O.set(o[j + 0], o[j + 1]),
          B.set(o[j + 2], o[j + 3]),
          N.set(o[j + 4], o[j + 5]),
          I.copy(C).add(R).add(L).divideScalar(3));
        const q = E(I);
        (w(O, j + 0, C, q), w(B, j + 2, R, q), w(N, j + 4, L, q));
      }
    }
    function w(C, R, L, I) {
      (I < 0 && C.x === 1 && (o[R] = C.x - 1),
        L.x === 0 && L.z === 0 && (o[R] = I / 2 / Math.PI + 0.5));
    }
    function E(C) {
      return Math.atan2(C.z, -C.x);
    }
    function T(C) {
      return Math.atan2(-C.y, Math.sqrt(C.x * C.x + C.z * C.z));
    }
  }
  copy(e) {
    return (
      super.copy(e),
      (this.parameters = Object.assign({}, e.parameters)),
      this
    );
  }
  static fromJSON(e) {
    return new df(e.vertices, e.indices, e.radius, e.detail);
  }
}
class gb extends df {
  constructor(e = 1, t = 0) {
    const n = (1 + Math.sqrt(5)) / 2,
      r = 1 / n,
      s = [
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        1,
        -1,
        -1,
        1,
        1,
        1,
        -1,
        -1,
        1,
        -1,
        1,
        1,
        1,
        -1,
        1,
        1,
        1,
        0,
        -r,
        -n,
        0,
        -r,
        n,
        0,
        r,
        -n,
        0,
        r,
        n,
        -r,
        -n,
        0,
        -r,
        n,
        0,
        r,
        -n,
        0,
        r,
        n,
        0,
        -n,
        0,
        -r,
        n,
        0,
        -r,
        -n,
        0,
        r,
        n,
        0,
        r,
      ],
      o = [
        3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8,
        17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18,
        0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13,
        18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5,
        11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14,
        5, 1, 5, 9,
      ];
    (super(s, o, e, t),
      (this.type = "DodecahedronGeometry"),
      (this.parameters = { radius: e, detail: t }));
  }
  static fromJSON(e) {
    return new gb(e.radius, e.detail);
  }
}
const Yy = new te(),
  Zy = new te(),
  dS = new te(),
  Ky = new ya();
class fN extends nn {
  constructor(e = null, t = 1) {
    if (
      (super(),
      (this.type = "EdgesGeometry"),
      (this.parameters = { geometry: e, thresholdAngle: t }),
      e !== null)
    ) {
      const r = Math.pow(10, 4),
        s = Math.cos(wh * t),
        o = e.getIndex(),
        u = e.getAttribute("position"),
        h = o ? o.count : u.count,
        d = [0, 0, 0],
        m = ["a", "b", "c"],
        v = new Array(3),
        y = {},
        b = [];
      for (let _ = 0; _ < h; _ += 3) {
        o
          ? ((d[0] = o.getX(_)), (d[1] = o.getX(_ + 1)), (d[2] = o.getX(_ + 2)))
          : ((d[0] = _), (d[1] = _ + 1), (d[2] = _ + 2));
        const { a: w, b: E, c: T } = Ky;
        if (
          (w.fromBufferAttribute(u, d[0]),
          E.fromBufferAttribute(u, d[1]),
          T.fromBufferAttribute(u, d[2]),
          Ky.getNormal(dS),
          (v[0] = `${Math.round(w.x * r)},${Math.round(w.y * r)},${Math.round(w.z * r)}`),
          (v[1] = `${Math.round(E.x * r)},${Math.round(E.y * r)},${Math.round(E.z * r)}`),
          (v[2] = `${Math.round(T.x * r)},${Math.round(T.y * r)},${Math.round(T.z * r)}`),
          !(v[0] === v[1] || v[1] === v[2] || v[2] === v[0]))
        )
          for (let C = 0; C < 3; C++) {
            const R = (C + 1) % 3,
              L = v[C],
              I = v[R],
              O = Ky[m[C]],
              B = Ky[m[R]],
              N = `${L}_${I}`,
              F = `${I}_${L}`;
            F in y && y[F]
              ? (dS.dot(y[F].normal) <= s &&
                  (b.push(O.x, O.y, O.z), b.push(B.x, B.y, B.z)),
                (y[F] = null))
              : N in y ||
                (y[N] = { index0: d[C], index1: d[R], normal: dS.clone() });
          }
      }
      for (const _ in y)
        if (y[_]) {
          const { index0: w, index1: E } = y[_];
          (Yy.fromBufferAttribute(u, w),
            Zy.fromBufferAttribute(u, E),
            b.push(Yy.x, Yy.y, Yy.z),
            b.push(Zy.x, Zy.y, Zy.z));
        }
      this.setAttribute("position", new Rt(b, 3));
    }
  }
  copy(e) {
    return (
      super.copy(e),
      (this.parameters = Object.assign({}, e.parameters)),
      this
    );
  }
}
class $o {
  constructor() {
    ((this.type = "Curve"),
      (this.arcLengthDivisions = 200),
      (this.needsUpdate = !1),
      (this.cacheArcLengths = null));
  }
  getPoint() {
    Tt("Curve: .getPoint() not implemented.");
  }
  getPointAt(e, t) {
    const n = this.getUtoTmapping(e);
    return this.getPoint(n, t);
  }
  getPoints(e = 5) {
    const t = [];
    for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
    return t;
  }
  getSpacedPoints(e = 5) {
    const t = [];
    for (let n = 0; n <= e; n++) t.push(this.getPointAt(n / e));
    return t;
  }
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  getLengths(e = this.arcLengthDivisions) {
    if (
      this.cacheArcLengths &&
      this.cacheArcLengths.length === e + 1 &&
      !this.needsUpdate
    )
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const t = [];
    let n,
      r = this.getPoint(0),
      s = 0;
    t.push(0);
    for (let o = 1; o <= e; o++)
      ((n = this.getPoint(o / e)), (s += n.distanceTo(r)), t.push(s), (r = n));
    return ((this.cacheArcLengths = t), t);
  }
  updateArcLengths() {
    ((this.needsUpdate = !0), this.getLengths());
  }
  getUtoTmapping(e, t = null) {
    const n = this.getLengths();
    let r = 0;
    const s = n.length;
    let o;
    t ? (o = t) : (o = e * n[s - 1]);
    let u = 0,
      h = s - 1,
      d;
    for (; u <= h; )
      if (((r = Math.floor(u + (h - u) / 2)), (d = n[r] - o), d < 0)) u = r + 1;
      else if (d > 0) h = r - 1;
      else {
        h = r;
        break;
      }
    if (((r = h), n[r] === o)) return r / (s - 1);
    const m = n[r],
      y = n[r + 1] - m,
      b = (o - m) / y;
    return (r + b) / (s - 1);
  }
  getTangent(e, t) {
    let r = e - 1e-4,
      s = e + 1e-4;
    (r < 0 && (r = 0), s > 1 && (s = 1));
    const o = this.getPoint(r),
      u = this.getPoint(s),
      h = t || (o.isVector2 ? new nt() : new te());
    return (h.copy(u).sub(o).normalize(), h);
  }
  getTangentAt(e, t) {
    const n = this.getUtoTmapping(e);
    return this.getTangent(n, t);
  }
  computeFrenetFrames(e, t = !1) {
    const n = new te(),
      r = [],
      s = [],
      o = [],
      u = new te(),
      h = new qt();
    for (let b = 0; b <= e; b++) {
      const _ = b / e;
      r[b] = this.getTangentAt(_, new te());
    }
    ((s[0] = new te()), (o[0] = new te()));
    let d = Number.MAX_VALUE;
    const m = Math.abs(r[0].x),
      v = Math.abs(r[0].y),
      y = Math.abs(r[0].z);
    (m <= d && ((d = m), n.set(1, 0, 0)),
      v <= d && ((d = v), n.set(0, 1, 0)),
      y <= d && n.set(0, 0, 1),
      u.crossVectors(r[0], n).normalize(),
      s[0].crossVectors(r[0], u),
      o[0].crossVectors(r[0], s[0]));
    for (let b = 1; b <= e; b++) {
      if (
        ((s[b] = s[b - 1].clone()),
        (o[b] = o[b - 1].clone()),
        u.crossVectors(r[b - 1], r[b]),
        u.length() > Number.EPSILON)
      ) {
        u.normalize();
        const _ = Math.acos(Yt(r[b - 1].dot(r[b]), -1, 1));
        s[b].applyMatrix4(h.makeRotationAxis(u, _));
      }
      o[b].crossVectors(r[b], s[b]);
    }
    if (t === !0) {
      let b = Math.acos(Yt(s[0].dot(s[e]), -1, 1));
      ((b /= e), r[0].dot(u.crossVectors(s[0], s[e])) > 0 && (b = -b));
      for (let _ = 1; _ <= e; _++)
        (s[_].applyMatrix4(h.makeRotationAxis(r[_], b * _)),
          o[_].crossVectors(r[_], s[_]));
    }
    return { tangents: r, normals: s, binormals: o };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return ((this.arcLengthDivisions = e.arcLengthDivisions), this);
  }
  toJSON() {
    const e = {
      metadata: { version: 4.7, type: "Curve", generator: "Curve.toJSON" },
    };
    return (
      (e.arcLengthDivisions = this.arcLengthDivisions),
      (e.type = this.type),
      e
    );
  }
  fromJSON(e) {
    return ((this.arcLengthDivisions = e.arcLengthDivisions), this);
  }
}
class vb extends $o {
  constructor(
    e = 0,
    t = 0,
    n = 1,
    r = 1,
    s = 0,
    o = Math.PI * 2,
    u = !1,
    h = 0,
  ) {
    (super(),
      (this.isEllipseCurve = !0),
      (this.type = "EllipseCurve"),
      (this.aX = e),
      (this.aY = t),
      (this.xRadius = n),
      (this.yRadius = r),
      (this.aStartAngle = s),
      (this.aEndAngle = o),
      (this.aClockwise = u),
      (this.aRotation = h));
  }
  getPoint(e, t = new nt()) {
    const n = t,
      r = Math.PI * 2;
    let s = this.aEndAngle - this.aStartAngle;
    const o = Math.abs(s) < Number.EPSILON;
    for (; s < 0; ) s += r;
    for (; s > r; ) s -= r;
    (s < Number.EPSILON && (o ? (s = 0) : (s = r)),
      this.aClockwise === !0 && !o && (s === r ? (s = -r) : (s = s - r)));
    const u = this.aStartAngle + e * s;
    let h = this.aX + this.xRadius * Math.cos(u),
      d = this.aY + this.yRadius * Math.sin(u);
    if (this.aRotation !== 0) {
      const m = Math.cos(this.aRotation),
        v = Math.sin(this.aRotation),
        y = h - this.aX,
        b = d - this.aY;
      ((h = y * m - b * v + this.aX), (d = y * v + b * m + this.aY));
    }
    return n.set(h, d);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.aX = e.aX),
      (this.aY = e.aY),
      (this.xRadius = e.xRadius),
      (this.yRadius = e.yRadius),
      (this.aStartAngle = e.aStartAngle),
      (this.aEndAngle = e.aEndAngle),
      (this.aClockwise = e.aClockwise),
      (this.aRotation = e.aRotation),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.aX = this.aX),
      (e.aY = this.aY),
      (e.xRadius = this.xRadius),
      (e.yRadius = this.yRadius),
      (e.aStartAngle = this.aStartAngle),
      (e.aEndAngle = this.aEndAngle),
      (e.aClockwise = this.aClockwise),
      (e.aRotation = this.aRotation),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      (this.aX = e.aX),
      (this.aY = e.aY),
      (this.xRadius = e.xRadius),
      (this.yRadius = e.yRadius),
      (this.aStartAngle = e.aStartAngle),
      (this.aEndAngle = e.aEndAngle),
      (this.aClockwise = e.aClockwise),
      (this.aRotation = e.aRotation),
      this
    );
  }
}
class hN extends vb {
  constructor(e, t, n, r, s, o) {
    (super(e, t, n, n, r, s, o),
      (this.isArcCurve = !0),
      (this.type = "ArcCurve"));
  }
}
function $T() {
  let i = 0,
    e = 0,
    t = 0,
    n = 0;
  function r(s, o, u, h) {
    ((i = s),
      (e = u),
      (t = -3 * s + 3 * o - 2 * u - h),
      (n = 2 * s - 2 * o + u + h));
  }
  return {
    initCatmullRom: function (s, o, u, h, d) {
      r(o, u, d * (u - s), d * (h - o));
    },
    initNonuniformCatmullRom: function (s, o, u, h, d, m, v) {
      let y = (o - s) / d - (u - s) / (d + m) + (u - o) / m,
        b = (u - o) / m - (h - o) / (m + v) + (h - u) / v;
      ((y *= m), (b *= m), r(o, u, y, b));
    },
    calc: function (s) {
      const o = s * s,
        u = o * s;
      return i + e * s + t * o + n * u;
    },
  };
}
const Qy = new te(),
  pS = new $T(),
  mS = new $T(),
  gS = new $T();
class dN extends $o {
  constructor(e = [], t = !1, n = "centripetal", r = 0.5) {
    (super(),
      (this.isCatmullRomCurve3 = !0),
      (this.type = "CatmullRomCurve3"),
      (this.points = e),
      (this.closed = t),
      (this.curveType = n),
      (this.tension = r));
  }
  getPoint(e, t = new te()) {
    const n = t,
      r = this.points,
      s = r.length,
      o = (s - (this.closed ? 0 : 1)) * e;
    let u = Math.floor(o),
      h = o - u;
    this.closed
      ? (u += u > 0 ? 0 : (Math.floor(Math.abs(u) / s) + 1) * s)
      : h === 0 && u === s - 1 && ((u = s - 2), (h = 1));
    let d, m;
    this.closed || u > 0
      ? (d = r[(u - 1) % s])
      : (Qy.subVectors(r[0], r[1]).add(r[0]), (d = Qy));
    const v = r[u % s],
      y = r[(u + 1) % s];
    if (
      (this.closed || u + 2 < s
        ? (m = r[(u + 2) % s])
        : (Qy.subVectors(r[s - 1], r[s - 2]).add(r[s - 1]), (m = Qy)),
      this.curveType === "centripetal" || this.curveType === "chordal")
    ) {
      const b = this.curveType === "chordal" ? 0.5 : 0.25;
      let _ = Math.pow(d.distanceToSquared(v), b),
        w = Math.pow(v.distanceToSquared(y), b),
        E = Math.pow(y.distanceToSquared(m), b);
      (w < 1e-4 && (w = 1),
        _ < 1e-4 && (_ = w),
        E < 1e-4 && (E = w),
        pS.initNonuniformCatmullRom(d.x, v.x, y.x, m.x, _, w, E),
        mS.initNonuniformCatmullRom(d.y, v.y, y.y, m.y, _, w, E),
        gS.initNonuniformCatmullRom(d.z, v.z, y.z, m.z, _, w, E));
    } else
      this.curveType === "catmullrom" &&
        (pS.initCatmullRom(d.x, v.x, y.x, m.x, this.tension),
        mS.initCatmullRom(d.y, v.y, y.y, m.y, this.tension),
        gS.initCatmullRom(d.z, v.z, y.z, m.z, this.tension));
    return (n.set(pS.calc(h), mS.calc(h), gS.calc(h)), n);
  }
  copy(e) {
    (super.copy(e), (this.points = []));
    for (let t = 0, n = e.points.length; t < n; t++) {
      const r = e.points[t];
      this.points.push(r.clone());
    }
    return (
      (this.closed = e.closed),
      (this.curveType = e.curveType),
      (this.tension = e.tension),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, n = this.points.length; t < n; t++) {
      const r = this.points[t];
      e.points.push(r.toArray());
    }
    return (
      (e.closed = this.closed),
      (e.curveType = this.curveType),
      (e.tension = this.tension),
      e
    );
  }
  fromJSON(e) {
    (super.fromJSON(e), (this.points = []));
    for (let t = 0, n = e.points.length; t < n; t++) {
      const r = e.points[t];
      this.points.push(new te().fromArray(r));
    }
    return (
      (this.closed = e.closed),
      (this.curveType = e.curveType),
      (this.tension = e.tension),
      this
    );
  }
}
function MC(i, e, t, n, r) {
  const s = (n - e) * 0.5,
    o = (r - t) * 0.5,
    u = i * i,
    h = i * u;
  return (
    (2 * t - 2 * n + s + o) * h + (-3 * t + 3 * n - 2 * s - o) * u + s * i + t
  );
}
function Gk(i, e) {
  const t = 1 - i;
  return t * t * e;
}
function Hk(i, e) {
  return 2 * (1 - i) * i * e;
}
function jk(i, e) {
  return i * i * e;
}
function Xg(i, e, t, n) {
  return Gk(i, e) + Hk(i, t) + jk(i, n);
}
function Wk(i, e) {
  const t = 1 - i;
  return t * t * t * e;
}
function Xk(i, e) {
  const t = 1 - i;
  return 3 * t * t * i * e;
}
function qk(i, e) {
  return 3 * (1 - i) * i * i * e;
}
function Yk(i, e) {
  return i * i * i * e;
}
function qg(i, e, t, n, r) {
  return Wk(i, e) + Xk(i, t) + qk(i, n) + Yk(i, r);
}
class eE extends $o {
  constructor(e = new nt(), t = new nt(), n = new nt(), r = new nt()) {
    (super(),
      (this.isCubicBezierCurve = !0),
      (this.type = "CubicBezierCurve"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = n),
      (this.v3 = r));
  }
  getPoint(e, t = new nt()) {
    const n = t,
      r = this.v0,
      s = this.v1,
      o = this.v2,
      u = this.v3;
    return (n.set(qg(e, r.x, s.x, o.x, u.x), qg(e, r.y, s.y, o.y, u.y)), n);
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this.v3.copy(e.v3),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      (e.v3 = this.v3.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this.v3.fromArray(e.v3),
      this
    );
  }
}
class pN extends $o {
  constructor(e = new te(), t = new te(), n = new te(), r = new te()) {
    (super(),
      (this.isCubicBezierCurve3 = !0),
      (this.type = "CubicBezierCurve3"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = n),
      (this.v3 = r));
  }
  getPoint(e, t = new te()) {
    const n = t,
      r = this.v0,
      s = this.v1,
      o = this.v2,
      u = this.v3;
    return (
      n.set(
        qg(e, r.x, s.x, o.x, u.x),
        qg(e, r.y, s.y, o.y, u.y),
        qg(e, r.z, s.z, o.z, u.z),
      ),
      n
    );
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this.v3.copy(e.v3),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      (e.v3 = this.v3.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this.v3.fromArray(e.v3),
      this
    );
  }
}
class tE extends $o {
  constructor(e = new nt(), t = new nt()) {
    (super(),
      (this.isLineCurve = !0),
      (this.type = "LineCurve"),
      (this.v1 = e),
      (this.v2 = t));
  }
  getPoint(e, t = new nt()) {
    const n = t;
    return (
      e === 1
        ? n.copy(this.v2)
        : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)),
      n
    );
  }
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new nt()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return (super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this);
  }
  toJSON() {
    const e = super.toJSON();
    return ((e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e);
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    );
  }
}
class mN extends $o {
  constructor(e = new te(), t = new te()) {
    (super(),
      (this.isLineCurve3 = !0),
      (this.type = "LineCurve3"),
      (this.v1 = e),
      (this.v2 = t));
  }
  getPoint(e, t = new te()) {
    const n = t;
    return (
      e === 1
        ? n.copy(this.v2)
        : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)),
      n
    );
  }
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new te()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return (super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this);
  }
  toJSON() {
    const e = super.toJSON();
    return ((e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e);
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    );
  }
}
class nE extends $o {
  constructor(e = new nt(), t = new nt(), n = new nt()) {
    (super(),
      (this.isQuadraticBezierCurve = !0),
      (this.type = "QuadraticBezierCurve"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = n));
  }
  getPoint(e, t = new nt()) {
    const n = t,
      r = this.v0,
      s = this.v1,
      o = this.v2;
    return (n.set(Xg(e, r.x, s.x, o.x), Xg(e, r.y, s.y, o.y)), n);
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    );
  }
}
class iE extends $o {
  constructor(e = new te(), t = new te(), n = new te()) {
    (super(),
      (this.isQuadraticBezierCurve3 = !0),
      (this.type = "QuadraticBezierCurve3"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = n));
  }
  getPoint(e, t = new te()) {
    const n = t,
      r = this.v0,
      s = this.v1,
      o = this.v2;
    return (
      n.set(Xg(e, r.x, s.x, o.x), Xg(e, r.y, s.y, o.y), Xg(e, r.z, s.z, o.z)),
      n
    );
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    );
  }
}
class rE extends $o {
  constructor(e = []) {
    (super(),
      (this.isSplineCurve = !0),
      (this.type = "SplineCurve"),
      (this.points = e));
  }
  getPoint(e, t = new nt()) {
    const n = t,
      r = this.points,
      s = (r.length - 1) * e,
      o = Math.floor(s),
      u = s - o,
      h = r[o === 0 ? o : o - 1],
      d = r[o],
      m = r[o > r.length - 2 ? r.length - 1 : o + 1],
      v = r[o > r.length - 3 ? r.length - 1 : o + 2];
    return (n.set(MC(u, h.x, d.x, m.x, v.x), MC(u, h.y, d.y, m.y, v.y)), n);
  }
  copy(e) {
    (super.copy(e), (this.points = []));
    for (let t = 0, n = e.points.length; t < n; t++) {
      const r = e.points[t];
      this.points.push(r.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, n = this.points.length; t < n; t++) {
      const r = this.points[t];
      e.points.push(r.toArray());
    }
    return e;
  }
  fromJSON(e) {
    (super.fromJSON(e), (this.points = []));
    for (let t = 0, n = e.points.length; t < n; t++) {
      const r = e.points[t];
      this.points.push(new nt().fromArray(r));
    }
    return this;
  }
}
var P1 = Object.freeze({
  __proto__: null,
  ArcCurve: hN,
  CatmullRomCurve3: dN,
  CubicBezierCurve: eE,
  CubicBezierCurve3: pN,
  EllipseCurve: vb,
  LineCurve: tE,
  LineCurve3: mN,
  QuadraticBezierCurve: nE,
  QuadraticBezierCurve3: iE,
  SplineCurve: rE,
});
class gN extends $o {
  constructor() {
    (super(),
      (this.type = "CurvePath"),
      (this.curves = []),
      (this.autoClose = !1));
  }
  add(e) {
    this.curves.push(e);
  }
  closePath() {
    const e = this.curves[0].getPoint(0),
      t = this.curves[this.curves.length - 1].getPoint(1);
    if (!e.equals(t)) {
      const n = e.isVector2 === !0 ? "LineCurve" : "LineCurve3";
      this.curves.push(new P1[n](t, e));
    }
    return this;
  }
  getPoint(e, t) {
    const n = e * this.getLength(),
      r = this.getCurveLengths();
    let s = 0;
    for (; s < r.length; ) {
      if (r[s] >= n) {
        const o = r[s] - n,
          u = this.curves[s],
          h = u.getLength(),
          d = h === 0 ? 0 : 1 - o / h;
        return u.getPointAt(d, t);
      }
      s++;
    }
    return null;
  }
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  updateArcLengths() {
    ((this.needsUpdate = !0),
      (this.cacheLengths = null),
      this.getCurveLengths());
  }
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const e = [];
    let t = 0;
    for (let n = 0, r = this.curves.length; n < r; n++)
      ((t += this.curves[n].getLength()), e.push(t));
    return ((this.cacheLengths = e), e);
  }
  getSpacedPoints(e = 40) {
    const t = [];
    for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
    return (this.autoClose && t.push(t[0]), t);
  }
  getPoints(e = 12) {
    const t = [];
    let n;
    for (let r = 0, s = this.curves; r < s.length; r++) {
      const o = s[r],
        u = o.isEllipseCurve
          ? e * 2
          : o.isLineCurve || o.isLineCurve3
            ? 1
            : o.isSplineCurve
              ? e * o.points.length
              : e,
        h = o.getPoints(u);
      for (let d = 0; d < h.length; d++) {
        const m = h[d];
        (n && n.equals(m)) || (t.push(m), (n = m));
      }
    }
    return (
      this.autoClose &&
        t.length > 1 &&
        !t[t.length - 1].equals(t[0]) &&
        t.push(t[0]),
      t
    );
  }
  copy(e) {
    (super.copy(e), (this.curves = []));
    for (let t = 0, n = e.curves.length; t < n; t++) {
      const r = e.curves[t];
      this.curves.push(r.clone());
    }
    return ((this.autoClose = e.autoClose), this);
  }
  toJSON() {
    const e = super.toJSON();
    ((e.autoClose = this.autoClose), (e.curves = []));
    for (let t = 0, n = this.curves.length; t < n; t++) {
      const r = this.curves[t];
      e.curves.push(r.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    (super.fromJSON(e), (this.autoClose = e.autoClose), (this.curves = []));
    for (let t = 0, n = e.curves.length; t < n; t++) {
      const r = e.curves[t];
      this.curves.push(new P1[r.type]().fromJSON(r));
    }
    return this;
  }
}
class I1 extends gN {
  constructor(e) {
    (super(),
      (this.type = "Path"),
      (this.currentPoint = new nt()),
      e && this.setFromPoints(e));
  }
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let t = 1, n = e.length; t < n; t++) this.lineTo(e[t].x, e[t].y);
    return this;
  }
  moveTo(e, t) {
    return (this.currentPoint.set(e, t), this);
  }
  lineTo(e, t) {
    const n = new tE(this.currentPoint.clone(), new nt(e, t));
    return (this.curves.push(n), this.currentPoint.set(e, t), this);
  }
  quadraticCurveTo(e, t, n, r) {
    const s = new nE(this.currentPoint.clone(), new nt(e, t), new nt(n, r));
    return (this.curves.push(s), this.currentPoint.set(n, r), this);
  }
  bezierCurveTo(e, t, n, r, s, o) {
    const u = new eE(
      this.currentPoint.clone(),
      new nt(e, t),
      new nt(n, r),
      new nt(s, o),
    );
    return (this.curves.push(u), this.currentPoint.set(s, o), this);
  }
  splineThru(e) {
    const t = [this.currentPoint.clone()].concat(e),
      n = new rE(t);
    return (this.curves.push(n), this.currentPoint.copy(e[e.length - 1]), this);
  }
  arc(e, t, n, r, s, o) {
    const u = this.currentPoint.x,
      h = this.currentPoint.y;
    return (this.absarc(e + u, t + h, n, r, s, o), this);
  }
  absarc(e, t, n, r, s, o) {
    return (this.absellipse(e, t, n, n, r, s, o), this);
  }
  ellipse(e, t, n, r, s, o, u, h) {
    const d = this.currentPoint.x,
      m = this.currentPoint.y;
    return (this.absellipse(e + d, t + m, n, r, s, o, u, h), this);
  }
  absellipse(e, t, n, r, s, o, u, h) {
    const d = new vb(e, t, n, r, s, o, u, h);
    if (this.curves.length > 0) {
      const v = d.getPoint(0);
      v.equals(this.currentPoint) || this.lineTo(v.x, v.y);
    }
    this.curves.push(d);
    const m = d.getPoint(1);
    return (this.currentPoint.copy(m), this);
  }
  copy(e) {
    return (super.copy(e), this.currentPoint.copy(e.currentPoint), this);
  }
  toJSON() {
    const e = super.toJSON();
    return ((e.currentPoint = this.currentPoint.toArray()), e);
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.currentPoint.fromArray(e.currentPoint),
      this
    );
  }
}
class Ah extends I1 {
  constructor(e) {
    (super(e), (this.uuid = Ia()), (this.type = "Shape"), (this.holes = []));
  }
  getPointsHoles(e) {
    const t = [];
    for (let n = 0, r = this.holes.length; n < r; n++)
      t[n] = this.holes[n].getPoints(e);
    return t;
  }
  extractPoints(e) {
    return { shape: this.getPoints(e), holes: this.getPointsHoles(e) };
  }
  copy(e) {
    (super.copy(e), (this.holes = []));
    for (let t = 0, n = e.holes.length; t < n; t++) {
      const r = e.holes[t];
      this.holes.push(r.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    ((e.uuid = this.uuid), (e.holes = []));
    for (let t = 0, n = this.holes.length; t < n; t++) {
      const r = this.holes[t];
      e.holes.push(r.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    (super.fromJSON(e), (this.uuid = e.uuid), (this.holes = []));
    for (let t = 0, n = e.holes.length; t < n; t++) {
      const r = e.holes[t];
      this.holes.push(new I1().fromJSON(r));
    }
    return this;
  }
}
function Zk(i, e, t = 2) {
  const n = e && e.length,
    r = n ? e[0] * t : i.length;
  let s = vN(i, 0, r, t, !0);
  const o = [];
  if (!s || s.next === s.prev) return o;
  let u, h, d;
  if ((n && (s = e6(i, e, s, t)), i.length > 80 * t)) {
    ((u = i[0]), (h = i[1]));
    let m = u,
      v = h;
    for (let y = t; y < r; y += t) {
      const b = i[y],
        _ = i[y + 1];
      (b < u && (u = b), _ < h && (h = _), b > m && (m = b), _ > v && (v = _));
    }
    ((d = Math.max(m - u, v - h)), (d = d !== 0 ? 32767 / d : 0));
  }
  return (d0(s, o, t, u, h, d, 0), o);
}
function vN(i, e, t, n, r) {
  let s;
  if (r === f6(i, e, t, n) > 0)
    for (let o = e; o < t; o += n) s = TC((o / n) | 0, i[o], i[o + 1], s);
  else
    for (let o = t - n; o >= e; o -= n) s = TC((o / n) | 0, i[o], i[o + 1], s);
  return (s && Rp(s, s.next) && (m0(s), (s = s.next)), s);
}
function Ph(i, e) {
  if (!i) return i;
  e || (e = i);
  let t = i,
    n;
  do
    if (
      ((n = !1), !t.steiner && (Rp(t, t.next) || Oi(t.prev, t, t.next) === 0))
    ) {
      if ((m0(t), (t = e = t.prev), t === t.next)) break;
      n = !0;
    } else t = t.next;
  while (n || t !== e);
  return e;
}
function d0(i, e, t, n, r, s, o) {
  if (!i) return;
  !o && s && s6(i, n, r, s);
  let u = i;
  for (; i.prev !== i.next; ) {
    const h = i.prev,
      d = i.next;
    if (s ? Qk(i, n, r, s) : Kk(i)) {
      (e.push(h.i, i.i, d.i), m0(i), (i = d.next), (u = d.next));
      continue;
    }
    if (((i = d), i === u)) {
      o
        ? o === 1
          ? ((i = Jk(Ph(i), e)), d0(i, e, t, n, r, s, 2))
          : o === 2 && $k(i, e, t, n, r, s)
        : d0(Ph(i), e, t, n, r, s, 1);
      break;
    }
  }
}
function Kk(i) {
  const e = i.prev,
    t = i,
    n = i.next;
  if (Oi(e, t, n) >= 0) return !1;
  const r = e.x,
    s = t.x,
    o = n.x,
    u = e.y,
    h = t.y,
    d = n.y,
    m = Math.min(r, s, o),
    v = Math.min(u, h, d),
    y = Math.max(r, s, o),
    b = Math.max(u, h, d);
  let _ = n.next;
  for (; _ !== e; ) {
    if (
      _.x >= m &&
      _.x <= y &&
      _.y >= v &&
      _.y <= b &&
      Dg(r, u, s, h, o, d, _.x, _.y) &&
      Oi(_.prev, _, _.next) >= 0
    )
      return !1;
    _ = _.next;
  }
  return !0;
}
function Qk(i, e, t, n) {
  const r = i.prev,
    s = i,
    o = i.next;
  if (Oi(r, s, o) >= 0) return !1;
  const u = r.x,
    h = s.x,
    d = o.x,
    m = r.y,
    v = s.y,
    y = o.y,
    b = Math.min(u, h, d),
    _ = Math.min(m, v, y),
    w = Math.max(u, h, d),
    E = Math.max(m, v, y),
    T = AM(b, _, e, t, n),
    C = AM(w, E, e, t, n);
  let R = i.prevZ,
    L = i.nextZ;
  for (; R && R.z >= T && L && L.z <= C; ) {
    if (
      (R.x >= b &&
        R.x <= w &&
        R.y >= _ &&
        R.y <= E &&
        R !== r &&
        R !== o &&
        Dg(u, m, h, v, d, y, R.x, R.y) &&
        Oi(R.prev, R, R.next) >= 0) ||
      ((R = R.prevZ),
      L.x >= b &&
        L.x <= w &&
        L.y >= _ &&
        L.y <= E &&
        L !== r &&
        L !== o &&
        Dg(u, m, h, v, d, y, L.x, L.y) &&
        Oi(L.prev, L, L.next) >= 0)
    )
      return !1;
    L = L.nextZ;
  }
  for (; R && R.z >= T; ) {
    if (
      R.x >= b &&
      R.x <= w &&
      R.y >= _ &&
      R.y <= E &&
      R !== r &&
      R !== o &&
      Dg(u, m, h, v, d, y, R.x, R.y) &&
      Oi(R.prev, R, R.next) >= 0
    )
      return !1;
    R = R.prevZ;
  }
  for (; L && L.z <= C; ) {
    if (
      L.x >= b &&
      L.x <= w &&
      L.y >= _ &&
      L.y <= E &&
      L !== r &&
      L !== o &&
      Dg(u, m, h, v, d, y, L.x, L.y) &&
      Oi(L.prev, L, L.next) >= 0
    )
      return !1;
    L = L.nextZ;
  }
  return !0;
}
function Jk(i, e) {
  let t = i;
  do {
    const n = t.prev,
      r = t.next.next;
    (!Rp(n, r) &&
      xN(n, t, t.next, r) &&
      p0(n, r) &&
      p0(r, n) &&
      (e.push(n.i, t.i, r.i), m0(t), m0(t.next), (t = i = r)),
      (t = t.next));
  } while (t !== i);
  return Ph(t);
}
function $k(i, e, t, n, r, s) {
  let o = i;
  do {
    let u = o.next.next;
    for (; u !== o.prev; ) {
      if (o.i !== u.i && l6(o, u)) {
        let h = bN(o, u);
        ((o = Ph(o, o.next)),
          (h = Ph(h, h.next)),
          d0(o, e, t, n, r, s, 0),
          d0(h, e, t, n, r, s, 0));
        return;
      }
      u = u.next;
    }
    o = o.next;
  } while (o !== i);
}
function e6(i, e, t, n) {
  const r = [];
  for (let s = 0, o = e.length; s < o; s++) {
    const u = e[s] * n,
      h = s < o - 1 ? e[s + 1] * n : i.length,
      d = vN(i, u, h, n, !1);
    (d === d.next && (d.steiner = !0), r.push(o6(d)));
  }
  r.sort(t6);
  for (let s = 0; s < r.length; s++) t = n6(r[s], t);
  return t;
}
function t6(i, e) {
  let t = i.x - e.x;
  if (t === 0 && ((t = i.y - e.y), t === 0)) {
    const n = (i.next.y - i.y) / (i.next.x - i.x),
      r = (e.next.y - e.y) / (e.next.x - e.x);
    t = n - r;
  }
  return t;
}
function n6(i, e) {
  const t = i6(i, e);
  if (!t) return e;
  const n = bN(t, i);
  return (Ph(n, n.next), Ph(t, t.next));
}
function i6(i, e) {
  let t = e;
  const n = i.x,
    r = i.y;
  let s = -1 / 0,
    o;
  if (Rp(i, t)) return t;
  do {
    if (Rp(i, t.next)) return t.next;
    if (r <= t.y && r >= t.next.y && t.next.y !== t.y) {
      const v = t.x + ((r - t.y) * (t.next.x - t.x)) / (t.next.y - t.y);
      if (
        v <= n &&
        v > s &&
        ((s = v), (o = t.x < t.next.x ? t : t.next), v === n)
      )
        return o;
    }
    t = t.next;
  } while (t !== e);
  if (!o) return null;
  const u = o,
    h = o.x,
    d = o.y;
  let m = 1 / 0;
  t = o;
  do {
    if (
      n >= t.x &&
      t.x >= h &&
      n !== t.x &&
      yN(r < d ? n : s, r, h, d, r < d ? s : n, r, t.x, t.y)
    ) {
      const v = Math.abs(r - t.y) / (n - t.x);
      p0(t, i) &&
        (v < m || (v === m && (t.x > o.x || (t.x === o.x && r6(o, t))))) &&
        ((o = t), (m = v));
    }
    t = t.next;
  } while (t !== u);
  return o;
}
function r6(i, e) {
  return Oi(i.prev, i, e.prev) < 0 && Oi(e.next, i, i.next) < 0;
}
function s6(i, e, t, n) {
  let r = i;
  do
    (r.z === 0 && (r.z = AM(r.x, r.y, e, t, n)),
      (r.prevZ = r.prev),
      (r.nextZ = r.next),
      (r = r.next));
  while (r !== i);
  ((r.prevZ.nextZ = null), (r.prevZ = null), a6(r));
}
function a6(i) {
  let e,
    t = 1;
  do {
    let n = i,
      r;
    i = null;
    let s = null;
    for (e = 0; n; ) {
      e++;
      let o = n,
        u = 0;
      for (let d = 0; d < t && (u++, (o = o.nextZ), !!o); d++);
      let h = t;
      for (; u > 0 || (h > 0 && o); )
        (u !== 0 && (h === 0 || !o || n.z <= o.z)
          ? ((r = n), (n = n.nextZ), u--)
          : ((r = o), (o = o.nextZ), h--),
          s ? (s.nextZ = r) : (i = r),
          (r.prevZ = s),
          (s = r));
      n = o;
    }
    ((s.nextZ = null), (t *= 2));
  } while (e > 1);
  return i;
}
function AM(i, e, t, n, r) {
  return (
    (i = ((i - t) * r) | 0),
    (e = ((e - n) * r) | 0),
    (i = (i | (i << 8)) & 16711935),
    (i = (i | (i << 4)) & 252645135),
    (i = (i | (i << 2)) & 858993459),
    (i = (i | (i << 1)) & 1431655765),
    (e = (e | (e << 8)) & 16711935),
    (e = (e | (e << 4)) & 252645135),
    (e = (e | (e << 2)) & 858993459),
    (e = (e | (e << 1)) & 1431655765),
    i | (e << 1)
  );
}
function o6(i) {
  let e = i,
    t = i;
  do ((e.x < t.x || (e.x === t.x && e.y < t.y)) && (t = e), (e = e.next));
  while (e !== i);
  return t;
}
function yN(i, e, t, n, r, s, o, u) {
  return (
    (r - o) * (e - u) >= (i - o) * (s - u) &&
    (i - o) * (n - u) >= (t - o) * (e - u) &&
    (t - o) * (s - u) >= (r - o) * (n - u)
  );
}
function Dg(i, e, t, n, r, s, o, u) {
  return !(i === o && e === u) && yN(i, e, t, n, r, s, o, u);
}
function l6(i, e) {
  return (
    i.next.i !== e.i &&
    i.prev.i !== e.i &&
    !c6(i, e) &&
    ((p0(i, e) &&
      p0(e, i) &&
      u6(i, e) &&
      (Oi(i.prev, i, e.prev) || Oi(i, e.prev, e))) ||
      (Rp(i, e) && Oi(i.prev, i, i.next) > 0 && Oi(e.prev, e, e.next) > 0))
  );
}
function Oi(i, e, t) {
  return (e.y - i.y) * (t.x - e.x) - (e.x - i.x) * (t.y - e.y);
}
function Rp(i, e) {
  return i.x === e.x && i.y === e.y;
}
function xN(i, e, t, n) {
  const r = $y(Oi(i, e, t)),
    s = $y(Oi(i, e, n)),
    o = $y(Oi(t, n, i)),
    u = $y(Oi(t, n, e));
  return !!(
    (r !== s && o !== u) ||
    (r === 0 && Jy(i, t, e)) ||
    (s === 0 && Jy(i, n, e)) ||
    (o === 0 && Jy(t, i, n)) ||
    (u === 0 && Jy(t, e, n))
  );
}
function Jy(i, e, t) {
  return (
    e.x <= Math.max(i.x, t.x) &&
    e.x >= Math.min(i.x, t.x) &&
    e.y <= Math.max(i.y, t.y) &&
    e.y >= Math.min(i.y, t.y)
  );
}
function $y(i) {
  return i > 0 ? 1 : i < 0 ? -1 : 0;
}
function c6(i, e) {
  let t = i;
  do {
    if (
      t.i !== i.i &&
      t.next.i !== i.i &&
      t.i !== e.i &&
      t.next.i !== e.i &&
      xN(t, t.next, i, e)
    )
      return !0;
    t = t.next;
  } while (t !== i);
  return !1;
}
function p0(i, e) {
  return Oi(i.prev, i, i.next) < 0
    ? Oi(i, e, i.next) >= 0 && Oi(i, i.prev, e) >= 0
    : Oi(i, e, i.prev) < 0 || Oi(i, i.next, e) < 0;
}
function u6(i, e) {
  let t = i,
    n = !1;
  const r = (i.x + e.x) / 2,
    s = (i.y + e.y) / 2;
  do
    (t.y > s != t.next.y > s &&
      t.next.y !== t.y &&
      r < ((t.next.x - t.x) * (s - t.y)) / (t.next.y - t.y) + t.x &&
      (n = !n),
      (t = t.next));
  while (t !== i);
  return n;
}
function bN(i, e) {
  const t = CM(i.i, i.x, i.y),
    n = CM(e.i, e.x, e.y),
    r = i.next,
    s = e.prev;
  return (
    (i.next = e),
    (e.prev = i),
    (t.next = r),
    (r.prev = t),
    (n.next = t),
    (t.prev = n),
    (s.next = n),
    (n.prev = s),
    n
  );
}
function TC(i, e, t, n) {
  const r = CM(i, e, t);
  return (
    n
      ? ((r.next = n.next), (r.prev = n), (n.next.prev = r), (n.next = r))
      : ((r.prev = r), (r.next = r)),
    r
  );
}
function m0(i) {
  ((i.next.prev = i.prev),
    (i.prev.next = i.next),
    i.prevZ && (i.prevZ.nextZ = i.nextZ),
    i.nextZ && (i.nextZ.prevZ = i.prevZ));
}
function CM(i, e, t) {
  return {
    i,
    x: e,
    y: t,
    prev: null,
    next: null,
    z: 0,
    prevZ: null,
    nextZ: null,
    steiner: !1,
  };
}
function f6(i, e, t, n) {
  let r = 0;
  for (let s = e, o = t - n; s < t; s += n)
    ((r += (i[o] - i[s]) * (i[s + 1] + i[o + 1])), (o = s));
  return r;
}
class h6 {
  static triangulate(e, t, n = 2) {
    return Zk(e, t, n);
  }
}
class qo {
  static area(e) {
    const t = e.length;
    let n = 0;
    for (let r = t - 1, s = 0; s < t; r = s++)
      n += e[r].x * e[s].y - e[s].x * e[r].y;
    return n * 0.5;
  }
  static isClockWise(e) {
    return qo.area(e) < 0;
  }
  static triangulateShape(e, t) {
    const n = [],
      r = [],
      s = [];
    (EC(e), wC(n, e));
    let o = e.length;
    t.forEach(EC);
    for (let h = 0; h < t.length; h++)
      (r.push(o), (o += t[h].length), wC(n, t[h]));
    const u = h6.triangulate(n, r);
    for (let h = 0; h < u.length; h += 3) s.push(u.slice(h, h + 3));
    return s;
  }
}
function EC(i) {
  const e = i.length;
  e > 2 && i[e - 1].equals(i[0]) && i.pop();
}
function wC(i, e) {
  for (let t = 0; t < e.length; t++) (i.push(e[t].x), i.push(e[t].y));
}
class yb extends nn {
  constructor(
    e = new Ah([
      new nt(0.5, 0.5),
      new nt(-0.5, 0.5),
      new nt(-0.5, -0.5),
      new nt(0.5, -0.5),
    ]),
    t = {},
  ) {
    (super(),
      (this.type = "ExtrudeGeometry"),
      (this.parameters = { shapes: e, options: t }),
      (e = Array.isArray(e) ? e : [e]));
    const n = this,
      r = [],
      s = [];
    for (let u = 0, h = e.length; u < h; u++) {
      const d = e[u];
      o(d);
    }
    (this.setAttribute("position", new Rt(r, 3)),
      this.setAttribute("uv", new Rt(s, 2)),
      this.computeVertexNormals());
    function o(u) {
      const h = [],
        d = t.curveSegments !== void 0 ? t.curveSegments : 12,
        m = t.steps !== void 0 ? t.steps : 1,
        v = t.depth !== void 0 ? t.depth : 1;
      let y = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0,
        b = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2,
        _ = t.bevelSize !== void 0 ? t.bevelSize : b - 0.1,
        w = t.bevelOffset !== void 0 ? t.bevelOffset : 0,
        E = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
      const T = t.extrudePath,
        C = t.UVGenerator !== void 0 ? t.UVGenerator : d6;
      let R,
        L = !1,
        I,
        O,
        B,
        N;
      if (T) {
        ((R = T.getSpacedPoints(m)), (L = !0), (y = !1));
        const Re = T.isCatmullRomCurve3 ? T.closed : !1;
        ((I = T.computeFrenetFrames(m, Re)),
          (O = new te()),
          (B = new te()),
          (N = new te()));
      }
      y || ((E = 0), (b = 0), (_ = 0), (w = 0));
      const F = u.extractPoints(d);
      let j = F.shape;
      const q = F.holes;
      if (!qo.isClockWise(j)) {
        j = j.reverse();
        for (let Re = 0, Ie = q.length; Re < Ie; Re++) {
          const De = q[Re];
          qo.isClockWise(De) && (q[Re] = De.reverse());
        }
      }
      function J(Re) {
        const De = 10000000000000001e-36;
        let Qe = Re[0];
        for (let K = 1; K <= Re.length; K++) {
          const rt = K % Re.length,
            je = Re[rt],
            Te = je.x - Qe.x,
            ke = je.y - Qe.y,
            H = Te * Te + ke * ke,
            k = Math.max(
              Math.abs(je.x),
              Math.abs(je.y),
              Math.abs(Qe.x),
              Math.abs(Qe.y),
            ),
            oe = De * k * k;
          if (H <= oe) {
            (Re.splice(rt, 1), K--);
            continue;
          }
          Qe = je;
        }
      }
      (J(j), q.forEach(J));
      const ee = q.length,
        ne = j;
      for (let Re = 0; Re < ee; Re++) {
        const Ie = q[Re];
        j = j.concat(Ie);
      }
      function W(Re, Ie, De) {
        return (
          Ie || Ft("ExtrudeGeometry: vec does not exist"),
          Re.clone().addScaledVector(Ie, De)
        );
      }
      const $ = j.length;
      function de(Re, Ie, De) {
        let Qe, K, rt;
        const je = Re.x - Ie.x,
          Te = Re.y - Ie.y,
          ke = De.x - Re.x,
          H = De.y - Re.y,
          k = je * je + Te * Te,
          oe = je * H - Te * ke;
        if (Math.abs(oe) > Number.EPSILON) {
          const Ae = Math.sqrt(k),
            _e = Math.sqrt(ke * ke + H * H),
            be = Ie.x - Te / Ae,
            et = Ie.y + je / Ae,
            $e = De.x - H / _e,
            ht = De.y + ke / _e,
            yt = (($e - be) * H - (ht - et) * ke) / (je * H - Te * ke);
          ((Qe = be + je * yt - Re.x), (K = et + Te * yt - Re.y));
          const Ge = Qe * Qe + K * K;
          if (Ge <= 2) return new nt(Qe, K);
          rt = Math.sqrt(Ge / 2);
        } else {
          let Ae = !1;
          (je > Number.EPSILON
            ? ke > Number.EPSILON && (Ae = !0)
            : je < -Number.EPSILON
              ? ke < -Number.EPSILON && (Ae = !0)
              : Math.sign(Te) === Math.sign(H) && (Ae = !0),
            Ae
              ? ((Qe = -Te), (K = je), (rt = Math.sqrt(k)))
              : ((Qe = je), (K = Te), (rt = Math.sqrt(k / 2))));
        }
        return new nt(Qe / rt, K / rt);
      }
      const le = [];
      for (
        let Re = 0, Ie = ne.length, De = Ie - 1, Qe = Re + 1;
        Re < Ie;
        Re++, De++, Qe++
      )
        (De === Ie && (De = 0),
          Qe === Ie && (Qe = 0),
          (le[Re] = de(ne[Re], ne[De], ne[Qe])));
      const fe = [];
      let V,
        Z = le.concat();
      for (let Re = 0, Ie = ee; Re < Ie; Re++) {
        const De = q[Re];
        V = [];
        for (
          let Qe = 0, K = De.length, rt = K - 1, je = Qe + 1;
          Qe < K;
          Qe++, rt++, je++
        )
          (rt === K && (rt = 0),
            je === K && (je = 0),
            (V[Qe] = de(De[Qe], De[rt], De[je])));
        (fe.push(V), (Z = Z.concat(V)));
      }
      let se;
      if (E === 0) se = qo.triangulateShape(ne, q);
      else {
        const Re = [],
          Ie = [];
        for (let De = 0; De < E; De++) {
          const Qe = De / E,
            K = b * Math.cos((Qe * Math.PI) / 2),
            rt = _ * Math.sin((Qe * Math.PI) / 2) + w;
          for (let je = 0, Te = ne.length; je < Te; je++) {
            const ke = W(ne[je], le[je], rt);
            (ze(ke.x, ke.y, -K), Qe === 0 && Re.push(ke));
          }
          for (let je = 0, Te = ee; je < Te; je++) {
            const ke = q[je];
            V = fe[je];
            const H = [];
            for (let k = 0, oe = ke.length; k < oe; k++) {
              const Ae = W(ke[k], V[k], rt);
              (ze(Ae.x, Ae.y, -K), Qe === 0 && H.push(Ae));
            }
            Qe === 0 && Ie.push(H);
          }
        }
        se = qo.triangulateShape(Re, Ie);
      }
      const ue = se.length,
        ge = _ + w;
      for (let Re = 0; Re < $; Re++) {
        const Ie = y ? W(j[Re], Z[Re], ge) : j[Re];
        L
          ? (B.copy(I.normals[0]).multiplyScalar(Ie.x),
            O.copy(I.binormals[0]).multiplyScalar(Ie.y),
            N.copy(R[0]).add(B).add(O),
            ze(N.x, N.y, N.z))
          : ze(Ie.x, Ie.y, 0);
      }
      for (let Re = 1; Re <= m; Re++)
        for (let Ie = 0; Ie < $; Ie++) {
          const De = y ? W(j[Ie], Z[Ie], ge) : j[Ie];
          L
            ? (B.copy(I.normals[Re]).multiplyScalar(De.x),
              O.copy(I.binormals[Re]).multiplyScalar(De.y),
              N.copy(R[Re]).add(B).add(O),
              ze(N.x, N.y, N.z))
            : ze(De.x, De.y, (v / m) * Re);
        }
      for (let Re = E - 1; Re >= 0; Re--) {
        const Ie = Re / E,
          De = b * Math.cos((Ie * Math.PI) / 2),
          Qe = _ * Math.sin((Ie * Math.PI) / 2) + w;
        for (let K = 0, rt = ne.length; K < rt; K++) {
          const je = W(ne[K], le[K], Qe);
          ze(je.x, je.y, v + De);
        }
        for (let K = 0, rt = q.length; K < rt; K++) {
          const je = q[K];
          V = fe[K];
          for (let Te = 0, ke = je.length; Te < ke; Te++) {
            const H = W(je[Te], V[Te], Qe);
            L
              ? ze(H.x, H.y + R[m - 1].y, R[m - 1].x + De)
              : ze(H.x, H.y, v + De);
          }
        }
      }
      (ae(), he());
      function ae() {
        const Re = r.length / 3;
        if (y) {
          let Ie = 0,
            De = $ * Ie;
          for (let Qe = 0; Qe < ue; Qe++) {
            const K = se[Qe];
            it(K[2] + De, K[1] + De, K[0] + De);
          }
          ((Ie = m + E * 2), (De = $ * Ie));
          for (let Qe = 0; Qe < ue; Qe++) {
            const K = se[Qe];
            it(K[0] + De, K[1] + De, K[2] + De);
          }
        } else {
          for (let Ie = 0; Ie < ue; Ie++) {
            const De = se[Ie];
            it(De[2], De[1], De[0]);
          }
          for (let Ie = 0; Ie < ue; Ie++) {
            const De = se[Ie];
            it(De[0] + $ * m, De[1] + $ * m, De[2] + $ * m);
          }
        }
        n.addGroup(Re, r.length / 3 - Re, 0);
      }
      function he() {
        const Re = r.length / 3;
        let Ie = 0;
        (ye(ne, Ie), (Ie += ne.length));
        for (let De = 0, Qe = q.length; De < Qe; De++) {
          const K = q[De];
          (ye(K, Ie), (Ie += K.length));
        }
        n.addGroup(Re, r.length / 3 - Re, 1);
      }
      function ye(Re, Ie) {
        let De = Re.length;
        for (; --De >= 0; ) {
          const Qe = De;
          let K = De - 1;
          K < 0 && (K = Re.length - 1);
          for (let rt = 0, je = m + E * 2; rt < je; rt++) {
            const Te = $ * rt,
              ke = $ * (rt + 1),
              H = Ie + Qe + Te,
              k = Ie + K + Te,
              oe = Ie + K + ke,
              Ae = Ie + Qe + ke;
            qe(H, k, oe, Ae);
          }
        }
      }
      function ze(Re, Ie, De) {
        (h.push(Re), h.push(Ie), h.push(De));
      }
      function it(Re, Ie, De) {
        (Ye(Re), Ye(Ie), Ye(De));
        const Qe = r.length / 3,
          K = C.generateTopUV(n, r, Qe - 3, Qe - 2, Qe - 1);
        (ft(K[0]), ft(K[1]), ft(K[2]));
      }
      function qe(Re, Ie, De, Qe) {
        (Ye(Re), Ye(Ie), Ye(Qe), Ye(Ie), Ye(De), Ye(Qe));
        const K = r.length / 3,
          rt = C.generateSideWallUV(n, r, K - 6, K - 3, K - 2, K - 1);
        (ft(rt[0]), ft(rt[1]), ft(rt[3]), ft(rt[1]), ft(rt[2]), ft(rt[3]));
      }
      function Ye(Re) {
        (r.push(h[Re * 3 + 0]), r.push(h[Re * 3 + 1]), r.push(h[Re * 3 + 2]));
      }
      function ft(Re) {
        (s.push(Re.x), s.push(Re.y));
      }
    }
  }
  copy(e) {
    return (
      super.copy(e),
      (this.parameters = Object.assign({}, e.parameters)),
      this
    );
  }
  toJSON() {
    const e = super.toJSON(),
      t = this.parameters.shapes,
      n = this.parameters.options;
    return p6(t, n, e);
  }
  static fromJSON(e, t) {
    const n = [];
    for (let s = 0, o = e.shapes.length; s < o; s++) {
      const u = t[e.shapes[s]];
      n.push(u);
    }
    const r = e.options.extrudePath;
    return (
      r !== void 0 && (e.options.extrudePath = new P1[r.type]().fromJSON(r)),
      new yb(n, e.options)
    );
  }
}
const d6 = {
  generateTopUV: function (i, e, t, n, r) {
    const s = e[t * 3],
      o = e[t * 3 + 1],
      u = e[n * 3],
      h = e[n * 3 + 1],
      d = e[r * 3],
      m = e[r * 3 + 1];
    return [new nt(s, o), new nt(u, h), new nt(d, m)];
  },
  generateSideWallUV: function (i, e, t, n, r, s) {
    const o = e[t * 3],
      u = e[t * 3 + 1],
      h = e[t * 3 + 2],
      d = e[n * 3],
      m = e[n * 3 + 1],
      v = e[n * 3 + 2],
      y = e[r * 3],
      b = e[r * 3 + 1],
      _ = e[r * 3 + 2],
      w = e[s * 3],
      E = e[s * 3 + 1],
      T = e[s * 3 + 2];
    return Math.abs(u - m) < Math.abs(o - d)
      ? [new nt(o, 1 - h), new nt(d, 1 - v), new nt(y, 1 - _), new nt(w, 1 - T)]
      : [
          new nt(u, 1 - h),
          new nt(m, 1 - v),
          new nt(b, 1 - _),
          new nt(E, 1 - T),
        ];
  },
};
function p6(i, e, t) {
  if (((t.shapes = []), Array.isArray(i)))
    for (let n = 0, r = i.length; n < r; n++) {
      const s = i[n];
      t.shapes.push(s.uuid);
    }
  else t.shapes.push(i.uuid);
  return (
    (t.options = Object.assign({}, e)),
    e.extrudePath !== void 0 &&
      (t.options.extrudePath = e.extrudePath.toJSON()),
    t
  );
}
class xb extends df {
  constructor(e = 1, t = 0) {
    const n = (1 + Math.sqrt(5)) / 2,
      r = [
        -1,
        n,
        0,
        1,
        n,
        0,
        -1,
        -n,
        0,
        1,
        -n,
        0,
        0,
        -1,
        n,
        0,
        1,
        n,
        0,
        -1,
        -n,
        0,
        1,
        -n,
        n,
        0,
        -1,
        n,
        0,
        1,
        -n,
        0,
        -1,
        -n,
        0,
        1,
      ],
      s = [
        0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11,
        10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9,
        4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
      ];
    (super(r, s, e, t),
      (this.type = "IcosahedronGeometry"),
      (this.parameters = { radius: e, detail: t }));
  }
  static fromJSON(e) {
    return new xb(e.radius, e.detail);
  }
}
class bb extends nn {
  constructor(
    e = [new nt(0, -0.5), new nt(0.5, 0), new nt(0, 0.5)],
    t = 12,
    n = 0,
    r = Math.PI * 2,
  ) {
    (super(),
      (this.type = "LatheGeometry"),
      (this.parameters = { points: e, segments: t, phiStart: n, phiLength: r }),
      (t = Math.floor(t)),
      (r = Yt(r, 0, Math.PI * 2)));
    const s = [],
      o = [],
      u = [],
      h = [],
      d = [],
      m = 1 / t,
      v = new te(),
      y = new nt(),
      b = new te(),
      _ = new te(),
      w = new te();
    let E = 0,
      T = 0;
    for (let C = 0; C <= e.length - 1; C++)
      switch (C) {
        case 0:
          ((E = e[C + 1].x - e[C].x),
            (T = e[C + 1].y - e[C].y),
            (b.x = T * 1),
            (b.y = -E),
            (b.z = T * 0),
            w.copy(b),
            b.normalize(),
            h.push(b.x, b.y, b.z));
          break;
        case e.length - 1:
          h.push(w.x, w.y, w.z);
          break;
        default:
          ((E = e[C + 1].x - e[C].x),
            (T = e[C + 1].y - e[C].y),
            (b.x = T * 1),
            (b.y = -E),
            (b.z = T * 0),
            _.copy(b),
            (b.x += w.x),
            (b.y += w.y),
            (b.z += w.z),
            b.normalize(),
            h.push(b.x, b.y, b.z),
            w.copy(_));
      }
    for (let C = 0; C <= t; C++) {
      const R = n + C * m * r,
        L = Math.sin(R),
        I = Math.cos(R);
      for (let O = 0; O <= e.length - 1; O++) {
        ((v.x = e[O].x * L),
          (v.y = e[O].y),
          (v.z = e[O].x * I),
          o.push(v.x, v.y, v.z),
          (y.x = C / t),
          (y.y = O / (e.length - 1)),
          u.push(y.x, y.y));
        const B = h[3 * O + 0] * L,
          N = h[3 * O + 1],
          F = h[3 * O + 0] * I;
        d.push(B, N, F);
      }
    }
    for (let C = 0; C < t; C++)
      for (let R = 0; R < e.length - 1; R++) {
        const L = R + C * e.length,
          I = L,
          O = L + e.length,
          B = L + e.length + 1,
          N = L + 1;
        (s.push(I, O, N), s.push(B, N, O));
      }
    (this.setIndex(s),
      this.setAttribute("position", new Rt(o, 3)),
      this.setAttribute("uv", new Rt(u, 2)),
      this.setAttribute("normal", new Rt(d, 3)));
  }
  copy(e) {
    return (
      super.copy(e),
      (this.parameters = Object.assign({}, e.parameters)),
      this
    );
  }
  static fromJSON(e) {
    return new bb(e.points, e.segments, e.phiStart, e.phiLength);
  }
}
class I0 extends df {
  constructor(e = 1, t = 0) {
    const n = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
      r = [
        0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2,
      ];
    (super(n, r, e, t),
      (this.type = "OctahedronGeometry"),
      (this.parameters = { radius: e, detail: t }));
  }
  static fromJSON(e) {
    return new I0(e.radius, e.detail);
  }
}
class $c extends nn {
  constructor(e = 1, t = 1, n = 1, r = 1) {
    (super(),
      (this.type = "PlaneGeometry"),
      (this.parameters = {
        width: e,
        height: t,
        widthSegments: n,
        heightSegments: r,
      }));
    const s = e / 2,
      o = t / 2,
      u = Math.floor(n),
      h = Math.floor(r),
      d = u + 1,
      m = h + 1,
      v = e / u,
      y = t / h,
      b = [],
      _ = [],
      w = [],
      E = [];
    for (let T = 0; T < m; T++) {
      const C = T * y - o;
      for (let R = 0; R < d; R++) {
        const L = R * v - s;
        (_.push(L, -C, 0), w.push(0, 0, 1), E.push(R / u), E.push(1 - T / h));
      }
    }
    for (let T = 0; T < h; T++)
      for (let C = 0; C < u; C++) {
        const R = C + d * T,
          L = C + d * (T + 1),
          I = C + 1 + d * (T + 1),
          O = C + 1 + d * T;
        (b.push(R, L, O), b.push(L, I, O));
      }
    (this.setIndex(b),
      this.setAttribute("position", new Rt(_, 3)),
      this.setAttribute("normal", new Rt(w, 3)),
      this.setAttribute("uv", new Rt(E, 2)));
  }
  copy(e) {
    return (
      super.copy(e),
      (this.parameters = Object.assign({}, e.parameters)),
      this
    );
  }
  static fromJSON(e) {
    return new $c(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
class _b extends nn {
  constructor(e = 0.5, t = 1, n = 32, r = 1, s = 0, o = Math.PI * 2) {
    (super(),
      (this.type = "RingGeometry"),
      (this.parameters = {
        innerRadius: e,
        outerRadius: t,
        thetaSegments: n,
        phiSegments: r,
        thetaStart: s,
        thetaLength: o,
      }),
      (n = Math.max(3, n)),
      (r = Math.max(1, r)));
    const u = [],
      h = [],
      d = [],
      m = [];
    let v = e;
    const y = (t - e) / r,
      b = new te(),
      _ = new nt();
    for (let w = 0; w <= r; w++) {
      for (let E = 0; E <= n; E++) {
        const T = s + (E / n) * o;
        ((b.x = v * Math.cos(T)),
          (b.y = v * Math.sin(T)),
          h.push(b.x, b.y, b.z),
          d.push(0, 0, 1),
          (_.x = (b.x / t + 1) / 2),
          (_.y = (b.y / t + 1) / 2),
          m.push(_.x, _.y));
      }
      v += y;
    }
    for (let w = 0; w < r; w++) {
      const E = w * (n + 1);
      for (let T = 0; T < n; T++) {
        const C = T + E,
          R = C,
          L = C + n + 1,
          I = C + n + 2,
          O = C + 1;
        (u.push(R, L, O), u.push(L, I, O));
      }
    }
    (this.setIndex(u),
      this.setAttribute("position", new Rt(h, 3)),
      this.setAttribute("normal", new Rt(d, 3)),
      this.setAttribute("uv", new Rt(m, 2)));
  }
  copy(e) {
    return (
      super.copy(e),
      (this.parameters = Object.assign({}, e.parameters)),
      this
    );
  }
  static fromJSON(e) {
    return new _b(
      e.innerRadius,
      e.outerRadius,
      e.thetaSegments,
      e.phiSegments,
      e.thetaStart,
      e.thetaLength,
    );
  }
}
class Sb extends nn {
  constructor(
    e = new Ah([new nt(0, 0.5), new nt(-0.5, -0.5), new nt(0.5, -0.5)]),
    t = 12,
  ) {
    (super(),
      (this.type = "ShapeGeometry"),
      (this.parameters = { shapes: e, curveSegments: t }));
    const n = [],
      r = [],
      s = [],
      o = [];
    let u = 0,
      h = 0;
    if (Array.isArray(e) === !1) d(e);
    else
      for (let m = 0; m < e.length; m++)
        (d(e[m]), this.addGroup(u, h, m), (u += h), (h = 0));
    (this.setIndex(n),
      this.setAttribute("position", new Rt(r, 3)),
      this.setAttribute("normal", new Rt(s, 3)),
      this.setAttribute("uv", new Rt(o, 2)));
    function d(m) {
      const v = r.length / 3,
        y = m.extractPoints(t);
      let b = y.shape;
      const _ = y.holes;
      qo.isClockWise(b) === !1 && (b = b.reverse());
      for (let E = 0, T = _.length; E < T; E++) {
        const C = _[E];
        qo.isClockWise(C) === !0 && (_[E] = C.reverse());
      }
      const w = qo.triangulateShape(b, _);
      for (let E = 0, T = _.length; E < T; E++) {
        const C = _[E];
        b = b.concat(C);
      }
      for (let E = 0, T = b.length; E < T; E++) {
        const C = b[E];
        (r.push(C.x, C.y, 0), s.push(0, 0, 1), o.push(C.x, C.y));
      }
      for (let E = 0, T = w.length; E < T; E++) {
        const C = w[E],
          R = C[0] + v,
          L = C[1] + v,
          I = C[2] + v;
        (n.push(R, L, I), (h += 3));
      }
    }
  }
  copy(e) {
    return (
      super.copy(e),
      (this.parameters = Object.assign({}, e.parameters)),
      this
    );
  }
  toJSON() {
    const e = super.toJSON(),
      t = this.parameters.shapes;
    return m6(t, e);
  }
  static fromJSON(e, t) {
    const n = [];
    for (let r = 0, s = e.shapes.length; r < s; r++) {
      const o = t[e.shapes[r]];
      n.push(o);
    }
    return new Sb(n, e.curveSegments);
  }
}
function m6(i, e) {
  if (((e.shapes = []), Array.isArray(i)))
    for (let t = 0, n = i.length; t < n; t++) {
      const r = i[t];
      e.shapes.push(r.uuid);
    }
  else e.shapes.push(i.uuid);
  return e;
}
class O0 extends nn {
  constructor(
    e = 1,
    t = 32,
    n = 16,
    r = 0,
    s = Math.PI * 2,
    o = 0,
    u = Math.PI,
  ) {
    (super(),
      (this.type = "SphereGeometry"),
      (this.parameters = {
        radius: e,
        widthSegments: t,
        heightSegments: n,
        phiStart: r,
        phiLength: s,
        thetaStart: o,
        thetaLength: u,
      }),
      (t = Math.max(3, Math.floor(t))),
      (n = Math.max(2, Math.floor(n))));
    const h = Math.min(o + u, Math.PI);
    let d = 0;
    const m = [],
      v = new te(),
      y = new te(),
      b = [],
      _ = [],
      w = [],
      E = [];
    for (let T = 0; T <= n; T++) {
      const C = [],
        R = T / n;
      let L = 0;
      T === 0 && o === 0
        ? (L = 0.5 / t)
        : T === n && h === Math.PI && (L = -0.5 / t);
      for (let I = 0; I <= t; I++) {
        const O = I / t;
        ((v.x = -e * Math.cos(r + O * s) * Math.sin(o + R * u)),
          (v.y = e * Math.cos(o + R * u)),
          (v.z = e * Math.sin(r + O * s) * Math.sin(o + R * u)),
          _.push(v.x, v.y, v.z),
          y.copy(v).normalize(),
          w.push(y.x, y.y, y.z),
          E.push(O + L, 1 - R),
          C.push(d++));
      }
      m.push(C);
    }
    for (let T = 0; T < n; T++)
      for (let C = 0; C < t; C++) {
        const R = m[T][C + 1],
          L = m[T][C],
          I = m[T + 1][C],
          O = m[T + 1][C + 1];
        ((T !== 0 || o > 0) && b.push(R, L, O),
          (T !== n - 1 || h < Math.PI) && b.push(L, I, O));
      }
    (this.setIndex(b),
      this.setAttribute("position", new Rt(_, 3)),
      this.setAttribute("normal", new Rt(w, 3)),
      this.setAttribute("uv", new Rt(E, 2)));
  }
  copy(e) {
    return (
      super.copy(e),
      (this.parameters = Object.assign({}, e.parameters)),
      this
    );
  }
  static fromJSON(e) {
    return new O0(
      e.radius,
      e.widthSegments,
      e.heightSegments,
      e.phiStart,
      e.phiLength,
      e.thetaStart,
      e.thetaLength,
    );
  }
}
class Mb extends df {
  constructor(e = 1, t = 0) {
    const n = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
      r = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
    (super(n, r, e, t),
      (this.type = "TetrahedronGeometry"),
      (this.parameters = { radius: e, detail: t }));
  }
  static fromJSON(e) {
    return new Mb(e.radius, e.detail);
  }
}
class Tb extends nn {
  constructor(
    e = 1,
    t = 0.4,
    n = 12,
    r = 48,
    s = Math.PI * 2,
    o = 0,
    u = Math.PI * 2,
  ) {
    (super(),
      (this.type = "TorusGeometry"),
      (this.parameters = {
        radius: e,
        tube: t,
        radialSegments: n,
        tubularSegments: r,
        arc: s,
        thetaStart: o,
        thetaLength: u,
      }),
      (n = Math.floor(n)),
      (r = Math.floor(r)));
    const h = [],
      d = [],
      m = [],
      v = [],
      y = new te(),
      b = new te(),
      _ = new te();
    for (let w = 0; w <= n; w++) {
      const E = o + (w / n) * u;
      for (let T = 0; T <= r; T++) {
        const C = (T / r) * s;
        ((b.x = (e + t * Math.cos(E)) * Math.cos(C)),
          (b.y = (e + t * Math.cos(E)) * Math.sin(C)),
          (b.z = t * Math.sin(E)),
          d.push(b.x, b.y, b.z),
          (y.x = e * Math.cos(C)),
          (y.y = e * Math.sin(C)),
          _.subVectors(b, y).normalize(),
          m.push(_.x, _.y, _.z),
          v.push(T / r),
          v.push(w / n));
      }
    }
    for (let w = 1; w <= n; w++)
      for (let E = 1; E <= r; E++) {
        const T = (r + 1) * w + E - 1,
          C = (r + 1) * (w - 1) + E - 1,
          R = (r + 1) * (w - 1) + E,
          L = (r + 1) * w + E;
        (h.push(T, C, L), h.push(C, R, L));
      }
    (this.setIndex(h),
      this.setAttribute("position", new Rt(d, 3)),
      this.setAttribute("normal", new Rt(m, 3)),
      this.setAttribute("uv", new Rt(v, 2)));
  }
  copy(e) {
    return (
      super.copy(e),
      (this.parameters = Object.assign({}, e.parameters)),
      this
    );
  }
  static fromJSON(e) {
    return new Tb(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
  }
}
class Eb extends nn {
  constructor(e = 1, t = 0.4, n = 64, r = 8, s = 2, o = 3) {
    (super(),
      (this.type = "TorusKnotGeometry"),
      (this.parameters = {
        radius: e,
        tube: t,
        tubularSegments: n,
        radialSegments: r,
        p: s,
        q: o,
      }),
      (n = Math.floor(n)),
      (r = Math.floor(r)));
    const u = [],
      h = [],
      d = [],
      m = [],
      v = new te(),
      y = new te(),
      b = new te(),
      _ = new te(),
      w = new te(),
      E = new te(),
      T = new te();
    for (let R = 0; R <= n; ++R) {
      const L = (R / n) * s * Math.PI * 2;
      (C(L, s, o, e, b),
        C(L + 0.01, s, o, e, _),
        E.subVectors(_, b),
        T.addVectors(_, b),
        w.crossVectors(E, T),
        T.crossVectors(w, E),
        w.normalize(),
        T.normalize());
      for (let I = 0; I <= r; ++I) {
        const O = (I / r) * Math.PI * 2,
          B = -t * Math.cos(O),
          N = t * Math.sin(O);
        ((v.x = b.x + (B * T.x + N * w.x)),
          (v.y = b.y + (B * T.y + N * w.y)),
          (v.z = b.z + (B * T.z + N * w.z)),
          h.push(v.x, v.y, v.z),
          y.subVectors(v, b).normalize(),
          d.push(y.x, y.y, y.z),
          m.push(R / n),
          m.push(I / r));
      }
    }
    for (let R = 1; R <= n; R++)
      for (let L = 1; L <= r; L++) {
        const I = (r + 1) * (R - 1) + (L - 1),
          O = (r + 1) * R + (L - 1),
          B = (r + 1) * R + L,
          N = (r + 1) * (R - 1) + L;
        (u.push(I, O, N), u.push(O, B, N));
      }
    (this.setIndex(u),
      this.setAttribute("position", new Rt(h, 3)),
      this.setAttribute("normal", new Rt(d, 3)),
      this.setAttribute("uv", new Rt(m, 2)));
    function C(R, L, I, O, B) {
      const N = Math.cos(R),
        F = Math.sin(R),
        j = (I / L) * R,
        q = Math.cos(j);
      ((B.x = O * (2 + q) * 0.5 * N),
        (B.y = O * (2 + q) * F * 0.5),
        (B.z = O * Math.sin(j) * 0.5));
    }
  }
  copy(e) {
    return (
      super.copy(e),
      (this.parameters = Object.assign({}, e.parameters)),
      this
    );
  }
  static fromJSON(e) {
    return new Eb(
      e.radius,
      e.tube,
      e.tubularSegments,
      e.radialSegments,
      e.p,
      e.q,
    );
  }
}
class wb extends nn {
  constructor(
    e = new iE(new te(-1, -1, 0), new te(-1, 1, 0), new te(1, 1, 0)),
    t = 64,
    n = 1,
    r = 8,
    s = !1,
  ) {
    (super(),
      (this.type = "TubeGeometry"),
      (this.parameters = {
        path: e,
        tubularSegments: t,
        radius: n,
        radialSegments: r,
        closed: s,
      }));
    const o = e.computeFrenetFrames(t, s);
    ((this.tangents = o.tangents),
      (this.normals = o.normals),
      (this.binormals = o.binormals));
    const u = new te(),
      h = new te(),
      d = new nt();
    let m = new te();
    const v = [],
      y = [],
      b = [],
      _ = [];
    (w(),
      this.setIndex(_),
      this.setAttribute("position", new Rt(v, 3)),
      this.setAttribute("normal", new Rt(y, 3)),
      this.setAttribute("uv", new Rt(b, 2)));
    function w() {
      for (let R = 0; R < t; R++) E(R);
      (E(s === !1 ? t : 0), C(), T());
    }
    function E(R) {
      m = e.getPointAt(R / t, m);
      const L = o.normals[R],
        I = o.binormals[R];
      for (let O = 0; O <= r; O++) {
        const B = (O / r) * Math.PI * 2,
          N = Math.sin(B),
          F = -Math.cos(B);
        ((h.x = F * L.x + N * I.x),
          (h.y = F * L.y + N * I.y),
          (h.z = F * L.z + N * I.z),
          h.normalize(),
          y.push(h.x, h.y, h.z),
          (u.x = m.x + n * h.x),
          (u.y = m.y + n * h.y),
          (u.z = m.z + n * h.z),
          v.push(u.x, u.y, u.z));
      }
    }
    function T() {
      for (let R = 1; R <= t; R++)
        for (let L = 1; L <= r; L++) {
          const I = (r + 1) * (R - 1) + (L - 1),
            O = (r + 1) * R + (L - 1),
            B = (r + 1) * R + L,
            N = (r + 1) * (R - 1) + L;
          (_.push(I, O, N), _.push(O, B, N));
        }
    }
    function C() {
      for (let R = 0; R <= t; R++)
        for (let L = 0; L <= r; L++)
          ((d.x = R / t), (d.y = L / r), b.push(d.x, d.y));
    }
  }
  copy(e) {
    return (
      super.copy(e),
      (this.parameters = Object.assign({}, e.parameters)),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return ((e.path = this.parameters.path.toJSON()), e);
  }
  static fromJSON(e) {
    return new wb(
      new P1[e.path.type]().fromJSON(e.path),
      e.tubularSegments,
      e.radius,
      e.radialSegments,
      e.closed,
    );
  }
}
class sE extends nn {
  constructor(e = null) {
    if (
      (super(),
      (this.type = "WireframeGeometry"),
      (this.parameters = { geometry: e }),
      e !== null)
    ) {
      const t = [],
        n = new Set(),
        r = new te(),
        s = new te();
      if (e.index !== null) {
        const o = e.attributes.position,
          u = e.index;
        let h = e.groups;
        h.length === 0 &&
          (h = [{ start: 0, count: u.count, materialIndex: 0 }]);
        for (let d = 0, m = h.length; d < m; ++d) {
          const v = h[d],
            y = v.start,
            b = v.count;
          for (let _ = y, w = y + b; _ < w; _ += 3)
            for (let E = 0; E < 3; E++) {
              const T = u.getX(_ + E),
                C = u.getX(_ + ((E + 1) % 3));
              (r.fromBufferAttribute(o, T),
                s.fromBufferAttribute(o, C),
                AC(r, s, n) === !0 &&
                  (t.push(r.x, r.y, r.z), t.push(s.x, s.y, s.z)));
            }
        }
      } else {
        const o = e.attributes.position;
        for (let u = 0, h = o.count / 3; u < h; u++)
          for (let d = 0; d < 3; d++) {
            const m = 3 * u + d,
              v = 3 * u + ((d + 1) % 3);
            (r.fromBufferAttribute(o, m),
              s.fromBufferAttribute(o, v),
              AC(r, s, n) === !0 &&
                (t.push(r.x, r.y, r.z), t.push(s.x, s.y, s.z)));
          }
      }
      this.setAttribute("position", new Rt(t, 3));
    }
  }
  copy(e) {
    return (
      super.copy(e),
      (this.parameters = Object.assign({}, e.parameters)),
      this
    );
  }
}
function AC(i, e, t) {
  const n = `${i.x},${i.y},${i.z}-${e.x},${e.y},${e.z}`,
    r = `${e.x},${e.y},${e.z}-${i.x},${i.y},${i.z}`;
  return t.has(n) === !0 || t.has(r) === !0 ? !1 : (t.add(n), t.add(r), !0);
}
var CC = Object.freeze({
  __proto__: null,
  BoxGeometry: Fh,
  CapsuleGeometry: pb,
  CircleGeometry: mb,
  ConeGeometry: P0,
  CylinderGeometry: U0,
  DodecahedronGeometry: gb,
  EdgesGeometry: fN,
  ExtrudeGeometry: yb,
  IcosahedronGeometry: xb,
  LatheGeometry: bb,
  OctahedronGeometry: I0,
  PlaneGeometry: $c,
  PolyhedronGeometry: df,
  RingGeometry: _b,
  ShapeGeometry: Sb,
  SphereGeometry: O0,
  TetrahedronGeometry: Mb,
  TorusGeometry: Tb,
  TorusKnotGeometry: Eb,
  TubeGeometry: wb,
  WireframeGeometry: sE,
});
class _N extends bs {
  constructor(e) {
    (super(),
      (this.isShadowMaterial = !0),
      (this.type = "ShadowMaterial"),
      (this.color = new wt(0)),
      (this.transparent = !0),
      (this.fog = !0),
      this.setValues(e));
  }
  copy(e) {
    return (super.copy(e), this.color.copy(e.color), (this.fog = e.fog), this);
  }
}
function Dp(i) {
  const e = {};
  for (const t in i) {
    e[t] = {};
    for (const n in i[t]) {
      const r = i[t][n];
      r &&
      (r.isColor ||
        r.isMatrix3 ||
        r.isMatrix4 ||
        r.isVector2 ||
        r.isVector3 ||
        r.isVector4 ||
        r.isTexture ||
        r.isQuaternion)
        ? r.isRenderTargetTexture
          ? (Tt(
              "UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().",
            ),
            (e[t][n] = null))
          : (e[t][n] = r.clone())
        : Array.isArray(r)
          ? (e[t][n] = r.slice())
          : (e[t][n] = r);
    }
  }
  return e;
}
function zs(i) {
  const e = {};
  for (let t = 0; t < i.length; t++) {
    const n = Dp(i[t]);
    for (const r in n) e[r] = n[r];
  }
  return e;
}
function g6(i) {
  const e = [];
  for (let t = 0; t < i.length; t++) e.push(i[t].clone());
  return e;
}
function SN(i) {
  const e = i.getRenderTarget();
  return e === null
    ? i.outputColorSpace
    : e.isXRRenderTarget === !0
      ? e.texture.colorSpace
      : Cn.workingColorSpace;
}
const g0 = { clone: Dp, merge: zs };
var v6 = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
  y6 = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class ba extends bs {
  constructor(e) {
    (super(),
      (this.isShaderMaterial = !0),
      (this.type = "ShaderMaterial"),
      (this.defines = {}),
      (this.uniforms = {}),
      (this.uniformsGroups = []),
      (this.vertexShader = v6),
      (this.fragmentShader = y6),
      (this.linewidth = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.lights = !1),
      (this.clipping = !1),
      (this.forceSinglePass = !0),
      (this.extensions = { clipCullDistance: !1, multiDraw: !1 }),
      (this.defaultAttributeValues = {
        color: [1, 1, 1],
        uv: [0, 0],
        uv1: [0, 0],
      }),
      (this.index0AttributeName = void 0),
      (this.uniformsNeedUpdate = !1),
      (this.glslVersion = null),
      e !== void 0 && this.setValues(e));
  }
  copy(e) {
    return (
      super.copy(e),
      (this.fragmentShader = e.fragmentShader),
      (this.vertexShader = e.vertexShader),
      (this.uniforms = Dp(e.uniforms)),
      (this.uniformsGroups = g6(e.uniformsGroups)),
      (this.defines = Object.assign({}, e.defines)),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.fog = e.fog),
      (this.lights = e.lights),
      (this.clipping = e.clipping),
      (this.extensions = Object.assign({}, e.extensions)),
      (this.glslVersion = e.glslVersion),
      (this.defaultAttributeValues = Object.assign(
        {},
        e.defaultAttributeValues,
      )),
      (this.index0AttributeName = e.index0AttributeName),
      (this.uniformsNeedUpdate = e.uniformsNeedUpdate),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    ((t.glslVersion = this.glslVersion), (t.uniforms = {}));
    for (const r in this.uniforms) {
      const o = this.uniforms[r].value;
      o && o.isTexture
        ? (t.uniforms[r] = { type: "t", value: o.toJSON(e).uuid })
        : o && o.isColor
          ? (t.uniforms[r] = { type: "c", value: o.getHex() })
          : o && o.isVector2
            ? (t.uniforms[r] = { type: "v2", value: o.toArray() })
            : o && o.isVector3
              ? (t.uniforms[r] = { type: "v3", value: o.toArray() })
              : o && o.isVector4
                ? (t.uniforms[r] = { type: "v4", value: o.toArray() })
                : o && o.isMatrix3
                  ? (t.uniforms[r] = { type: "m3", value: o.toArray() })
                  : o && o.isMatrix4
                    ? (t.uniforms[r] = { type: "m4", value: o.toArray() })
                    : (t.uniforms[r] = { value: o });
    }
    (Object.keys(this.defines).length > 0 && (t.defines = this.defines),
      (t.vertexShader = this.vertexShader),
      (t.fragmentShader = this.fragmentShader),
      (t.lights = this.lights),
      (t.clipping = this.clipping));
    const n = {};
    for (const r in this.extensions) this.extensions[r] === !0 && (n[r] = !0);
    return (Object.keys(n).length > 0 && (t.extensions = n), t);
  }
}
class aE extends ba {
  constructor(e) {
    (super(e),
      (this.isRawShaderMaterial = !0),
      (this.type = "RawShaderMaterial"));
  }
}
class oE extends bs {
  constructor(e) {
    (super(),
      (this.isMeshStandardMaterial = !0),
      (this.type = "MeshStandardMaterial"),
      (this.defines = { STANDARD: "" }),
      (this.color = new wt(16777215)),
      (this.roughness = 1),
      (this.metalness = 0),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new wt(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = hf),
      (this.normalScale = new nt(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.roughnessMap = null),
      (this.metalnessMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new Fa()),
      (this.envMapIntensity = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e));
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "" }),
      this.color.copy(e.color),
      (this.roughness = e.roughness),
      (this.metalness = e.metalness),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.roughnessMap = e.roughnessMap),
      (this.metalnessMap = e.metalnessMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.envMapIntensity = e.envMapIntensity),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class lE extends oE {
  constructor(e) {
    (super(),
      (this.isMeshPhysicalMaterial = !0),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.type = "MeshPhysicalMaterial"),
      (this.anisotropyRotation = 0),
      (this.anisotropyMap = null),
      (this.clearcoatMap = null),
      (this.clearcoatRoughness = 0),
      (this.clearcoatRoughnessMap = null),
      (this.clearcoatNormalScale = new nt(1, 1)),
      (this.clearcoatNormalMap = null),
      (this.ior = 1.5),
      Object.defineProperty(this, "reflectivity", {
        get: function () {
          return Yt((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
        },
        set: function (t) {
          this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
        },
      }),
      (this.iridescenceMap = null),
      (this.iridescenceIOR = 1.3),
      (this.iridescenceThicknessRange = [100, 400]),
      (this.iridescenceThicknessMap = null),
      (this.sheenColor = new wt(0)),
      (this.sheenColorMap = null),
      (this.sheenRoughness = 1),
      (this.sheenRoughnessMap = null),
      (this.transmissionMap = null),
      (this.thickness = 0),
      (this.thicknessMap = null),
      (this.attenuationDistance = 1 / 0),
      (this.attenuationColor = new wt(1, 1, 1)),
      (this.specularIntensity = 1),
      (this.specularIntensityMap = null),
      (this.specularColor = new wt(1, 1, 1)),
      (this.specularColorMap = null),
      (this._anisotropy = 0),
      (this._clearcoat = 0),
      (this._dispersion = 0),
      (this._iridescence = 0),
      (this._sheen = 0),
      (this._transmission = 0),
      this.setValues(e));
  }
  get anisotropy() {
    return this._anisotropy;
  }
  set anisotropy(e) {
    (this._anisotropy > 0 != e > 0 && this.version++, (this._anisotropy = e));
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    (this._clearcoat > 0 != e > 0 && this.version++, (this._clearcoat = e));
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(e) {
    (this._iridescence > 0 != e > 0 && this.version++, (this._iridescence = e));
  }
  get dispersion() {
    return this._dispersion;
  }
  set dispersion(e) {
    (this._dispersion > 0 != e > 0 && this.version++, (this._dispersion = e));
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    (this._sheen > 0 != e > 0 && this.version++, (this._sheen = e));
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    (this._transmission > 0 != e > 0 && this.version++,
      (this._transmission = e));
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.anisotropy = e.anisotropy),
      (this.anisotropyRotation = e.anisotropyRotation),
      (this.anisotropyMap = e.anisotropyMap),
      (this.clearcoat = e.clearcoat),
      (this.clearcoatMap = e.clearcoatMap),
      (this.clearcoatRoughness = e.clearcoatRoughness),
      (this.clearcoatRoughnessMap = e.clearcoatRoughnessMap),
      (this.clearcoatNormalMap = e.clearcoatNormalMap),
      this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
      (this.dispersion = e.dispersion),
      (this.ior = e.ior),
      (this.iridescence = e.iridescence),
      (this.iridescenceMap = e.iridescenceMap),
      (this.iridescenceIOR = e.iridescenceIOR),
      (this.iridescenceThicknessRange = [...e.iridescenceThicknessRange]),
      (this.iridescenceThicknessMap = e.iridescenceThicknessMap),
      (this.sheen = e.sheen),
      this.sheenColor.copy(e.sheenColor),
      (this.sheenColorMap = e.sheenColorMap),
      (this.sheenRoughness = e.sheenRoughness),
      (this.sheenRoughnessMap = e.sheenRoughnessMap),
      (this.transmission = e.transmission),
      (this.transmissionMap = e.transmissionMap),
      (this.thickness = e.thickness),
      (this.thicknessMap = e.thicknessMap),
      (this.attenuationDistance = e.attenuationDistance),
      this.attenuationColor.copy(e.attenuationColor),
      (this.specularIntensity = e.specularIntensity),
      (this.specularIntensityMap = e.specularIntensityMap),
      this.specularColor.copy(e.specularColor),
      (this.specularColorMap = e.specularColorMap),
      this
    );
  }
}
class MN extends bs {
  constructor(e) {
    (super(),
      (this.isMeshPhongMaterial = !0),
      (this.type = "MeshPhongMaterial"),
      (this.color = new wt(16777215)),
      (this.specular = new wt(1118481)),
      (this.shininess = 30),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new wt(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = hf),
      (this.normalScale = new nt(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new Fa()),
      (this.combine = D0),
      (this.reflectivity = 1),
      (this.envMapIntensity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e));
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      this.specular.copy(e.specular),
      (this.shininess = e.shininess),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.envMapIntensity = e.envMapIntensity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class TN extends bs {
  constructor(e) {
    (super(),
      (this.isMeshToonMaterial = !0),
      (this.defines = { TOON: "" }),
      (this.type = "MeshToonMaterial"),
      (this.color = new wt(16777215)),
      (this.map = null),
      (this.gradientMap = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new wt(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = hf),
      (this.normalScale = new nt(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.fog = !0),
      this.setValues(e));
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.gradientMap = e.gradientMap),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.alphaMap = e.alphaMap),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    );
  }
}
class EN extends bs {
  constructor(e) {
    (super(),
      (this.isMeshNormalMaterial = !0),
      (this.type = "MeshNormalMaterial"),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = hf),
      (this.normalScale = new nt(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.flatShading = !1),
      this.setValues(e));
  }
  copy(e) {
    return (
      super.copy(e),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.flatShading = e.flatShading),
      this
    );
  }
}
class wN extends bs {
  constructor(e) {
    (super(),
      (this.isMeshLambertMaterial = !0),
      (this.type = "MeshLambertMaterial"),
      (this.color = new wt(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new wt(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = hf),
      (this.normalScale = new nt(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new Fa()),
      (this.combine = D0),
      (this.reflectivity = 1),
      (this.envMapIntensity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e));
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.envMapIntensity = e.envMapIntensity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class Ab extends bs {
  constructor(e) {
    (super(),
      (this.isMeshDepthMaterial = !0),
      (this.type = "MeshDepthMaterial"),
      (this.depthPacking = VL),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      this.setValues(e));
  }
  copy(e) {
    return (
      super.copy(e),
      (this.depthPacking = e.depthPacking),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      this
    );
  }
}
class Cb extends bs {
  constructor(e) {
    (super(),
      (this.isMeshDistanceMaterial = !0),
      (this.type = "MeshDistanceMaterial"),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      this.setValues(e));
  }
  copy(e) {
    return (
      super.copy(e),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      this
    );
  }
}
class AN extends bs {
  constructor(e) {
    (super(),
      (this.isMeshMatcapMaterial = !0),
      (this.defines = { MATCAP: "" }),
      (this.type = "MeshMatcapMaterial"),
      (this.color = new wt(16777215)),
      (this.matcap = null),
      (this.map = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = hf),
      (this.normalScale = new nt(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e));
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { MATCAP: "" }),
      this.color.copy(e.color),
      (this.matcap = e.matcap),
      (this.map = e.map),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.alphaMap = e.alphaMap),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class CN extends Ws {
  constructor(e) {
    (super(),
      (this.isLineDashedMaterial = !0),
      (this.type = "LineDashedMaterial"),
      (this.scale = 1),
      (this.dashSize = 3),
      (this.gapSize = 1),
      this.setValues(e));
  }
  copy(e) {
    return (
      super.copy(e),
      (this.scale = e.scale),
      (this.dashSize = e.dashSize),
      (this.gapSize = e.gapSize),
      this
    );
  }
}
function Mh(i, e) {
  return !i || i.constructor === e
    ? i
    : typeof e.BYTES_PER_ELEMENT == "number"
      ? new e(i)
      : Array.prototype.slice.call(i);
}
function RN(i) {
  function e(r, s) {
    return i[r] - i[s];
  }
  const t = i.length,
    n = new Array(t);
  for (let r = 0; r !== t; ++r) n[r] = r;
  return (n.sort(e), n);
}
function RM(i, e, t) {
  const n = i.length,
    r = new i.constructor(n);
  for (let s = 0, o = 0; o !== n; ++s) {
    const u = t[s] * e;
    for (let h = 0; h !== e; ++h) r[o++] = i[u + h];
  }
  return r;
}
function cE(i, e, t, n) {
  let r = 1,
    s = i[0];
  for (; s !== void 0 && s[n] === void 0; ) s = i[r++];
  if (s === void 0) return;
  let o = s[n];
  if (o !== void 0)
    if (Array.isArray(o))
      do
        ((o = s[n]),
          o !== void 0 && (e.push(s.time), t.push(...o)),
          (s = i[r++]));
      while (s !== void 0);
    else if (o.toArray !== void 0)
      do
        ((o = s[n]),
          o !== void 0 && (e.push(s.time), o.toArray(t, t.length)),
          (s = i[r++]));
      while (s !== void 0);
    else
      do
        ((o = s[n]), o !== void 0 && (e.push(s.time), t.push(o)), (s = i[r++]));
      while (s !== void 0);
}
function x6(i, e, t, n, r = 30) {
  const s = i.clone();
  s.name = e;
  const o = [];
  for (let h = 0; h < s.tracks.length; ++h) {
    const d = s.tracks[h],
      m = d.getValueSize(),
      v = [],
      y = [];
    for (let b = 0; b < d.times.length; ++b) {
      const _ = d.times[b] * r;
      if (!(_ < t || _ >= n)) {
        v.push(d.times[b]);
        for (let w = 0; w < m; ++w) y.push(d.values[b * m + w]);
      }
    }
    v.length !== 0 &&
      ((d.times = Mh(v, d.times.constructor)),
      (d.values = Mh(y, d.values.constructor)),
      o.push(d));
  }
  s.tracks = o;
  let u = 1 / 0;
  for (let h = 0; h < s.tracks.length; ++h)
    u > s.tracks[h].times[0] && (u = s.tracks[h].times[0]);
  for (let h = 0; h < s.tracks.length; ++h) s.tracks[h].shift(-1 * u);
  return (s.resetDuration(), s);
}
function b6(i, e = 0, t = i, n = 30) {
  n <= 0 && (n = 30);
  const r = t.tracks.length,
    s = e / n;
  for (let o = 0; o < r; ++o) {
    const u = t.tracks[o],
      h = u.ValueTypeName;
    if (h === "bool" || h === "string") continue;
    const d = i.tracks.find(function (T) {
      return T.name === u.name && T.ValueTypeName === h;
    });
    if (d === void 0) continue;
    let m = 0;
    const v = u.getValueSize();
    u.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
      (m = v / 3);
    let y = 0;
    const b = d.getValueSize();
    d.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
      (y = b / 3);
    const _ = u.times.length - 1;
    let w;
    if (s <= u.times[0]) {
      const T = m,
        C = v - m;
      w = u.values.slice(T, C);
    } else if (s >= u.times[_]) {
      const T = _ * v + m,
        C = T + v - m;
      w = u.values.slice(T, C);
    } else {
      const T = u.createInterpolant(),
        C = m,
        R = v - m;
      (T.evaluate(s), (w = T.resultBuffer.slice(C, R)));
    }
    h === "quaternion" &&
      new Jr().fromArray(w).normalize().conjugate().toArray(w);
    const E = d.times.length;
    for (let T = 0; T < E; ++T) {
      const C = T * b + y;
      if (h === "quaternion")
        Jr.multiplyQuaternionsFlat(d.values, C, w, 0, d.values, C);
      else {
        const R = b - y * 2;
        for (let L = 0; L < R; ++L) d.values[C + L] -= w[L];
      }
    }
  }
  return ((i.blendMode = GT), i);
}
class _6 {
  static convertArray(e, t) {
    return Mh(e, t);
  }
  static isTypedArray(e) {
    return KL(e);
  }
  static getKeyframeOrder(e) {
    return RN(e);
  }
  static sortedArray(e, t, n) {
    return RM(e, t, n);
  }
  static flattenJSON(e, t, n, r) {
    cE(e, t, n, r);
  }
  static subclip(e, t, n, r, s = 30) {
    return x6(e, t, n, r, s);
  }
  static makeClipAdditive(e, t = 0, n = e, r = 30) {
    return b6(e, t, n, r);
  }
}
class Vp {
  constructor(e, t, n, r) {
    ((this.parameterPositions = e),
      (this._cachedIndex = 0),
      (this.resultBuffer = r !== void 0 ? r : new t.constructor(n)),
      (this.sampleValues = t),
      (this.valueSize = n),
      (this.settings = null),
      (this.DefaultSettings_ = {}));
  }
  evaluate(e) {
    const t = this.parameterPositions;
    let n = this._cachedIndex,
      r = t[n],
      s = t[n - 1];
    e: {
      t: {
        let o;
        n: {
          i: if (!(e < r)) {
            for (let u = n + 2; ; ) {
              if (r === void 0) {
                if (e < s) break i;
                return (
                  (n = t.length),
                  (this._cachedIndex = n),
                  this.copySampleValue_(n - 1)
                );
              }
              if (n === u) break;
              if (((s = r), (r = t[++n]), e < r)) break t;
            }
            o = t.length;
            break n;
          }
          if (!(e >= s)) {
            const u = t[1];
            e < u && ((n = 2), (s = u));
            for (let h = n - 2; ; ) {
              if (s === void 0)
                return ((this._cachedIndex = 0), this.copySampleValue_(0));
              if (n === h) break;
              if (((r = s), (s = t[--n - 1]), e >= s)) break t;
            }
            ((o = n), (n = 0));
            break n;
          }
          break e;
        }
        for (; n < o; ) {
          const u = (n + o) >>> 1;
          e < t[u] ? (o = u) : (n = u + 1);
        }
        if (((r = t[n]), (s = t[n - 1]), s === void 0))
          return ((this._cachedIndex = 0), this.copySampleValue_(0));
        if (r === void 0)
          return (
            (n = t.length),
            (this._cachedIndex = n),
            this.copySampleValue_(n - 1)
          );
      }
      ((this._cachedIndex = n), this.intervalChanged_(n, s, r));
    }
    return this.interpolate_(n, s, e, r);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(e) {
    const t = this.resultBuffer,
      n = this.sampleValues,
      r = this.valueSize,
      s = e * r;
    for (let o = 0; o !== r; ++o) t[o] = n[s + o];
    return t;
  }
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {}
}
class DN extends Vp {
  constructor(e, t, n, r) {
    (super(e, t, n, r),
      (this._weightPrev = -0),
      (this._offsetPrev = -0),
      (this._weightNext = -0),
      (this._offsetNext = -0),
      (this.DefaultSettings_ = { endingStart: _h, endingEnd: _h }));
  }
  intervalChanged_(e, t, n) {
    const r = this.parameterPositions;
    let s = e - 2,
      o = e + 1,
      u = r[s],
      h = r[o];
    if (u === void 0)
      switch (this.getSettings_().endingStart) {
        case Sh:
          ((s = e), (u = 2 * t - n));
          break;
        case o0:
          ((s = r.length - 2), (u = t + r[s] - r[s + 1]));
          break;
        default:
          ((s = e), (u = n));
      }
    if (h === void 0)
      switch (this.getSettings_().endingEnd) {
        case Sh:
          ((o = e), (h = 2 * n - t));
          break;
        case o0:
          ((o = 1), (h = n + r[1] - r[0]));
          break;
        default:
          ((o = e - 1), (h = t));
      }
    const d = (n - t) * 0.5,
      m = this.valueSize;
    ((this._weightPrev = d / (t - u)),
      (this._weightNext = d / (h - n)),
      (this._offsetPrev = s * m),
      (this._offsetNext = o * m));
  }
  interpolate_(e, t, n, r) {
    const s = this.resultBuffer,
      o = this.sampleValues,
      u = this.valueSize,
      h = e * u,
      d = h - u,
      m = this._offsetPrev,
      v = this._offsetNext,
      y = this._weightPrev,
      b = this._weightNext,
      _ = (n - t) / (r - t),
      w = _ * _,
      E = w * _,
      T = -y * E + 2 * y * w - y * _,
      C = (1 + y) * E + (-1.5 - 2 * y) * w + (-0.5 + y) * _ + 1,
      R = (-1 - b) * E + (1.5 + b) * w + 0.5 * _,
      L = b * E - b * w;
    for (let I = 0; I !== u; ++I)
      s[I] = T * o[m + I] + C * o[d + I] + R * o[h + I] + L * o[v + I];
    return s;
  }
}
class uE extends Vp {
  constructor(e, t, n, r) {
    super(e, t, n, r);
  }
  interpolate_(e, t, n, r) {
    const s = this.resultBuffer,
      o = this.sampleValues,
      u = this.valueSize,
      h = e * u,
      d = h - u,
      m = (n - t) / (r - t),
      v = 1 - m;
    for (let y = 0; y !== u; ++y) s[y] = o[d + y] * v + o[h + y] * m;
    return s;
  }
}
class LN extends Vp {
  constructor(e, t, n, r) {
    super(e, t, n, r);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class NN extends Vp {
  interpolate_(e, t, n, r) {
    const s = this.resultBuffer,
      o = this.sampleValues,
      u = this.valueSize,
      h = e * u,
      d = h - u,
      m = this.settings || this.DefaultSettings_,
      v = m.inTangents,
      y = m.outTangents;
    if (!v || !y) {
      const w = (n - t) / (r - t),
        E = 1 - w;
      for (let T = 0; T !== u; ++T) s[T] = o[d + T] * E + o[h + T] * w;
      return s;
    }
    const b = u * 2,
      _ = e - 1;
    for (let w = 0; w !== u; ++w) {
      const E = o[d + w],
        T = o[h + w],
        C = _ * b + w * 2,
        R = y[C],
        L = y[C + 1],
        I = e * b + w * 2,
        O = v[I],
        B = v[I + 1];
      let N = (n - t) / (r - t),
        F,
        j,
        q,
        X,
        J;
      for (let ee = 0; ee < 8; ee++) {
        ((F = N * N), (j = F * N), (q = 1 - N), (X = q * q), (J = X * q));
        const W = J * t + 3 * X * N * R + 3 * q * F * O + j * r - n;
        if (Math.abs(W) < 1e-10) break;
        const $ = 3 * X * (R - t) + 6 * q * N * (O - R) + 3 * F * (r - O);
        if (Math.abs($) < 1e-10) break;
        ((N = N - W / $), (N = Math.max(0, Math.min(1, N))));
      }
      s[w] = J * E + 3 * X * N * L + 3 * q * F * B + j * T;
    }
    return s;
  }
}
class _o {
  constructor(e, t, n, r) {
    if (e === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (t === void 0 || t.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
    ((this.name = e),
      (this.times = Mh(t, this.TimeBufferType)),
      (this.values = Mh(n, this.ValueBufferType)),
      this.setInterpolation(r || this.DefaultInterpolation));
  }
  static toJSON(e) {
    const t = e.constructor;
    let n;
    if (t.toJSON !== this.toJSON) n = t.toJSON(e);
    else {
      n = {
        name: e.name,
        times: Mh(e.times, Array),
        values: Mh(e.values, Array),
      };
      const r = e.getInterpolation();
      r !== e.DefaultInterpolation && (n.interpolation = r);
    }
    return ((n.type = e.ValueTypeName), n);
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new LN(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodLinear(e) {
    return new uE(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodSmooth(e) {
    return new DN(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodBezier(e) {
    const t = new NN(this.times, this.values, this.getValueSize(), e);
    return (this.settings && (t.settings = this.settings), t);
  }
  setInterpolation(e) {
    let t;
    switch (e) {
      case a0:
        t = this.InterpolantFactoryMethodDiscrete;
        break;
      case L1:
        t = this.InterpolantFactoryMethodLinear;
        break;
      case Cx:
        t = this.InterpolantFactoryMethodSmooth;
        break;
      case MM:
        t = this.InterpolantFactoryMethodBezier;
        break;
    }
    if (t === void 0) {
      const n =
        "unsupported interpolation for " +
        this.ValueTypeName +
        " keyframe track named " +
        this.name;
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else throw new Error(n);
      return (Tt("KeyframeTrack:", n), this);
    }
    return ((this.createInterpolant = t), this);
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return a0;
      case this.InterpolantFactoryMethodLinear:
        return L1;
      case this.InterpolantFactoryMethodSmooth:
        return Cx;
      case this.InterpolantFactoryMethodBezier:
        return MM;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(e) {
    if (e !== 0) {
      const t = this.times;
      for (let n = 0, r = t.length; n !== r; ++n) t[n] += e;
    }
    return this;
  }
  scale(e) {
    if (e !== 1) {
      const t = this.times;
      for (let n = 0, r = t.length; n !== r; ++n) t[n] *= e;
    }
    return this;
  }
  trim(e, t) {
    const n = this.times,
      r = n.length;
    let s = 0,
      o = r - 1;
    for (; s !== r && n[s] < e; ) ++s;
    for (; o !== -1 && n[o] > t; ) --o;
    if ((++o, s !== 0 || o !== r)) {
      s >= o && ((o = Math.max(o, 1)), (s = o - 1));
      const u = this.getValueSize();
      ((this.times = n.slice(s, o)),
        (this.values = this.values.slice(s * u, o * u)));
    }
    return this;
  }
  validate() {
    let e = !0;
    const t = this.getValueSize();
    t - Math.floor(t) !== 0 &&
      (Ft("KeyframeTrack: Invalid value size in track.", this), (e = !1));
    const n = this.times,
      r = this.values,
      s = n.length;
    s === 0 && (Ft("KeyframeTrack: Track is empty.", this), (e = !1));
    let o = null;
    for (let u = 0; u !== s; u++) {
      const h = n[u];
      if (typeof h == "number" && isNaN(h)) {
        (Ft("KeyframeTrack: Time is not a valid number.", this, u, h),
          (e = !1));
        break;
      }
      if (o !== null && o > h) {
        (Ft("KeyframeTrack: Out of order keys.", this, u, h, o), (e = !1));
        break;
      }
      o = h;
    }
    if (r !== void 0 && KL(r))
      for (let u = 0, h = r.length; u !== h; ++u) {
        const d = r[u];
        if (isNaN(d)) {
          (Ft("KeyframeTrack: Value is not a valid number.", this, u, d),
            (e = !1));
          break;
        }
      }
    return e;
  }
  optimize() {
    const e = this.times.slice(),
      t = this.values.slice(),
      n = this.getValueSize(),
      r = this.getInterpolation() === Cx,
      s = e.length - 1;
    let o = 1;
    for (let u = 1; u < s; ++u) {
      let h = !1;
      const d = e[u],
        m = e[u + 1];
      if (d !== m && (u !== 1 || d !== e[0]))
        if (r) h = !0;
        else {
          const v = u * n,
            y = v - n,
            b = v + n;
          for (let _ = 0; _ !== n; ++_) {
            const w = t[v + _];
            if (w !== t[y + _] || w !== t[b + _]) {
              h = !0;
              break;
            }
          }
        }
      if (h) {
        if (u !== o) {
          e[o] = e[u];
          const v = u * n,
            y = o * n;
          for (let b = 0; b !== n; ++b) t[y + b] = t[v + b];
        }
        ++o;
      }
    }
    if (s > 0) {
      e[o] = e[s];
      for (let u = s * n, h = o * n, d = 0; d !== n; ++d) t[h + d] = t[u + d];
      ++o;
    }
    return (
      o !== e.length
        ? ((this.times = e.slice(0, o)), (this.values = t.slice(0, o * n)))
        : ((this.times = e), (this.values = t)),
      this
    );
  }
  clone() {
    const e = this.times.slice(),
      t = this.values.slice(),
      n = this.constructor,
      r = new n(this.name, e, t);
    return ((r.createInterpolant = this.createInterpolant), r);
  }
}
_o.prototype.ValueTypeName = "";
_o.prototype.TimeBufferType = Float32Array;
_o.prototype.ValueBufferType = Float32Array;
_o.prototype.DefaultInterpolation = L1;
class zh extends _o {
  constructor(e, t, n) {
    super(e, t, n);
  }
}
zh.prototype.ValueTypeName = "bool";
zh.prototype.ValueBufferType = Array;
zh.prototype.DefaultInterpolation = a0;
zh.prototype.InterpolantFactoryMethodLinear = void 0;
zh.prototype.InterpolantFactoryMethodSmooth = void 0;
class fE extends _o {
  constructor(e, t, n, r) {
    super(e, t, n, r);
  }
}
fE.prototype.ValueTypeName = "color";
class v0 extends _o {
  constructor(e, t, n, r) {
    super(e, t, n, r);
  }
}
v0.prototype.ValueTypeName = "number";
class UN extends Vp {
  constructor(e, t, n, r) {
    super(e, t, n, r);
  }
  interpolate_(e, t, n, r) {
    const s = this.resultBuffer,
      o = this.sampleValues,
      u = this.valueSize,
      h = (n - t) / (r - t);
    let d = e * u;
    for (let m = d + u; d !== m; d += 4) Jr.slerpFlat(s, 0, o, d - u, o, d, h);
    return s;
  }
}
class F0 extends _o {
  constructor(e, t, n, r) {
    super(e, t, n, r);
  }
  InterpolantFactoryMethodLinear(e) {
    return new UN(this.times, this.values, this.getValueSize(), e);
  }
}
F0.prototype.ValueTypeName = "quaternion";
F0.prototype.InterpolantFactoryMethodSmooth = void 0;
class Bh extends _o {
  constructor(e, t, n) {
    super(e, t, n);
  }
}
Bh.prototype.ValueTypeName = "string";
Bh.prototype.ValueBufferType = Array;
Bh.prototype.DefaultInterpolation = a0;
Bh.prototype.InterpolantFactoryMethodLinear = void 0;
Bh.prototype.InterpolantFactoryMethodSmooth = void 0;
class y0 extends _o {
  constructor(e, t, n, r) {
    super(e, t, n, r);
  }
}
y0.prototype.ValueTypeName = "vector";
class x0 {
  constructor(e = "", t = -1, n = [], r = ib) {
    ((this.name = e),
      (this.tracks = n),
      (this.duration = t),
      (this.blendMode = r),
      (this.uuid = Ia()),
      (this.userData = {}),
      this.duration < 0 && this.resetDuration());
  }
  static parse(e) {
    const t = [],
      n = e.tracks,
      r = 1 / (e.fps || 1);
    for (let o = 0, u = n.length; o !== u; ++o) t.push(M6(n[o]).scale(r));
    const s = new this(e.name, e.duration, t, e.blendMode);
    return (
      (s.uuid = e.uuid),
      (s.userData = JSON.parse(e.userData || "{}")),
      s
    );
  }
  static toJSON(e) {
    const t = [],
      n = e.tracks,
      r = {
        name: e.name,
        duration: e.duration,
        tracks: t,
        uuid: e.uuid,
        blendMode: e.blendMode,
        userData: JSON.stringify(e.userData),
      };
    for (let s = 0, o = n.length; s !== o; ++s) t.push(_o.toJSON(n[s]));
    return r;
  }
  static CreateFromMorphTargetSequence(e, t, n, r) {
    const s = t.length,
      o = [];
    for (let u = 0; u < s; u++) {
      let h = [],
        d = [];
      (h.push((u + s - 1) % s, u, (u + 1) % s), d.push(0, 1, 0));
      const m = RN(h);
      ((h = RM(h, 1, m)),
        (d = RM(d, 1, m)),
        !r && h[0] === 0 && (h.push(s), d.push(d[0])),
        o.push(
          new v0(".morphTargetInfluences[" + t[u].name + "]", h, d).scale(
            1 / n,
          ),
        ));
    }
    return new this(e, -1, o);
  }
  static findByName(e, t) {
    let n = e;
    if (!Array.isArray(e)) {
      const r = e;
      n = (r.geometry && r.geometry.animations) || r.animations;
    }
    for (let r = 0; r < n.length; r++) if (n[r].name === t) return n[r];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e, t, n) {
    const r = {},
      s = /^([\w-]*?)([\d]+)$/;
    for (let u = 0, h = e.length; u < h; u++) {
      const d = e[u],
        m = d.name.match(s);
      if (m && m.length > 1) {
        const v = m[1];
        let y = r[v];
        (y || (r[v] = y = []), y.push(d));
      }
    }
    const o = [];
    for (const u in r)
      o.push(this.CreateFromMorphTargetSequence(u, r[u], t, n));
    return o;
  }
  static parseAnimation(e, t) {
    if (
      (Tt(
        "AnimationClip: parseAnimation() is deprecated and will be removed with r185",
      ),
      !e)
    )
      return (Ft("AnimationClip: No animation in JSONLoader data."), null);
    const n = function (v, y, b, _, w) {
        if (b.length !== 0) {
          const E = [],
            T = [];
          (cE(b, E, T, _), E.length !== 0 && w.push(new v(y, E, T)));
        }
      },
      r = [],
      s = e.name || "default",
      o = e.fps || 30,
      u = e.blendMode;
    let h = e.length || -1;
    const d = e.hierarchy || [];
    for (let v = 0; v < d.length; v++) {
      const y = d[v].keys;
      if (!(!y || y.length === 0))
        if (y[0].morphTargets) {
          const b = {};
          let _;
          for (_ = 0; _ < y.length; _++)
            if (y[_].morphTargets)
              for (let w = 0; w < y[_].morphTargets.length; w++)
                b[y[_].morphTargets[w]] = -1;
          for (const w in b) {
            const E = [],
              T = [];
            for (let C = 0; C !== y[_].morphTargets.length; ++C) {
              const R = y[_];
              (E.push(R.time), T.push(R.morphTarget === w ? 1 : 0));
            }
            r.push(new v0(".morphTargetInfluence[" + w + "]", E, T));
          }
          h = b.length * o;
        } else {
          const b = ".bones[" + t[v].name + "]";
          (n(y0, b + ".position", y, "pos", r),
            n(F0, b + ".quaternion", y, "rot", r),
            n(y0, b + ".scale", y, "scl", r));
        }
    }
    return r.length === 0 ? null : new this(s, h, r, u);
  }
  resetDuration() {
    const e = this.tracks;
    let t = 0;
    for (let n = 0, r = e.length; n !== r; ++n) {
      const s = this.tracks[n];
      t = Math.max(t, s.times[s.times.length - 1]);
    }
    return ((this.duration = t), this);
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  }
  validate() {
    let e = !0;
    for (let t = 0; t < this.tracks.length; t++)
      e = e && this.tracks[t].validate();
    return e;
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
    return this;
  }
  clone() {
    const e = [];
    for (let n = 0; n < this.tracks.length; n++) e.push(this.tracks[n].clone());
    const t = new this.constructor(this.name, this.duration, e, this.blendMode);
    return ((t.userData = JSON.parse(JSON.stringify(this.userData))), t);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function S6(i) {
  switch (i.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return v0;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return y0;
    case "color":
      return fE;
    case "quaternion":
      return F0;
    case "bool":
    case "boolean":
      return zh;
    case "string":
      return Bh;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + i);
}
function M6(i) {
  if (i.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e = S6(i.type);
  if (i.times === void 0) {
    const t = [],
      n = [];
    (cE(i.keys, t, n, "value"), (i.times = t), (i.values = n));
  }
  return e.parse !== void 0
    ? e.parse(i)
    : new e(i.name, i.times, i.values, i.interpolation);
}
const jl = {
  enabled: !1,
  files: {},
  add: function (i, e) {
    this.enabled !== !1 && (RC(i) || (this.files[i] = e));
  },
  get: function (i) {
    if (this.enabled !== !1 && !RC(i)) return this.files[i];
  },
  remove: function (i) {
    delete this.files[i];
  },
  clear: function () {
    this.files = {};
  },
};
function RC(i) {
  try {
    const e = i.slice(i.indexOf(":") + 1);
    return new URL(e).protocol === "blob:";
  } catch {
    return !1;
  }
}
class hE {
  constructor(e, t, n) {
    const r = this;
    let s = !1,
      o = 0,
      u = 0,
      h;
    const d = [];
    ((this.onStart = void 0),
      (this.onLoad = e),
      (this.onProgress = t),
      (this.onError = n),
      (this._abortController = null),
      (this.itemStart = function (m) {
        (u++, s === !1 && r.onStart !== void 0 && r.onStart(m, o, u), (s = !0));
      }),
      (this.itemEnd = function (m) {
        (o++,
          r.onProgress !== void 0 && r.onProgress(m, o, u),
          o === u && ((s = !1), r.onLoad !== void 0 && r.onLoad()));
      }),
      (this.itemError = function (m) {
        r.onError !== void 0 && r.onError(m);
      }),
      (this.resolveURL = function (m) {
        return h ? h(m) : m;
      }),
      (this.setURLModifier = function (m) {
        return ((h = m), this);
      }),
      (this.addHandler = function (m, v) {
        return (d.push(m, v), this);
      }),
      (this.removeHandler = function (m) {
        const v = d.indexOf(m);
        return (v !== -1 && d.splice(v, 2), this);
      }),
      (this.getHandler = function (m) {
        for (let v = 0, y = d.length; v < y; v += 2) {
          const b = d[v],
            _ = d[v + 1];
          if ((b.global && (b.lastIndex = 0), b.test(m))) return _;
        }
        return null;
      }),
      (this.abort = function () {
        return (
          this.abortController.abort(),
          (this._abortController = null),
          this
        );
      }));
  }
  get abortController() {
    return (
      this._abortController || (this._abortController = new AbortController()),
      this._abortController
    );
  }
}
const PN = new hE();
class _a {
  constructor(e) {
    ((this.manager = e !== void 0 ? e : PN),
      (this.crossOrigin = "anonymous"),
      (this.withCredentials = !1),
      (this.path = ""),
      (this.resourcePath = ""),
      (this.requestHeader = {}),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this }),
        ));
  }
  load() {}
  loadAsync(e, t) {
    const n = this;
    return new Promise(function (r, s) {
      n.load(e, r, t, s);
    });
  }
  parse() {}
  setCrossOrigin(e) {
    return ((this.crossOrigin = e), this);
  }
  setWithCredentials(e) {
    return ((this.withCredentials = e), this);
  }
  setPath(e) {
    return ((this.path = e), this);
  }
  setResourcePath(e) {
    return ((this.resourcePath = e), this);
  }
  setRequestHeader(e) {
    return ((this.requestHeader = e), this);
  }
  abort() {
    return this;
  }
}
_a.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const kc = {};
class T6 extends Error {
  constructor(e, t) {
    (super(e), (this.response = t));
  }
}
class Kc extends _a {
  constructor(e) {
    (super(e),
      (this.mimeType = ""),
      (this.responseType = ""),
      (this._abortController = new AbortController()));
  }
  load(e, t, n, r) {
    (e === void 0 && (e = ""),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e)));
    const s = jl.get(`file:${e}`);
    if (s !== void 0)
      return (
        this.manager.itemStart(e),
        setTimeout(() => {
          (t && t(s), this.manager.itemEnd(e));
        }, 0),
        s
      );
    if (kc[e] !== void 0) {
      kc[e].push({ onLoad: t, onProgress: n, onError: r });
      return;
    }
    ((kc[e] = []), kc[e].push({ onLoad: t, onProgress: n, onError: r }));
    const o = new Request(e, {
        headers: new Headers(this.requestHeader),
        credentials: this.withCredentials ? "include" : "same-origin",
        signal:
          typeof AbortSignal.any == "function"
            ? AbortSignal.any([
                this._abortController.signal,
                this.manager.abortController.signal,
              ])
            : this._abortController.signal,
      }),
      u = this.mimeType,
      h = this.responseType;
    (fetch(o)
      .then((d) => {
        if (d.status === 200 || d.status === 0) {
          if (
            (d.status === 0 && Tt("FileLoader: HTTP Status 0 received."),
            typeof ReadableStream > "u" ||
              d.body === void 0 ||
              d.body.getReader === void 0)
          )
            return d;
          const m = kc[e],
            v = d.body.getReader(),
            y = d.headers.get("X-File-Size") || d.headers.get("Content-Length"),
            b = y ? parseInt(y) : 0,
            _ = b !== 0;
          let w = 0;
          const E = new ReadableStream({
            start(T) {
              C();
              function C() {
                v.read().then(
                  ({ done: R, value: L }) => {
                    if (R) T.close();
                    else {
                      w += L.byteLength;
                      const I = new ProgressEvent("progress", {
                        lengthComputable: _,
                        loaded: w,
                        total: b,
                      });
                      for (let O = 0, B = m.length; O < B; O++) {
                        const N = m[O];
                        N.onProgress && N.onProgress(I);
                      }
                      (T.enqueue(L), C());
                    }
                  },
                  (R) => {
                    T.error(R);
                  },
                );
              }
            },
          });
          return new Response(E);
        } else
          throw new T6(
            `fetch for "${d.url}" responded with ${d.status}: ${d.statusText}`,
            d,
          );
      })
      .then((d) => {
        switch (h) {
          case "arraybuffer":
            return d.arrayBuffer();
          case "blob":
            return d.blob();
          case "document":
            return d.text().then((m) => new DOMParser().parseFromString(m, u));
          case "json":
            return d.json();
          default:
            if (u === "") return d.text();
            {
              const v = /charset="?([^;"\s]*)"?/i.exec(u),
                y = v && v[1] ? v[1].toLowerCase() : void 0,
                b = new TextDecoder(y);
              return d.arrayBuffer().then((_) => b.decode(_));
            }
        }
      })
      .then((d) => {
        jl.add(`file:${e}`, d);
        const m = kc[e];
        delete kc[e];
        for (let v = 0, y = m.length; v < y; v++) {
          const b = m[v];
          b.onLoad && b.onLoad(d);
        }
      })
      .catch((d) => {
        const m = kc[e];
        if (m === void 0) throw (this.manager.itemError(e), d);
        delete kc[e];
        for (let v = 0, y = m.length; v < y; v++) {
          const b = m[v];
          b.onError && b.onError(d);
        }
        this.manager.itemError(e);
      })
      .finally(() => {
        this.manager.itemEnd(e);
      }),
      this.manager.itemStart(e));
  }
  setResponseType(e) {
    return ((this.responseType = e), this);
  }
  setMimeType(e) {
    return ((this.mimeType = e), this);
  }
  abort() {
    return (
      this._abortController.abort(),
      (this._abortController = new AbortController()),
      this
    );
  }
}
class E6 extends _a {
  constructor(e) {
    super(e);
  }
  load(e, t, n, r) {
    const s = this,
      o = new Kc(this.manager);
    (o.setPath(this.path),
      o.setRequestHeader(this.requestHeader),
      o.setWithCredentials(this.withCredentials),
      o.load(
        e,
        function (u) {
          try {
            t(s.parse(JSON.parse(u)));
          } catch (h) {
            (r ? r(h) : Ft(h), s.manager.itemError(e));
          }
        },
        n,
        r,
      ));
  }
  parse(e) {
    const t = [];
    for (let n = 0; n < e.length; n++) {
      const r = x0.parse(e[n]);
      t.push(r);
    }
    return t;
  }
}
class w6 extends _a {
  constructor(e) {
    super(e);
  }
  load(e, t, n, r) {
    const s = this,
      o = [],
      u = new db(),
      h = new Kc(this.manager);
    (h.setPath(this.path),
      h.setResponseType("arraybuffer"),
      h.setRequestHeader(this.requestHeader),
      h.setWithCredentials(s.withCredentials));
    let d = 0;
    function m(v) {
      h.load(
        e[v],
        function (y) {
          const b = s.parse(y, !0);
          ((o[v] = {
            width: b.width,
            height: b.height,
            format: b.format,
            mipmaps: b.mipmaps,
          }),
            (d += 1),
            d === 6 &&
              (b.mipmapCount === 1 && (u.minFilter = ni),
              (u.image = o),
              (u.format = b.format),
              (u.needsUpdate = !0),
              t && t(u)));
        },
        n,
        r,
      );
    }
    if (Array.isArray(e)) for (let v = 0, y = e.length; v < y; ++v) m(v);
    else
      h.load(
        e,
        function (v) {
          const y = s.parse(v, !0);
          if (y.isCubemap) {
            const b = y.mipmaps.length / y.mipmapCount;
            for (let _ = 0; _ < b; _++) {
              o[_] = { mipmaps: [] };
              for (let w = 0; w < y.mipmapCount; w++)
                (o[_].mipmaps.push(y.mipmaps[_ * y.mipmapCount + w]),
                  (o[_].format = y.format),
                  (o[_].width = y.width),
                  (o[_].height = y.height));
            }
            u.image = o;
          } else
            ((u.image.width = y.width),
              (u.image.height = y.height),
              (u.mipmaps = y.mipmaps));
          (y.mipmapCount === 1 && (u.minFilter = ni),
            (u.format = y.format),
            (u.needsUpdate = !0),
            t && t(u));
        },
        n,
        r,
      );
    return u;
  }
}
const tp = new WeakMap();
class b0 extends _a {
  constructor(e) {
    super(e);
  }
  load(e, t, n, r) {
    (this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e)));
    const s = this,
      o = jl.get(`image:${e}`);
    if (o !== void 0) {
      if (o.complete === !0)
        (s.manager.itemStart(e),
          setTimeout(function () {
            (t && t(o), s.manager.itemEnd(e));
          }, 0));
      else {
        let v = tp.get(o);
        (v === void 0 && ((v = []), tp.set(o, v)),
          v.push({ onLoad: t, onError: r }));
      }
      return o;
    }
    const u = u0("img");
    function h() {
      (m(), t && t(this));
      const v = tp.get(this) || [];
      for (let y = 0; y < v.length; y++) {
        const b = v[y];
        b.onLoad && b.onLoad(this);
      }
      (tp.delete(this), s.manager.itemEnd(e));
    }
    function d(v) {
      (m(), r && r(v), jl.remove(`image:${e}`));
      const y = tp.get(this) || [];
      for (let b = 0; b < y.length; b++) {
        const _ = y[b];
        _.onError && _.onError(v);
      }
      (tp.delete(this), s.manager.itemError(e), s.manager.itemEnd(e));
    }
    function m() {
      (u.removeEventListener("load", h, !1),
        u.removeEventListener("error", d, !1));
    }
    return (
      u.addEventListener("load", h, !1),
      u.addEventListener("error", d, !1),
      e.slice(0, 5) !== "data:" &&
        this.crossOrigin !== void 0 &&
        (u.crossOrigin = this.crossOrigin),
      jl.add(`image:${e}`, u),
      s.manager.itemStart(e),
      (u.src = e),
      u
    );
  }
}
class A6 extends _a {
  constructor(e) {
    super(e);
  }
  load(e, t, n, r) {
    const s = new N0();
    s.colorSpace = vs;
    const o = new b0(this.manager);
    (o.setCrossOrigin(this.crossOrigin), o.setPath(this.path));
    let u = 0;
    function h(d) {
      o.load(
        e[d],
        function (m) {
          ((s.images[d] = m),
            u++,
            u === 6 && ((s.needsUpdate = !0), t && t(s)));
        },
        void 0,
        r,
      );
    }
    for (let d = 0; d < e.length; ++d) h(d);
    return s;
  }
}
class C6 extends _a {
  constructor(e) {
    super(e);
  }
  load(e, t, n, r) {
    const s = this,
      o = new Ko(),
      u = new Kc(this.manager);
    return (
      u.setResponseType("arraybuffer"),
      u.setRequestHeader(this.requestHeader),
      u.setPath(this.path),
      u.setWithCredentials(s.withCredentials),
      u.load(
        e,
        function (h) {
          let d;
          try {
            d = s.parse(h);
          } catch (m) {
            if (r !== void 0) r(m);
            else {
              m(m);
              return;
            }
          }
          (d.image !== void 0
            ? (o.image = d.image)
            : d.data !== void 0 &&
              ((o.image.width = d.width),
              (o.image.height = d.height),
              (o.image.data = d.data)),
            (o.wrapS = d.wrapS !== void 0 ? d.wrapS : xa),
            (o.wrapT = d.wrapT !== void 0 ? d.wrapT : xa),
            (o.magFilter = d.magFilter !== void 0 ? d.magFilter : ni),
            (o.minFilter = d.minFilter !== void 0 ? d.minFilter : ni),
            (o.anisotropy = d.anisotropy !== void 0 ? d.anisotropy : 1),
            d.colorSpace !== void 0 && (o.colorSpace = d.colorSpace),
            d.flipY !== void 0 && (o.flipY = d.flipY),
            d.format !== void 0 && (o.format = d.format),
            d.type !== void 0 && (o.type = d.type),
            d.mipmaps !== void 0 &&
              ((o.mipmaps = d.mipmaps), (o.minFilter = Hl)),
            d.mipmapCount === 1 && (o.minFilter = ni),
            d.generateMipmaps !== void 0 &&
              (o.generateMipmaps = d.generateMipmaps),
            (o.needsUpdate = !0),
            t && t(o, d));
        },
        n,
        r,
      ),
      o
    );
  }
}
class R6 extends _a {
  constructor(e) {
    super(e);
  }
  load(e, t, n, r) {
    const s = new Fi(),
      o = new b0(this.manager);
    return (
      o.setCrossOrigin(this.crossOrigin),
      o.setPath(this.path),
      o.load(
        e,
        function (u) {
          ((s.image = u), (s.needsUpdate = !0), t !== void 0 && t(s));
        },
        n,
        r,
      ),
      s
    );
  }
}
class pf extends In {
  constructor(e, t = 1) {
    (super(),
      (this.isLight = !0),
      (this.type = "Light"),
      (this.color = new wt(e)),
      (this.intensity = t));
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.color.copy(e.color),
      (this.intensity = e.intensity),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.color = this.color.getHex()),
      (t.object.intensity = this.intensity),
      t
    );
  }
}
class IN extends pf {
  constructor(e, t, n) {
    (super(e, n),
      (this.isHemisphereLight = !0),
      (this.type = "HemisphereLight"),
      this.position.copy(In.DEFAULT_UP),
      this.updateMatrix(),
      (this.groundColor = new wt(t)));
  }
  copy(e, t) {
    return (super.copy(e, t), this.groundColor.copy(e.groundColor), this);
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return ((t.object.groundColor = this.groundColor.getHex()), t);
  }
}
const vS = new qt(),
  DC = new te(),
  LC = new te();
class dE {
  constructor(e) {
    ((this.camera = e),
      (this.intensity = 1),
      (this.bias = 0),
      (this.biasNode = null),
      (this.normalBias = 0),
      (this.radius = 1),
      (this.blurSamples = 8),
      (this.mapSize = new nt(512, 512)),
      (this.mapType = Bs),
      (this.map = null),
      (this.mapPass = null),
      (this.matrix = new qt()),
      (this.autoUpdate = !0),
      (this.needsUpdate = !1),
      (this._frustum = new kp()),
      (this._frameExtents = new nt(1, 1)),
      (this._viewportCount = 1),
      (this._viewports = [new Dn(0, 0, 1, 1)]));
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const t = this.camera,
      n = this.matrix;
    (DC.setFromMatrixPosition(e.matrixWorld),
      t.position.copy(DC),
      LC.setFromMatrixPosition(e.target.matrixWorld),
      t.lookAt(LC),
      t.updateMatrixWorld(),
      vS.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(
        vS,
        t.coordinateSystem,
        t.reversedDepth,
      ),
      t.coordinateSystem === Nh || t.reversedDepth
        ? n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 1, 0, 0, 0, 0, 1)
        : n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
      n.multiply(vS));
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    (this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose());
  }
  copy(e) {
    return (
      (this.camera = e.camera.clone()),
      (this.intensity = e.intensity),
      (this.bias = e.bias),
      (this.radius = e.radius),
      (this.autoUpdate = e.autoUpdate),
      (this.needsUpdate = e.needsUpdate),
      (this.normalBias = e.normalBias),
      (this.blurSamples = e.blurSamples),
      this.mapSize.copy(e.mapSize),
      (this.biasNode = e.biasNode),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return (
      this.intensity !== 1 && (e.intensity = this.intensity),
      this.bias !== 0 && (e.bias = this.bias),
      this.normalBias !== 0 && (e.normalBias = this.normalBias),
      this.radius !== 1 && (e.radius = this.radius),
      (this.mapSize.x !== 512 || this.mapSize.y !== 512) &&
        (e.mapSize = this.mapSize.toArray()),
      (e.camera = this.camera.toJSON(!1).object),
      delete e.camera.matrix,
      e
    );
  }
}
const ex = new te(),
  tx = new Jr(),
  Ol = new te();
class Rb extends In {
  constructor() {
    (super(),
      (this.isCamera = !0),
      (this.type = "Camera"),
      (this.matrixWorldInverse = new qt()),
      (this.projectionMatrix = new qt()),
      (this.projectionMatrixInverse = new qt()),
      (this.coordinateSystem = Ua),
      (this._reversedDepth = !1));
  }
  get reversedDepth() {
    return this._reversedDepth;
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.matrixWorldInverse.copy(e.matrixWorldInverse),
      this.projectionMatrix.copy(e.projectionMatrix),
      this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
      (this.coordinateSystem = e.coordinateSystem),
      this
    );
  }
  getWorldDirection(e) {
    return super.getWorldDirection(e).negate();
  }
  updateMatrixWorld(e) {
    (super.updateMatrixWorld(e),
      this.matrixWorld.decompose(ex, tx, Ol),
      Ol.x === 1 && Ol.y === 1 && Ol.z === 1
        ? this.matrixWorldInverse.copy(this.matrixWorld).invert()
        : this.matrixWorldInverse.compose(ex, tx, Ol.set(1, 1, 1)).invert());
  }
  updateWorldMatrix(e, t) {
    (super.updateWorldMatrix(e, t),
      this.matrixWorld.decompose(ex, tx, Ol),
      Ol.x === 1 && Ol.y === 1 && Ol.z === 1
        ? this.matrixWorldInverse.copy(this.matrixWorld).invert()
        : this.matrixWorldInverse.compose(ex, tx, Ol.set(1, 1, 1)).invert());
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Xu = new te(),
  NC = new nt(),
  UC = new nt();
class ir extends Rb {
  constructor(e = 50, t = 1, n = 0.1, r = 2e3) {
    (super(),
      (this.isPerspectiveCamera = !0),
      (this.type = "PerspectiveCamera"),
      (this.fov = e),
      (this.zoom = 1),
      (this.near = n),
      (this.far = r),
      (this.focus = 10),
      (this.aspect = t),
      (this.view = null),
      (this.filmGauge = 35),
      (this.filmOffset = 0),
      this.updateProjectionMatrix());
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.fov = e.fov),
      (this.zoom = e.zoom),
      (this.near = e.near),
      (this.far = e.far),
      (this.focus = e.focus),
      (this.aspect = e.aspect),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      (this.filmGauge = e.filmGauge),
      (this.filmOffset = e.filmOffset),
      this
    );
  }
  setFocalLength(e) {
    const t = (0.5 * this.getFilmHeight()) / e;
    ((this.fov = wp * 2 * Math.atan(t)), this.updateProjectionMatrix());
  }
  getFocalLength() {
    const e = Math.tan(wh * 0.5 * this.fov);
    return (0.5 * this.getFilmHeight()) / e;
  }
  getEffectiveFOV() {
    return wp * 2 * Math.atan(Math.tan(wh * 0.5 * this.fov) / this.zoom);
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  getViewBounds(e, t, n) {
    (Xu.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse),
      t.set(Xu.x, Xu.y).multiplyScalar(-e / Xu.z),
      Xu.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse),
      n.set(Xu.x, Xu.y).multiplyScalar(-e / Xu.z));
  }
  getViewSize(e, t) {
    return (this.getViewBounds(e, NC, UC), t.subVectors(UC, NC));
  }
  setViewOffset(e, t, n, r, s, o) {
    ((this.aspect = e / t),
      this.view === null &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1,
        }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = n),
      (this.view.offsetY = r),
      (this.view.width = s),
      (this.view.height = o),
      this.updateProjectionMatrix());
  }
  clearViewOffset() {
    (this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix());
  }
  updateProjectionMatrix() {
    const e = this.near;
    let t = (e * Math.tan(wh * 0.5 * this.fov)) / this.zoom,
      n = 2 * t,
      r = this.aspect * n,
      s = -0.5 * r;
    const o = this.view;
    if (this.view !== null && this.view.enabled) {
      const h = o.fullWidth,
        d = o.fullHeight;
      ((s += (o.offsetX * r) / h),
        (t -= (o.offsetY * n) / d),
        (r *= o.width / h),
        (n *= o.height / d));
    }
    const u = this.filmOffset;
    (u !== 0 && (s += (e * u) / this.getFilmWidth()),
      this.projectionMatrix.makePerspective(
        s,
        s + r,
        t,
        t - n,
        e,
        this.far,
        this.coordinateSystem,
        this.reversedDepth,
      ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert());
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.fov = this.fov),
      (t.object.zoom = this.zoom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      (t.object.focus = this.focus),
      (t.object.aspect = this.aspect),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      (t.object.filmGauge = this.filmGauge),
      (t.object.filmOffset = this.filmOffset),
      t
    );
  }
}
class D6 extends dE {
  constructor() {
    (super(new ir(50, 1, 0.5, 500)),
      (this.isSpotLightShadow = !0),
      (this.focus = 1),
      (this.aspect = 1));
  }
  updateMatrices(e) {
    const t = this.camera,
      n = wp * 2 * e.angle * this.focus,
      r = (this.mapSize.width / this.mapSize.height) * this.aspect,
      s = e.distance || t.far;
    ((n !== t.fov || r !== t.aspect || s !== t.far) &&
      ((t.fov = n), (t.aspect = r), (t.far = s), t.updateProjectionMatrix()),
      super.updateMatrices(e));
  }
  copy(e) {
    return (super.copy(e), (this.focus = e.focus), this);
  }
}
class ON extends pf {
  constructor(e, t, n = 0, r = Math.PI / 3, s = 0, o = 2) {
    (super(e, t),
      (this.isSpotLight = !0),
      (this.type = "SpotLight"),
      this.position.copy(In.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new In()),
      (this.distance = n),
      (this.angle = r),
      (this.penumbra = s),
      (this.decay = o),
      (this.map = null),
      (this.shadow = new D6()));
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    (super.dispose(), this.shadow.dispose());
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.distance = e.distance),
      (this.angle = e.angle),
      (this.penumbra = e.penumbra),
      (this.decay = e.decay),
      (this.target = e.target.clone()),
      (this.map = e.map),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.distance = this.distance),
      (t.object.angle = this.angle),
      (t.object.decay = this.decay),
      (t.object.penumbra = this.penumbra),
      (t.object.target = this.target.uuid),
      this.map &&
        this.map.isTexture &&
        (t.object.map = this.map.toJSON(e).uuid),
      (t.object.shadow = this.shadow.toJSON()),
      t
    );
  }
}
class L6 extends dE {
  constructor() {
    (super(new ir(90, 1, 0.5, 500)), (this.isPointLightShadow = !0));
  }
}
class FN extends pf {
  constructor(e, t, n = 0, r = 2) {
    (super(e, t),
      (this.isPointLight = !0),
      (this.type = "PointLight"),
      (this.distance = n),
      (this.decay = r),
      (this.shadow = new L6()));
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    (super.dispose(), this.shadow.dispose());
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.distance = e.distance),
      (this.decay = e.decay),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.distance = this.distance),
      (t.object.decay = this.decay),
      (t.object.shadow = this.shadow.toJSON()),
      t
    );
  }
}
class Wc extends Rb {
  constructor(e = -1, t = 1, n = 1, r = -1, s = 0.1, o = 2e3) {
    (super(),
      (this.isOrthographicCamera = !0),
      (this.type = "OrthographicCamera"),
      (this.zoom = 1),
      (this.view = null),
      (this.left = e),
      (this.right = t),
      (this.top = n),
      (this.bottom = r),
      (this.near = s),
      (this.far = o),
      this.updateProjectionMatrix());
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.left = e.left),
      (this.right = e.right),
      (this.top = e.top),
      (this.bottom = e.bottom),
      (this.near = e.near),
      (this.far = e.far),
      (this.zoom = e.zoom),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      this
    );
  }
  setViewOffset(e, t, n, r, s, o) {
    (this.view === null &&
      (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1,
      }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = n),
      (this.view.offsetY = r),
      (this.view.width = s),
      (this.view.height = o),
      this.updateProjectionMatrix());
  }
  clearViewOffset() {
    (this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix());
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom),
      t = (this.top - this.bottom) / (2 * this.zoom),
      n = (this.right + this.left) / 2,
      r = (this.top + this.bottom) / 2;
    let s = n - e,
      o = n + e,
      u = r + t,
      h = r - t;
    if (this.view !== null && this.view.enabled) {
      const d = (this.right - this.left) / this.view.fullWidth / this.zoom,
        m = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      ((s += d * this.view.offsetX),
        (o = s + d * this.view.width),
        (u -= m * this.view.offsetY),
        (h = u - m * this.view.height));
    }
    (this.projectionMatrix.makeOrthographic(
      s,
      o,
      u,
      h,
      this.near,
      this.far,
      this.coordinateSystem,
      this.reversedDepth,
    ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert());
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.zoom = this.zoom),
      (t.object.left = this.left),
      (t.object.right = this.right),
      (t.object.top = this.top),
      (t.object.bottom = this.bottom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      t
    );
  }
}
class N6 extends dE {
  constructor() {
    (super(new Wc(-5, 5, 5, -5, 0.5, 500)),
      (this.isDirectionalLightShadow = !0));
  }
}
class zN extends pf {
  constructor(e, t) {
    (super(e, t),
      (this.isDirectionalLight = !0),
      (this.type = "DirectionalLight"),
      this.position.copy(In.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new In()),
      (this.shadow = new N6()));
  }
  dispose() {
    (super.dispose(), this.shadow.dispose());
  }
  copy(e) {
    return (
      super.copy(e),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.shadow = this.shadow.toJSON()),
      (t.object.target = this.target.uuid),
      t
    );
  }
}
class BN extends pf {
  constructor(e, t) {
    (super(e, t), (this.isAmbientLight = !0), (this.type = "AmbientLight"));
  }
}
class kN extends pf {
  constructor(e, t, n = 10, r = 10) {
    (super(e, t),
      (this.isRectAreaLight = !0),
      (this.type = "RectAreaLight"),
      (this.width = n),
      (this.height = r));
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(e) {
    this.intensity = e / (this.width * this.height * Math.PI);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.width = e.width),
      (this.height = e.height),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return ((t.object.width = this.width), (t.object.height = this.height), t);
  }
}
class pE {
  constructor() {
    ((this.isSphericalHarmonics3 = !0), (this.coefficients = []));
    for (let e = 0; e < 9; e++) this.coefficients.push(new te());
  }
  set(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
    return this;
  }
  zero() {
    for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
    return this;
  }
  getAt(e, t) {
    const n = e.x,
      r = e.y,
      s = e.z,
      o = this.coefficients;
    return (
      t.copy(o[0]).multiplyScalar(0.282095),
      t.addScaledVector(o[1], 0.488603 * r),
      t.addScaledVector(o[2], 0.488603 * s),
      t.addScaledVector(o[3], 0.488603 * n),
      t.addScaledVector(o[4], 1.092548 * (n * r)),
      t.addScaledVector(o[5], 1.092548 * (r * s)),
      t.addScaledVector(o[6], 0.315392 * (3 * s * s - 1)),
      t.addScaledVector(o[7], 1.092548 * (n * s)),
      t.addScaledVector(o[8], 0.546274 * (n * n - r * r)),
      t
    );
  }
  getIrradianceAt(e, t) {
    const n = e.x,
      r = e.y,
      s = e.z,
      o = this.coefficients;
    return (
      t.copy(o[0]).multiplyScalar(0.886227),
      t.addScaledVector(o[1], 2 * 0.511664 * r),
      t.addScaledVector(o[2], 2 * 0.511664 * s),
      t.addScaledVector(o[3], 2 * 0.511664 * n),
      t.addScaledVector(o[4], 2 * 0.429043 * n * r),
      t.addScaledVector(o[5], 2 * 0.429043 * r * s),
      t.addScaledVector(o[6], 0.743125 * s * s - 0.247708),
      t.addScaledVector(o[7], 2 * 0.429043 * n * s),
      t.addScaledVector(o[8], 0.429043 * (n * n - r * r)),
      t
    );
  }
  add(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].add(e.coefficients[t]);
    return this;
  }
  addScaledSH(e, t) {
    for (let n = 0; n < 9; n++)
      this.coefficients[n].addScaledVector(e.coefficients[n], t);
    return this;
  }
  scale(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
    return this;
  }
  lerp(e, t) {
    for (let n = 0; n < 9; n++) this.coefficients[n].lerp(e.coefficients[n], t);
    return this;
  }
  equals(e) {
    for (let t = 0; t < 9; t++)
      if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
    return !0;
  }
  copy(e) {
    return this.set(e.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(e, t = 0) {
    const n = this.coefficients;
    for (let r = 0; r < 9; r++) n[r].fromArray(e, t + r * 3);
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.coefficients;
    for (let r = 0; r < 9; r++) n[r].toArray(e, t + r * 3);
    return e;
  }
  static getBasisAt(e, t) {
    const n = e.x,
      r = e.y,
      s = e.z;
    ((t[0] = 0.282095),
      (t[1] = 0.488603 * r),
      (t[2] = 0.488603 * s),
      (t[3] = 0.488603 * n),
      (t[4] = 1.092548 * n * r),
      (t[5] = 1.092548 * r * s),
      (t[6] = 0.315392 * (3 * s * s - 1)),
      (t[7] = 1.092548 * n * s),
      (t[8] = 0.546274 * (n * n - r * r)));
  }
}
class VN extends pf {
  constructor(e = new pE(), t = 1) {
    (super(void 0, t), (this.isLightProbe = !0), (this.sh = e));
  }
  copy(e) {
    return (super.copy(e), this.sh.copy(e.sh), this);
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return ((t.object.sh = this.sh.toArray()), t);
  }
}
class Db extends _a {
  constructor(e) {
    (super(e), (this.textures = {}));
  }
  load(e, t, n, r) {
    const s = this,
      o = new Kc(s.manager);
    (o.setPath(s.path),
      o.setRequestHeader(s.requestHeader),
      o.setWithCredentials(s.withCredentials),
      o.load(
        e,
        function (u) {
          try {
            t(s.parse(JSON.parse(u)));
          } catch (h) {
            (r ? r(h) : Ft(h), s.manager.itemError(e));
          }
        },
        n,
        r,
      ));
  }
  parse(e) {
    const t = this.textures;
    function n(s) {
      return (
        t[s] === void 0 && Tt("MaterialLoader: Undefined texture", s),
        t[s]
      );
    }
    const r = this.createMaterialFromType(e.type);
    if (
      (e.uuid !== void 0 && (r.uuid = e.uuid),
      e.name !== void 0 && (r.name = e.name),
      e.color !== void 0 && r.color !== void 0 && r.color.setHex(e.color),
      e.roughness !== void 0 && (r.roughness = e.roughness),
      e.metalness !== void 0 && (r.metalness = e.metalness),
      e.sheen !== void 0 && (r.sheen = e.sheen),
      e.sheenColor !== void 0 && (r.sheenColor = new wt().setHex(e.sheenColor)),
      e.sheenRoughness !== void 0 && (r.sheenRoughness = e.sheenRoughness),
      e.emissive !== void 0 &&
        r.emissive !== void 0 &&
        r.emissive.setHex(e.emissive),
      e.specular !== void 0 &&
        r.specular !== void 0 &&
        r.specular.setHex(e.specular),
      e.specularIntensity !== void 0 &&
        (r.specularIntensity = e.specularIntensity),
      e.specularColor !== void 0 &&
        r.specularColor !== void 0 &&
        r.specularColor.setHex(e.specularColor),
      e.shininess !== void 0 && (r.shininess = e.shininess),
      e.clearcoat !== void 0 && (r.clearcoat = e.clearcoat),
      e.clearcoatRoughness !== void 0 &&
        (r.clearcoatRoughness = e.clearcoatRoughness),
      e.dispersion !== void 0 && (r.dispersion = e.dispersion),
      e.iridescence !== void 0 && (r.iridescence = e.iridescence),
      e.iridescenceIOR !== void 0 && (r.iridescenceIOR = e.iridescenceIOR),
      e.iridescenceThicknessRange !== void 0 &&
        (r.iridescenceThicknessRange = e.iridescenceThicknessRange),
      e.transmission !== void 0 && (r.transmission = e.transmission),
      e.thickness !== void 0 && (r.thickness = e.thickness),
      e.attenuationDistance !== void 0 &&
        (r.attenuationDistance = e.attenuationDistance),
      e.attenuationColor !== void 0 &&
        r.attenuationColor !== void 0 &&
        r.attenuationColor.setHex(e.attenuationColor),
      e.anisotropy !== void 0 && (r.anisotropy = e.anisotropy),
      e.anisotropyRotation !== void 0 &&
        (r.anisotropyRotation = e.anisotropyRotation),
      e.fog !== void 0 && (r.fog = e.fog),
      e.flatShading !== void 0 && (r.flatShading = e.flatShading),
      e.blending !== void 0 && (r.blending = e.blending),
      e.combine !== void 0 && (r.combine = e.combine),
      e.side !== void 0 && (r.side = e.side),
      e.shadowSide !== void 0 && (r.shadowSide = e.shadowSide),
      e.opacity !== void 0 && (r.opacity = e.opacity),
      e.transparent !== void 0 && (r.transparent = e.transparent),
      e.alphaTest !== void 0 && (r.alphaTest = e.alphaTest),
      e.alphaHash !== void 0 && (r.alphaHash = e.alphaHash),
      e.depthFunc !== void 0 && (r.depthFunc = e.depthFunc),
      e.depthTest !== void 0 && (r.depthTest = e.depthTest),
      e.depthWrite !== void 0 && (r.depthWrite = e.depthWrite),
      e.colorWrite !== void 0 && (r.colorWrite = e.colorWrite),
      e.blendSrc !== void 0 && (r.blendSrc = e.blendSrc),
      e.blendDst !== void 0 && (r.blendDst = e.blendDst),
      e.blendEquation !== void 0 && (r.blendEquation = e.blendEquation),
      e.blendSrcAlpha !== void 0 && (r.blendSrcAlpha = e.blendSrcAlpha),
      e.blendDstAlpha !== void 0 && (r.blendDstAlpha = e.blendDstAlpha),
      e.blendEquationAlpha !== void 0 &&
        (r.blendEquationAlpha = e.blendEquationAlpha),
      e.blendColor !== void 0 &&
        r.blendColor !== void 0 &&
        r.blendColor.setHex(e.blendColor),
      e.blendAlpha !== void 0 && (r.blendAlpha = e.blendAlpha),
      e.stencilWriteMask !== void 0 &&
        (r.stencilWriteMask = e.stencilWriteMask),
      e.stencilFunc !== void 0 && (r.stencilFunc = e.stencilFunc),
      e.stencilRef !== void 0 && (r.stencilRef = e.stencilRef),
      e.stencilFuncMask !== void 0 && (r.stencilFuncMask = e.stencilFuncMask),
      e.stencilFail !== void 0 && (r.stencilFail = e.stencilFail),
      e.stencilZFail !== void 0 && (r.stencilZFail = e.stencilZFail),
      e.stencilZPass !== void 0 && (r.stencilZPass = e.stencilZPass),
      e.stencilWrite !== void 0 && (r.stencilWrite = e.stencilWrite),
      e.wireframe !== void 0 && (r.wireframe = e.wireframe),
      e.wireframeLinewidth !== void 0 &&
        (r.wireframeLinewidth = e.wireframeLinewidth),
      e.wireframeLinecap !== void 0 &&
        (r.wireframeLinecap = e.wireframeLinecap),
      e.wireframeLinejoin !== void 0 &&
        (r.wireframeLinejoin = e.wireframeLinejoin),
      e.rotation !== void 0 && (r.rotation = e.rotation),
      e.linewidth !== void 0 && (r.linewidth = e.linewidth),
      e.dashSize !== void 0 && (r.dashSize = e.dashSize),
      e.gapSize !== void 0 && (r.gapSize = e.gapSize),
      e.scale !== void 0 && (r.scale = e.scale),
      e.polygonOffset !== void 0 && (r.polygonOffset = e.polygonOffset),
      e.polygonOffsetFactor !== void 0 &&
        (r.polygonOffsetFactor = e.polygonOffsetFactor),
      e.polygonOffsetUnits !== void 0 &&
        (r.polygonOffsetUnits = e.polygonOffsetUnits),
      e.dithering !== void 0 && (r.dithering = e.dithering),
      e.alphaToCoverage !== void 0 && (r.alphaToCoverage = e.alphaToCoverage),
      e.premultipliedAlpha !== void 0 &&
        (r.premultipliedAlpha = e.premultipliedAlpha),
      e.forceSinglePass !== void 0 && (r.forceSinglePass = e.forceSinglePass),
      e.allowOverride !== void 0 && (r.allowOverride = e.allowOverride),
      e.visible !== void 0 && (r.visible = e.visible),
      e.toneMapped !== void 0 && (r.toneMapped = e.toneMapped),
      e.userData !== void 0 && (r.userData = e.userData),
      e.vertexColors !== void 0 &&
        (typeof e.vertexColors == "number"
          ? (r.vertexColors = e.vertexColors > 0)
          : (r.vertexColors = e.vertexColors)),
      e.uniforms !== void 0)
    )
      for (const s in e.uniforms) {
        const o = e.uniforms[s];
        switch (((r.uniforms[s] = {}), o.type)) {
          case "t":
            r.uniforms[s].value = n(o.value);
            break;
          case "c":
            r.uniforms[s].value = new wt().setHex(o.value);
            break;
          case "v2":
            r.uniforms[s].value = new nt().fromArray(o.value);
            break;
          case "v3":
            r.uniforms[s].value = new te().fromArray(o.value);
            break;
          case "v4":
            r.uniforms[s].value = new Dn().fromArray(o.value);
            break;
          case "m3":
            r.uniforms[s].value = new tn().fromArray(o.value);
            break;
          case "m4":
            r.uniforms[s].value = new qt().fromArray(o.value);
            break;
          default:
            r.uniforms[s].value = o.value;
        }
      }
    if (
      (e.defines !== void 0 && (r.defines = e.defines),
      e.vertexShader !== void 0 && (r.vertexShader = e.vertexShader),
      e.fragmentShader !== void 0 && (r.fragmentShader = e.fragmentShader),
      e.glslVersion !== void 0 && (r.glslVersion = e.glslVersion),
      e.extensions !== void 0)
    )
      for (const s in e.extensions) r.extensions[s] = e.extensions[s];
    if (
      (e.lights !== void 0 && (r.lights = e.lights),
      e.clipping !== void 0 && (r.clipping = e.clipping),
      e.size !== void 0 && (r.size = e.size),
      e.sizeAttenuation !== void 0 && (r.sizeAttenuation = e.sizeAttenuation),
      e.map !== void 0 && (r.map = n(e.map)),
      e.matcap !== void 0 && (r.matcap = n(e.matcap)),
      e.alphaMap !== void 0 && (r.alphaMap = n(e.alphaMap)),
      e.bumpMap !== void 0 && (r.bumpMap = n(e.bumpMap)),
      e.bumpScale !== void 0 && (r.bumpScale = e.bumpScale),
      e.normalMap !== void 0 && (r.normalMap = n(e.normalMap)),
      e.normalMapType !== void 0 && (r.normalMapType = e.normalMapType),
      e.normalScale !== void 0)
    ) {
      let s = e.normalScale;
      (Array.isArray(s) === !1 && (s = [s, s]),
        (r.normalScale = new nt().fromArray(s)));
    }
    return (
      e.displacementMap !== void 0 &&
        (r.displacementMap = n(e.displacementMap)),
      e.displacementScale !== void 0 &&
        (r.displacementScale = e.displacementScale),
      e.displacementBias !== void 0 &&
        (r.displacementBias = e.displacementBias),
      e.roughnessMap !== void 0 && (r.roughnessMap = n(e.roughnessMap)),
      e.metalnessMap !== void 0 && (r.metalnessMap = n(e.metalnessMap)),
      e.emissiveMap !== void 0 && (r.emissiveMap = n(e.emissiveMap)),
      e.emissiveIntensity !== void 0 &&
        (r.emissiveIntensity = e.emissiveIntensity),
      e.specularMap !== void 0 && (r.specularMap = n(e.specularMap)),
      e.specularIntensityMap !== void 0 &&
        (r.specularIntensityMap = n(e.specularIntensityMap)),
      e.specularColorMap !== void 0 &&
        (r.specularColorMap = n(e.specularColorMap)),
      e.envMap !== void 0 && (r.envMap = n(e.envMap)),
      e.envMapRotation !== void 0 &&
        r.envMapRotation.fromArray(e.envMapRotation),
      e.envMapIntensity !== void 0 && (r.envMapIntensity = e.envMapIntensity),
      e.reflectivity !== void 0 && (r.reflectivity = e.reflectivity),
      e.refractionRatio !== void 0 && (r.refractionRatio = e.refractionRatio),
      e.lightMap !== void 0 && (r.lightMap = n(e.lightMap)),
      e.lightMapIntensity !== void 0 &&
        (r.lightMapIntensity = e.lightMapIntensity),
      e.aoMap !== void 0 && (r.aoMap = n(e.aoMap)),
      e.aoMapIntensity !== void 0 && (r.aoMapIntensity = e.aoMapIntensity),
      e.gradientMap !== void 0 && (r.gradientMap = n(e.gradientMap)),
      e.clearcoatMap !== void 0 && (r.clearcoatMap = n(e.clearcoatMap)),
      e.clearcoatRoughnessMap !== void 0 &&
        (r.clearcoatRoughnessMap = n(e.clearcoatRoughnessMap)),
      e.clearcoatNormalMap !== void 0 &&
        (r.clearcoatNormalMap = n(e.clearcoatNormalMap)),
      e.clearcoatNormalScale !== void 0 &&
        (r.clearcoatNormalScale = new nt().fromArray(e.clearcoatNormalScale)),
      e.iridescenceMap !== void 0 && (r.iridescenceMap = n(e.iridescenceMap)),
      e.iridescenceThicknessMap !== void 0 &&
        (r.iridescenceThicknessMap = n(e.iridescenceThicknessMap)),
      e.transmissionMap !== void 0 &&
        (r.transmissionMap = n(e.transmissionMap)),
      e.thicknessMap !== void 0 && (r.thicknessMap = n(e.thicknessMap)),
      e.anisotropyMap !== void 0 && (r.anisotropyMap = n(e.anisotropyMap)),
      e.sheenColorMap !== void 0 && (r.sheenColorMap = n(e.sheenColorMap)),
      e.sheenRoughnessMap !== void 0 &&
        (r.sheenRoughnessMap = n(e.sheenRoughnessMap)),
      r
    );
  }
  setTextures(e) {
    return ((this.textures = e), this);
  }
  createMaterialFromType(e) {
    return Db.createMaterialFromType(e);
  }
  static createMaterialFromType(e) {
    const t = {
      ShadowMaterial: _N,
      SpriteMaterial: ZT,
      RawShaderMaterial: aE,
      ShaderMaterial: ba,
      PointsMaterial: QT,
      MeshPhysicalMaterial: lE,
      MeshStandardMaterial: oE,
      MeshPhongMaterial: MN,
      MeshToonMaterial: TN,
      MeshNormalMaterial: EN,
      MeshLambertMaterial: wN,
      MeshDepthMaterial: Ab,
      MeshDistanceMaterial: Cb,
      MeshBasicMaterial: Jc,
      MeshMatcapMaterial: AN,
      LineDashedMaterial: CN,
      LineBasicMaterial: Ws,
      Material: bs,
    };
    return new t[e]();
  }
}
class DM {
  static extractUrlBase(e) {
    const t = e.lastIndexOf("/");
    return t === -1 ? "./" : e.slice(0, t + 1);
  }
  static resolveURL(e, t) {
    return typeof e != "string" || e === ""
      ? ""
      : (/^https?:\/\//i.test(t) &&
          /^\//.test(e) &&
          (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
        /^(https?:)?\/\//i.test(e) ||
        /^data:.*,.*$/i.test(e) ||
        /^blob:.*$/i.test(e)
          ? e
          : t + e);
  }
}
class Lb extends nn {
  constructor() {
    (super(),
      (this.isInstancedBufferGeometry = !0),
      (this.type = "InstancedBufferGeometry"),
      (this.instanceCount = 1 / 0));
  }
  copy(e) {
    return (super.copy(e), (this.instanceCount = e.instanceCount), this);
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.instanceCount = this.instanceCount),
      (e.isInstancedBufferGeometry = !0),
      e
    );
  }
}
class GN extends _a {
  constructor(e) {
    super(e);
  }
  load(e, t, n, r) {
    const s = this,
      o = new Kc(s.manager);
    (o.setPath(s.path),
      o.setRequestHeader(s.requestHeader),
      o.setWithCredentials(s.withCredentials),
      o.load(
        e,
        function (u) {
          try {
            t(s.parse(JSON.parse(u)));
          } catch (h) {
            (r ? r(h) : Ft(h), s.manager.itemError(e));
          }
        },
        n,
        r,
      ));
  }
  parse(e) {
    const t = {},
      n = {};
    function r(b, _) {
      if (t[_] !== void 0) return t[_];
      const E = b.interleavedBuffers[_],
        T = s(b, E.buffer),
        C = yp(E.type, T),
        R = new ub(C, E.stride);
      return ((R.uuid = E.uuid), (t[_] = R), R);
    }
    function s(b, _) {
      if (n[_] !== void 0) return n[_];
      const E = b.arrayBuffers[_],
        T = new Uint32Array(E).buffer;
      return ((n[_] = T), T);
    }
    const o = e.isInstancedBufferGeometry ? new Lb() : new nn(),
      u = e.data.index;
    if (u !== void 0) {
      const b = yp(u.type, u.array);
      o.setIndex(new $n(b, 1));
    }
    const h = e.data.attributes;
    for (const b in h) {
      const _ = h[b];
      let w;
      if (_.isInterleavedBufferAttribute) {
        const E = r(e.data, _.data);
        w = new Pa(E, _.itemSize, _.offset, _.normalized);
      } else {
        const E = yp(_.type, _.array),
          T = _.isInstancedBufferAttribute ? Uh : $n;
        w = new T(E, _.itemSize, _.normalized);
      }
      (_.name !== void 0 && (w.name = _.name),
        _.usage !== void 0 && w.setUsage(_.usage),
        o.setAttribute(b, w));
    }
    const d = e.data.morphAttributes;
    if (d)
      for (const b in d) {
        const _ = d[b],
          w = [];
        for (let E = 0, T = _.length; E < T; E++) {
          const C = _[E];
          let R;
          if (C.isInterleavedBufferAttribute) {
            const L = r(e.data, C.data);
            R = new Pa(L, C.itemSize, C.offset, C.normalized);
          } else {
            const L = yp(C.type, C.array);
            R = new $n(L, C.itemSize, C.normalized);
          }
          (C.name !== void 0 && (R.name = C.name), w.push(R));
        }
        o.morphAttributes[b] = w;
      }
    e.data.morphTargetsRelative && (o.morphTargetsRelative = !0);
    const v = e.data.groups || e.data.drawcalls || e.data.offsets;
    if (v !== void 0)
      for (let b = 0, _ = v.length; b !== _; ++b) {
        const w = v[b];
        o.addGroup(w.start, w.count, w.materialIndex);
      }
    const y = e.data.boundingSphere;
    return (
      y !== void 0 && (o.boundingSphere = new mr().fromJSON(y)),
      e.name && (o.name = e.name),
      e.userData && (o.userData = e.userData),
      o
    );
  }
}
class U6 extends _a {
  constructor(e) {
    super(e);
  }
  load(e, t, n, r) {
    const s = this,
      o = this.path === "" ? DM.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || o;
    const u = new Kc(this.manager);
    (u.setPath(this.path),
      u.setRequestHeader(this.requestHeader),
      u.setWithCredentials(this.withCredentials),
      u.load(
        e,
        function (h) {
          let d = null;
          try {
            d = JSON.parse(h);
          } catch (v) {
            (r !== void 0 && r(v),
              v("ObjectLoader: Can't parse " + e + ".", v.message));
            return;
          }
          const m = d.metadata;
          if (
            m === void 0 ||
            m.type === void 0 ||
            m.type.toLowerCase() === "geometry"
          ) {
            (r !== void 0 &&
              r(new Error("THREE.ObjectLoader: Can't load " + e)),
              Ft("ObjectLoader: Can't load " + e));
            return;
          }
          s.parse(d, t);
        },
        n,
        r,
      ));
  }
  async loadAsync(e, t) {
    const n = this,
      r = this.path === "" ? DM.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || r;
    const s = new Kc(this.manager);
    (s.setPath(this.path),
      s.setRequestHeader(this.requestHeader),
      s.setWithCredentials(this.withCredentials));
    const o = await s.loadAsync(e, t);
    let u;
    try {
      u = JSON.parse(o);
    } catch (d) {
      throw new Error("ObjectLoader: Can't parse " + e + ". " + d.message);
    }
    const h = u.metadata;
    if (
      h === void 0 ||
      h.type === void 0 ||
      h.type.toLowerCase() === "geometry"
    )
      throw new Error("THREE.ObjectLoader: Can't load " + e);
    return await n.parseAsync(u);
  }
  parse(e, t) {
    const n = this.parseAnimations(e.animations),
      r = this.parseShapes(e.shapes),
      s = this.parseGeometries(e.geometries, r),
      o = this.parseImages(e.images, function () {
        t !== void 0 && t(d);
      }),
      u = this.parseTextures(e.textures, o),
      h = this.parseMaterials(e.materials, u),
      d = this.parseObject(e.object, s, h, u, n),
      m = this.parseSkeletons(e.skeletons, d);
    if ((this.bindSkeletons(d, m), this.bindLightTargets(d), t !== void 0)) {
      let v = !1;
      for (const y in o)
        if (o[y].data instanceof HTMLImageElement) {
          v = !0;
          break;
        }
      v === !1 && t(d);
    }
    return d;
  }
  async parseAsync(e) {
    const t = this.parseAnimations(e.animations),
      n = this.parseShapes(e.shapes),
      r = this.parseGeometries(e.geometries, n),
      s = await this.parseImagesAsync(e.images),
      o = this.parseTextures(e.textures, s),
      u = this.parseMaterials(e.materials, o),
      h = this.parseObject(e.object, r, u, o, t),
      d = this.parseSkeletons(e.skeletons, h);
    return (this.bindSkeletons(h, d), this.bindLightTargets(h), h);
  }
  parseShapes(e) {
    const t = {};
    if (e !== void 0)
      for (let n = 0, r = e.length; n < r; n++) {
        const s = new Ah().fromJSON(e[n]);
        t[s.uuid] = s;
      }
    return t;
  }
  parseSkeletons(e, t) {
    const n = {},
      r = {};
    if (
      (t.traverse(function (s) {
        s.isBone && (r[s.uuid] = s);
      }),
      e !== void 0)
    )
      for (let s = 0, o = e.length; s < o; s++) {
        const u = new fb().fromJSON(e[s], r);
        n[u.uuid] = u;
      }
    return n;
  }
  parseGeometries(e, t) {
    const n = {};
    if (e !== void 0) {
      const r = new GN();
      for (let s = 0, o = e.length; s < o; s++) {
        let u;
        const h = e[s];
        switch (h.type) {
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            u = r.parse(h);
            break;
          default:
            h.type in CC
              ? (u = CC[h.type].fromJSON(h, t))
              : Tt(`ObjectLoader: Unsupported geometry type "${h.type}"`);
        }
        ((u.uuid = h.uuid),
          h.name !== void 0 && (u.name = h.name),
          h.userData !== void 0 && (u.userData = h.userData),
          (n[h.uuid] = u));
      }
    }
    return n;
  }
  parseMaterials(e, t) {
    const n = {},
      r = {};
    if (e !== void 0) {
      const s = new Db();
      s.setTextures(t);
      for (let o = 0, u = e.length; o < u; o++) {
        const h = e[o];
        (n[h.uuid] === void 0 && (n[h.uuid] = s.parse(h)),
          (r[h.uuid] = n[h.uuid]));
      }
    }
    return r;
  }
  parseAnimations(e) {
    const t = {};
    if (e !== void 0)
      for (let n = 0; n < e.length; n++) {
        const r = e[n],
          s = x0.parse(r);
        t[s.uuid] = s;
      }
    return t;
  }
  parseImages(e, t) {
    const n = this,
      r = {};
    let s;
    function o(h) {
      return (
        n.manager.itemStart(h),
        s.load(
          h,
          function () {
            n.manager.itemEnd(h);
          },
          void 0,
          function () {
            (n.manager.itemError(h), n.manager.itemEnd(h));
          },
        )
      );
    }
    function u(h) {
      if (typeof h == "string") {
        const d = h,
          m = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(d) ? d : n.resourcePath + d;
        return o(m);
      } else
        return h.data
          ? { data: yp(h.type, h.data), width: h.width, height: h.height }
          : null;
    }
    if (e !== void 0 && e.length > 0) {
      const h = new hE(t);
      ((s = new b0(h)), s.setCrossOrigin(this.crossOrigin));
      for (let d = 0, m = e.length; d < m; d++) {
        const v = e[d],
          y = v.url;
        if (Array.isArray(y)) {
          const b = [];
          for (let _ = 0, w = y.length; _ < w; _++) {
            const E = y[_],
              T = u(E);
            T !== null &&
              (T instanceof HTMLImageElement
                ? b.push(T)
                : b.push(new Ko(T.data, T.width, T.height)));
          }
          r[v.uuid] = new ef(b);
        } else {
          const b = u(v.url);
          r[v.uuid] = new ef(b);
        }
      }
    }
    return r;
  }
  async parseImagesAsync(e) {
    const t = this,
      n = {};
    let r;
    async function s(o) {
      if (typeof o == "string") {
        const u = o,
          h = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(u) ? u : t.resourcePath + u;
        return await r.loadAsync(h);
      } else
        return o.data
          ? { data: yp(o.type, o.data), width: o.width, height: o.height }
          : null;
    }
    if (e !== void 0 && e.length > 0) {
      ((r = new b0(this.manager)), r.setCrossOrigin(this.crossOrigin));
      for (let o = 0, u = e.length; o < u; o++) {
        const h = e[o],
          d = h.url;
        if (Array.isArray(d)) {
          const m = [];
          for (let v = 0, y = d.length; v < y; v++) {
            const b = d[v],
              _ = await s(b);
            _ !== null &&
              (_ instanceof HTMLImageElement
                ? m.push(_)
                : m.push(new Ko(_.data, _.width, _.height)));
          }
          n[h.uuid] = new ef(m);
        } else {
          const m = await s(h.url);
          n[h.uuid] = new ef(m);
        }
      }
    }
    return n;
  }
  parseTextures(e, t) {
    function n(s, o) {
      return typeof s == "number"
        ? s
        : (Tt(
            "ObjectLoader.parseTexture: Constant should be in numeric form.",
            s,
          ),
          o[s]);
    }
    const r = {};
    if (e !== void 0)
      for (let s = 0, o = e.length; s < o; s++) {
        const u = e[s];
        (u.image === void 0 &&
          Tt('ObjectLoader: No "image" specified for', u.uuid),
          t[u.image] === void 0 &&
            Tt("ObjectLoader: Undefined image", u.image));
        const h = t[u.image],
          d = h.data;
        let m;
        (Array.isArray(d)
          ? ((m = new N0()), d.length === 6 && (m.needsUpdate = !0))
          : (d && d.data ? (m = new Ko()) : (m = new Fi()),
            d && (m.needsUpdate = !0)),
          (m.source = h),
          (m.uuid = u.uuid),
          u.name !== void 0 && (m.name = u.name),
          u.mapping !== void 0 && (m.mapping = n(u.mapping, P6)),
          u.channel !== void 0 && (m.channel = u.channel),
          u.offset !== void 0 && m.offset.fromArray(u.offset),
          u.repeat !== void 0 && m.repeat.fromArray(u.repeat),
          u.center !== void 0 && m.center.fromArray(u.center),
          u.rotation !== void 0 && (m.rotation = u.rotation),
          u.wrap !== void 0 &&
            ((m.wrapS = n(u.wrap[0], PC)), (m.wrapT = n(u.wrap[1], PC))),
          u.format !== void 0 && (m.format = u.format),
          u.internalFormat !== void 0 && (m.internalFormat = u.internalFormat),
          u.type !== void 0 && (m.type = u.type),
          u.colorSpace !== void 0 && (m.colorSpace = u.colorSpace),
          u.minFilter !== void 0 && (m.minFilter = n(u.minFilter, IC)),
          u.magFilter !== void 0 && (m.magFilter = n(u.magFilter, IC)),
          u.anisotropy !== void 0 && (m.anisotropy = u.anisotropy),
          u.flipY !== void 0 && (m.flipY = u.flipY),
          u.generateMipmaps !== void 0 &&
            (m.generateMipmaps = u.generateMipmaps),
          u.premultiplyAlpha !== void 0 &&
            (m.premultiplyAlpha = u.premultiplyAlpha),
          u.unpackAlignment !== void 0 &&
            (m.unpackAlignment = u.unpackAlignment),
          u.compareFunction !== void 0 &&
            (m.compareFunction = u.compareFunction),
          u.userData !== void 0 && (m.userData = u.userData),
          (r[u.uuid] = m));
      }
    return r;
  }
  parseObject(e, t, n, r, s) {
    let o;
    function u(y) {
      return (
        t[y] === void 0 && Tt("ObjectLoader: Undefined geometry", y),
        t[y]
      );
    }
    function h(y) {
      if (y !== void 0) {
        if (Array.isArray(y)) {
          const b = [];
          for (let _ = 0, w = y.length; _ < w; _++) {
            const E = y[_];
            (n[E] === void 0 && Tt("ObjectLoader: Undefined material", E),
              b.push(n[E]));
          }
          return b;
        }
        return (
          n[y] === void 0 && Tt("ObjectLoader: Undefined material", y),
          n[y]
        );
      }
    }
    function d(y) {
      return (
        r[y] === void 0 && Tt("ObjectLoader: Undefined texture", y),
        r[y]
      );
    }
    let m, v;
    switch (e.type) {
      case "Scene":
        ((o = new XT()),
          e.background !== void 0 &&
            (Number.isInteger(e.background)
              ? (o.background = new wt(e.background))
              : (o.background = d(e.background))),
          e.environment !== void 0 && (o.environment = d(e.environment)),
          e.fog !== void 0 &&
            (e.fog.type === "Fog"
              ? (o.fog = new cb(e.fog.color, e.fog.near, e.fog.far))
              : e.fog.type === "FogExp2" &&
                (o.fog = new lb(e.fog.color, e.fog.density)),
            e.fog.name !== "" && (o.fog.name = e.fog.name)),
          e.backgroundBlurriness !== void 0 &&
            (o.backgroundBlurriness = e.backgroundBlurriness),
          e.backgroundIntensity !== void 0 &&
            (o.backgroundIntensity = e.backgroundIntensity),
          e.backgroundRotation !== void 0 &&
            o.backgroundRotation.fromArray(e.backgroundRotation),
          e.environmentIntensity !== void 0 &&
            (o.environmentIntensity = e.environmentIntensity),
          e.environmentRotation !== void 0 &&
            o.environmentRotation.fromArray(e.environmentRotation));
        break;
      case "PerspectiveCamera":
        ((o = new ir(e.fov, e.aspect, e.near, e.far)),
          e.focus !== void 0 && (o.focus = e.focus),
          e.zoom !== void 0 && (o.zoom = e.zoom),
          e.filmGauge !== void 0 && (o.filmGauge = e.filmGauge),
          e.filmOffset !== void 0 && (o.filmOffset = e.filmOffset),
          e.view !== void 0 && (o.view = Object.assign({}, e.view)));
        break;
      case "OrthographicCamera":
        ((o = new Wc(e.left, e.right, e.top, e.bottom, e.near, e.far)),
          e.zoom !== void 0 && (o.zoom = e.zoom),
          e.view !== void 0 && (o.view = Object.assign({}, e.view)));
        break;
      case "AmbientLight":
        o = new BN(e.color, e.intensity);
        break;
      case "DirectionalLight":
        ((o = new zN(e.color, e.intensity)), (o.target = e.target || ""));
        break;
      case "PointLight":
        o = new FN(e.color, e.intensity, e.distance, e.decay);
        break;
      case "RectAreaLight":
        o = new kN(e.color, e.intensity, e.width, e.height);
        break;
      case "SpotLight":
        ((o = new ON(
          e.color,
          e.intensity,
          e.distance,
          e.angle,
          e.penumbra,
          e.decay,
        )),
          (o.target = e.target || ""));
        break;
      case "HemisphereLight":
        o = new IN(e.color, e.groundColor, e.intensity);
        break;
      case "LightProbe":
        const y = new pE().fromArray(e.sh);
        o = new VN(y, e.intensity);
        break;
      case "SkinnedMesh":
        ((m = u(e.geometry)),
          (v = h(e.material)),
          (o = new rN(m, v)),
          e.bindMode !== void 0 && (o.bindMode = e.bindMode),
          e.bindMatrix !== void 0 && o.bindMatrix.fromArray(e.bindMatrix),
          e.skeleton !== void 0 && (o.skeleton = e.skeleton));
        break;
      case "Mesh":
        ((m = u(e.geometry)), (v = h(e.material)), (o = new wi(m, v)));
        break;
      case "InstancedMesh":
        ((m = u(e.geometry)), (v = h(e.material)));
        const b = e.count,
          _ = e.instanceMatrix,
          w = e.instanceColor;
        ((o = new sN(m, v, b)),
          (o.instanceMatrix = new Uh(new Float32Array(_.array), 16)),
          w !== void 0 &&
            (o.instanceColor = new Uh(new Float32Array(w.array), w.itemSize)));
        break;
      case "BatchedMesh":
        ((m = u(e.geometry)),
          (v = h(e.material)),
          (o = new aN(
            e.maxInstanceCount,
            e.maxVertexCount,
            e.maxIndexCount,
            v,
          )),
          (o.geometry = m),
          (o.perObjectFrustumCulled = e.perObjectFrustumCulled),
          (o.sortObjects = e.sortObjects),
          (o._drawRanges = e.drawRanges),
          (o._reservedRanges = e.reservedRanges),
          (o._geometryInfo = e.geometryInfo.map((E) => {
            let T = null,
              C = null;
            return (
              E.boundingBox !== void 0 &&
                (T = new sr().fromJSON(E.boundingBox)),
              E.boundingSphere !== void 0 &&
                (C = new mr().fromJSON(E.boundingSphere)),
              { ...E, boundingBox: T, boundingSphere: C }
            );
          })),
          (o._instanceInfo = e.instanceInfo),
          (o._availableInstanceIds = e._availableInstanceIds),
          (o._availableGeometryIds = e._availableGeometryIds),
          (o._nextIndexStart = e.nextIndexStart),
          (o._nextVertexStart = e.nextVertexStart),
          (o._geometryCount = e.geometryCount),
          (o._maxInstanceCount = e.maxInstanceCount),
          (o._maxVertexCount = e.maxVertexCount),
          (o._maxIndexCount = e.maxIndexCount),
          (o._geometryInitialized = e.geometryInitialized),
          (o._matricesTexture = d(e.matricesTexture.uuid)),
          (o._indirectTexture = d(e.indirectTexture.uuid)),
          e.colorsTexture !== void 0 &&
            (o._colorsTexture = d(e.colorsTexture.uuid)),
          e.boundingSphere !== void 0 &&
            (o.boundingSphere = new mr().fromJSON(e.boundingSphere)),
          e.boundingBox !== void 0 &&
            (o.boundingBox = new sr().fromJSON(e.boundingBox)));
        break;
      case "LOD":
        o = new iN();
        break;
      case "Line":
        o = new lf(u(e.geometry), h(e.material));
        break;
      case "LineLoop":
        o = new oN(u(e.geometry), h(e.material));
        break;
      case "LineSegments":
        o = new tc(u(e.geometry), h(e.material));
        break;
      case "PointCloud":
      case "Points":
        o = new lN(u(e.geometry), h(e.material));
        break;
      case "Sprite":
        o = new nN(h(e.material));
        break;
      case "Group":
        o = new xp();
        break;
      case "Bone":
        o = new KT();
        break;
      default:
        o = new In();
    }
    if (
      ((o.uuid = e.uuid),
      e.name !== void 0 && (o.name = e.name),
      e.matrix !== void 0
        ? (o.matrix.fromArray(e.matrix),
          e.matrixAutoUpdate !== void 0 &&
            (o.matrixAutoUpdate = e.matrixAutoUpdate),
          o.matrixAutoUpdate &&
            o.matrix.decompose(o.position, o.quaternion, o.scale))
        : (e.position !== void 0 && o.position.fromArray(e.position),
          e.rotation !== void 0 && o.rotation.fromArray(e.rotation),
          e.quaternion !== void 0 && o.quaternion.fromArray(e.quaternion),
          e.scale !== void 0 && o.scale.fromArray(e.scale)),
      e.up !== void 0 && o.up.fromArray(e.up),
      e.pivot !== void 0 && (o.pivot = new te().fromArray(e.pivot)),
      e.morphTargetDictionary !== void 0 &&
        (o.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)),
      e.morphTargetInfluences !== void 0 &&
        (o.morphTargetInfluences = e.morphTargetInfluences.slice()),
      e.castShadow !== void 0 && (o.castShadow = e.castShadow),
      e.receiveShadow !== void 0 && (o.receiveShadow = e.receiveShadow),
      e.shadow &&
        (e.shadow.intensity !== void 0 &&
          (o.shadow.intensity = e.shadow.intensity),
        e.shadow.bias !== void 0 && (o.shadow.bias = e.shadow.bias),
        e.shadow.normalBias !== void 0 &&
          (o.shadow.normalBias = e.shadow.normalBias),
        e.shadow.radius !== void 0 && (o.shadow.radius = e.shadow.radius),
        e.shadow.mapSize !== void 0 &&
          o.shadow.mapSize.fromArray(e.shadow.mapSize),
        e.shadow.camera !== void 0 &&
          (o.shadow.camera = this.parseObject(e.shadow.camera))),
      e.visible !== void 0 && (o.visible = e.visible),
      e.frustumCulled !== void 0 && (o.frustumCulled = e.frustumCulled),
      e.renderOrder !== void 0 && (o.renderOrder = e.renderOrder),
      e.static !== void 0 && (o.static = e.static),
      e.userData !== void 0 && (o.userData = e.userData),
      e.layers !== void 0 && (o.layers.mask = e.layers),
      e.children !== void 0)
    ) {
      const y = e.children;
      for (let b = 0; b < y.length; b++)
        o.add(this.parseObject(y[b], t, n, r, s));
    }
    if (e.animations !== void 0) {
      const y = e.animations;
      for (let b = 0; b < y.length; b++) {
        const _ = y[b];
        o.animations.push(s[_]);
      }
    }
    if (e.type === "LOD") {
      e.autoUpdate !== void 0 && (o.autoUpdate = e.autoUpdate);
      const y = e.levels;
      for (let b = 0; b < y.length; b++) {
        const _ = y[b],
          w = o.getObjectByProperty("uuid", _.object);
        w !== void 0 && o.addLevel(w, _.distance, _.hysteresis);
      }
    }
    return o;
  }
  bindSkeletons(e, t) {
    Object.keys(t).length !== 0 &&
      e.traverse(function (n) {
        if (n.isSkinnedMesh === !0 && n.skeleton !== void 0) {
          const r = t[n.skeleton];
          r === void 0
            ? Tt("ObjectLoader: No skeleton found with UUID:", n.skeleton)
            : n.bind(r, n.bindMatrix);
        }
      });
  }
  bindLightTargets(e) {
    e.traverse(function (t) {
      if (t.isDirectionalLight || t.isSpotLight) {
        const n = t.target,
          r = e.getObjectByProperty("uuid", n);
        r !== void 0 ? (t.target = r) : (t.target = new In());
      }
    });
  }
}
const P6 = {
    UVMapping: K1,
    CubeReflectionMapping: Zl,
    CubeRefractionMapping: sf,
    EquirectangularReflectionMapping: zg,
    EquirectangularRefractionMapping: Bg,
    CubeUVReflectionMapping: Bp,
  },
  PC = {
    RepeatWrapping: r0,
    ClampToEdgeWrapping: xa,
    MirroredRepeatWrapping: s0,
  },
  IC = {
    NearestFilter: rr,
    NearestMipmapNearestFilter: IT,
    NearestMipmapLinearFilter: vp,
    LinearFilter: ni,
    LinearMipmapNearestFilter: kg,
    LinearMipmapLinearFilter: Hl,
  },
  yS = new WeakMap();
class I6 extends _a {
  constructor(e) {
    (super(e),
      (this.isImageBitmapLoader = !0),
      typeof createImageBitmap > "u" &&
        Tt("ImageBitmapLoader: createImageBitmap() not supported."),
      typeof fetch > "u" && Tt("ImageBitmapLoader: fetch() not supported."),
      (this.options = { premultiplyAlpha: "none" }),
      (this._abortController = new AbortController()));
  }
  setOptions(e) {
    return ((this.options = e), this);
  }
  load(e, t, n, r) {
    (e === void 0 && (e = ""),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e)));
    const s = this,
      o = jl.get(`image-bitmap:${e}`);
    if (o !== void 0) {
      if ((s.manager.itemStart(e), o.then)) {
        o.then((d) => {
          if (yS.has(o) === !0)
            (r && r(yS.get(o)), s.manager.itemError(e), s.manager.itemEnd(e));
          else return (t && t(d), s.manager.itemEnd(e), d);
        });
        return;
      }
      return (
        setTimeout(function () {
          (t && t(o), s.manager.itemEnd(e));
        }, 0),
        o
      );
    }
    const u = {};
    ((u.credentials =
      this.crossOrigin === "anonymous" ? "same-origin" : "include"),
      (u.headers = this.requestHeader),
      (u.signal =
        typeof AbortSignal.any == "function"
          ? AbortSignal.any([
              this._abortController.signal,
              this.manager.abortController.signal,
            ])
          : this._abortController.signal));
    const h = fetch(e, u)
      .then(function (d) {
        return d.blob();
      })
      .then(function (d) {
        return createImageBitmap(
          d,
          Object.assign(s.options, { colorSpaceConversion: "none" }),
        );
      })
      .then(function (d) {
        return (
          jl.add(`image-bitmap:${e}`, d),
          t && t(d),
          s.manager.itemEnd(e),
          d
        );
      })
      .catch(function (d) {
        (r && r(d),
          yS.set(h, d),
          jl.remove(`image-bitmap:${e}`),
          s.manager.itemError(e),
          s.manager.itemEnd(e));
      });
    (jl.add(`image-bitmap:${e}`, h), s.manager.itemStart(e));
  }
  abort() {
    return (
      this._abortController.abort(),
      (this._abortController = new AbortController()),
      this
    );
  }
}
let nx;
class mE {
  static getContext() {
    return (
      nx === void 0 &&
        (nx = new (window.AudioContext || window.webkitAudioContext)()),
      nx
    );
  }
  static setContext(e) {
    nx = e;
  }
}
class O6 extends _a {
  constructor(e) {
    super(e);
  }
  load(e, t, n, r) {
    const s = this,
      o = new Kc(this.manager);
    (o.setResponseType("arraybuffer"),
      o.setPath(this.path),
      o.setRequestHeader(this.requestHeader),
      o.setWithCredentials(this.withCredentials),
      o.load(
        e,
        function (h) {
          try {
            const d = h.slice(0);
            mE.getContext()
              .decodeAudioData(d, function (v) {
                t(v);
              })
              .catch(u);
          } catch (d) {
            u(d);
          }
        },
        n,
        r,
      ));
    function u(h) {
      (r ? r(h) : Ft(h), s.manager.itemError(e));
    }
  }
}
const OC = new qt(),
  FC = new qt(),
  rh = new qt();
class F6 {
  constructor() {
    ((this.type = "StereoCamera"),
      (this.aspect = 1),
      (this.eyeSep = 0.064),
      (this.cameraL = new ir()),
      this.cameraL.layers.enable(1),
      (this.cameraL.matrixAutoUpdate = !1),
      (this.cameraR = new ir()),
      this.cameraR.layers.enable(2),
      (this.cameraR.matrixAutoUpdate = !1),
      (this._cache = {
        focus: null,
        fov: null,
        aspect: null,
        near: null,
        far: null,
        zoom: null,
        eyeSep: null,
      }));
  }
  update(e) {
    const t = this._cache;
    if (
      t.focus !== e.focus ||
      t.fov !== e.fov ||
      t.aspect !== e.aspect * this.aspect ||
      t.near !== e.near ||
      t.far !== e.far ||
      t.zoom !== e.zoom ||
      t.eyeSep !== this.eyeSep
    ) {
      ((t.focus = e.focus),
        (t.fov = e.fov),
        (t.aspect = e.aspect * this.aspect),
        (t.near = e.near),
        (t.far = e.far),
        (t.zoom = e.zoom),
        (t.eyeSep = this.eyeSep),
        rh.copy(e.projectionMatrix));
      const r = t.eyeSep / 2,
        s = (r * t.near) / t.focus,
        o = (t.near * Math.tan(wh * t.fov * 0.5)) / t.zoom;
      let u, h;
      ((FC.elements[12] = -r),
        (OC.elements[12] = r),
        (u = -o * t.aspect + s),
        (h = o * t.aspect + s),
        (rh.elements[0] = (2 * t.near) / (h - u)),
        (rh.elements[8] = (h + u) / (h - u)),
        this.cameraL.projectionMatrix.copy(rh),
        (u = -o * t.aspect - s),
        (h = o * t.aspect - s),
        (rh.elements[0] = (2 * t.near) / (h - u)),
        (rh.elements[8] = (h + u) / (h - u)),
        this.cameraR.projectionMatrix.copy(rh));
    }
    (this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(FC),
      this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(OC));
  }
}
const np = -90,
  ip = 1;
class HN extends In {
  constructor(e, t, n) {
    (super(),
      (this.type = "CubeCamera"),
      (this.renderTarget = n),
      (this.coordinateSystem = null),
      (this.activeMipmapLevel = 0));
    const r = new ir(np, ip, e, t);
    ((r.layers = this.layers), this.add(r));
    const s = new ir(np, ip, e, t);
    ((s.layers = this.layers), this.add(s));
    const o = new ir(np, ip, e, t);
    ((o.layers = this.layers), this.add(o));
    const u = new ir(np, ip, e, t);
    ((u.layers = this.layers), this.add(u));
    const h = new ir(np, ip, e, t);
    ((h.layers = this.layers), this.add(h));
    const d = new ir(np, ip, e, t);
    ((d.layers = this.layers), this.add(d));
  }
  updateCoordinateSystem() {
    const e = this.coordinateSystem,
      t = this.children.concat(),
      [n, r, s, o, u, h] = t;
    for (const d of t) this.remove(d);
    if (e === Ua)
      (n.up.set(0, 1, 0),
        n.lookAt(1, 0, 0),
        r.up.set(0, 1, 0),
        r.lookAt(-1, 0, 0),
        s.up.set(0, 0, -1),
        s.lookAt(0, 1, 0),
        o.up.set(0, 0, 1),
        o.lookAt(0, -1, 0),
        u.up.set(0, 1, 0),
        u.lookAt(0, 0, 1),
        h.up.set(0, 1, 0),
        h.lookAt(0, 0, -1));
    else if (e === Nh)
      (n.up.set(0, -1, 0),
        n.lookAt(-1, 0, 0),
        r.up.set(0, -1, 0),
        r.lookAt(1, 0, 0),
        s.up.set(0, 0, 1),
        s.lookAt(0, 1, 0),
        o.up.set(0, 0, -1),
        o.lookAt(0, -1, 0),
        u.up.set(0, -1, 0),
        u.lookAt(0, 0, 1),
        h.up.set(0, -1, 0),
        h.lookAt(0, 0, -1));
    else
      throw new Error(
        "THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " +
          e,
      );
    for (const d of t) (this.add(d), d.updateMatrixWorld());
  }
  update(e, t) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: n, activeMipmapLevel: r } = this;
    this.coordinateSystem !== e.coordinateSystem &&
      ((this.coordinateSystem = e.coordinateSystem),
      this.updateCoordinateSystem());
    const [s, o, u, h, d, m] = this.children,
      v = e.getRenderTarget(),
      y = e.getActiveCubeFace(),
      b = e.getActiveMipmapLevel(),
      _ = e.xr.enabled;
    e.xr.enabled = !1;
    const w = n.texture.generateMipmaps;
    n.texture.generateMipmaps = !1;
    let E = !1;
    (e.isWebGLRenderer === !0
      ? (E = e.state.buffers.depth.getReversed())
      : (E = e.reversedDepthBuffer),
      e.setRenderTarget(n, 0, r),
      E && e.autoClear === !1 && e.clearDepth(),
      e.render(t, s),
      e.setRenderTarget(n, 1, r),
      E && e.autoClear === !1 && e.clearDepth(),
      e.render(t, o),
      e.setRenderTarget(n, 2, r),
      E && e.autoClear === !1 && e.clearDepth(),
      e.render(t, u),
      e.setRenderTarget(n, 3, r),
      E && e.autoClear === !1 && e.clearDepth(),
      e.render(t, h),
      e.setRenderTarget(n, 4, r),
      E && e.autoClear === !1 && e.clearDepth(),
      e.render(t, d),
      (n.texture.generateMipmaps = w),
      e.setRenderTarget(n, 5, r),
      E && e.autoClear === !1 && e.clearDepth(),
      e.render(t, m),
      e.setRenderTarget(v, y, b),
      (e.xr.enabled = _),
      (n.texture.needsPMREMUpdate = !0));
  }
}
class jN extends ir {
  constructor(e = []) {
    (super(),
      (this.isArrayCamera = !0),
      (this.isMultiViewCamera = !1),
      (this.cameras = e));
  }
}
class WN {
  constructor() {
    ((this._previousTime = 0),
      (this._currentTime = 0),
      (this._startTime = performance.now()),
      (this._delta = 0),
      (this._elapsed = 0),
      (this._timescale = 1),
      (this._document = null),
      (this._pageVisibilityHandler = null));
  }
  connect(e) {
    ((this._document = e),
      e.hidden !== void 0 &&
        ((this._pageVisibilityHandler = z6.bind(this)),
        e.addEventListener(
          "visibilitychange",
          this._pageVisibilityHandler,
          !1,
        )));
  }
  disconnect() {
    (this._pageVisibilityHandler !== null &&
      (this._document.removeEventListener(
        "visibilitychange",
        this._pageVisibilityHandler,
      ),
      (this._pageVisibilityHandler = null)),
      (this._document = null));
  }
  getDelta() {
    return this._delta / 1e3;
  }
  getElapsed() {
    return this._elapsed / 1e3;
  }
  getTimescale() {
    return this._timescale;
  }
  setTimescale(e) {
    return ((this._timescale = e), this);
  }
  reset() {
    return ((this._currentTime = performance.now() - this._startTime), this);
  }
  dispose() {
    this.disconnect();
  }
  update(e) {
    return (
      this._pageVisibilityHandler !== null && this._document.hidden === !0
        ? (this._delta = 0)
        : ((this._previousTime = this._currentTime),
          (this._currentTime =
            (e !== void 0 ? e : performance.now()) - this._startTime),
          (this._delta =
            (this._currentTime - this._previousTime) * this._timescale),
          (this._elapsed += this._delta)),
      this
    );
  }
}
function z6() {
  this._document.hidden === !1 && this.reset();
}
const sh = new te(),
  xS = new Jr(),
  B6 = new te(),
  ah = new te(),
  oh = new te();
class k6 extends In {
  constructor() {
    (super(),
      (this.type = "AudioListener"),
      (this.context = mE.getContext()),
      (this.gain = this.context.createGain()),
      this.gain.connect(this.context.destination),
      (this.filter = null),
      (this.timeDelta = 0),
      (this._timer = new WN()));
  }
  getInput() {
    return this.gain;
  }
  removeFilter() {
    return (
      this.filter !== null &&
        (this.gain.disconnect(this.filter),
        this.filter.disconnect(this.context.destination),
        this.gain.connect(this.context.destination),
        (this.filter = null)),
      this
    );
  }
  getFilter() {
    return this.filter;
  }
  setFilter(e) {
    return (
      this.filter !== null
        ? (this.gain.disconnect(this.filter),
          this.filter.disconnect(this.context.destination))
        : this.gain.disconnect(this.context.destination),
      (this.filter = e),
      this.gain.connect(this.filter),
      this.filter.connect(this.context.destination),
      this
    );
  }
  getMasterVolume() {
    return this.gain.gain.value;
  }
  setMasterVolume(e) {
    return (
      this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01),
      this
    );
  }
  updateMatrixWorld(e) {
    (super.updateMatrixWorld(e), this._timer.update());
    const t = this.context.listener;
    if (
      ((this.timeDelta = this._timer.getDelta()),
      this.matrixWorld.decompose(sh, xS, B6),
      ah.set(0, 0, -1).applyQuaternion(xS),
      oh.set(0, 1, 0).applyQuaternion(xS),
      t.positionX)
    ) {
      const n = this.context.currentTime + this.timeDelta;
      (t.positionX.linearRampToValueAtTime(sh.x, n),
        t.positionY.linearRampToValueAtTime(sh.y, n),
        t.positionZ.linearRampToValueAtTime(sh.z, n),
        t.forwardX.linearRampToValueAtTime(ah.x, n),
        t.forwardY.linearRampToValueAtTime(ah.y, n),
        t.forwardZ.linearRampToValueAtTime(ah.z, n),
        t.upX.linearRampToValueAtTime(oh.x, n),
        t.upY.linearRampToValueAtTime(oh.y, n),
        t.upZ.linearRampToValueAtTime(oh.z, n));
    } else
      (t.setPosition(sh.x, sh.y, sh.z),
        t.setOrientation(ah.x, ah.y, ah.z, oh.x, oh.y, oh.z));
  }
}
class XN extends In {
  constructor(e) {
    (super(),
      (this.type = "Audio"),
      (this.listener = e),
      (this.context = e.context),
      (this.gain = this.context.createGain()),
      this.gain.connect(e.getInput()),
      (this.autoplay = !1),
      (this.buffer = null),
      (this.detune = 0),
      (this.loop = !1),
      (this.loopStart = 0),
      (this.loopEnd = 0),
      (this.offset = 0),
      (this.duration = void 0),
      (this.playbackRate = 1),
      (this.isPlaying = !1),
      (this.hasPlaybackControl = !0),
      (this.source = null),
      (this.sourceType = "empty"),
      (this._startedAt = 0),
      (this._progress = 0),
      (this._connected = !1),
      (this.filters = []));
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "audioNode"),
      (this.source = e),
      this.connect(),
      this
    );
  }
  setMediaElementSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "mediaNode"),
      (this.source = this.context.createMediaElementSource(e)),
      this.connect(),
      this
    );
  }
  setMediaStreamSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "mediaStreamNode"),
      (this.source = this.context.createMediaStreamSource(e)),
      this.connect(),
      this
    );
  }
  setBuffer(e) {
    return (
      (this.buffer = e),
      (this.sourceType = "buffer"),
      this.autoplay && this.play(),
      this
    );
  }
  play(e = 0) {
    if (this.isPlaying === !0) {
      Tt("Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === !1) {
      Tt("Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + e;
    const t = this.context.createBufferSource();
    return (
      (t.buffer = this.buffer),
      (t.loop = this.loop),
      (t.loopStart = this.loopStart),
      (t.loopEnd = this.loopEnd),
      (t.onended = this.onEnded.bind(this)),
      t.start(this._startedAt, this._progress + this.offset, this.duration),
      (this.isPlaying = !0),
      (this.source = t),
      this.setDetune(this.detune),
      this.setPlaybackRate(this.playbackRate),
      this.connect()
    );
  }
  pause() {
    if (this.hasPlaybackControl === !1) {
      Tt("Audio: this Audio has no playback control.");
      return;
    }
    return (
      this.isPlaying === !0 &&
        ((this._progress +=
          Math.max(this.context.currentTime - this._startedAt, 0) *
          this.playbackRate),
        this.loop === !0 &&
          (this._progress =
            this._progress % (this.duration || this.buffer.duration)),
        this.source.stop(),
        (this.source.onended = null),
        (this.isPlaying = !1)),
      this
    );
  }
  stop(e = 0) {
    if (this.hasPlaybackControl === !1) {
      Tt("Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this._progress = 0),
      this.source !== null &&
        (this.source.stop(this.context.currentTime + e),
        (this.source.onended = null)),
      (this.isPlaying = !1),
      this
    );
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let e = 1, t = this.filters.length; e < t; e++)
        this.filters[e - 1].connect(this.filters[e]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else this.source.connect(this.getOutput());
    return ((this._connected = !0), this);
  }
  disconnect() {
    if (this._connected !== !1) {
      if (this.filters.length > 0) {
        this.source.disconnect(this.filters[0]);
        for (let e = 1, t = this.filters.length; e < t; e++)
          this.filters[e - 1].disconnect(this.filters[e]);
        this.filters[this.filters.length - 1].disconnect(this.getOutput());
      } else this.source.disconnect(this.getOutput());
      return ((this._connected = !1), this);
    }
  }
  getFilters() {
    return this.filters;
  }
  setFilters(e) {
    return (
      e || (e = []),
      this._connected === !0
        ? (this.disconnect(), (this.filters = e.slice()), this.connect())
        : (this.filters = e.slice()),
      this
    );
  }
  setDetune(e) {
    return (
      (this.detune = e),
      this.isPlaying === !0 &&
        this.source.detune !== void 0 &&
        this.source.detune.setTargetAtTime(
          this.detune,
          this.context.currentTime,
          0.01,
        ),
      this
    );
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(e) {
    return this.setFilters(e ? [e] : []);
  }
  setPlaybackRate(e) {
    if (this.hasPlaybackControl === !1) {
      Tt("Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this.playbackRate = e),
      this.isPlaying === !0 &&
        this.source.playbackRate.setTargetAtTime(
          this.playbackRate,
          this.context.currentTime,
          0.01,
        ),
      this
    );
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    ((this.isPlaying = !1), (this._progress = 0));
  }
  getLoop() {
    return this.hasPlaybackControl === !1
      ? (Tt("Audio: this Audio has no playback control."), !1)
      : this.loop;
  }
  setLoop(e) {
    if (this.hasPlaybackControl === !1) {
      Tt("Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this.loop = e),
      this.isPlaying === !0 && (this.source.loop = this.loop),
      this
    );
  }
  setLoopStart(e) {
    return ((this.loopStart = e), this);
  }
  setLoopEnd(e) {
    return ((this.loopEnd = e), this);
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(e) {
    return (
      this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01),
      this
    );
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.sourceType !== "buffer"
        ? (Tt("Audio: Audio source type cannot be copied."), this)
        : ((this.autoplay = e.autoplay),
          (this.buffer = e.buffer),
          (this.detune = e.detune),
          (this.loop = e.loop),
          (this.loopStart = e.loopStart),
          (this.loopEnd = e.loopEnd),
          (this.offset = e.offset),
          (this.duration = e.duration),
          (this.playbackRate = e.playbackRate),
          (this.hasPlaybackControl = e.hasPlaybackControl),
          (this.sourceType = e.sourceType),
          (this.filters = e.filters.slice()),
          this)
    );
  }
  clone(e) {
    return new this.constructor(this.listener).copy(this, e);
  }
}
const lh = new te(),
  zC = new Jr(),
  V6 = new te(),
  ch = new te();
class G6 extends XN {
  constructor(e) {
    (super(e),
      (this.panner = this.context.createPanner()),
      (this.panner.panningModel = "HRTF"),
      this.panner.connect(this.gain));
  }
  connect() {
    return (super.connect(), this.panner.connect(this.gain), this);
  }
  disconnect() {
    return (super.disconnect(), this.panner.disconnect(this.gain), this);
  }
  getOutput() {
    return this.panner;
  }
  getRefDistance() {
    return this.panner.refDistance;
  }
  setRefDistance(e) {
    return ((this.panner.refDistance = e), this);
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  setRolloffFactor(e) {
    return ((this.panner.rolloffFactor = e), this);
  }
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  setDistanceModel(e) {
    return ((this.panner.distanceModel = e), this);
  }
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  setMaxDistance(e) {
    return ((this.panner.maxDistance = e), this);
  }
  setDirectionalCone(e, t, n) {
    return (
      (this.panner.coneInnerAngle = e),
      (this.panner.coneOuterAngle = t),
      (this.panner.coneOuterGain = n),
      this
    );
  }
  updateMatrixWorld(e) {
    if (
      (super.updateMatrixWorld(e),
      this.hasPlaybackControl === !0 && this.isPlaying === !1)
    )
      return;
    (this.matrixWorld.decompose(lh, zC, V6),
      ch.set(0, 0, 1).applyQuaternion(zC));
    const t = this.panner;
    if (t.positionX) {
      const n = this.context.currentTime + this.listener.timeDelta;
      (t.positionX.linearRampToValueAtTime(lh.x, n),
        t.positionY.linearRampToValueAtTime(lh.y, n),
        t.positionZ.linearRampToValueAtTime(lh.z, n),
        t.orientationX.linearRampToValueAtTime(ch.x, n),
        t.orientationY.linearRampToValueAtTime(ch.y, n),
        t.orientationZ.linearRampToValueAtTime(ch.z, n));
    } else
      (t.setPosition(lh.x, lh.y, lh.z), t.setOrientation(ch.x, ch.y, ch.z));
  }
}
class H6 {
  constructor(e, t = 2048) {
    ((this.analyser = e.context.createAnalyser()),
      (this.analyser.fftSize = t),
      (this.data = new Uint8Array(this.analyser.frequencyBinCount)),
      e.getOutput().connect(this.analyser));
  }
  getFrequencyData() {
    return (this.analyser.getByteFrequencyData(this.data), this.data);
  }
  getAverageFrequency() {
    let e = 0;
    const t = this.getFrequencyData();
    for (let n = 0; n < t.length; n++) e += t[n];
    return e / t.length;
  }
}
class qN {
  constructor(e, t, n) {
    ((this.binding = e), (this.valueSize = n));
    let r, s, o;
    switch (t) {
      case "quaternion":
        ((r = this._slerp),
          (s = this._slerpAdditive),
          (o = this._setAdditiveIdentityQuaternion),
          (this.buffer = new Float64Array(n * 6)),
          (this._workIndex = 5));
        break;
      case "string":
      case "bool":
        ((r = this._select),
          (s = this._select),
          (o = this._setAdditiveIdentityOther),
          (this.buffer = new Array(n * 5)));
        break;
      default:
        ((r = this._lerp),
          (s = this._lerpAdditive),
          (o = this._setAdditiveIdentityNumeric),
          (this.buffer = new Float64Array(n * 5)));
    }
    ((this._mixBufferRegion = r),
      (this._mixBufferRegionAdditive = s),
      (this._setIdentity = o),
      (this._origIndex = 3),
      (this._addIndex = 4),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0),
      (this.useCount = 0),
      (this.referenceCount = 0));
  }
  accumulate(e, t) {
    const n = this.buffer,
      r = this.valueSize,
      s = e * r + r;
    let o = this.cumulativeWeight;
    if (o === 0) {
      for (let u = 0; u !== r; ++u) n[s + u] = n[u];
      o = t;
    } else {
      o += t;
      const u = t / o;
      this._mixBufferRegion(n, s, 0, u, r);
    }
    this.cumulativeWeight = o;
  }
  accumulateAdditive(e) {
    const t = this.buffer,
      n = this.valueSize,
      r = n * this._addIndex;
    (this.cumulativeWeightAdditive === 0 && this._setIdentity(),
      this._mixBufferRegionAdditive(t, r, 0, e, n),
      (this.cumulativeWeightAdditive += e));
  }
  apply(e) {
    const t = this.valueSize,
      n = this.buffer,
      r = e * t + t,
      s = this.cumulativeWeight,
      o = this.cumulativeWeightAdditive,
      u = this.binding;
    if (
      ((this.cumulativeWeight = 0), (this.cumulativeWeightAdditive = 0), s < 1)
    ) {
      const h = t * this._origIndex;
      this._mixBufferRegion(n, r, h, 1 - s, t);
    }
    o > 0 && this._mixBufferRegionAdditive(n, r, this._addIndex * t, 1, t);
    for (let h = t, d = t + t; h !== d; ++h)
      if (n[h] !== n[h + t]) {
        u.setValue(n, r);
        break;
      }
  }
  saveOriginalState() {
    const e = this.binding,
      t = this.buffer,
      n = this.valueSize,
      r = n * this._origIndex;
    e.getValue(t, r);
    for (let s = n, o = r; s !== o; ++s) t[s] = t[r + (s % n)];
    (this._setIdentity(),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0));
  }
  restoreOriginalState() {
    const e = this.valueSize * 3;
    this.binding.setValue(this.buffer, e);
  }
  _setAdditiveIdentityNumeric() {
    const e = this._addIndex * this.valueSize,
      t = e + this.valueSize;
    for (let n = e; n < t; n++) this.buffer[n] = 0;
  }
  _setAdditiveIdentityQuaternion() {
    (this._setAdditiveIdentityNumeric(),
      (this.buffer[this._addIndex * this.valueSize + 3] = 1));
  }
  _setAdditiveIdentityOther() {
    const e = this._origIndex * this.valueSize,
      t = this._addIndex * this.valueSize;
    for (let n = 0; n < this.valueSize; n++)
      this.buffer[t + n] = this.buffer[e + n];
  }
  _select(e, t, n, r, s) {
    if (r >= 0.5) for (let o = 0; o !== s; ++o) e[t + o] = e[n + o];
  }
  _slerp(e, t, n, r) {
    Jr.slerpFlat(e, t, e, t, e, n, r);
  }
  _slerpAdditive(e, t, n, r, s) {
    const o = this._workIndex * s;
    (Jr.multiplyQuaternionsFlat(e, o, e, t, e, n),
      Jr.slerpFlat(e, t, e, t, e, o, r));
  }
  _lerp(e, t, n, r, s) {
    const o = 1 - r;
    for (let u = 0; u !== s; ++u) {
      const h = t + u;
      e[h] = e[h] * o + e[n + u] * r;
    }
  }
  _lerpAdditive(e, t, n, r, s) {
    for (let o = 0; o !== s; ++o) {
      const u = t + o;
      e[u] = e[u] + e[n + o] * r;
    }
  }
}
const gE = "\\[\\]\\.:\\/",
  j6 = new RegExp("[" + gE + "]", "g"),
  vE = "[^" + gE + "]",
  W6 = "[^" + gE.replace("\\.", "") + "]",
  X6 = /((?:WC+[\/:])*)/.source.replace("WC", vE),
  q6 = /(WCOD+)?/.source.replace("WCOD", W6),
  Y6 = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", vE),
  Z6 = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", vE),
  K6 = new RegExp("^" + X6 + q6 + Y6 + Z6 + "$"),
  Q6 = ["material", "materials", "bones", "map"];
class J6 {
  constructor(e, t, n) {
    const r = n || Pn.parseTrackName(t);
    ((this._targetGroup = e), (this._bindings = e.subscribe_(t, r)));
  }
  getValue(e, t) {
    this.bind();
    const n = this._targetGroup.nCachedObjects_,
      r = this._bindings[n];
    r !== void 0 && r.getValue(e, t);
  }
  setValue(e, t) {
    const n = this._bindings;
    for (let r = this._targetGroup.nCachedObjects_, s = n.length; r !== s; ++r)
      n[r].setValue(e, t);
  }
  bind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
      e[t].bind();
  }
  unbind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
      e[t].unbind();
  }
}
class Pn {
  constructor(e, t, n) {
    ((this.path = t),
      (this.parsedPath = n || Pn.parseTrackName(t)),
      (this.node = Pn.findNode(e, this.parsedPath.nodeName)),
      (this.rootNode = e),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound));
  }
  static create(e, t, n) {
    return e && e.isAnimationObjectGroup
      ? new Pn.Composite(e, t, n)
      : new Pn(e, t, n);
  }
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace(j6, "");
  }
  static parseTrackName(e) {
    const t = K6.exec(e);
    if (t === null)
      throw new Error("PropertyBinding: Cannot parse trackName: " + e);
    const n = {
        nodeName: t[2],
        objectName: t[3],
        objectIndex: t[4],
        propertyName: t[5],
        propertyIndex: t[6],
      },
      r = n.nodeName && n.nodeName.lastIndexOf(".");
    if (r !== void 0 && r !== -1) {
      const s = n.nodeName.substring(r + 1);
      Q6.indexOf(s) !== -1 &&
        ((n.nodeName = n.nodeName.substring(0, r)), (n.objectName = s));
    }
    if (n.propertyName === null || n.propertyName.length === 0)
      throw new Error(
        "PropertyBinding: can not parse propertyName from trackName: " + e,
      );
    return n;
  }
  static findNode(e, t) {
    if (
      t === void 0 ||
      t === "" ||
      t === "." ||
      t === -1 ||
      t === e.name ||
      t === e.uuid
    )
      return e;
    if (e.skeleton) {
      const n = e.skeleton.getBoneByName(t);
      if (n !== void 0) return n;
    }
    if (e.children) {
      const n = function (s) {
          for (let o = 0; o < s.length; o++) {
            const u = s[o];
            if (u.name === t || u.uuid === t) return u;
            const h = n(u.children);
            if (h) return h;
          }
          return null;
        },
        r = n(e.children);
      if (r) return r;
    }
    return null;
  }
  _getValue_unavailable() {}
  _setValue_unavailable() {}
  _getValue_direct(e, t) {
    e[t] = this.targetObject[this.propertyName];
  }
  _getValue_array(e, t) {
    const n = this.resolvedProperty;
    for (let r = 0, s = n.length; r !== s; ++r) e[t++] = n[r];
  }
  _getValue_arrayElement(e, t) {
    e[t] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, t) {
    this.resolvedProperty.toArray(e, t);
  }
  _setValue_direct(e, t) {
    this.targetObject[this.propertyName] = e[t];
  }
  _setValue_direct_setNeedsUpdate(e, t) {
    ((this.targetObject[this.propertyName] = e[t]),
      (this.targetObject.needsUpdate = !0));
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
    ((this.targetObject[this.propertyName] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0));
  }
  _setValue_array(e, t) {
    const n = this.resolvedProperty;
    for (let r = 0, s = n.length; r !== s; ++r) n[r] = e[t++];
  }
  _setValue_array_setNeedsUpdate(e, t) {
    const n = this.resolvedProperty;
    for (let r = 0, s = n.length; r !== s; ++r) n[r] = e[t++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
    const n = this.resolvedProperty;
    for (let r = 0, s = n.length; r !== s; ++r) n[r] = e[t++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _setValue_arrayElement(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t];
  }
  _setValue_arrayElement_setNeedsUpdate(e, t) {
    ((this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.needsUpdate = !0));
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
    ((this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0));
  }
  _setValue_fromArray(e, t) {
    this.resolvedProperty.fromArray(e, t);
  }
  _setValue_fromArray_setNeedsUpdate(e, t) {
    (this.resolvedProperty.fromArray(e, t),
      (this.targetObject.needsUpdate = !0));
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
    (this.resolvedProperty.fromArray(e, t),
      (this.targetObject.matrixWorldNeedsUpdate = !0));
  }
  _getValue_unbound(e, t) {
    (this.bind(), this.getValue(e, t));
  }
  _setValue_unbound(e, t) {
    (this.bind(), this.setValue(e, t));
  }
  bind() {
    let e = this.node;
    const t = this.parsedPath,
      n = t.objectName,
      r = t.propertyName;
    let s = t.propertyIndex;
    if (
      (e || ((e = Pn.findNode(this.rootNode, t.nodeName)), (this.node = e)),
      (this.getValue = this._getValue_unavailable),
      (this.setValue = this._setValue_unavailable),
      !e)
    ) {
      Tt("PropertyBinding: No target node found for track: " + this.path + ".");
      return;
    }
    if (n) {
      let d = t.objectIndex;
      switch (n) {
        case "materials":
          if (!e.material) {
            Ft(
              "PropertyBinding: Can not bind to material as node does not have a material.",
              this,
            );
            return;
          }
          if (!e.material.materials) {
            Ft(
              "PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
              this,
            );
            return;
          }
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton) {
            Ft(
              "PropertyBinding: Can not bind to bones as node does not have a skeleton.",
              this,
            );
            return;
          }
          e = e.skeleton.bones;
          for (let m = 0; m < e.length; m++)
            if (e[m].name === d) {
              d = m;
              break;
            }
          break;
        case "map":
          if ("map" in e) {
            e = e.map;
            break;
          }
          if (!e.material) {
            Ft(
              "PropertyBinding: Can not bind to material as node does not have a material.",
              this,
            );
            return;
          }
          if (!e.material.map) {
            Ft(
              "PropertyBinding: Can not bind to material.map as node.material does not have a map.",
              this,
            );
            return;
          }
          e = e.material.map;
          break;
        default:
          if (e[n] === void 0) {
            Ft(
              "PropertyBinding: Can not bind to objectName of node undefined.",
              this,
            );
            return;
          }
          e = e[n];
      }
      if (d !== void 0) {
        if (e[d] === void 0) {
          Ft(
            "PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
            this,
            e,
          );
          return;
        }
        e = e[d];
      }
    }
    const o = e[r];
    if (o === void 0) {
      const d = t.nodeName;
      Ft(
        "PropertyBinding: Trying to update property for track: " +
          d +
          "." +
          r +
          " but it wasn't found.",
        e,
      );
      return;
    }
    let u = this.Versioning.None;
    ((this.targetObject = e),
      e.isMaterial === !0
        ? (u = this.Versioning.NeedsUpdate)
        : e.isObject3D === !0 && (u = this.Versioning.MatrixWorldNeedsUpdate));
    let h = this.BindingType.Direct;
    if (s !== void 0) {
      if (r === "morphTargetInfluences") {
        if (!e.geometry) {
          Ft(
            "PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
            this,
          );
          return;
        }
        if (!e.geometry.morphAttributes) {
          Ft(
            "PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
            this,
          );
          return;
        }
        e.morphTargetDictionary[s] !== void 0 &&
          (s = e.morphTargetDictionary[s]);
      }
      ((h = this.BindingType.ArrayElement),
        (this.resolvedProperty = o),
        (this.propertyIndex = s));
    } else
      o.fromArray !== void 0 && o.toArray !== void 0
        ? ((h = this.BindingType.HasFromToArray), (this.resolvedProperty = o))
        : Array.isArray(o)
          ? ((h = this.BindingType.EntireArray), (this.resolvedProperty = o))
          : (this.propertyName = r);
    ((this.getValue = this.GetterByBindingType[h]),
      (this.setValue = this.SetterByBindingTypeAndVersioning[h][u]));
  }
  unbind() {
    ((this.node = null),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound));
  }
}
Pn.Composite = J6;
Pn.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3,
};
Pn.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2,
};
Pn.prototype.GetterByBindingType = [
  Pn.prototype._getValue_direct,
  Pn.prototype._getValue_array,
  Pn.prototype._getValue_arrayElement,
  Pn.prototype._getValue_toArray,
];
Pn.prototype.SetterByBindingTypeAndVersioning = [
  [
    Pn.prototype._setValue_direct,
    Pn.prototype._setValue_direct_setNeedsUpdate,
    Pn.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
  ],
  [
    Pn.prototype._setValue_array,
    Pn.prototype._setValue_array_setNeedsUpdate,
    Pn.prototype._setValue_array_setMatrixWorldNeedsUpdate,
  ],
  [
    Pn.prototype._setValue_arrayElement,
    Pn.prototype._setValue_arrayElement_setNeedsUpdate,
    Pn.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
  ],
  [
    Pn.prototype._setValue_fromArray,
    Pn.prototype._setValue_fromArray_setNeedsUpdate,
    Pn.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
  ],
];
class $6 {
  constructor() {
    ((this.isAnimationObjectGroup = !0),
      (this.uuid = Ia()),
      (this._objects = Array.prototype.slice.call(arguments)),
      (this.nCachedObjects_ = 0));
    const e = {};
    this._indicesByUUID = e;
    for (let n = 0, r = arguments.length; n !== r; ++n)
      e[arguments[n].uuid] = n;
    ((this._paths = []),
      (this._parsedPaths = []),
      (this._bindings = []),
      (this._bindingsIndicesByPath = {}));
    const t = this;
    this.stats = {
      objects: {
        get total() {
          return t._objects.length;
        },
        get inUse() {
          return this.total - t.nCachedObjects_;
        },
      },
      get bindingsPerObject() {
        return t._bindings.length;
      },
    };
  }
  add() {
    const e = this._objects,
      t = this._indicesByUUID,
      n = this._paths,
      r = this._parsedPaths,
      s = this._bindings,
      o = s.length;
    let u,
      h = e.length,
      d = this.nCachedObjects_;
    for (let m = 0, v = arguments.length; m !== v; ++m) {
      const y = arguments[m],
        b = y.uuid;
      let _ = t[b];
      if (_ === void 0) {
        ((_ = h++), (t[b] = _), e.push(y));
        for (let w = 0, E = o; w !== E; ++w) s[w].push(new Pn(y, n[w], r[w]));
      } else if (_ < d) {
        u = e[_];
        const w = --d,
          E = e[w];
        ((t[E.uuid] = _), (e[_] = E), (t[b] = w), (e[w] = y));
        for (let T = 0, C = o; T !== C; ++T) {
          const R = s[T],
            L = R[w];
          let I = R[_];
          ((R[_] = L), I === void 0 && (I = new Pn(y, n[T], r[T])), (R[w] = I));
        }
      } else
        e[_] !== u &&
          Ft(
            "AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.",
          );
    }
    this.nCachedObjects_ = d;
  }
  remove() {
    const e = this._objects,
      t = this._indicesByUUID,
      n = this._bindings,
      r = n.length;
    let s = this.nCachedObjects_;
    for (let o = 0, u = arguments.length; o !== u; ++o) {
      const h = arguments[o],
        d = h.uuid,
        m = t[d];
      if (m !== void 0 && m >= s) {
        const v = s++,
          y = e[v];
        ((t[y.uuid] = m), (e[m] = y), (t[d] = v), (e[v] = h));
        for (let b = 0, _ = r; b !== _; ++b) {
          const w = n[b],
            E = w[v],
            T = w[m];
          ((w[m] = E), (w[v] = T));
        }
      }
    }
    this.nCachedObjects_ = s;
  }
  uncache() {
    const e = this._objects,
      t = this._indicesByUUID,
      n = this._bindings,
      r = n.length;
    let s = this.nCachedObjects_,
      o = e.length;
    for (let u = 0, h = arguments.length; u !== h; ++u) {
      const d = arguments[u],
        m = d.uuid,
        v = t[m];
      if (v !== void 0)
        if ((delete t[m], v < s)) {
          const y = --s,
            b = e[y],
            _ = --o,
            w = e[_];
          ((t[b.uuid] = v), (e[v] = b), (t[w.uuid] = y), (e[y] = w), e.pop());
          for (let E = 0, T = r; E !== T; ++E) {
            const C = n[E],
              R = C[y],
              L = C[_];
            ((C[v] = R), (C[y] = L), C.pop());
          }
        } else {
          const y = --o,
            b = e[y];
          (y > 0 && (t[b.uuid] = v), (e[v] = b), e.pop());
          for (let _ = 0, w = r; _ !== w; ++_) {
            const E = n[_];
            ((E[v] = E[y]), E.pop());
          }
        }
    }
    this.nCachedObjects_ = s;
  }
  subscribe_(e, t) {
    const n = this._bindingsIndicesByPath;
    let r = n[e];
    const s = this._bindings;
    if (r !== void 0) return s[r];
    const o = this._paths,
      u = this._parsedPaths,
      h = this._objects,
      d = h.length,
      m = this.nCachedObjects_,
      v = new Array(d);
    ((r = s.length), (n[e] = r), o.push(e), u.push(t), s.push(v));
    for (let y = m, b = h.length; y !== b; ++y) {
      const _ = h[y];
      v[y] = new Pn(_, e, t);
    }
    return v;
  }
  unsubscribe_(e) {
    const t = this._bindingsIndicesByPath,
      n = t[e];
    if (n !== void 0) {
      const r = this._paths,
        s = this._parsedPaths,
        o = this._bindings,
        u = o.length - 1,
        h = o[u],
        d = e[u];
      ((t[d] = n),
        (o[n] = h),
        o.pop(),
        (s[n] = s[u]),
        s.pop(),
        (r[n] = r[u]),
        r.pop());
    }
  }
}
class YN {
  constructor(e, t, n = null, r = t.blendMode) {
    ((this._mixer = e),
      (this._clip = t),
      (this._localRoot = n),
      (this.blendMode = r));
    const s = t.tracks,
      o = s.length,
      u = new Array(o),
      h = { endingStart: _h, endingEnd: _h };
    for (let d = 0; d !== o; ++d) {
      const m = s[d].createInterpolant(null);
      ((u[d] = m), (m.settings = h));
    }
    ((this._interpolantSettings = h),
      (this._interpolants = u),
      (this._propertyBindings = new Array(o)),
      (this._cacheIndex = null),
      (this._byClipCacheIndex = null),
      (this._timeScaleInterpolant = null),
      (this._weightInterpolant = null),
      (this.loop = BL),
      (this._loopCount = -1),
      (this._startTime = null),
      (this.time = 0),
      (this.timeScale = 1),
      (this._effectiveTimeScale = 1),
      (this.weight = 1),
      (this._effectiveWeight = 1),
      (this.repetitions = 1 / 0),
      (this.paused = !1),
      (this.enabled = !0),
      (this.clampWhenFinished = !1),
      (this.zeroSlopeAtStart = !0),
      (this.zeroSlopeAtEnd = !0));
  }
  play() {
    return (this._mixer._activateAction(this), this);
  }
  stop() {
    return (this._mixer._deactivateAction(this), this.reset());
  }
  reset() {
    return (
      (this.paused = !1),
      (this.enabled = !0),
      (this.time = 0),
      (this._loopCount = -1),
      (this._startTime = null),
      this.stopFading().stopWarping()
    );
  }
  isRunning() {
    return (
      this.enabled &&
      !this.paused &&
      this.timeScale !== 0 &&
      this._startTime === null &&
      this._mixer._isActiveAction(this)
    );
  }
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(e) {
    return ((this._startTime = e), this);
  }
  setLoop(e, t) {
    return ((this.loop = e), (this.repetitions = t), this);
  }
  setEffectiveWeight(e) {
    return (
      (this.weight = e),
      (this._effectiveWeight = this.enabled ? e : 0),
      this.stopFading()
    );
  }
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(e) {
    return this._scheduleFading(e, 0, 1);
  }
  fadeOut(e) {
    return this._scheduleFading(e, 1, 0);
  }
  crossFadeFrom(e, t, n = !1) {
    if ((e.fadeOut(t), this.fadeIn(t), n === !0)) {
      const r = this._clip.duration,
        s = e._clip.duration,
        o = s / r,
        u = r / s;
      (e.warp(1, o, t), this.warp(u, 1, t));
    }
    return this;
  }
  crossFadeTo(e, t, n = !1) {
    return e.crossFadeFrom(this, t, n);
  }
  stopFading() {
    const e = this._weightInterpolant;
    return (
      e !== null &&
        ((this._weightInterpolant = null),
        this._mixer._takeBackControlInterpolant(e)),
      this
    );
  }
  setEffectiveTimeScale(e) {
    return (
      (this.timeScale = e),
      (this._effectiveTimeScale = this.paused ? 0 : e),
      this.stopWarping()
    );
  }
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(e) {
    return ((this.timeScale = this._clip.duration / e), this.stopWarping());
  }
  syncWith(e) {
    return (
      (this.time = e.time),
      (this.timeScale = e.timeScale),
      this.stopWarping()
    );
  }
  halt(e) {
    return this.warp(this._effectiveTimeScale, 0, e);
  }
  warp(e, t, n) {
    const r = this._mixer,
      s = r.time,
      o = this.timeScale;
    let u = this._timeScaleInterpolant;
    u === null &&
      ((u = r._lendControlInterpolant()), (this._timeScaleInterpolant = u));
    const h = u.parameterPositions,
      d = u.sampleValues;
    return ((h[0] = s), (h[1] = s + n), (d[0] = e / o), (d[1] = t / o), this);
  }
  stopWarping() {
    const e = this._timeScaleInterpolant;
    return (
      e !== null &&
        ((this._timeScaleInterpolant = null),
        this._mixer._takeBackControlInterpolant(e)),
      this
    );
  }
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  _update(e, t, n, r) {
    if (!this.enabled) {
      this._updateWeight(e);
      return;
    }
    const s = this._startTime;
    if (s !== null) {
      const h = (e - s) * n;
      h < 0 || n === 0 ? (t = 0) : ((this._startTime = null), (t = n * h));
    }
    t *= this._updateTimeScale(e);
    const o = this._updateTime(t),
      u = this._updateWeight(e);
    if (u > 0) {
      const h = this._interpolants,
        d = this._propertyBindings;
      switch (this.blendMode) {
        case GT:
          for (let m = 0, v = h.length; m !== v; ++m)
            (h[m].evaluate(o), d[m].accumulateAdditive(u));
          break;
        case ib:
        default:
          for (let m = 0, v = h.length; m !== v; ++m)
            (h[m].evaluate(o), d[m].accumulate(r, u));
      }
    }
  }
  _updateWeight(e) {
    let t = 0;
    if (this.enabled) {
      t = this.weight;
      const n = this._weightInterpolant;
      if (n !== null) {
        const r = n.evaluate(e)[0];
        ((t *= r),
          e > n.parameterPositions[1] &&
            (this.stopFading(), r === 0 && (this.enabled = !1)));
      }
    }
    return ((this._effectiveWeight = t), t);
  }
  _updateTimeScale(e) {
    let t = 0;
    if (!this.paused) {
      t = this.timeScale;
      const n = this._timeScaleInterpolant;
      if (n !== null) {
        const r = n.evaluate(e)[0];
        ((t *= r),
          e > n.parameterPositions[1] &&
            (this.stopWarping(),
            t === 0 ? (this.paused = !0) : (this.timeScale = t)));
      }
    }
    return ((this._effectiveTimeScale = t), t);
  }
  _updateTime(e) {
    const t = this._clip.duration,
      n = this.loop;
    let r = this.time + e,
      s = this._loopCount;
    const o = n === kL;
    if (e === 0) return s === -1 ? r : o && (s & 1) === 1 ? t - r : r;
    if (n === zL) {
      s === -1 && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
      e: {
        if (r >= t) r = t;
        else if (r < 0) r = 0;
        else {
          this.time = r;
          break e;
        }
        (this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
          (this.time = r),
          this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: e < 0 ? -1 : 1,
          }));
      }
    } else {
      if (
        (s === -1 &&
          (e >= 0
            ? ((s = 0), this._setEndings(!0, this.repetitions === 0, o))
            : this._setEndings(this.repetitions === 0, !0, o)),
        r >= t || r < 0)
      ) {
        const u = Math.floor(r / t);
        ((r -= t * u), (s += Math.abs(u)));
        const h = this.repetitions - s;
        if (h <= 0)
          (this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
            (r = e > 0 ? t : 0),
            (this.time = r),
            this._mixer.dispatchEvent({
              type: "finished",
              action: this,
              direction: e > 0 ? 1 : -1,
            }));
        else {
          if (h === 1) {
            const d = e < 0;
            this._setEndings(d, !d, o);
          } else this._setEndings(!1, !1, o);
          ((this._loopCount = s),
            (this.time = r),
            this._mixer.dispatchEvent({
              type: "loop",
              action: this,
              loopDelta: u,
            }));
        }
      } else this.time = r;
      if (o && (s & 1) === 1) return t - r;
    }
    return r;
  }
  _setEndings(e, t, n) {
    const r = this._interpolantSettings;
    n
      ? ((r.endingStart = Sh), (r.endingEnd = Sh))
      : (e
          ? (r.endingStart = this.zeroSlopeAtStart ? Sh : _h)
          : (r.endingStart = o0),
        t ? (r.endingEnd = this.zeroSlopeAtEnd ? Sh : _h) : (r.endingEnd = o0));
  }
  _scheduleFading(e, t, n) {
    const r = this._mixer,
      s = r.time;
    let o = this._weightInterpolant;
    o === null &&
      ((o = r._lendControlInterpolant()), (this._weightInterpolant = o));
    const u = o.parameterPositions,
      h = o.sampleValues;
    return ((u[0] = s), (h[0] = t), (u[1] = s + e), (h[1] = n), this);
  }
}
const eV = new Float32Array(1);
class tV extends ec {
  constructor(e) {
    (super(),
      (this._root = e),
      this._initMemoryManager(),
      (this._accuIndex = 0),
      (this.time = 0),
      (this.timeScale = 1),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this }),
        ));
  }
  _bindAction(e, t) {
    const n = e._localRoot || this._root,
      r = e._clip.tracks,
      s = r.length,
      o = e._propertyBindings,
      u = e._interpolants,
      h = n.uuid,
      d = this._bindingsByRootAndName;
    let m = d[h];
    m === void 0 && ((m = {}), (d[h] = m));
    for (let v = 0; v !== s; ++v) {
      const y = r[v],
        b = y.name;
      let _ = m[b];
      if (_ !== void 0) (++_.referenceCount, (o[v] = _));
      else {
        if (((_ = o[v]), _ !== void 0)) {
          _._cacheIndex === null &&
            (++_.referenceCount, this._addInactiveBinding(_, h, b));
          continue;
        }
        const w = t && t._propertyBindings[v].binding.parsedPath;
        ((_ = new qN(Pn.create(n, b, w), y.ValueTypeName, y.getValueSize())),
          ++_.referenceCount,
          this._addInactiveBinding(_, h, b),
          (o[v] = _));
      }
      u[v].resultBuffer = _.buffer;
    }
  }
  _activateAction(e) {
    if (!this._isActiveAction(e)) {
      if (e._cacheIndex === null) {
        const n = (e._localRoot || this._root).uuid,
          r = e._clip.uuid,
          s = this._actionsByClip[r];
        (this._bindAction(e, s && s.knownActions[0]),
          this._addInactiveAction(e, r, n));
      }
      const t = e._propertyBindings;
      for (let n = 0, r = t.length; n !== r; ++n) {
        const s = t[n];
        s.useCount++ === 0 && (this._lendBinding(s), s.saveOriginalState());
      }
      this._lendAction(e);
    }
  }
  _deactivateAction(e) {
    if (this._isActiveAction(e)) {
      const t = e._propertyBindings;
      for (let n = 0, r = t.length; n !== r; ++n) {
        const s = t[n];
        --s.useCount === 0 &&
          (s.restoreOriginalState(), this._takeBackBinding(s));
      }
      this._takeBackAction(e);
    }
  }
  _initMemoryManager() {
    ((this._actions = []),
      (this._nActiveActions = 0),
      (this._actionsByClip = {}),
      (this._bindings = []),
      (this._nActiveBindings = 0),
      (this._bindingsByRootAndName = {}),
      (this._controlInterpolants = []),
      (this._nActiveControlInterpolants = 0));
    const e = this;
    this.stats = {
      actions: {
        get total() {
          return e._actions.length;
        },
        get inUse() {
          return e._nActiveActions;
        },
      },
      bindings: {
        get total() {
          return e._bindings.length;
        },
        get inUse() {
          return e._nActiveBindings;
        },
      },
      controlInterpolants: {
        get total() {
          return e._controlInterpolants.length;
        },
        get inUse() {
          return e._nActiveControlInterpolants;
        },
      },
    };
  }
  _isActiveAction(e) {
    const t = e._cacheIndex;
    return t !== null && t < this._nActiveActions;
  }
  _addInactiveAction(e, t, n) {
    const r = this._actions,
      s = this._actionsByClip;
    let o = s[t];
    if (o === void 0)
      ((o = { knownActions: [e], actionByRoot: {} }),
        (e._byClipCacheIndex = 0),
        (s[t] = o));
    else {
      const u = o.knownActions;
      ((e._byClipCacheIndex = u.length), u.push(e));
    }
    ((e._cacheIndex = r.length), r.push(e), (o.actionByRoot[n] = e));
  }
  _removeInactiveAction(e) {
    const t = this._actions,
      n = t[t.length - 1],
      r = e._cacheIndex;
    ((n._cacheIndex = r), (t[r] = n), t.pop(), (e._cacheIndex = null));
    const s = e._clip.uuid,
      o = this._actionsByClip,
      u = o[s],
      h = u.knownActions,
      d = h[h.length - 1],
      m = e._byClipCacheIndex;
    ((d._byClipCacheIndex = m),
      (h[m] = d),
      h.pop(),
      (e._byClipCacheIndex = null));
    const v = u.actionByRoot,
      y = (e._localRoot || this._root).uuid;
    (delete v[y],
      h.length === 0 && delete o[s],
      this._removeInactiveBindingsForAction(e));
  }
  _removeInactiveBindingsForAction(e) {
    const t = e._propertyBindings;
    for (let n = 0, r = t.length; n !== r; ++n) {
      const s = t[n];
      --s.referenceCount === 0 && this._removeInactiveBinding(s);
    }
  }
  _lendAction(e) {
    const t = this._actions,
      n = e._cacheIndex,
      r = this._nActiveActions++,
      s = t[r];
    ((e._cacheIndex = r), (t[r] = e), (s._cacheIndex = n), (t[n] = s));
  }
  _takeBackAction(e) {
    const t = this._actions,
      n = e._cacheIndex,
      r = --this._nActiveActions,
      s = t[r];
    ((e._cacheIndex = r), (t[r] = e), (s._cacheIndex = n), (t[n] = s));
  }
  _addInactiveBinding(e, t, n) {
    const r = this._bindingsByRootAndName,
      s = this._bindings;
    let o = r[t];
    (o === void 0 && ((o = {}), (r[t] = o)),
      (o[n] = e),
      (e._cacheIndex = s.length),
      s.push(e));
  }
  _removeInactiveBinding(e) {
    const t = this._bindings,
      n = e.binding,
      r = n.rootNode.uuid,
      s = n.path,
      o = this._bindingsByRootAndName,
      u = o[r],
      h = t[t.length - 1],
      d = e._cacheIndex;
    ((h._cacheIndex = d),
      (t[d] = h),
      t.pop(),
      delete u[s],
      Object.keys(u).length === 0 && delete o[r]);
  }
  _lendBinding(e) {
    const t = this._bindings,
      n = e._cacheIndex,
      r = this._nActiveBindings++,
      s = t[r];
    ((e._cacheIndex = r), (t[r] = e), (s._cacheIndex = n), (t[n] = s));
  }
  _takeBackBinding(e) {
    const t = this._bindings,
      n = e._cacheIndex,
      r = --this._nActiveBindings,
      s = t[r];
    ((e._cacheIndex = r), (t[r] = e), (s._cacheIndex = n), (t[n] = s));
  }
  _lendControlInterpolant() {
    const e = this._controlInterpolants,
      t = this._nActiveControlInterpolants++;
    let n = e[t];
    return (
      n === void 0 &&
        ((n = new uE(new Float32Array(2), new Float32Array(2), 1, eV)),
        (n.__cacheIndex = t),
        (e[t] = n)),
      n
    );
  }
  _takeBackControlInterpolant(e) {
    const t = this._controlInterpolants,
      n = e.__cacheIndex,
      r = --this._nActiveControlInterpolants,
      s = t[r];
    ((e.__cacheIndex = r), (t[r] = e), (s.__cacheIndex = n), (t[n] = s));
  }
  clipAction(e, t, n) {
    const r = t || this._root,
      s = r.uuid;
    let o = typeof e == "string" ? x0.findByName(r, e) : e;
    const u = o !== null ? o.uuid : e,
      h = this._actionsByClip[u];
    let d = null;
    if (
      (n === void 0 && (o !== null ? (n = o.blendMode) : (n = ib)),
      h !== void 0)
    ) {
      const v = h.actionByRoot[s];
      if (v !== void 0 && v.blendMode === n) return v;
      ((d = h.knownActions[0]), o === null && (o = d._clip));
    }
    if (o === null) return null;
    const m = new YN(this, o, t, n);
    return (this._bindAction(m, d), this._addInactiveAction(m, u, s), m);
  }
  existingAction(e, t) {
    const n = t || this._root,
      r = n.uuid,
      s = typeof e == "string" ? x0.findByName(n, e) : e,
      o = s ? s.uuid : e,
      u = this._actionsByClip[o];
    return (u !== void 0 && u.actionByRoot[r]) || null;
  }
  stopAllAction() {
    const e = this._actions,
      t = this._nActiveActions;
    for (let n = t - 1; n >= 0; --n) e[n].stop();
    return this;
  }
  update(e) {
    e *= this.timeScale;
    const t = this._actions,
      n = this._nActiveActions,
      r = (this.time += e),
      s = Math.sign(e),
      o = (this._accuIndex ^= 1);
    for (let d = 0; d !== n; ++d) t[d]._update(r, e, s, o);
    const u = this._bindings,
      h = this._nActiveBindings;
    for (let d = 0; d !== h; ++d) u[d].apply(o);
    return this;
  }
  setTime(e) {
    this.time = 0;
    for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0;
    return this.update(e);
  }
  getRoot() {
    return this._root;
  }
  uncacheClip(e) {
    const t = this._actions,
      n = e.uuid,
      r = this._actionsByClip,
      s = r[n];
    if (s !== void 0) {
      const o = s.knownActions;
      for (let u = 0, h = o.length; u !== h; ++u) {
        const d = o[u];
        this._deactivateAction(d);
        const m = d._cacheIndex,
          v = t[t.length - 1];
        ((d._cacheIndex = null),
          (d._byClipCacheIndex = null),
          (v._cacheIndex = m),
          (t[m] = v),
          t.pop(),
          this._removeInactiveBindingsForAction(d));
      }
      delete r[n];
    }
  }
  uncacheRoot(e) {
    const t = e.uuid,
      n = this._actionsByClip;
    for (const o in n) {
      const u = n[o].actionByRoot,
        h = u[t];
      h !== void 0 &&
        (this._deactivateAction(h), this._removeInactiveAction(h));
    }
    const r = this._bindingsByRootAndName,
      s = r[t];
    if (s !== void 0)
      for (const o in s) {
        const u = s[o];
        (u.restoreOriginalState(), this._removeInactiveBinding(u));
      }
  }
  uncacheAction(e, t) {
    const n = this.existingAction(e, t);
    n !== null && (this._deactivateAction(n), this._removeInactiveAction(n));
  }
}
class nV extends WT {
  constructor(e = 1, t = 1, n = 1, r = {}) {
    (super(e, t, r),
      (this.isRenderTarget3D = !0),
      (this.depth = n),
      (this.texture = new ob(null, e, t, n)),
      this._setTextureOptions(r),
      (this.texture.isRenderTargetTexture = !0));
  }
}
class yE {
  constructor(e) {
    this.value = e;
  }
  clone() {
    return new yE(
      this.value.clone === void 0 ? this.value : this.value.clone(),
    );
  }
}
let iV = 0;
class rV extends ec {
  constructor() {
    (super(),
      (this.isUniformsGroup = !0),
      Object.defineProperty(this, "id", { value: iV++ }),
      (this.name = ""),
      (this.usage = c0),
      (this.uniforms = []));
  }
  add(e) {
    return (this.uniforms.push(e), this);
  }
  remove(e) {
    const t = this.uniforms.indexOf(e);
    return (t !== -1 && this.uniforms.splice(t, 1), this);
  }
  setName(e) {
    return ((this.name = e), this);
  }
  setUsage(e) {
    return ((this.usage = e), this);
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  copy(e) {
    ((this.name = e.name), (this.usage = e.usage));
    const t = e.uniforms;
    this.uniforms.length = 0;
    for (let n = 0, r = t.length; n < r; n++) {
      const s = Array.isArray(t[n]) ? t[n] : [t[n]];
      for (let o = 0; o < s.length; o++) this.uniforms.push(s[o].clone());
    }
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class O1 extends ub {
  constructor(e, t, n = 1) {
    (super(e, t),
      (this.isInstancedInterleavedBuffer = !0),
      (this.meshPerAttribute = n));
  }
  copy(e) {
    return (super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this);
  }
  clone(e) {
    const t = super.clone(e);
    return ((t.meshPerAttribute = this.meshPerAttribute), t);
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.isInstancedInterleavedBuffer = !0),
      (t.meshPerAttribute = this.meshPerAttribute),
      t
    );
  }
}
class sV {
  constructor(e, t, n, r, s, o = !1) {
    ((this.isGLBufferAttribute = !0),
      (this.name = ""),
      (this.buffer = e),
      (this.type = t),
      (this.itemSize = n),
      (this.elementSize = r),
      (this.count = s),
      (this.normalized = o),
      (this.version = 0));
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setBuffer(e) {
    return ((this.buffer = e), this);
  }
  setType(e, t) {
    return ((this.type = e), (this.elementSize = t), this);
  }
  setItemSize(e) {
    return ((this.itemSize = e), this);
  }
  setCount(e) {
    return ((this.count = e), this);
  }
}
const BC = new qt();
class ZN {
  constructor(e, t, n = 0, r = 1 / 0) {
    ((this.ray = new Oh(e, t)),
      (this.near = n),
      (this.far = r),
      (this.camera = null),
      (this.layers = new Ap()),
      (this.params = {
        Mesh: {},
        Line: { threshold: 1 },
        LOD: {},
        Points: { threshold: 1 },
        Sprite: {},
      }));
  }
  set(e, t) {
    this.ray.set(e, t);
  }
  setFromCamera(e, t) {
    t.isPerspectiveCamera
      ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
        this.ray.direction
          .set(e.x, e.y, 0.5)
          .unproject(t)
          .sub(this.ray.origin)
          .normalize(),
        (this.camera = t))
      : t.isOrthographicCamera
        ? (this.ray.origin
            .set(e.x, e.y, (t.near + t.far) / (t.near - t.far))
            .unproject(t),
          this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld),
          (this.camera = t))
        : Ft("Raycaster: Unsupported camera type: " + t.type);
  }
  setFromXRController(e) {
    return (
      BC.identity().extractRotation(e.matrixWorld),
      this.ray.origin.setFromMatrixPosition(e.matrixWorld),
      this.ray.direction.set(0, 0, -1).applyMatrix4(BC),
      this
    );
  }
  intersectObject(e, t = !0, n = []) {
    return (LM(e, this, n, t), n.sort(kC), n);
  }
  intersectObjects(e, t = !0, n = []) {
    for (let r = 0, s = e.length; r < s; r++) LM(e[r], this, n, t);
    return (n.sort(kC), n);
  }
}
function kC(i, e) {
  return i.distance - e.distance;
}
function LM(i, e, t, n) {
  let r = !0;
  if (
    (i.layers.test(e.layers) && i.raycast(e, t) === !1 && (r = !1),
    r === !0 && n === !0)
  ) {
    const s = i.children;
    for (let o = 0, u = s.length; o < u; o++) LM(s[o], e, t, !0);
  }
}
class KN {
  constructor(e = !0) {
    ((this.autoStart = e),
      (this.startTime = 0),
      (this.oldTime = 0),
      (this.elapsedTime = 0),
      (this.running = !1),
      Tt(
        "THREE.Clock: This module has been deprecated. Please use THREE.Timer instead.",
      ));
  }
  start() {
    ((this.startTime = performance.now()),
      (this.oldTime = this.startTime),
      (this.elapsedTime = 0),
      (this.running = !0));
  }
  stop() {
    (this.getElapsedTime(), (this.running = !1), (this.autoStart = !1));
  }
  getElapsedTime() {
    return (this.getDelta(), this.elapsedTime);
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running) return (this.start(), 0);
    if (this.running) {
      const t = performance.now();
      ((e = (t - this.oldTime) / 1e3),
        (this.oldTime = t),
        (this.elapsedTime += e));
    }
    return e;
  }
}
class F1 {
  constructor(e = 1, t = 0, n = 0) {
    ((this.radius = e), (this.phi = t), (this.theta = n));
  }
  set(e, t, n) {
    return ((this.radius = e), (this.phi = t), (this.theta = n), this);
  }
  copy(e) {
    return (
      (this.radius = e.radius),
      (this.phi = e.phi),
      (this.theta = e.theta),
      this
    );
  }
  makeSafe() {
    return ((this.phi = Yt(this.phi, 1e-6, Math.PI - 1e-6)), this);
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, n) {
    return (
      (this.radius = Math.sqrt(e * e + t * t + n * n)),
      this.radius === 0
        ? ((this.theta = 0), (this.phi = 0))
        : ((this.theta = Math.atan2(e, n)),
          (this.phi = Math.acos(Yt(t / this.radius, -1, 1)))),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class aV {
  constructor(e = 1, t = 0, n = 0) {
    ((this.radius = e), (this.theta = t), (this.y = n));
  }
  set(e, t, n) {
    return ((this.radius = e), (this.theta = t), (this.y = n), this);
  }
  copy(e) {
    return (
      (this.radius = e.radius),
      (this.theta = e.theta),
      (this.y = e.y),
      this
    );
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, n) {
    return (
      (this.radius = Math.sqrt(e * e + n * n)),
      (this.theta = Math.atan2(e, n)),
      (this.y = t),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class xE {
  constructor(e, t, n, r) {
    ((xE.prototype.isMatrix2 = !0),
      (this.elements = [1, 0, 0, 1]),
      e !== void 0 && this.set(e, t, n, r));
  }
  identity() {
    return (this.set(1, 0, 0, 1), this);
  }
  fromArray(e, t = 0) {
    for (let n = 0; n < 4; n++) this.elements[n] = e[n + t];
    return this;
  }
  set(e, t, n, r) {
    const s = this.elements;
    return ((s[0] = e), (s[2] = t), (s[1] = n), (s[3] = r), this);
  }
}
const VC = new nt();
class oV {
  constructor(e = new nt(1 / 0, 1 / 0), t = new nt(-1 / 0, -1 / 0)) {
    ((this.isBox2 = !0), (this.min = e), (this.max = t));
  }
  set(e, t) {
    return (this.min.copy(e), this.max.copy(t), this);
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const n = VC.copy(t).multiplyScalar(0.5);
    return (this.min.copy(e).sub(n), this.max.copy(e).add(n), this);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (this.min.copy(e.min), this.max.copy(e.max), this);
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = 1 / 0),
      (this.max.x = this.max.y = -1 / 0),
      this
    );
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return (this.min.min(e), this.max.max(e), this);
  }
  expandByVector(e) {
    return (this.min.sub(e), this.max.add(e), this);
  }
  expandByScalar(e) {
    return (this.min.addScalar(-e), this.max.addScalar(e), this);
  }
  containsPoint(e) {
    return (
      e.x >= this.min.x &&
      e.x <= this.max.x &&
      e.y >= this.min.y &&
      e.y <= this.max.y
    );
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y
    );
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
    );
  }
  intersectsBox(e) {
    return (
      e.max.x >= this.min.x &&
      e.min.x <= this.max.x &&
      e.max.y >= this.min.y &&
      e.min.y <= this.max.y
    );
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, VC).distanceTo(e);
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(e) {
    return (this.min.min(e.min), this.max.max(e.max), this);
  }
  translate(e) {
    return (this.min.add(e), this.max.add(e), this);
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const GC = new te(),
  ix = new te(),
  rp = new te(),
  sp = new te(),
  bS = new te(),
  lV = new te(),
  cV = new te();
class QN {
  constructor(e = new te(), t = new te()) {
    ((this.start = e), (this.end = t));
  }
  set(e, t) {
    return (this.start.copy(e), this.end.copy(t), this);
  }
  copy(e) {
    return (this.start.copy(e.start), this.end.copy(e.end), this);
  }
  getCenter(e) {
    return e.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(e) {
    return e.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(e, t) {
    return this.delta(t).multiplyScalar(e).add(this.start);
  }
  closestPointToPointParameter(e, t) {
    (GC.subVectors(e, this.start), ix.subVectors(this.end, this.start));
    const n = ix.dot(ix);
    let s = ix.dot(GC) / n;
    return (t && (s = Yt(s, 0, 1)), s);
  }
  closestPointToPoint(e, t, n) {
    const r = this.closestPointToPointParameter(e, t);
    return this.delta(n).multiplyScalar(r).add(this.start);
  }
  distanceSqToLine3(e, t = lV, n = cV) {
    const r = 10000000000000001e-32;
    let s, o;
    const u = this.start,
      h = e.start,
      d = this.end,
      m = e.end;
    (rp.subVectors(d, u), sp.subVectors(m, h), bS.subVectors(u, h));
    const v = rp.dot(rp),
      y = sp.dot(sp),
      b = sp.dot(bS);
    if (v <= r && y <= r) return (t.copy(u), n.copy(h), t.sub(n), t.dot(t));
    if (v <= r) ((s = 0), (o = b / y), (o = Yt(o, 0, 1)));
    else {
      const _ = rp.dot(bS);
      if (y <= r) ((o = 0), (s = Yt(-_ / v, 0, 1)));
      else {
        const w = rp.dot(sp),
          E = v * y - w * w;
        (E !== 0 ? (s = Yt((w * b - _ * y) / E, 0, 1)) : (s = 0),
          (o = (w * s + b) / y),
          o < 0
            ? ((o = 0), (s = Yt(-_ / v, 0, 1)))
            : o > 1 && ((o = 1), (s = Yt((w - _) / v, 0, 1))));
      }
    }
    return (
      t.copy(u).addScaledVector(rp, s),
      n.copy(h).addScaledVector(sp, o),
      t.distanceToSquared(n)
    );
  }
  applyMatrix4(e) {
    return (this.start.applyMatrix4(e), this.end.applyMatrix4(e), this);
  }
  equals(e) {
    return e.start.equals(this.start) && e.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const HC = new te();
class uV extends In {
  constructor(e, t) {
    (super(),
      (this.light = e),
      (this.matrixAutoUpdate = !1),
      (this.color = t),
      (this.type = "SpotLightHelper"));
    const n = new nn(),
      r = [
        0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1,
        0, 0, 0, 0, -1, 1,
      ];
    for (let o = 0, u = 1, h = 32; o < h; o++, u++) {
      const d = (o / h) * Math.PI * 2,
        m = (u / h) * Math.PI * 2;
      r.push(Math.cos(d), Math.sin(d), 1, Math.cos(m), Math.sin(m), 1);
    }
    n.setAttribute("position", new Rt(r, 3));
    const s = new Ws({ fog: !1, toneMapped: !1 });
    ((this.cone = new tc(n, s)), this.add(this.cone), this.update());
  }
  dispose() {
    (this.cone.geometry.dispose(), this.cone.material.dispose());
  }
  update() {
    (this.light.updateWorldMatrix(!0, !1),
      this.light.target.updateWorldMatrix(!0, !1),
      this.parent
        ? (this.parent.updateWorldMatrix(!0),
          this.matrix
            .copy(this.parent.matrixWorld)
            .invert()
            .multiply(this.light.matrixWorld))
        : this.matrix.copy(this.light.matrixWorld),
      this.matrixWorld.copy(this.light.matrixWorld));
    const e = this.light.distance ? this.light.distance : 1e3,
      t = e * Math.tan(this.light.angle);
    (this.cone.scale.set(t, t, e),
      HC.setFromMatrixPosition(this.light.target.matrixWorld),
      this.cone.lookAt(HC),
      this.color !== void 0
        ? this.cone.material.color.set(this.color)
        : this.cone.material.color.copy(this.light.color));
  }
}
const qu = new te(),
  rx = new qt(),
  _S = new qt();
class fV extends tc {
  constructor(e) {
    const t = JN(e),
      n = new nn(),
      r = [],
      s = [];
    for (let d = 0; d < t.length; d++) {
      const m = t[d];
      m.parent &&
        m.parent.isBone &&
        (r.push(0, 0, 0), r.push(0, 0, 0), s.push(0, 0, 0), s.push(0, 0, 0));
    }
    (n.setAttribute("position", new Rt(r, 3)),
      n.setAttribute("color", new Rt(s, 3)));
    const o = new Ws({
      vertexColors: !0,
      depthTest: !1,
      depthWrite: !1,
      toneMapped: !1,
      transparent: !0,
    });
    (super(n, o),
      (this.isSkeletonHelper = !0),
      (this.type = "SkeletonHelper"),
      (this.root = e),
      (this.bones = t),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1));
    const u = new wt(255),
      h = new wt(65280);
    this.setColors(u, h);
  }
  updateMatrixWorld(e) {
    const t = this.bones,
      n = this.geometry,
      r = n.getAttribute("position");
    _S.copy(this.root.matrixWorld).invert();
    for (let s = 0, o = 0; s < t.length; s++) {
      const u = t[s];
      u.parent &&
        u.parent.isBone &&
        (rx.multiplyMatrices(_S, u.matrixWorld),
        qu.setFromMatrixPosition(rx),
        r.setXYZ(o, qu.x, qu.y, qu.z),
        rx.multiplyMatrices(_S, u.parent.matrixWorld),
        qu.setFromMatrixPosition(rx),
        r.setXYZ(o + 1, qu.x, qu.y, qu.z),
        (o += 2));
    }
    ((n.getAttribute("position").needsUpdate = !0), super.updateMatrixWorld(e));
  }
  setColors(e, t) {
    const r = this.geometry.getAttribute("color");
    for (let s = 0; s < r.count; s += 2)
      (r.setXYZ(s, e.r, e.g, e.b), r.setXYZ(s + 1, t.r, t.g, t.b));
    return ((r.needsUpdate = !0), this);
  }
  dispose() {
    (this.geometry.dispose(), this.material.dispose());
  }
}
function JN(i) {
  const e = [];
  i.isBone === !0 && e.push(i);
  for (let t = 0; t < i.children.length; t++) e.push(...JN(i.children[t]));
  return e;
}
class hV extends wi {
  constructor(e, t, n) {
    const r = new O0(t, 4, 2),
      s = new Jc({ wireframe: !0, fog: !1, toneMapped: !1 });
    (super(r, s),
      (this.light = e),
      (this.color = n),
      (this.type = "PointLightHelper"),
      (this.matrix = this.light.matrixWorld),
      (this.matrixAutoUpdate = !1),
      this.update());
  }
  dispose() {
    (this.geometry.dispose(), this.material.dispose());
  }
  update() {
    (this.light.updateWorldMatrix(!0, !1),
      this.color !== void 0
        ? this.material.color.set(this.color)
        : this.material.color.copy(this.light.color));
  }
}
const dV = new te(),
  jC = new wt(),
  WC = new wt();
class pV extends In {
  constructor(e, t, n) {
    (super(),
      (this.light = e),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = n),
      (this.type = "HemisphereLightHelper"));
    const r = new I0(t);
    (r.rotateY(Math.PI * 0.5),
      (this.material = new Jc({ wireframe: !0, fog: !1, toneMapped: !1 })),
      this.color === void 0 && (this.material.vertexColors = !0));
    const s = r.getAttribute("position"),
      o = new Float32Array(s.count * 3);
    (r.setAttribute("color", new $n(o, 3)),
      this.add(new wi(r, this.material)),
      this.update());
  }
  dispose() {
    (this.children[0].geometry.dispose(), this.children[0].material.dispose());
  }
  update() {
    const e = this.children[0];
    if (this.color !== void 0) this.material.color.set(this.color);
    else {
      const t = e.geometry.getAttribute("color");
      (jC.copy(this.light.color), WC.copy(this.light.groundColor));
      for (let n = 0, r = t.count; n < r; n++) {
        const s = n < r / 2 ? jC : WC;
        t.setXYZ(n, s.r, s.g, s.b);
      }
      t.needsUpdate = !0;
    }
    (this.light.updateWorldMatrix(!0, !1),
      e.lookAt(dV.setFromMatrixPosition(this.light.matrixWorld).negate()));
  }
}
class mV extends tc {
  constructor(e = 10, t = 10, n = 4473924, r = 8947848) {
    ((n = new wt(n)), (r = new wt(r)));
    const s = t / 2,
      o = e / t,
      u = e / 2,
      h = [],
      d = [];
    for (let y = 0, b = 0, _ = -u; y <= t; y++, _ += o) {
      (h.push(-u, 0, _, u, 0, _), h.push(_, 0, -u, _, 0, u));
      const w = y === s ? n : r;
      (w.toArray(d, b),
        (b += 3),
        w.toArray(d, b),
        (b += 3),
        w.toArray(d, b),
        (b += 3),
        w.toArray(d, b),
        (b += 3));
    }
    const m = new nn();
    (m.setAttribute("position", new Rt(h, 3)),
      m.setAttribute("color", new Rt(d, 3)));
    const v = new Ws({ vertexColors: !0, toneMapped: !1 });
    (super(m, v), (this.type = "GridHelper"));
  }
  dispose() {
    (this.geometry.dispose(), this.material.dispose());
  }
}
class gV extends tc {
  constructor(e = 10, t = 16, n = 8, r = 64, s = 4473924, o = 8947848) {
    ((s = new wt(s)), (o = new wt(o)));
    const u = [],
      h = [];
    if (t > 1)
      for (let v = 0; v < t; v++) {
        const y = (v / t) * (Math.PI * 2),
          b = Math.sin(y) * e,
          _ = Math.cos(y) * e;
        (u.push(0, 0, 0), u.push(b, 0, _));
        const w = v & 1 ? s : o;
        (h.push(w.r, w.g, w.b), h.push(w.r, w.g, w.b));
      }
    for (let v = 0; v < n; v++) {
      const y = v & 1 ? s : o,
        b = e - (e / n) * v;
      for (let _ = 0; _ < r; _++) {
        let w = (_ / r) * (Math.PI * 2),
          E = Math.sin(w) * b,
          T = Math.cos(w) * b;
        (u.push(E, 0, T),
          h.push(y.r, y.g, y.b),
          (w = ((_ + 1) / r) * (Math.PI * 2)),
          (E = Math.sin(w) * b),
          (T = Math.cos(w) * b),
          u.push(E, 0, T),
          h.push(y.r, y.g, y.b));
      }
    }
    const d = new nn();
    (d.setAttribute("position", new Rt(u, 3)),
      d.setAttribute("color", new Rt(h, 3)));
    const m = new Ws({ vertexColors: !0, toneMapped: !1 });
    (super(d, m), (this.type = "PolarGridHelper"));
  }
  dispose() {
    (this.geometry.dispose(), this.material.dispose());
  }
}
const XC = new te(),
  sx = new te(),
  qC = new te();
class vV extends In {
  constructor(e, t, n) {
    (super(),
      (this.light = e),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = n),
      (this.type = "DirectionalLightHelper"),
      t === void 0 && (t = 1));
    let r = new nn();
    r.setAttribute(
      "position",
      new Rt([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3),
    );
    const s = new Ws({ fog: !1, toneMapped: !1 });
    ((this.lightPlane = new lf(r, s)),
      this.add(this.lightPlane),
      (r = new nn()),
      r.setAttribute("position", new Rt([0, 0, 0, 0, 0, 1], 3)),
      (this.targetLine = new lf(r, s)),
      this.add(this.targetLine),
      this.update());
  }
  dispose() {
    (this.lightPlane.geometry.dispose(),
      this.lightPlane.material.dispose(),
      this.targetLine.geometry.dispose(),
      this.targetLine.material.dispose());
  }
  update() {
    (this.light.updateWorldMatrix(!0, !1),
      this.light.target.updateWorldMatrix(!0, !1),
      XC.setFromMatrixPosition(this.light.matrixWorld),
      sx.setFromMatrixPosition(this.light.target.matrixWorld),
      qC.subVectors(sx, XC),
      this.lightPlane.lookAt(sx),
      this.color !== void 0
        ? (this.lightPlane.material.color.set(this.color),
          this.targetLine.material.color.set(this.color))
        : (this.lightPlane.material.color.copy(this.light.color),
          this.targetLine.material.color.copy(this.light.color)),
      this.targetLine.lookAt(sx),
      (this.targetLine.scale.z = qC.length()));
  }
}
const ax = new te(),
  qi = new Rb();
class yV extends tc {
  constructor(e) {
    const t = new nn(),
      n = new Ws({ color: 16777215, vertexColors: !0, toneMapped: !1 }),
      r = [],
      s = [],
      o = {};
    (u("n1", "n2"),
      u("n2", "n4"),
      u("n4", "n3"),
      u("n3", "n1"),
      u("f1", "f2"),
      u("f2", "f4"),
      u("f4", "f3"),
      u("f3", "f1"),
      u("n1", "f1"),
      u("n2", "f2"),
      u("n3", "f3"),
      u("n4", "f4"),
      u("p", "n1"),
      u("p", "n2"),
      u("p", "n3"),
      u("p", "n4"),
      u("u1", "u2"),
      u("u2", "u3"),
      u("u3", "u1"),
      u("c", "t"),
      u("p", "c"),
      u("cn1", "cn2"),
      u("cn3", "cn4"),
      u("cf1", "cf2"),
      u("cf3", "cf4"));
    function u(_, w) {
      (h(_), h(w));
    }
    function h(_) {
      (r.push(0, 0, 0),
        s.push(0, 0, 0),
        o[_] === void 0 && (o[_] = []),
        o[_].push(r.length / 3 - 1));
    }
    (t.setAttribute("position", new Rt(r, 3)),
      t.setAttribute("color", new Rt(s, 3)),
      super(t, n),
      (this.type = "CameraHelper"),
      (this.camera = e),
      this.camera.updateProjectionMatrix &&
        this.camera.updateProjectionMatrix(),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.pointMap = o),
      this.update());
    const d = new wt(16755200),
      m = new wt(16711680),
      v = new wt(43775),
      y = new wt(16777215),
      b = new wt(3355443);
    this.setColors(d, m, v, y, b);
  }
  setColors(e, t, n, r, s) {
    const u = this.geometry.getAttribute("color");
    return (
      u.setXYZ(0, e.r, e.g, e.b),
      u.setXYZ(1, e.r, e.g, e.b),
      u.setXYZ(2, e.r, e.g, e.b),
      u.setXYZ(3, e.r, e.g, e.b),
      u.setXYZ(4, e.r, e.g, e.b),
      u.setXYZ(5, e.r, e.g, e.b),
      u.setXYZ(6, e.r, e.g, e.b),
      u.setXYZ(7, e.r, e.g, e.b),
      u.setXYZ(8, e.r, e.g, e.b),
      u.setXYZ(9, e.r, e.g, e.b),
      u.setXYZ(10, e.r, e.g, e.b),
      u.setXYZ(11, e.r, e.g, e.b),
      u.setXYZ(12, e.r, e.g, e.b),
      u.setXYZ(13, e.r, e.g, e.b),
      u.setXYZ(14, e.r, e.g, e.b),
      u.setXYZ(15, e.r, e.g, e.b),
      u.setXYZ(16, e.r, e.g, e.b),
      u.setXYZ(17, e.r, e.g, e.b),
      u.setXYZ(18, e.r, e.g, e.b),
      u.setXYZ(19, e.r, e.g, e.b),
      u.setXYZ(20, e.r, e.g, e.b),
      u.setXYZ(21, e.r, e.g, e.b),
      u.setXYZ(22, e.r, e.g, e.b),
      u.setXYZ(23, e.r, e.g, e.b),
      u.setXYZ(24, t.r, t.g, t.b),
      u.setXYZ(25, t.r, t.g, t.b),
      u.setXYZ(26, t.r, t.g, t.b),
      u.setXYZ(27, t.r, t.g, t.b),
      u.setXYZ(28, t.r, t.g, t.b),
      u.setXYZ(29, t.r, t.g, t.b),
      u.setXYZ(30, t.r, t.g, t.b),
      u.setXYZ(31, t.r, t.g, t.b),
      u.setXYZ(32, n.r, n.g, n.b),
      u.setXYZ(33, n.r, n.g, n.b),
      u.setXYZ(34, n.r, n.g, n.b),
      u.setXYZ(35, n.r, n.g, n.b),
      u.setXYZ(36, n.r, n.g, n.b),
      u.setXYZ(37, n.r, n.g, n.b),
      u.setXYZ(38, r.r, r.g, r.b),
      u.setXYZ(39, r.r, r.g, r.b),
      u.setXYZ(40, s.r, s.g, s.b),
      u.setXYZ(41, s.r, s.g, s.b),
      u.setXYZ(42, s.r, s.g, s.b),
      u.setXYZ(43, s.r, s.g, s.b),
      u.setXYZ(44, s.r, s.g, s.b),
      u.setXYZ(45, s.r, s.g, s.b),
      u.setXYZ(46, s.r, s.g, s.b),
      u.setXYZ(47, s.r, s.g, s.b),
      u.setXYZ(48, s.r, s.g, s.b),
      u.setXYZ(49, s.r, s.g, s.b),
      (u.needsUpdate = !0),
      this
    );
  }
  update() {
    const e = this.geometry,
      t = this.pointMap,
      n = 1,
      r = 1;
    let s, o;
    if (
      (qi.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
      this.camera.reversedDepth === !0)
    )
      ((s = 1), (o = 0));
    else if (this.camera.coordinateSystem === Ua) ((s = -1), (o = 1));
    else if (this.camera.coordinateSystem === Nh) ((s = 0), (o = 1));
    else
      throw new Error(
        "THREE.CameraHelper.update(): Invalid coordinate system: " +
          this.camera.coordinateSystem,
      );
    (nr("c", t, e, qi, 0, 0, s),
      nr("t", t, e, qi, 0, 0, o),
      nr("n1", t, e, qi, -n, -r, s),
      nr("n2", t, e, qi, n, -r, s),
      nr("n3", t, e, qi, -n, r, s),
      nr("n4", t, e, qi, n, r, s),
      nr("f1", t, e, qi, -n, -r, o),
      nr("f2", t, e, qi, n, -r, o),
      nr("f3", t, e, qi, -n, r, o),
      nr("f4", t, e, qi, n, r, o),
      nr("u1", t, e, qi, n * 0.7, r * 1.1, s),
      nr("u2", t, e, qi, -n * 0.7, r * 1.1, s),
      nr("u3", t, e, qi, 0, r * 2, s),
      nr("cf1", t, e, qi, -n, 0, o),
      nr("cf2", t, e, qi, n, 0, o),
      nr("cf3", t, e, qi, 0, -r, o),
      nr("cf4", t, e, qi, 0, r, o),
      nr("cn1", t, e, qi, -n, 0, s),
      nr("cn2", t, e, qi, n, 0, s),
      nr("cn3", t, e, qi, 0, -r, s),
      nr("cn4", t, e, qi, 0, r, s),
      (e.getAttribute("position").needsUpdate = !0));
  }
  dispose() {
    (this.geometry.dispose(), this.material.dispose());
  }
}
function nr(i, e, t, n, r, s, o) {
  ax.set(r, s, o).unproject(n);
  const u = e[i];
  if (u !== void 0) {
    const h = t.getAttribute("position");
    for (let d = 0, m = u.length; d < m; d++) h.setXYZ(u[d], ax.x, ax.y, ax.z);
  }
}
const ox = new sr();
class xV extends tc {
  constructor(e, t = 16776960) {
    const n = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
      ]),
      r = new Float32Array(24),
      s = new nn();
    (s.setIndex(new $n(n, 1)),
      s.setAttribute("position", new $n(r, 3)),
      super(s, new Ws({ color: t, toneMapped: !1 })),
      (this.object = e),
      (this.type = "BoxHelper"),
      (this.matrixAutoUpdate = !1),
      this.update());
  }
  update() {
    if ((this.object !== void 0 && ox.setFromObject(this.object), ox.isEmpty()))
      return;
    const e = ox.min,
      t = ox.max,
      n = this.geometry.attributes.position,
      r = n.array;
    ((r[0] = t.x),
      (r[1] = t.y),
      (r[2] = t.z),
      (r[3] = e.x),
      (r[4] = t.y),
      (r[5] = t.z),
      (r[6] = e.x),
      (r[7] = e.y),
      (r[8] = t.z),
      (r[9] = t.x),
      (r[10] = e.y),
      (r[11] = t.z),
      (r[12] = t.x),
      (r[13] = t.y),
      (r[14] = e.z),
      (r[15] = e.x),
      (r[16] = t.y),
      (r[17] = e.z),
      (r[18] = e.x),
      (r[19] = e.y),
      (r[20] = e.z),
      (r[21] = t.x),
      (r[22] = e.y),
      (r[23] = e.z),
      (n.needsUpdate = !0),
      this.geometry.computeBoundingSphere());
  }
  setFromObject(e) {
    return ((this.object = e), this.update(), this);
  }
  copy(e, t) {
    return (super.copy(e, t), (this.object = e.object), this);
  }
  dispose() {
    (this.geometry.dispose(), this.material.dispose());
  }
}
class bV extends tc {
  constructor(e, t = 16776960) {
    const n = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
      ]),
      r = [
        1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1,
        1, -1, -1,
      ],
      s = new nn();
    (s.setIndex(new $n(n, 1)),
      s.setAttribute("position", new Rt(r, 3)),
      super(s, new Ws({ color: t, toneMapped: !1 })),
      (this.box = e),
      (this.type = "Box3Helper"),
      this.geometry.computeBoundingSphere());
  }
  updateMatrixWorld(e) {
    const t = this.box;
    t.isEmpty() ||
      (t.getCenter(this.position),
      t.getSize(this.scale),
      this.scale.multiplyScalar(0.5),
      super.updateMatrixWorld(e));
  }
  dispose() {
    (this.geometry.dispose(), this.material.dispose());
  }
}
class _V extends lf {
  constructor(e, t = 1, n = 16776960) {
    const r = n,
      s = [
        1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0,
        1, 1, 0,
      ],
      o = new nn();
    (o.setAttribute("position", new Rt(s, 3)),
      o.computeBoundingSphere(),
      super(o, new Ws({ color: r, toneMapped: !1 })),
      (this.type = "PlaneHelper"),
      (this.plane = e),
      (this.size = t));
    const u = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0],
      h = new nn();
    (h.setAttribute("position", new Rt(u, 3)),
      h.computeBoundingSphere(),
      this.add(
        new wi(
          h,
          new Jc({
            color: r,
            opacity: 0.2,
            transparent: !0,
            depthWrite: !1,
            toneMapped: !1,
          }),
        ),
      ));
  }
  updateMatrixWorld(e) {
    (this.position.set(0, 0, 0),
      this.scale.set(0.5 * this.size, 0.5 * this.size, 1),
      this.lookAt(this.plane.normal),
      this.translateZ(-this.plane.constant),
      super.updateMatrixWorld(e));
  }
  dispose() {
    (this.geometry.dispose(),
      this.material.dispose(),
      this.children[0].geometry.dispose(),
      this.children[0].material.dispose());
  }
}
const YC = new te();
let lx, SS;
class SV extends In {
  constructor(
    e = new te(0, 0, 1),
    t = new te(0, 0, 0),
    n = 1,
    r = 16776960,
    s = n * 0.2,
    o = s * 0.2,
  ) {
    (super(),
      (this.type = "ArrowHelper"),
      lx === void 0 &&
        ((lx = new nn()),
        lx.setAttribute("position", new Rt([0, 0, 0, 0, 1, 0], 3)),
        (SS = new P0(0.5, 1, 5, 1)),
        SS.translate(0, -0.5, 0)),
      this.position.copy(t),
      (this.line = new lf(lx, new Ws({ color: r, toneMapped: !1 }))),
      (this.line.matrixAutoUpdate = !1),
      this.add(this.line),
      (this.cone = new wi(SS, new Jc({ color: r, toneMapped: !1 }))),
      (this.cone.matrixAutoUpdate = !1),
      this.add(this.cone),
      this.setDirection(e),
      this.setLength(n, s, o));
  }
  setDirection(e) {
    if (e.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
    else if (e.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
    else {
      YC.set(e.z, 0, -e.x).normalize();
      const t = Math.acos(e.y);
      this.quaternion.setFromAxisAngle(YC, t);
    }
  }
  setLength(e, t = e * 0.2, n = t * 0.2) {
    (this.line.scale.set(1, Math.max(1e-4, e - t), 1),
      this.line.updateMatrix(),
      this.cone.scale.set(n, t, n),
      (this.cone.position.y = e),
      this.cone.updateMatrix());
  }
  setColor(e) {
    (this.line.material.color.set(e), this.cone.material.color.set(e));
  }
  copy(e) {
    return (
      super.copy(e, !1),
      this.line.copy(e.line),
      this.cone.copy(e.cone),
      this
    );
  }
  dispose() {
    (this.line.geometry.dispose(),
      this.line.material.dispose(),
      this.cone.geometry.dispose(),
      this.cone.material.dispose());
  }
}
class MV extends tc {
  constructor(e = 1) {
    const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
      n = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1],
      r = new nn();
    (r.setAttribute("position", new Rt(t, 3)),
      r.setAttribute("color", new Rt(n, 3)));
    const s = new Ws({ vertexColors: !0, toneMapped: !1 });
    (super(r, s), (this.type = "AxesHelper"));
  }
  setColors(e, t, n) {
    const r = new wt(),
      s = this.geometry.attributes.color.array;
    return (
      r.set(e),
      r.toArray(s, 0),
      r.toArray(s, 3),
      r.set(t),
      r.toArray(s, 6),
      r.toArray(s, 9),
      r.set(n),
      r.toArray(s, 12),
      r.toArray(s, 15),
      (this.geometry.attributes.color.needsUpdate = !0),
      this
    );
  }
  dispose() {
    (this.geometry.dispose(), this.material.dispose());
  }
}
class TV {
  constructor() {
    ((this.type = "ShapePath"),
      (this.color = new wt()),
      (this.subPaths = []),
      (this.currentPath = null));
  }
  moveTo(e, t) {
    return (
      (this.currentPath = new I1()),
      this.subPaths.push(this.currentPath),
      this.currentPath.moveTo(e, t),
      this
    );
  }
  lineTo(e, t) {
    return (this.currentPath.lineTo(e, t), this);
  }
  quadraticCurveTo(e, t, n, r) {
    return (this.currentPath.quadraticCurveTo(e, t, n, r), this);
  }
  bezierCurveTo(e, t, n, r, s, o) {
    return (this.currentPath.bezierCurveTo(e, t, n, r, s, o), this);
  }
  splineThru(e) {
    return (this.currentPath.splineThru(e), this);
  }
  toShapes(e) {
    function t(T) {
      const C = [];
      for (let R = 0, L = T.length; R < L; R++) {
        const I = T[R],
          O = new Ah();
        ((O.curves = I.curves), C.push(O));
      }
      return C;
    }
    function n(T, C) {
      const R = C.length;
      let L = !1;
      for (let I = R - 1, O = 0; O < R; I = O++) {
        let B = C[I],
          N = C[O],
          F = N.x - B.x,
          j = N.y - B.y;
        if (Math.abs(j) > Number.EPSILON) {
          if (
            (j < 0 && ((B = C[O]), (F = -F), (N = C[I]), (j = -j)),
            T.y < B.y || T.y > N.y)
          )
            continue;
          if (T.y === B.y) {
            if (T.x === B.x) return !0;
          } else {
            const q = j * (T.x - B.x) - F * (T.y - B.y);
            if (q === 0) return !0;
            if (q < 0) continue;
            L = !L;
          }
        } else {
          if (T.y !== B.y) continue;
          if ((N.x <= T.x && T.x <= B.x) || (B.x <= T.x && T.x <= N.x))
            return !0;
        }
      }
      return L;
    }
    const r = qo.isClockWise,
      s = this.subPaths;
    if (s.length === 0) return [];
    let o, u, h;
    const d = [];
    if (s.length === 1)
      return ((u = s[0]), (h = new Ah()), (h.curves = u.curves), d.push(h), d);
    let m = !r(s[0].getPoints());
    m = e ? !m : m;
    const v = [],
      y = [];
    let b = [],
      _ = 0,
      w;
    ((y[_] = void 0), (b[_] = []));
    for (let T = 0, C = s.length; T < C; T++)
      ((u = s[T]),
        (w = u.getPoints()),
        (o = r(w)),
        (o = e ? !o : o),
        o
          ? (!m && y[_] && _++,
            (y[_] = { s: new Ah(), p: w }),
            (y[_].s.curves = u.curves),
            m && _++,
            (b[_] = []))
          : b[_].push({ h: u, p: w[0] }));
    if (!y[0]) return t(s);
    if (y.length > 1) {
      let T = !1,
        C = 0;
      for (let R = 0, L = y.length; R < L; R++) v[R] = [];
      for (let R = 0, L = y.length; R < L; R++) {
        const I = b[R];
        for (let O = 0; O < I.length; O++) {
          const B = I[O];
          let N = !0;
          for (let F = 0; F < y.length; F++)
            n(B.p, y[F].p) &&
              (R !== F && C++, N ? ((N = !1), v[F].push(B)) : (T = !0));
          N && v[R].push(B);
        }
      }
      C > 0 && T === !1 && (b = v);
    }
    let E;
    for (let T = 0, C = y.length; T < C; T++) {
      ((h = y[T].s), d.push(h), (E = b[T]));
      for (let R = 0, L = E.length; R < L; R++) h.holes.push(E[R].h);
    }
    return d;
  }
}
class EV extends ec {
  constructor(e, t = null) {
    (super(),
      (this.object = e),
      (this.domElement = t),
      (this.enabled = !0),
      (this.state = -1),
      (this.keys = {}),
      (this.mouseButtons = { LEFT: null, MIDDLE: null, RIGHT: null }),
      (this.touches = { ONE: null, TWO: null }));
  }
  connect(e) {
    if (e === void 0) {
      Tt("Controls: connect() now requires an element.");
      return;
    }
    (this.domElement !== null && this.disconnect(), (this.domElement = e));
  }
  disconnect() {}
  dispose() {}
  update() {}
}
function wV(i, e) {
  const t = i.image && i.image.width ? i.image.width / i.image.height : 1;
  return (
    t > e
      ? ((i.repeat.x = 1),
        (i.repeat.y = t / e),
        (i.offset.x = 0),
        (i.offset.y = (1 - i.repeat.y) / 2))
      : ((i.repeat.x = e / t),
        (i.repeat.y = 1),
        (i.offset.x = (1 - i.repeat.x) / 2),
        (i.offset.y = 0)),
    i
  );
}
function AV(i, e) {
  const t = i.image && i.image.width ? i.image.width / i.image.height : 1;
  return (
    t > e
      ? ((i.repeat.x = e / t),
        (i.repeat.y = 1),
        (i.offset.x = (1 - i.repeat.x) / 2),
        (i.offset.y = 0))
      : ((i.repeat.x = 1),
        (i.repeat.y = t / e),
        (i.offset.x = 0),
        (i.offset.y = (1 - i.repeat.y) / 2)),
    i
  );
}
function CV(i) {
  return (
    (i.repeat.x = 1),
    (i.repeat.y = 1),
    (i.offset.x = 0),
    (i.offset.y = 0),
    i
  );
}
function NM(i, e, t, n) {
  const r = RV(n);
  switch (t) {
    case kT:
      return i * e;
    case eb:
      return ((i * e) / r.components) * r.byteLength;
    case L0:
      return ((i * e) / r.components) * r.byteLength;
    case Lh:
      return ((i * e * 2) / r.components) * r.byteLength;
    case tb:
      return ((i * e * 2) / r.components) * r.byteLength;
    case VT:
      return ((i * e * 3) / r.components) * r.byteLength;
    case xs:
      return ((i * e * 4) / r.components) * r.byteLength;
    case nb:
      return ((i * e * 4) / r.components) * r.byteLength;
    case Vg:
    case Gg:
      return Math.floor((i + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case Hg:
    case jg:
      return Math.floor((i + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case e1:
    case n1:
      return (Math.max(i, 16) * Math.max(e, 8)) / 4;
    case $x:
    case t1:
      return (Math.max(i, 8) * Math.max(e, 8)) / 2;
    case i1:
    case r1:
    case a1:
    case o1:
      return Math.floor((i + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case s1:
    case l1:
    case c1:
      return Math.floor((i + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case u1:
      return Math.floor((i + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case f1:
      return Math.floor((i + 4) / 5) * Math.floor((e + 3) / 4) * 16;
    case h1:
      return Math.floor((i + 4) / 5) * Math.floor((e + 4) / 5) * 16;
    case d1:
      return Math.floor((i + 5) / 6) * Math.floor((e + 4) / 5) * 16;
    case p1:
      return Math.floor((i + 5) / 6) * Math.floor((e + 5) / 6) * 16;
    case m1:
      return Math.floor((i + 7) / 8) * Math.floor((e + 4) / 5) * 16;
    case g1:
      return Math.floor((i + 7) / 8) * Math.floor((e + 5) / 6) * 16;
    case v1:
      return Math.floor((i + 7) / 8) * Math.floor((e + 7) / 8) * 16;
    case y1:
      return Math.floor((i + 9) / 10) * Math.floor((e + 4) / 5) * 16;
    case x1:
      return Math.floor((i + 9) / 10) * Math.floor((e + 5) / 6) * 16;
    case b1:
      return Math.floor((i + 9) / 10) * Math.floor((e + 7) / 8) * 16;
    case _1:
      return Math.floor((i + 9) / 10) * Math.floor((e + 9) / 10) * 16;
    case S1:
      return Math.floor((i + 11) / 12) * Math.floor((e + 9) / 10) * 16;
    case M1:
      return Math.floor((i + 11) / 12) * Math.floor((e + 11) / 12) * 16;
    case T1:
    case E1:
    case w1:
      return Math.ceil(i / 4) * Math.ceil(e / 4) * 16;
    case A1:
    case C1:
      return Math.ceil(i / 4) * Math.ceil(e / 4) * 8;
    case R1:
    case D1:
      return Math.ceil(i / 4) * Math.ceil(e / 4) * 16;
  }
  throw new Error(`Unable to determine texture byte length for ${t} format.`);
}
function RV(i) {
  switch (i) {
    case Bs:
    case OT:
      return { byteLength: 1, components: 1 };
    case Tp:
    case FT:
    case Kl:
      return { byteLength: 2, components: 1 };
    case J1:
    case $1:
      return { byteLength: 2, components: 4 };
    case bo:
    case Q1:
    case Hs:
      return { byteLength: 4, components: 1 };
    case zT:
    case BT:
      return { byteLength: 4, components: 3 };
  }
  throw new Error(`Unknown texture type ${i}.`);
}
class DV {
  static contain(e, t) {
    return wV(e, t);
  }
  static cover(e, t) {
    return AV(e, t);
  }
  static fill(e) {
    return CV(e);
  }
  static getByteLength(e, t, n, r) {
    return NM(e, t, n, r);
  }
}
typeof __THREE_DEVTOOLS__ < "u" &&
  __THREE_DEVTOOLS__.dispatchEvent(
    new CustomEvent("register", { detail: { revision: zp } }),
  );
typeof window < "u" &&
  (window.__THREE__
    ? Tt("WARNING: Multiple instances of Three.js being imported.")
    : (window.__THREE__ = zp));
/**
 * @license
 * Copyright 2010-2026 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ function $N() {
  let i = null,
    e = !1,
    t = null,
    n = null;
  function r(s, o) {
    (t(s, o), (n = i.requestAnimationFrame(r)));
  }
  return {
    start: function () {
      e !== !0 && t !== null && ((n = i.requestAnimationFrame(r)), (e = !0));
    },
    stop: function () {
      (i.cancelAnimationFrame(n), (e = !1));
    },
    setAnimationLoop: function (s) {
      t = s;
    },
    setContext: function (s) {
      i = s;
    },
  };
}
function LV(i) {
  const e = new WeakMap();
  function t(u, h) {
    const d = u.array,
      m = u.usage,
      v = d.byteLength,
      y = i.createBuffer();
    (i.bindBuffer(h, y), i.bufferData(h, d, m), u.onUploadCallback());
    let b;
    if (d instanceof Float32Array) b = i.FLOAT;
    else if (typeof Float16Array < "u" && d instanceof Float16Array)
      b = i.HALF_FLOAT;
    else if (d instanceof Uint16Array)
      u.isFloat16BufferAttribute ? (b = i.HALF_FLOAT) : (b = i.UNSIGNED_SHORT);
    else if (d instanceof Int16Array) b = i.SHORT;
    else if (d instanceof Uint32Array) b = i.UNSIGNED_INT;
    else if (d instanceof Int32Array) b = i.INT;
    else if (d instanceof Int8Array) b = i.BYTE;
    else if (d instanceof Uint8Array) b = i.UNSIGNED_BYTE;
    else if (d instanceof Uint8ClampedArray) b = i.UNSIGNED_BYTE;
    else
      throw new Error(
        "THREE.WebGLAttributes: Unsupported buffer data format: " + d,
      );
    return {
      buffer: y,
      type: b,
      bytesPerElement: d.BYTES_PER_ELEMENT,
      version: u.version,
      size: v,
    };
  }
  function n(u, h, d) {
    const m = h.array,
      v = h.updateRanges;
    if ((i.bindBuffer(d, u), v.length === 0)) i.bufferSubData(d, 0, m);
    else {
      v.sort((b, _) => b.start - _.start);
      let y = 0;
      for (let b = 1; b < v.length; b++) {
        const _ = v[y],
          w = v[b];
        w.start <= _.start + _.count + 1
          ? (_.count = Math.max(_.count, w.start + w.count - _.start))
          : (++y, (v[y] = w));
      }
      v.length = y + 1;
      for (let b = 0, _ = v.length; b < _; b++) {
        const w = v[b];
        i.bufferSubData(d, w.start * m.BYTES_PER_ELEMENT, m, w.start, w.count);
      }
      h.clearUpdateRanges();
    }
    h.onUploadCallback();
  }
  function r(u) {
    return (u.isInterleavedBufferAttribute && (u = u.data), e.get(u));
  }
  function s(u) {
    u.isInterleavedBufferAttribute && (u = u.data);
    const h = e.get(u);
    h && (i.deleteBuffer(h.buffer), e.delete(u));
  }
  function o(u, h) {
    if (
      (u.isInterleavedBufferAttribute && (u = u.data), u.isGLBufferAttribute)
    ) {
      const m = e.get(u);
      (!m || m.version < u.version) &&
        e.set(u, {
          buffer: u.buffer,
          type: u.type,
          bytesPerElement: u.elementSize,
          version: u.version,
        });
      return;
    }
    const d = e.get(u);
    if (d === void 0) e.set(u, t(u, h));
    else if (d.version < u.version) {
      if (d.size !== u.array.byteLength)
        throw new Error(
          "THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.",
        );
      (n(d.buffer, u, h), (d.version = u.version));
    }
  }
  return { get: r, remove: s, update: o };
}
var NV = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,
  UV = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,
  PV = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,
  IV = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  OV = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,
  FV = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
  zV = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
  BV = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
  kV = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec4 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 );
	}
#endif`,
  VV = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`,
  GV = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,
  HV = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
  jV = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,
  WV = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
  XV = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
  qV = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,
  YV = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
  ZV = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
  KV = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
  QV = `#if defined( USE_COLOR ) || defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#endif`,
  JV = `#if defined( USE_COLOR ) || defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#endif`,
  $V = `#if defined( USE_COLOR ) || defined( USE_COLOR_ALPHA ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec4 vColor;
#endif`,
  e8 = `#if defined( USE_COLOR ) || defined( USE_COLOR_ALPHA ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec4( 1.0 );
#endif
#ifdef USE_COLOR_ALPHA
	vColor *= color;
#elif defined( USE_COLOR )
	vColor.rgb *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.rgb *= instanceColor.rgb;
#endif
#ifdef USE_BATCHING_COLOR
	vColor *= getBatchingColor( getIndirectIndex( gl_DrawID ) );
#endif`,
  t8 = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,
  n8 = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
  i8 = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
  r8 = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
  s8 = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,
  a8 = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
  o8 = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
  l8 = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
  c8 = `vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,
  u8 = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
		#ifdef ENVMAP_BLENDING_MULTIPLY
			outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
		#elif defined( ENVMAP_BLENDING_MIX )
			outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
		#elif defined( ENVMAP_BLENDING_ADD )
			outgoingLight += envColor.xyz * specularStrength * reflectivity;
		#endif
	#endif
#endif`,
  f8 = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
#endif`,
  h8 = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
  d8 = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
  p8 = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
  m8 = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
  g8 = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
  v8 = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
  y8 = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
  x8 = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
  b8 = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
  _8 = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
  S8 = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
  M8 = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
  T8 = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, pow4( roughness ) ) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,
  E8 = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
  w8 = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
  A8 = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
  C8 = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
  R8 = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.diffuseContribution = diffuseColor.rgb * ( 1.0 - metalnessFactor );
material.metalness = metalnessFactor;
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor;
	material.specularColorBlended = mix( material.specularColor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = vec3( 0.04 );
	material.specularColorBlended = mix( material.specularColor, diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.0001, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,
  D8 = `uniform sampler2D dfgLUT;
struct PhysicalMaterial {
	vec3 diffuseColor;
	vec3 diffuseContribution;
	vec3 specularColor;
	vec3 specularColorBlended;
	float roughness;
	float metalness;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
		vec3 iridescenceFresnelDielectric;
		vec3 iridescenceFresnelMetallic;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return v;
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColorBlended;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transpose( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float rInv = 1.0 / ( roughness + 0.1 );
	float a = -1.9362 + 1.0678 * roughness + 0.4573 * r2 - 0.8469 * rInv;
	float b = -0.6014 + 0.5538 * roughness - 0.4670 * r2 - 0.1255 * rInv;
	float DG = exp( a * dotNV + b );
	return saturate( DG );
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	vec2 fab = texture2D( dfgLUT, vec2( roughness, dotNV ) ).rg;
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	float dotNV = saturate( dot( normal, viewDir ) );
	vec2 fab = texture2D( dfgLUT, vec2( roughness, dotNV ) ).rg;
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
vec3 BRDF_GGX_Multiscatter( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 singleScatter = BRDF_GGX( lightDir, viewDir, normal, material );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	vec2 dfgV = texture2D( dfgLUT, vec2( material.roughness, dotNV ) ).rg;
	vec2 dfgL = texture2D( dfgLUT, vec2( material.roughness, dotNL ) ).rg;
	vec3 FssEss_V = material.specularColorBlended * dfgV.x + material.specularF90 * dfgV.y;
	vec3 FssEss_L = material.specularColorBlended * dfgL.x + material.specularF90 * dfgL.y;
	float Ess_V = dfgV.x + dfgV.y;
	float Ess_L = dfgL.x + dfgL.y;
	float Ems_V = 1.0 - Ess_V;
	float Ems_L = 1.0 - Ess_L;
	vec3 Favg = material.specularColorBlended + ( 1.0 - material.specularColorBlended ) * 0.047619;
	vec3 Fms = FssEss_V * FssEss_L * Favg / ( 1.0 - Ems_V * Ems_L * Favg + EPSILON );
	float compensationFactor = Ems_V * Ems_L;
	vec3 multiScatter = Fms * compensationFactor;
	return singleScatter + multiScatter;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColorBlended * t2.x + ( material.specularF90 - material.specularColorBlended ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseContribution * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
		#ifdef USE_CLEARCOAT
			vec3 Ncc = geometryClearcoatNormal;
			vec2 uvClearcoat = LTC_Uv( Ncc, viewDir, material.clearcoatRoughness );
			vec4 t1Clearcoat = texture2D( ltc_1, uvClearcoat );
			vec4 t2Clearcoat = texture2D( ltc_2, uvClearcoat );
			mat3 mInvClearcoat = mat3(
				vec3( t1Clearcoat.x, 0, t1Clearcoat.y ),
				vec3(             0, 1,             0 ),
				vec3( t1Clearcoat.z, 0, t1Clearcoat.w )
			);
			vec3 fresnelClearcoat = material.clearcoatF0 * t2Clearcoat.x + ( material.clearcoatF90 - material.clearcoatF0 ) * t2Clearcoat.y;
			clearcoatSpecularDirect += lightColor * fresnelClearcoat * LTC_Evaluate( Ncc, viewDir, position, mInvClearcoat, rectCoords );
		#endif
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
 
 		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
 
 		float sheenAlbedoV = IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
 		float sheenAlbedoL = IBLSheenBRDF( geometryNormal, directLight.direction, material.sheenRoughness );
 
 		float sheenEnergyComp = 1.0 - max3( material.sheenColor ) * max( sheenAlbedoV, sheenAlbedoL );
 
 		irradiance *= sheenEnergyComp;
 
 	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX_Multiscatter( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseContribution );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 diffuse = irradiance * BRDF_Lambert( material.diffuseContribution );
	#ifdef USE_SHEEN
		float sheenAlbedo = IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
		float sheenEnergyComp = 1.0 - max3( material.sheenColor ) * sheenAlbedo;
		diffuse *= sheenEnergyComp;
	#endif
	reflectedLight.indirectDiffuse += diffuse;
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness ) * RECIPROCAL_PI;
 	#endif
	vec3 singleScatteringDielectric = vec3( 0.0 );
	vec3 multiScatteringDielectric = vec3( 0.0 );
	vec3 singleScatteringMetallic = vec3( 0.0 );
	vec3 multiScatteringMetallic = vec3( 0.0 );
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnelDielectric, material.roughness, singleScatteringDielectric, multiScatteringDielectric );
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.diffuseColor, material.specularF90, material.iridescence, material.iridescenceFresnelMetallic, material.roughness, singleScatteringMetallic, multiScatteringMetallic );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScatteringDielectric, multiScatteringDielectric );
		computeMultiscattering( geometryNormal, geometryViewDir, material.diffuseColor, material.specularF90, material.roughness, singleScatteringMetallic, multiScatteringMetallic );
	#endif
	vec3 singleScattering = mix( singleScatteringDielectric, singleScatteringMetallic, material.metalness );
	vec3 multiScattering = mix( multiScatteringDielectric, multiScatteringMetallic, material.metalness );
	vec3 totalScatteringDielectric = singleScatteringDielectric + multiScatteringDielectric;
	vec3 diffuse = material.diffuseContribution * ( 1.0 - totalScatteringDielectric );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	vec3 indirectSpecular = radiance * singleScattering;
	indirectSpecular += multiScattering * cosineWeightedIrradiance;
	vec3 indirectDiffuse = diffuse * cosineWeightedIrradiance;
	#ifdef USE_SHEEN
		float sheenAlbedo = IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
		float sheenEnergyComp = 1.0 - max3( material.sheenColor ) * sheenAlbedo;
		indirectSpecular *= sheenEnergyComp;
		indirectDiffuse *= sheenEnergyComp;
	#endif
	reflectedLight.indirectSpecular += indirectSpecular;
	reflectedLight.indirectDiffuse += indirectDiffuse;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
  L8 = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnelDielectric = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceFresnelMetallic = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.diffuseColor );
		material.iridescenceFresnel = mix( material.iridescenceFresnelDielectric, material.iridescenceFresnelMetallic, material.metalness );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS ) && ( defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_BASIC ) )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
  N8 = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( ENVMAP_TYPE_CUBE_UV )
		#if defined( STANDARD ) || defined( LAMBERT ) || defined( PHONG )
			iblIrradiance += getIBLIrradiance( geometryNormal );
		#endif
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
  U8 = `#if defined( RE_IndirectDiffuse )
	#if defined( LAMBERT ) || defined( PHONG )
		irradiance += iblIrradiance;
	#endif
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,
  P8 = `#if defined( USE_LOGARITHMIC_DEPTH_BUFFER )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
  I8 = `#if defined( USE_LOGARITHMIC_DEPTH_BUFFER )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  O8 = `#ifdef USE_LOGARITHMIC_DEPTH_BUFFER
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  F8 = `#ifdef USE_LOGARITHMIC_DEPTH_BUFFER
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`,
  z8 = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
  B8 = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
  k8 = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
  V8 = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  G8 = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
  H8 = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
  j8 = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`,
  W8 = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
  X8 = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
  q8 = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`,
  Y8 = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
  Z8 = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,
  K8 = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
  Q8 = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  J8 = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  $8 = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
  eG = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,
  tG = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,
  nG = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,
  iG = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,
  rG = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
  sG = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
  aG = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	#ifdef USE_REVERSED_DEPTH_BUFFER
	
		return depth * ( far - near ) - far;
	#else
		return depth * ( near - far ) - near;
	#endif
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	
	#ifdef USE_REVERSED_DEPTH_BUFFER
		return ( near * far ) / ( ( near - far ) * depth - near );
	#else
		return ( near * far ) / ( ( far - near ) * depth - far );
	#endif
}`,
  oG = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
  lG = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
  cG = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
  uG = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
  fG = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
  hG = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
  dG = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#if defined( SHADOWMAP_TYPE_PCF )
			uniform sampler2DShadow directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		#else
			uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		#endif
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		#if defined( SHADOWMAP_TYPE_PCF )
			uniform sampler2DShadow spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		#else
			uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		#endif
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#if defined( SHADOWMAP_TYPE_PCF )
			uniform samplerCubeShadow pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		#elif defined( SHADOWMAP_TYPE_BASIC )
			uniform samplerCube pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		#endif
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	#if defined( SHADOWMAP_TYPE_PCF )
		float interleavedGradientNoise( vec2 position ) {
			return fract( 52.9829189 * fract( dot( position, vec2( 0.06711056, 0.00583715 ) ) ) );
		}
		vec2 vogelDiskSample( int sampleIndex, int samplesCount, float phi ) {
			const float goldenAngle = 2.399963229728653;
			float r = sqrt( ( float( sampleIndex ) + 0.5 ) / float( samplesCount ) );
			float theta = float( sampleIndex ) * goldenAngle + phi;
			return vec2( cos( theta ), sin( theta ) ) * r;
		}
	#endif
	#if defined( SHADOWMAP_TYPE_PCF )
		float getShadow( sampler2DShadow shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
			float shadow = 1.0;
			shadowCoord.xyz /= shadowCoord.w;
			shadowCoord.z += shadowBias;
			bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
			bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
			if ( frustumTest ) {
				vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
				float radius = shadowRadius * texelSize.x;
				float phi = interleavedGradientNoise( gl_FragCoord.xy ) * PI2;
				shadow = (
					texture( shadowMap, vec3( shadowCoord.xy + vogelDiskSample( 0, 5, phi ) * radius, shadowCoord.z ) ) +
					texture( shadowMap, vec3( shadowCoord.xy + vogelDiskSample( 1, 5, phi ) * radius, shadowCoord.z ) ) +
					texture( shadowMap, vec3( shadowCoord.xy + vogelDiskSample( 2, 5, phi ) * radius, shadowCoord.z ) ) +
					texture( shadowMap, vec3( shadowCoord.xy + vogelDiskSample( 3, 5, phi ) * radius, shadowCoord.z ) ) +
					texture( shadowMap, vec3( shadowCoord.xy + vogelDiskSample( 4, 5, phi ) * radius, shadowCoord.z ) )
				) * 0.2;
			}
			return mix( 1.0, shadow, shadowIntensity );
		}
	#elif defined( SHADOWMAP_TYPE_VSM )
		float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
			float shadow = 1.0;
			shadowCoord.xyz /= shadowCoord.w;
			#ifdef USE_REVERSED_DEPTH_BUFFER
				shadowCoord.z -= shadowBias;
			#else
				shadowCoord.z += shadowBias;
			#endif
			bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
			bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
			if ( frustumTest ) {
				vec2 distribution = texture2D( shadowMap, shadowCoord.xy ).rg;
				float mean = distribution.x;
				float variance = distribution.y * distribution.y;
				#ifdef USE_REVERSED_DEPTH_BUFFER
					float hard_shadow = step( mean, shadowCoord.z );
				#else
					float hard_shadow = step( shadowCoord.z, mean );
				#endif
				
				if ( hard_shadow == 1.0 ) {
					shadow = 1.0;
				} else {
					variance = max( variance, 0.0000001 );
					float d = shadowCoord.z - mean;
					float p_max = variance / ( variance + d * d );
					p_max = clamp( ( p_max - 0.3 ) / 0.65, 0.0, 1.0 );
					shadow = max( hard_shadow, p_max );
				}
			}
			return mix( 1.0, shadow, shadowIntensity );
		}
	#else
		float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
			float shadow = 1.0;
			shadowCoord.xyz /= shadowCoord.w;
			#ifdef USE_REVERSED_DEPTH_BUFFER
				shadowCoord.z -= shadowBias;
			#else
				shadowCoord.z += shadowBias;
			#endif
			bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
			bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
			if ( frustumTest ) {
				float depth = texture2D( shadowMap, shadowCoord.xy ).r;
				#ifdef USE_REVERSED_DEPTH_BUFFER
					shadow = step( depth, shadowCoord.z );
				#else
					shadow = step( shadowCoord.z, depth );
				#endif
			}
			return mix( 1.0, shadow, shadowIntensity );
		}
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#if defined( SHADOWMAP_TYPE_PCF )
	float getPointShadow( samplerCubeShadow shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		vec3 bd3D = normalize( lightToPosition );
		vec3 absVec = abs( lightToPosition );
		float viewSpaceZ = max( max( absVec.x, absVec.y ), absVec.z );
		if ( viewSpaceZ - shadowCameraFar <= 0.0 && viewSpaceZ - shadowCameraNear >= 0.0 ) {
			#ifdef USE_REVERSED_DEPTH_BUFFER
				float dp = ( shadowCameraNear * ( shadowCameraFar - viewSpaceZ ) ) / ( viewSpaceZ * ( shadowCameraFar - shadowCameraNear ) );
				dp -= shadowBias;
			#else
				float dp = ( shadowCameraFar * ( viewSpaceZ - shadowCameraNear ) ) / ( viewSpaceZ * ( shadowCameraFar - shadowCameraNear ) );
				dp += shadowBias;
			#endif
			float texelSize = shadowRadius / shadowMapSize.x;
			vec3 absDir = abs( bd3D );
			vec3 tangent = absDir.x > absDir.z ? vec3( 0.0, 1.0, 0.0 ) : vec3( 1.0, 0.0, 0.0 );
			tangent = normalize( cross( bd3D, tangent ) );
			vec3 bitangent = cross( bd3D, tangent );
			float phi = interleavedGradientNoise( gl_FragCoord.xy ) * PI2;
			vec2 sample0 = vogelDiskSample( 0, 5, phi );
			vec2 sample1 = vogelDiskSample( 1, 5, phi );
			vec2 sample2 = vogelDiskSample( 2, 5, phi );
			vec2 sample3 = vogelDiskSample( 3, 5, phi );
			vec2 sample4 = vogelDiskSample( 4, 5, phi );
			shadow = (
				texture( shadowMap, vec4( bd3D + ( tangent * sample0.x + bitangent * sample0.y ) * texelSize, dp ) ) +
				texture( shadowMap, vec4( bd3D + ( tangent * sample1.x + bitangent * sample1.y ) * texelSize, dp ) ) +
				texture( shadowMap, vec4( bd3D + ( tangent * sample2.x + bitangent * sample2.y ) * texelSize, dp ) ) +
				texture( shadowMap, vec4( bd3D + ( tangent * sample3.x + bitangent * sample3.y ) * texelSize, dp ) ) +
				texture( shadowMap, vec4( bd3D + ( tangent * sample4.x + bitangent * sample4.y ) * texelSize, dp ) )
			) * 0.2;
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	#elif defined( SHADOWMAP_TYPE_BASIC )
	float getPointShadow( samplerCube shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		vec3 absVec = abs( lightToPosition );
		float viewSpaceZ = max( max( absVec.x, absVec.y ), absVec.z );
		if ( viewSpaceZ - shadowCameraFar <= 0.0 && viewSpaceZ - shadowCameraNear >= 0.0 ) {
			float dp = ( shadowCameraFar * ( viewSpaceZ - shadowCameraNear ) ) / ( viewSpaceZ * ( shadowCameraFar - shadowCameraNear ) );
			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			float depth = textureCube( shadowMap, bd3D ).r;
			#ifdef USE_REVERSED_DEPTH_BUFFER
				depth = 1.0 - depth;
			#endif
			shadow = step( dp, depth );
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	#endif
	#endif
#endif`,
  pG = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
  mG = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
  gG = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0 && ( defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_BASIC ) )
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
  vG = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
  yG = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,
  xG = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
  bG = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
  _G = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
  SG = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
  MG = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
  TG = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
  EG = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseContribution, material.specularColorBlended, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,
  wG = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		#else
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,
  AG = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  CG = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  RG = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,
  DG = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const LG = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
  NG = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  UG = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  PG = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  IG = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  OG = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  FG = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
  zG = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	#ifdef USE_REVERSED_DEPTH_BUFFER
		float fragCoordZ = vHighPrecisionZW[ 0 ] / vHighPrecisionZW[ 1 ];
	#else
		float fragCoordZ = 0.5 * vHighPrecisionZW[ 0 ] / vHighPrecisionZW[ 1 ] + 0.5;
	#endif
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`,
  BG = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
  kG = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = vec4( dist, 0.0, 0.0, 1.0 );
}`,
  VG = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
  GG = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  HG = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  jG = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  WG = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
  XG = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  qG = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  YG = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  ZG = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
  KG = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  QG = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
  JG = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( normalize( normal ) * 0.5 + 0.5, diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
  $G = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  eH = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  tH = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
  nH = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
 
		outgoingLight = outgoingLight + sheenSpecularDirect + sheenSpecularIndirect;
 
 	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  iH = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  rH = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  sH = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
  aH = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  oH = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  lH = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  cH = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  uH = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  cn = {
    alphahash_fragment: NV,
    alphahash_pars_fragment: UV,
    alphamap_fragment: PV,
    alphamap_pars_fragment: IV,
    alphatest_fragment: OV,
    alphatest_pars_fragment: FV,
    aomap_fragment: zV,
    aomap_pars_fragment: BV,
    batching_pars_vertex: kV,
    batching_vertex: VV,
    begin_vertex: GV,
    beginnormal_vertex: HV,
    bsdfs: jV,
    iridescence_fragment: WV,
    bumpmap_pars_fragment: XV,
    clipping_planes_fragment: qV,
    clipping_planes_pars_fragment: YV,
    clipping_planes_pars_vertex: ZV,
    clipping_planes_vertex: KV,
    color_fragment: QV,
    color_pars_fragment: JV,
    color_pars_vertex: $V,
    color_vertex: e8,
    common: t8,
    cube_uv_reflection_fragment: n8,
    defaultnormal_vertex: i8,
    displacementmap_pars_vertex: r8,
    displacementmap_vertex: s8,
    emissivemap_fragment: a8,
    emissivemap_pars_fragment: o8,
    colorspace_fragment: l8,
    colorspace_pars_fragment: c8,
    envmap_fragment: u8,
    envmap_common_pars_fragment: f8,
    envmap_pars_fragment: h8,
    envmap_pars_vertex: d8,
    envmap_physical_pars_fragment: T8,
    envmap_vertex: p8,
    fog_vertex: m8,
    fog_pars_vertex: g8,
    fog_fragment: v8,
    fog_pars_fragment: y8,
    gradientmap_pars_fragment: x8,
    lightmap_pars_fragment: b8,
    lights_lambert_fragment: _8,
    lights_lambert_pars_fragment: S8,
    lights_pars_begin: M8,
    lights_toon_fragment: E8,
    lights_toon_pars_fragment: w8,
    lights_phong_fragment: A8,
    lights_phong_pars_fragment: C8,
    lights_physical_fragment: R8,
    lights_physical_pars_fragment: D8,
    lights_fragment_begin: L8,
    lights_fragment_maps: N8,
    lights_fragment_end: U8,
    logdepthbuf_fragment: P8,
    logdepthbuf_pars_fragment: I8,
    logdepthbuf_pars_vertex: O8,
    logdepthbuf_vertex: F8,
    map_fragment: z8,
    map_pars_fragment: B8,
    map_particle_fragment: k8,
    map_particle_pars_fragment: V8,
    metalnessmap_fragment: G8,
    metalnessmap_pars_fragment: H8,
    morphinstance_vertex: j8,
    morphcolor_vertex: W8,
    morphnormal_vertex: X8,
    morphtarget_pars_vertex: q8,
    morphtarget_vertex: Y8,
    normal_fragment_begin: Z8,
    normal_fragment_maps: K8,
    normal_pars_fragment: Q8,
    normal_pars_vertex: J8,
    normal_vertex: $8,
    normalmap_pars_fragment: eG,
    clearcoat_normal_fragment_begin: tG,
    clearcoat_normal_fragment_maps: nG,
    clearcoat_pars_fragment: iG,
    iridescence_pars_fragment: rG,
    opaque_fragment: sG,
    packing: aG,
    premultiplied_alpha_fragment: oG,
    project_vertex: lG,
    dithering_fragment: cG,
    dithering_pars_fragment: uG,
    roughnessmap_fragment: fG,
    roughnessmap_pars_fragment: hG,
    shadowmap_pars_fragment: dG,
    shadowmap_pars_vertex: pG,
    shadowmap_vertex: mG,
    shadowmask_pars_fragment: gG,
    skinbase_vertex: vG,
    skinning_pars_vertex: yG,
    skinning_vertex: xG,
    skinnormal_vertex: bG,
    specularmap_fragment: _G,
    specularmap_pars_fragment: SG,
    tonemapping_fragment: MG,
    tonemapping_pars_fragment: TG,
    transmission_fragment: EG,
    transmission_pars_fragment: wG,
    uv_pars_fragment: AG,
    uv_pars_vertex: CG,
    uv_vertex: RG,
    worldpos_vertex: DG,
    background_vert: LG,
    background_frag: NG,
    backgroundCube_vert: UG,
    backgroundCube_frag: PG,
    cube_vert: IG,
    cube_frag: OG,
    depth_vert: FG,
    depth_frag: zG,
    distance_vert: BG,
    distance_frag: kG,
    equirect_vert: VG,
    equirect_frag: GG,
    linedashed_vert: HG,
    linedashed_frag: jG,
    meshbasic_vert: WG,
    meshbasic_frag: XG,
    meshlambert_vert: qG,
    meshlambert_frag: YG,
    meshmatcap_vert: ZG,
    meshmatcap_frag: KG,
    meshnormal_vert: QG,
    meshnormal_frag: JG,
    meshphong_vert: $G,
    meshphong_frag: eH,
    meshphysical_vert: tH,
    meshphysical_frag: nH,
    meshtoon_vert: iH,
    meshtoon_frag: rH,
    points_vert: sH,
    points_frag: aH,
    shadow_vert: oH,
    shadow_frag: lH,
    sprite_vert: cH,
    sprite_frag: uH,
  },
  Et = {
    common: {
      diffuse: { value: new wt(16777215) },
      opacity: { value: 1 },
      map: { value: null },
      mapTransform: { value: new tn() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new tn() },
      alphaTest: { value: 0 },
    },
    specularmap: {
      specularMap: { value: null },
      specularMapTransform: { value: new tn() },
    },
    envmap: {
      envMap: { value: null },
      envMapRotation: { value: new tn() },
      flipEnvMap: { value: -1 },
      reflectivity: { value: 1 },
      ior: { value: 1.5 },
      refractionRatio: { value: 0.98 },
      dfgLUT: { value: null },
    },
    aomap: {
      aoMap: { value: null },
      aoMapIntensity: { value: 1 },
      aoMapTransform: { value: new tn() },
    },
    lightmap: {
      lightMap: { value: null },
      lightMapIntensity: { value: 1 },
      lightMapTransform: { value: new tn() },
    },
    bumpmap: {
      bumpMap: { value: null },
      bumpMapTransform: { value: new tn() },
      bumpScale: { value: 1 },
    },
    normalmap: {
      normalMap: { value: null },
      normalMapTransform: { value: new tn() },
      normalScale: { value: new nt(1, 1) },
    },
    displacementmap: {
      displacementMap: { value: null },
      displacementMapTransform: { value: new tn() },
      displacementScale: { value: 1 },
      displacementBias: { value: 0 },
    },
    emissivemap: {
      emissiveMap: { value: null },
      emissiveMapTransform: { value: new tn() },
    },
    metalnessmap: {
      metalnessMap: { value: null },
      metalnessMapTransform: { value: new tn() },
    },
    roughnessmap: {
      roughnessMap: { value: null },
      roughnessMapTransform: { value: new tn() },
    },
    gradientmap: { gradientMap: { value: null } },
    fog: {
      fogDensity: { value: 25e-5 },
      fogNear: { value: 1 },
      fogFar: { value: 2e3 },
      fogColor: { value: new wt(16777215) },
    },
    lights: {
      ambientLightColor: { value: [] },
      lightProbe: { value: [] },
      directionalLights: {
        value: [],
        properties: { direction: {}, color: {} },
      },
      directionalLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      directionalShadowMatrix: { value: [] },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {},
        },
      },
      spotLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      spotLightMap: { value: [] },
      spotLightMatrix: { value: [] },
      pointLights: {
        value: [],
        properties: { color: {}, position: {}, decay: {}, distance: {} },
      },
      pointLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {},
        },
      },
      pointShadowMatrix: { value: [] },
      hemisphereLights: {
        value: [],
        properties: { direction: {}, skyColor: {}, groundColor: {} },
      },
      rectAreaLights: {
        value: [],
        properties: { color: {}, position: {}, width: {}, height: {} },
      },
      ltc_1: { value: null },
      ltc_2: { value: null },
    },
    points: {
      diffuse: { value: new wt(16777215) },
      opacity: { value: 1 },
      size: { value: 1 },
      scale: { value: 1 },
      map: { value: null },
      alphaMap: { value: null },
      alphaMapTransform: { value: new tn() },
      alphaTest: { value: 0 },
      uvTransform: { value: new tn() },
    },
    sprite: {
      diffuse: { value: new wt(16777215) },
      opacity: { value: 1 },
      center: { value: new nt(0.5, 0.5) },
      rotation: { value: 0 },
      map: { value: null },
      mapTransform: { value: new tn() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new tn() },
      alphaTest: { value: 0 },
    },
  },
  Xo = {
    basic: {
      uniforms: zs([
        Et.common,
        Et.specularmap,
        Et.envmap,
        Et.aomap,
        Et.lightmap,
        Et.fog,
      ]),
      vertexShader: cn.meshbasic_vert,
      fragmentShader: cn.meshbasic_frag,
    },
    lambert: {
      uniforms: zs([
        Et.common,
        Et.specularmap,
        Et.envmap,
        Et.aomap,
        Et.lightmap,
        Et.emissivemap,
        Et.bumpmap,
        Et.normalmap,
        Et.displacementmap,
        Et.fog,
        Et.lights,
        { emissive: { value: new wt(0) }, envMapIntensity: { value: 1 } },
      ]),
      vertexShader: cn.meshlambert_vert,
      fragmentShader: cn.meshlambert_frag,
    },
    phong: {
      uniforms: zs([
        Et.common,
        Et.specularmap,
        Et.envmap,
        Et.aomap,
        Et.lightmap,
        Et.emissivemap,
        Et.bumpmap,
        Et.normalmap,
        Et.displacementmap,
        Et.fog,
        Et.lights,
        {
          emissive: { value: new wt(0) },
          specular: { value: new wt(1118481) },
          shininess: { value: 30 },
          envMapIntensity: { value: 1 },
        },
      ]),
      vertexShader: cn.meshphong_vert,
      fragmentShader: cn.meshphong_frag,
    },
    standard: {
      uniforms: zs([
        Et.common,
        Et.envmap,
        Et.aomap,
        Et.lightmap,
        Et.emissivemap,
        Et.bumpmap,
        Et.normalmap,
        Et.displacementmap,
        Et.roughnessmap,
        Et.metalnessmap,
        Et.fog,
        Et.lights,
        {
          emissive: { value: new wt(0) },
          roughness: { value: 1 },
          metalness: { value: 0 },
          envMapIntensity: { value: 1 },
        },
      ]),
      vertexShader: cn.meshphysical_vert,
      fragmentShader: cn.meshphysical_frag,
    },
    toon: {
      uniforms: zs([
        Et.common,
        Et.aomap,
        Et.lightmap,
        Et.emissivemap,
        Et.bumpmap,
        Et.normalmap,
        Et.displacementmap,
        Et.gradientmap,
        Et.fog,
        Et.lights,
        { emissive: { value: new wt(0) } },
      ]),
      vertexShader: cn.meshtoon_vert,
      fragmentShader: cn.meshtoon_frag,
    },
    matcap: {
      uniforms: zs([
        Et.common,
        Et.bumpmap,
        Et.normalmap,
        Et.displacementmap,
        Et.fog,
        { matcap: { value: null } },
      ]),
      vertexShader: cn.meshmatcap_vert,
      fragmentShader: cn.meshmatcap_frag,
    },
    points: {
      uniforms: zs([Et.points, Et.fog]),
      vertexShader: cn.points_vert,
      fragmentShader: cn.points_frag,
    },
    dashed: {
      uniforms: zs([
        Et.common,
        Et.fog,
        {
          scale: { value: 1 },
          dashSize: { value: 1 },
          totalSize: { value: 2 },
        },
      ]),
      vertexShader: cn.linedashed_vert,
      fragmentShader: cn.linedashed_frag,
    },
    depth: {
      uniforms: zs([Et.common, Et.displacementmap]),
      vertexShader: cn.depth_vert,
      fragmentShader: cn.depth_frag,
    },
    normal: {
      uniforms: zs([
        Et.common,
        Et.bumpmap,
        Et.normalmap,
        Et.displacementmap,
        { opacity: { value: 1 } },
      ]),
      vertexShader: cn.meshnormal_vert,
      fragmentShader: cn.meshnormal_frag,
    },
    sprite: {
      uniforms: zs([Et.sprite, Et.fog]),
      vertexShader: cn.sprite_vert,
      fragmentShader: cn.sprite_frag,
    },
    background: {
      uniforms: {
        uvTransform: { value: new tn() },
        t2D: { value: null },
        backgroundIntensity: { value: 1 },
      },
      vertexShader: cn.background_vert,
      fragmentShader: cn.background_frag,
    },
    backgroundCube: {
      uniforms: {
        envMap: { value: null },
        flipEnvMap: { value: -1 },
        backgroundBlurriness: { value: 0 },
        backgroundIntensity: { value: 1 },
        backgroundRotation: { value: new tn() },
      },
      vertexShader: cn.backgroundCube_vert,
      fragmentShader: cn.backgroundCube_frag,
    },
    cube: {
      uniforms: {
        tCube: { value: null },
        tFlip: { value: -1 },
        opacity: { value: 1 },
      },
      vertexShader: cn.cube_vert,
      fragmentShader: cn.cube_frag,
    },
    equirect: {
      uniforms: { tEquirect: { value: null } },
      vertexShader: cn.equirect_vert,
      fragmentShader: cn.equirect_frag,
    },
    distance: {
      uniforms: zs([
        Et.common,
        Et.displacementmap,
        {
          referencePosition: { value: new te() },
          nearDistance: { value: 1 },
          farDistance: { value: 1e3 },
        },
      ]),
      vertexShader: cn.distance_vert,
      fragmentShader: cn.distance_frag,
    },
    shadow: {
      uniforms: zs([
        Et.lights,
        Et.fog,
        { color: { value: new wt(0) }, opacity: { value: 1 } },
      ]),
      vertexShader: cn.shadow_vert,
      fragmentShader: cn.shadow_frag,
    },
  };
Xo.physical = {
  uniforms: zs([
    Xo.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: new tn() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: new tn() },
      clearcoatNormalScale: { value: new nt(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: new tn() },
      dispersion: { value: 0 },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: new tn() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: new tn() },
      sheen: { value: 0 },
      sheenColor: { value: new wt(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: new tn() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: new tn() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: new tn() },
      transmissionSamplerSize: { value: new nt() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: new tn() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: new wt(0) },
      specularColor: { value: new wt(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: new tn() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: new tn() },
      anisotropyVector: { value: new nt() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: new tn() },
    },
  ]),
  vertexShader: cn.meshphysical_vert,
  fragmentShader: cn.meshphysical_frag,
};
const cx = { r: 0, b: 0, g: 0 },
  uh = new Fa(),
  fH = new qt();
function hH(i, e, t, n, r, s) {
  const o = new wt(0);
  let u = r === !0 ? 0 : 1,
    h,
    d,
    m = null,
    v = 0,
    y = null;
  function b(C) {
    let R = C.isScene === !0 ? C.background : null;
    if (R && R.isTexture) {
      const L = C.backgroundBlurriness > 0;
      R = e.get(R, L);
    }
    return R;
  }
  function _(C) {
    let R = !1;
    const L = b(C);
    L === null ? E(o, u) : L && L.isColor && (E(L, 1), (R = !0));
    const I = i.xr.getEnvironmentBlendMode();
    (I === "additive"
      ? t.buffers.color.setClear(0, 0, 0, 1, s)
      : I === "alpha-blend" && t.buffers.color.setClear(0, 0, 0, 0, s),
      (i.autoClear || R) &&
        (t.buffers.depth.setTest(!0),
        t.buffers.depth.setMask(!0),
        t.buffers.color.setMask(!0),
        i.clear(i.autoClearColor, i.autoClearDepth, i.autoClearStencil)));
  }
  function w(C, R) {
    const L = b(R);
    L && (L.isCubeTexture || L.mapping === Bp)
      ? (d === void 0 &&
          ((d = new wi(
            new Fh(1, 1, 1),
            new ba({
              name: "BackgroundCubeMaterial",
              uniforms: Dp(Xo.backgroundCube.uniforms),
              vertexShader: Xo.backgroundCube.vertexShader,
              fragmentShader: Xo.backgroundCube.fragmentShader,
              side: js,
              depthTest: !1,
              depthWrite: !1,
              fog: !1,
              allowOverride: !1,
            }),
          )),
          d.geometry.deleteAttribute("normal"),
          d.geometry.deleteAttribute("uv"),
          (d.onBeforeRender = function (I, O, B) {
            this.matrixWorld.copyPosition(B.matrixWorld);
          }),
          Object.defineProperty(d.material, "envMap", {
            get: function () {
              return this.uniforms.envMap.value;
            },
          }),
          n.update(d)),
        uh.copy(R.backgroundRotation),
        (uh.x *= -1),
        (uh.y *= -1),
        (uh.z *= -1),
        L.isCubeTexture &&
          L.isRenderTargetTexture === !1 &&
          ((uh.y *= -1), (uh.z *= -1)),
        (d.material.uniforms.envMap.value = L),
        (d.material.uniforms.flipEnvMap.value =
          L.isCubeTexture && L.isRenderTargetTexture === !1 ? -1 : 1),
        (d.material.uniforms.backgroundBlurriness.value =
          R.backgroundBlurriness),
        (d.material.uniforms.backgroundIntensity.value = R.backgroundIntensity),
        d.material.uniforms.backgroundRotation.value.setFromMatrix4(
          fH.makeRotationFromEuler(uh),
        ),
        (d.material.toneMapped = Cn.getTransfer(L.colorSpace) !== Xn),
        (m !== L || v !== L.version || y !== i.toneMapping) &&
          ((d.material.needsUpdate = !0),
          (m = L),
          (v = L.version),
          (y = i.toneMapping)),
        d.layers.enableAll(),
        C.unshift(d, d.geometry, d.material, 0, 0, null))
      : L &&
        L.isTexture &&
        (h === void 0 &&
          ((h = new wi(
            new $c(2, 2),
            new ba({
              name: "BackgroundMaterial",
              uniforms: Dp(Xo.background.uniforms),
              vertexShader: Xo.background.vertexShader,
              fragmentShader: Xo.background.fragmentShader,
              side: Zc,
              depthTest: !1,
              depthWrite: !1,
              fog: !1,
              allowOverride: !1,
            }),
          )),
          h.geometry.deleteAttribute("normal"),
          Object.defineProperty(h.material, "map", {
            get: function () {
              return this.uniforms.t2D.value;
            },
          }),
          n.update(h)),
        (h.material.uniforms.t2D.value = L),
        (h.material.uniforms.backgroundIntensity.value = R.backgroundIntensity),
        (h.material.toneMapped = Cn.getTransfer(L.colorSpace) !== Xn),
        L.matrixAutoUpdate === !0 && L.updateMatrix(),
        h.material.uniforms.uvTransform.value.copy(L.matrix),
        (m !== L || v !== L.version || y !== i.toneMapping) &&
          ((h.material.needsUpdate = !0),
          (m = L),
          (v = L.version),
          (y = i.toneMapping)),
        h.layers.enableAll(),
        C.unshift(h, h.geometry, h.material, 0, 0, null));
  }
  function E(C, R) {
    (C.getRGB(cx, SN(i)), t.buffers.color.setClear(cx.r, cx.g, cx.b, R, s));
  }
  function T() {
    (d !== void 0 && (d.geometry.dispose(), d.material.dispose(), (d = void 0)),
      h !== void 0 &&
        (h.geometry.dispose(), h.material.dispose(), (h = void 0)));
  }
  return {
    getClearColor: function () {
      return o;
    },
    setClearColor: function (C, R = 1) {
      (o.set(C), (u = R), E(o, u));
    },
    getClearAlpha: function () {
      return u;
    },
    setClearAlpha: function (C) {
      ((u = C), E(o, u));
    },
    render: _,
    addToRenderList: w,
    dispose: T,
  };
}
function dH(i, e) {
  const t = i.getParameter(i.MAX_VERTEX_ATTRIBS),
    n = {},
    r = y(null);
  let s = r,
    o = !1;
  function u(q, X, J, ee, ne) {
    let W = !1;
    const $ = v(q, ee, J, X);
    (s !== $ && ((s = $), d(s.object)),
      (W = b(q, ee, J, ne)),
      W && _(q, ee, J, ne),
      ne !== null && e.update(ne, i.ELEMENT_ARRAY_BUFFER),
      (W || o) &&
        ((o = !1),
        L(q, X, J, ee),
        ne !== null && i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, e.get(ne).buffer)));
  }
  function h() {
    return i.createVertexArray();
  }
  function d(q) {
    return i.bindVertexArray(q);
  }
  function m(q) {
    return i.deleteVertexArray(q);
  }
  function v(q, X, J, ee) {
    const ne = ee.wireframe === !0;
    let W = n[X.id];
    W === void 0 && ((W = {}), (n[X.id] = W));
    const $ = q.isInstancedMesh === !0 ? q.id : 0;
    let de = W[$];
    de === void 0 && ((de = {}), (W[$] = de));
    let le = de[J.id];
    le === void 0 && ((le = {}), (de[J.id] = le));
    let fe = le[ne];
    return (fe === void 0 && ((fe = y(h())), (le[ne] = fe)), fe);
  }
  function y(q) {
    const X = [],
      J = [],
      ee = [];
    for (let ne = 0; ne < t; ne++) ((X[ne] = 0), (J[ne] = 0), (ee[ne] = 0));
    return {
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: X,
      enabledAttributes: J,
      attributeDivisors: ee,
      object: q,
      attributes: {},
      index: null,
    };
  }
  function b(q, X, J, ee) {
    const ne = s.attributes,
      W = X.attributes;
    let $ = 0;
    const de = J.getAttributes();
    for (const le in de)
      if (de[le].location >= 0) {
        const V = ne[le];
        let Z = W[le];
        if (
          (Z === void 0 &&
            (le === "instanceMatrix" &&
              q.instanceMatrix &&
              (Z = q.instanceMatrix),
            le === "instanceColor" && q.instanceColor && (Z = q.instanceColor)),
          V === void 0 || V.attribute !== Z || (Z && V.data !== Z.data))
        )
          return !0;
        $++;
      }
    return s.attributesNum !== $ || s.index !== ee;
  }
  function _(q, X, J, ee) {
    const ne = {},
      W = X.attributes;
    let $ = 0;
    const de = J.getAttributes();
    for (const le in de)
      if (de[le].location >= 0) {
        let V = W[le];
        V === void 0 &&
          (le === "instanceMatrix" &&
            q.instanceMatrix &&
            (V = q.instanceMatrix),
          le === "instanceColor" && q.instanceColor && (V = q.instanceColor));
        const Z = {};
        ((Z.attribute = V),
          V && V.data && (Z.data = V.data),
          (ne[le] = Z),
          $++);
      }
    ((s.attributes = ne), (s.attributesNum = $), (s.index = ee));
  }
  function w() {
    const q = s.newAttributes;
    for (let X = 0, J = q.length; X < J; X++) q[X] = 0;
  }
  function E(q) {
    T(q, 0);
  }
  function T(q, X) {
    const J = s.newAttributes,
      ee = s.enabledAttributes,
      ne = s.attributeDivisors;
    ((J[q] = 1),
      ee[q] === 0 && (i.enableVertexAttribArray(q), (ee[q] = 1)),
      ne[q] !== X && (i.vertexAttribDivisor(q, X), (ne[q] = X)));
  }
  function C() {
    const q = s.newAttributes,
      X = s.enabledAttributes;
    for (let J = 0, ee = X.length; J < ee; J++)
      X[J] !== q[J] && (i.disableVertexAttribArray(J), (X[J] = 0));
  }
  function R(q, X, J, ee, ne, W, $) {
    $ === !0
      ? i.vertexAttribIPointer(q, X, J, ne, W)
      : i.vertexAttribPointer(q, X, J, ee, ne, W);
  }
  function L(q, X, J, ee) {
    w();
    const ne = ee.attributes,
      W = J.getAttributes(),
      $ = X.defaultAttributeValues;
    for (const de in W) {
      const le = W[de];
      if (le.location >= 0) {
        let fe = ne[de];
        if (
          (fe === void 0 &&
            (de === "instanceMatrix" &&
              q.instanceMatrix &&
              (fe = q.instanceMatrix),
            de === "instanceColor" &&
              q.instanceColor &&
              (fe = q.instanceColor)),
          fe !== void 0)
        ) {
          const V = fe.normalized,
            Z = fe.itemSize,
            se = e.get(fe);
          if (se === void 0) continue;
          const ue = se.buffer,
            ge = se.type,
            ae = se.bytesPerElement,
            he = ge === i.INT || ge === i.UNSIGNED_INT || fe.gpuType === Q1;
          if (fe.isInterleavedBufferAttribute) {
            const ye = fe.data,
              ze = ye.stride,
              it = fe.offset;
            if (ye.isInstancedInterleavedBuffer) {
              for (let qe = 0; qe < le.locationSize; qe++)
                T(le.location + qe, ye.meshPerAttribute);
              q.isInstancedMesh !== !0 &&
                ee._maxInstanceCount === void 0 &&
                (ee._maxInstanceCount = ye.meshPerAttribute * ye.count);
            } else
              for (let qe = 0; qe < le.locationSize; qe++) E(le.location + qe);
            i.bindBuffer(i.ARRAY_BUFFER, ue);
            for (let qe = 0; qe < le.locationSize; qe++)
              R(
                le.location + qe,
                Z / le.locationSize,
                ge,
                V,
                ze * ae,
                (it + (Z / le.locationSize) * qe) * ae,
                he,
              );
          } else {
            if (fe.isInstancedBufferAttribute) {
              for (let ye = 0; ye < le.locationSize; ye++)
                T(le.location + ye, fe.meshPerAttribute);
              q.isInstancedMesh !== !0 &&
                ee._maxInstanceCount === void 0 &&
                (ee._maxInstanceCount = fe.meshPerAttribute * fe.count);
            } else
              for (let ye = 0; ye < le.locationSize; ye++) E(le.location + ye);
            i.bindBuffer(i.ARRAY_BUFFER, ue);
            for (let ye = 0; ye < le.locationSize; ye++)
              R(
                le.location + ye,
                Z / le.locationSize,
                ge,
                V,
                Z * ae,
                (Z / le.locationSize) * ye * ae,
                he,
              );
          }
        } else if ($ !== void 0) {
          const V = $[de];
          if (V !== void 0)
            switch (V.length) {
              case 2:
                i.vertexAttrib2fv(le.location, V);
                break;
              case 3:
                i.vertexAttrib3fv(le.location, V);
                break;
              case 4:
                i.vertexAttrib4fv(le.location, V);
                break;
              default:
                i.vertexAttrib1fv(le.location, V);
            }
        }
      }
    }
    C();
  }
  function I() {
    F();
    for (const q in n) {
      const X = n[q];
      for (const J in X) {
        const ee = X[J];
        for (const ne in ee) {
          const W = ee[ne];
          for (const $ in W) (m(W[$].object), delete W[$]);
          delete ee[ne];
        }
      }
      delete n[q];
    }
  }
  function O(q) {
    if (n[q.id] === void 0) return;
    const X = n[q.id];
    for (const J in X) {
      const ee = X[J];
      for (const ne in ee) {
        const W = ee[ne];
        for (const $ in W) (m(W[$].object), delete W[$]);
        delete ee[ne];
      }
    }
    delete n[q.id];
  }
  function B(q) {
    for (const X in n) {
      const J = n[X];
      for (const ee in J) {
        const ne = J[ee];
        if (ne[q.id] === void 0) continue;
        const W = ne[q.id];
        for (const $ in W) (m(W[$].object), delete W[$]);
        delete ne[q.id];
      }
    }
  }
  function N(q) {
    for (const X in n) {
      const J = n[X],
        ee = q.isInstancedMesh === !0 ? q.id : 0,
        ne = J[ee];
      if (ne !== void 0) {
        for (const W in ne) {
          const $ = ne[W];
          for (const de in $) (m($[de].object), delete $[de]);
          delete ne[W];
        }
        (delete J[ee], Object.keys(J).length === 0 && delete n[X]);
      }
    }
  }
  function F() {
    (j(), (o = !0), s !== r && ((s = r), d(s.object)));
  }
  function j() {
    ((r.geometry = null), (r.program = null), (r.wireframe = !1));
  }
  return {
    setup: u,
    reset: F,
    resetDefaultState: j,
    dispose: I,
    releaseStatesOfGeometry: O,
    releaseStatesOfObject: N,
    releaseStatesOfProgram: B,
    initAttributes: w,
    enableAttribute: E,
    disableUnusedAttributes: C,
  };
}
function pH(i, e, t) {
  let n;
  function r(d) {
    n = d;
  }
  function s(d, m) {
    (i.drawArrays(n, d, m), t.update(m, n, 1));
  }
  function o(d, m, v) {
    v !== 0 && (i.drawArraysInstanced(n, d, m, v), t.update(m, n, v));
  }
  function u(d, m, v) {
    if (v === 0) return;
    e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(n, d, 0, m, 0, v);
    let b = 0;
    for (let _ = 0; _ < v; _++) b += m[_];
    t.update(b, n, 1);
  }
  function h(d, m, v, y) {
    if (v === 0) return;
    const b = e.get("WEBGL_multi_draw");
    if (b === null) for (let _ = 0; _ < d.length; _++) o(d[_], m[_], y[_]);
    else {
      b.multiDrawArraysInstancedWEBGL(n, d, 0, m, 0, y, 0, v);
      let _ = 0;
      for (let w = 0; w < v; w++) _ += m[w] * y[w];
      t.update(_, n, 1);
    }
  }
  ((this.setMode = r),
    (this.render = s),
    (this.renderInstances = o),
    (this.renderMultiDraw = u),
    (this.renderMultiDrawInstances = h));
}
function mH(i, e, t, n) {
  let r;
  function s() {
    if (r !== void 0) return r;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const B = e.get("EXT_texture_filter_anisotropic");
      r = i.getParameter(B.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else r = 0;
    return r;
  }
  function o(B) {
    return !(
      B !== xs &&
      n.convert(B) !== i.getParameter(i.IMPLEMENTATION_COLOR_READ_FORMAT)
    );
  }
  function u(B) {
    const N =
      B === Kl &&
      (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
    return !(
      B !== Bs &&
      n.convert(B) !== i.getParameter(i.IMPLEMENTATION_COLOR_READ_TYPE) &&
      B !== Hs &&
      !N
    );
  }
  function h(B) {
    if (B === "highp") {
      if (
        i.getShaderPrecisionFormat(i.VERTEX_SHADER, i.HIGH_FLOAT).precision >
          0 &&
        i.getShaderPrecisionFormat(i.FRAGMENT_SHADER, i.HIGH_FLOAT).precision >
          0
      )
        return "highp";
      B = "mediump";
    }
    return B === "mediump" &&
      i.getShaderPrecisionFormat(i.VERTEX_SHADER, i.MEDIUM_FLOAT).precision >
        0 &&
      i.getShaderPrecisionFormat(i.FRAGMENT_SHADER, i.MEDIUM_FLOAT).precision >
        0
      ? "mediump"
      : "lowp";
  }
  let d = t.precision !== void 0 ? t.precision : "highp";
  const m = h(d);
  m !== d &&
    (Tt("WebGLRenderer:", d, "not supported, using", m, "instead."), (d = m));
  const v = t.logarithmicDepthBuffer === !0,
    y = t.reversedDepthBuffer === !0 && e.has("EXT_clip_control"),
    b = i.getParameter(i.MAX_TEXTURE_IMAGE_UNITS),
    _ = i.getParameter(i.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
    w = i.getParameter(i.MAX_TEXTURE_SIZE),
    E = i.getParameter(i.MAX_CUBE_MAP_TEXTURE_SIZE),
    T = i.getParameter(i.MAX_VERTEX_ATTRIBS),
    C = i.getParameter(i.MAX_VERTEX_UNIFORM_VECTORS),
    R = i.getParameter(i.MAX_VARYING_VECTORS),
    L = i.getParameter(i.MAX_FRAGMENT_UNIFORM_VECTORS),
    I = i.getParameter(i.MAX_SAMPLES),
    O = i.getParameter(i.SAMPLES);
  return {
    isWebGL2: !0,
    getMaxAnisotropy: s,
    getMaxPrecision: h,
    textureFormatReadable: o,
    textureTypeReadable: u,
    precision: d,
    logarithmicDepthBuffer: v,
    reversedDepthBuffer: y,
    maxTextures: b,
    maxVertexTextures: _,
    maxTextureSize: w,
    maxCubemapSize: E,
    maxAttributes: T,
    maxVertexUniforms: C,
    maxVaryings: R,
    maxFragmentUniforms: L,
    maxSamples: I,
    samples: O,
  };
}
function gH(i) {
  const e = this;
  let t = null,
    n = 0,
    r = !1,
    s = !1;
  const o = new Vc(),
    u = new tn(),
    h = { value: null, needsUpdate: !1 };
  ((this.uniform = h),
    (this.numPlanes = 0),
    (this.numIntersection = 0),
    (this.init = function (v, y) {
      const b = v.length !== 0 || y || n !== 0 || r;
      return ((r = y), (n = v.length), b);
    }),
    (this.beginShadows = function () {
      ((s = !0), m(null));
    }),
    (this.endShadows = function () {
      s = !1;
    }),
    (this.setGlobalState = function (v, y) {
      t = m(v, y, 0);
    }),
    (this.setState = function (v, y, b) {
      const _ = v.clippingPlanes,
        w = v.clipIntersection,
        E = v.clipShadows,
        T = i.get(v);
      if (!r || _ === null || _.length === 0 || (s && !E)) s ? m(null) : d();
      else {
        const C = s ? 0 : n,
          R = C * 4;
        let L = T.clippingState || null;
        ((h.value = L), (L = m(_, y, R, b)));
        for (let I = 0; I !== R; ++I) L[I] = t[I];
        ((T.clippingState = L),
          (this.numIntersection = w ? this.numPlanes : 0),
          (this.numPlanes += C));
      }
    }));
  function d() {
    (h.value !== t && ((h.value = t), (h.needsUpdate = n > 0)),
      (e.numPlanes = n),
      (e.numIntersection = 0));
  }
  function m(v, y, b, _) {
    const w = v !== null ? v.length : 0;
    let E = null;
    if (w !== 0) {
      if (((E = h.value), _ !== !0 || E === null)) {
        const T = b + w * 4,
          C = y.matrixWorldInverse;
        (u.getNormalMatrix(C),
          (E === null || E.length < T) && (E = new Float32Array(T)));
        for (let R = 0, L = b; R !== w; ++R, L += 4)
          (o.copy(v[R]).applyMatrix4(C, u),
            o.normal.toArray(E, L),
            (E[L + 3] = o.constant));
      }
      ((h.value = E), (h.needsUpdate = !0));
    }
    return ((e.numPlanes = w), (e.numIntersection = 0), E);
  }
}
const tf = 4,
  ZC = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
  vh = 20,
  vH = 256,
  Eg = new Wc(),
  KC = new wt();
let MS = null,
  TS = 0,
  ES = 0,
  wS = !1;
const yH = new te();
class UM {
  constructor(e) {
    ((this._renderer = e),
      (this._pingPongRenderTarget = null),
      (this._lodMax = 0),
      (this._cubeSize = 0),
      (this._sizeLods = []),
      (this._sigmas = []),
      (this._lodMeshes = []),
      (this._backgroundBox = null),
      (this._cubemapMaterial = null),
      (this._equirectMaterial = null),
      (this._blurMaterial = null),
      (this._ggxMaterial = null));
  }
  fromScene(e, t = 0, n = 0.1, r = 100, s = {}) {
    const { size: o = 256, position: u = yH } = s;
    ((MS = this._renderer.getRenderTarget()),
      (TS = this._renderer.getActiveCubeFace()),
      (ES = this._renderer.getActiveMipmapLevel()),
      (wS = this._renderer.xr.enabled),
      (this._renderer.xr.enabled = !1),
      this._setSize(o));
    const h = this._allocateTargets();
    return (
      (h.depthBuffer = !0),
      this._sceneToCubeUV(e, n, r, h, u),
      t > 0 && this._blur(h, 0, 0, t),
      this._applyPMREM(h),
      this._cleanup(h),
      h
    );
  }
  fromEquirectangular(e, t = null) {
    return this._fromTexture(e, t);
  }
  fromCubemap(e, t = null) {
    return this._fromTexture(e, t);
  }
  compileCubemapShader() {
    this._cubemapMaterial === null &&
      ((this._cubemapMaterial = $C()),
      this._compileMaterial(this._cubemapMaterial));
  }
  compileEquirectangularShader() {
    this._equirectMaterial === null &&
      ((this._equirectMaterial = JC()),
      this._compileMaterial(this._equirectMaterial));
  }
  dispose() {
    (this._dispose(),
      this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
      this._equirectMaterial !== null && this._equirectMaterial.dispose(),
      this._backgroundBox !== null &&
        (this._backgroundBox.geometry.dispose(),
        this._backgroundBox.material.dispose()));
  }
  _setSize(e) {
    ((this._lodMax = Math.floor(Math.log2(e))),
      (this._cubeSize = Math.pow(2, this._lodMax)));
  }
  _dispose() {
    (this._blurMaterial !== null && this._blurMaterial.dispose(),
      this._ggxMaterial !== null && this._ggxMaterial.dispose(),
      this._pingPongRenderTarget !== null &&
        this._pingPongRenderTarget.dispose());
    for (let e = 0; e < this._lodMeshes.length; e++)
      this._lodMeshes[e].geometry.dispose();
  }
  _cleanup(e) {
    (this._renderer.setRenderTarget(MS, TS, ES),
      (this._renderer.xr.enabled = wS),
      (e.scissorTest = !1),
      ap(e, 0, 0, e.width, e.height));
  }
  _fromTexture(e, t) {
    (e.mapping === Zl || e.mapping === sf
      ? this._setSize(
          e.image.length === 0
            ? 16
            : e.image[0].width || e.image[0].image.width,
        )
      : this._setSize(e.image.width / 4),
      (MS = this._renderer.getRenderTarget()),
      (TS = this._renderer.getActiveCubeFace()),
      (ES = this._renderer.getActiveMipmapLevel()),
      (wS = this._renderer.xr.enabled),
      (this._renderer.xr.enabled = !1));
    const n = t || this._allocateTargets();
    return (
      this._textureToCubeUV(e, n),
      this._applyPMREM(n),
      this._cleanup(n),
      n
    );
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112),
      t = 4 * this._cubeSize,
      n = {
        magFilter: ni,
        minFilter: ni,
        generateMipmaps: !1,
        type: Kl,
        format: xs,
        colorSpace: af,
        depthBuffer: !1,
      },
      r = QC(e, t, n);
    if (
      this._pingPongRenderTarget === null ||
      this._pingPongRenderTarget.width !== e ||
      this._pingPongRenderTarget.height !== t
    ) {
      (this._pingPongRenderTarget !== null && this._dispose(),
        (this._pingPongRenderTarget = QC(e, t, n)));
      const { _lodMax: s } = this;
      (({
        lodMeshes: this._lodMeshes,
        sizeLods: this._sizeLods,
        sigmas: this._sigmas,
      } = xH(s)),
        (this._blurMaterial = _H(s, e, t)),
        (this._ggxMaterial = bH(s, e, t)));
    }
    return r;
  }
  _compileMaterial(e) {
    const t = new wi(new nn(), e);
    this._renderer.compile(t, Eg);
  }
  _sceneToCubeUV(e, t, n, r, s) {
    const h = new ir(90, 1, t, n),
      d = [1, -1, 1, 1, 1, 1],
      m = [1, 1, 1, -1, -1, -1],
      v = this._renderer,
      y = v.autoClear,
      b = v.toneMapping;
    (v.getClearColor(KC),
      (v.toneMapping = xo),
      (v.autoClear = !1),
      v.state.buffers.depth.getReversed() &&
        (v.setRenderTarget(r), v.clearDepth(), v.setRenderTarget(null)),
      this._backgroundBox === null &&
        (this._backgroundBox = new wi(
          new Fh(),
          new Jc({
            name: "PMREM.Background",
            side: js,
            depthWrite: !1,
            depthTest: !1,
          }),
        )));
    const w = this._backgroundBox,
      E = w.material;
    let T = !1;
    const C = e.background;
    C
      ? C.isColor && (E.color.copy(C), (e.background = null), (T = !0))
      : (E.color.copy(KC), (T = !0));
    for (let R = 0; R < 6; R++) {
      const L = R % 3;
      L === 0
        ? (h.up.set(0, d[R], 0),
          h.position.set(s.x, s.y, s.z),
          h.lookAt(s.x + m[R], s.y, s.z))
        : L === 1
          ? (h.up.set(0, 0, d[R]),
            h.position.set(s.x, s.y, s.z),
            h.lookAt(s.x, s.y + m[R], s.z))
          : (h.up.set(0, d[R], 0),
            h.position.set(s.x, s.y, s.z),
            h.lookAt(s.x, s.y, s.z + m[R]));
      const I = this._cubeSize;
      (ap(r, L * I, R > 2 ? I : 0, I, I),
        v.setRenderTarget(r),
        T && v.render(w, h),
        v.render(e, h));
    }
    ((v.toneMapping = b), (v.autoClear = y), (e.background = C));
  }
  _textureToCubeUV(e, t) {
    const n = this._renderer,
      r = e.mapping === Zl || e.mapping === sf;
    r
      ? (this._cubemapMaterial === null && (this._cubemapMaterial = $C()),
        (this._cubemapMaterial.uniforms.flipEnvMap.value =
          e.isRenderTargetTexture === !1 ? -1 : 1))
      : this._equirectMaterial === null && (this._equirectMaterial = JC());
    const s = r ? this._cubemapMaterial : this._equirectMaterial,
      o = this._lodMeshes[0];
    o.material = s;
    const u = s.uniforms;
    u.envMap.value = e;
    const h = this._cubeSize;
    (ap(t, 0, 0, 3 * h, 2 * h), n.setRenderTarget(t), n.render(o, Eg));
  }
  _applyPMREM(e) {
    const t = this._renderer,
      n = t.autoClear;
    t.autoClear = !1;
    const r = this._lodMeshes.length;
    for (let s = 1; s < r; s++) this._applyGGXFilter(e, s - 1, s);
    t.autoClear = n;
  }
  _applyGGXFilter(e, t, n) {
    const r = this._renderer,
      s = this._pingPongRenderTarget,
      o = this._ggxMaterial,
      u = this._lodMeshes[n];
    u.material = o;
    const h = o.uniforms,
      d = n / (this._lodMeshes.length - 1),
      m = t / (this._lodMeshes.length - 1),
      v = Math.sqrt(d * d - m * m),
      y = 0 + d * 1.25,
      b = v * y,
      { _lodMax: _ } = this,
      w = this._sizeLods[n],
      E = 3 * w * (n > _ - tf ? n - _ + tf : 0),
      T = 4 * (this._cubeSize - w);
    ((h.envMap.value = e.texture),
      (h.roughness.value = b),
      (h.mipInt.value = _ - t),
      ap(s, E, T, 3 * w, 2 * w),
      r.setRenderTarget(s),
      r.render(u, Eg),
      (h.envMap.value = s.texture),
      (h.roughness.value = 0),
      (h.mipInt.value = _ - n),
      ap(e, E, T, 3 * w, 2 * w),
      r.setRenderTarget(e),
      r.render(u, Eg));
  }
  _blur(e, t, n, r, s) {
    const o = this._pingPongRenderTarget;
    (this._halfBlur(e, o, t, n, r, "latitudinal", s),
      this._halfBlur(o, e, n, n, r, "longitudinal", s));
  }
  _halfBlur(e, t, n, r, s, o, u) {
    const h = this._renderer,
      d = this._blurMaterial;
    o !== "latitudinal" &&
      o !== "longitudinal" &&
      Ft("blur direction must be either latitudinal or longitudinal!");
    const m = 3,
      v = this._lodMeshes[r];
    v.material = d;
    const y = d.uniforms,
      b = this._sizeLods[n] - 1,
      _ = isFinite(s) ? Math.PI / (2 * b) : (2 * Math.PI) / (2 * vh - 1),
      w = s / _,
      E = isFinite(s) ? 1 + Math.floor(m * w) : vh;
    E > vh &&
      Tt(
        `sigmaRadians, ${s}, is too large and will clip, as it requested ${E} samples when the maximum is set to ${vh}`,
      );
    const T = [];
    let C = 0;
    for (let B = 0; B < vh; ++B) {
      const N = B / w,
        F = Math.exp((-N * N) / 2);
      (T.push(F), B === 0 ? (C += F) : B < E && (C += 2 * F));
    }
    for (let B = 0; B < T.length; B++) T[B] = T[B] / C;
    ((y.envMap.value = e.texture),
      (y.samples.value = E),
      (y.weights.value = T),
      (y.latitudinal.value = o === "latitudinal"),
      u && (y.poleAxis.value = u));
    const { _lodMax: R } = this;
    ((y.dTheta.value = _), (y.mipInt.value = R - n));
    const L = this._sizeLods[r],
      I = 3 * L * (r > R - tf ? r - R + tf : 0),
      O = 4 * (this._cubeSize - L);
    (ap(t, I, O, 3 * L, 2 * L), h.setRenderTarget(t), h.render(v, Eg));
  }
}
function xH(i) {
  const e = [],
    t = [],
    n = [];
  let r = i;
  const s = i - tf + 1 + ZC.length;
  for (let o = 0; o < s; o++) {
    const u = Math.pow(2, r);
    e.push(u);
    let h = 1 / u;
    (o > i - tf ? (h = ZC[o - i + tf - 1]) : o === 0 && (h = 0), t.push(h));
    const d = 1 / (u - 2),
      m = -d,
      v = 1 + d,
      y = [m, m, v, m, v, v, m, m, v, v, m, v],
      b = 6,
      _ = 6,
      w = 3,
      E = 2,
      T = 1,
      C = new Float32Array(w * _ * b),
      R = new Float32Array(E * _ * b),
      L = new Float32Array(T * _ * b);
    for (let O = 0; O < b; O++) {
      const B = ((O % 3) * 2) / 3 - 1,
        N = O > 2 ? 0 : -1,
        F = [
          B,
          N,
          0,
          B + 2 / 3,
          N,
          0,
          B + 2 / 3,
          N + 1,
          0,
          B,
          N,
          0,
          B + 2 / 3,
          N + 1,
          0,
          B,
          N + 1,
          0,
        ];
      (C.set(F, w * _ * O), R.set(y, E * _ * O));
      const j = [O, O, O, O, O, O];
      L.set(j, T * _ * O);
    }
    const I = new nn();
    (I.setAttribute("position", new $n(C, w)),
      I.setAttribute("uv", new $n(R, E)),
      I.setAttribute("faceIndex", new $n(L, T)),
      n.push(new wi(I, null)),
      r > tf && r--);
  }
  return { lodMeshes: n, sizeLods: e, sigmas: t };
}
function QC(i, e, t) {
  const n = new Oa(i, e, t);
  return (
    (n.texture.mapping = Bp),
    (n.texture.name = "PMREM.cubeUv"),
    (n.scissorTest = !0),
    n
  );
}
function ap(i, e, t, n, r) {
  (i.viewport.set(e, t, n, r), i.scissor.set(e, t, n, r));
}
function bH(i, e, t) {
  return new ba({
    name: "PMREMGGXConvolution",
    defines: {
      GGX_SAMPLES: vH,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / t,
      CUBEUV_MAX_MIP: `${i}.0`,
    },
    uniforms: {
      envMap: { value: null },
      roughness: { value: 0 },
      mipInt: { value: 0 },
    },
    vertexShader: Nb(),
    fragmentShader: `

			precision highp float;
			precision highp int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform float roughness;
			uniform float mipInt;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			#define PI 3.14159265359

			// Van der Corput radical inverse
			float radicalInverse_VdC(uint bits) {
				bits = (bits << 16u) | (bits >> 16u);
				bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
				bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
				bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
				bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
				return float(bits) * 2.3283064365386963e-10; // / 0x100000000
			}

			// Hammersley sequence
			vec2 hammersley(uint i, uint N) {
				return vec2(float(i) / float(N), radicalInverse_VdC(i));
			}

			// GGX VNDF importance sampling (Eric Heitz 2018)
			// "Sampling the GGX Distribution of Visible Normals"
			// https://jcgt.org/published/0007/04/01/
			vec3 importanceSampleGGX_VNDF(vec2 Xi, vec3 V, float roughness) {
				float alpha = roughness * roughness;

				// Section 4.1: Orthonormal basis
				vec3 T1 = vec3(1.0, 0.0, 0.0);
				vec3 T2 = cross(V, T1);

				// Section 4.2: Parameterization of projected area
				float r = sqrt(Xi.x);
				float phi = 2.0 * PI * Xi.y;
				float t1 = r * cos(phi);
				float t2 = r * sin(phi);
				float s = 0.5 * (1.0 + V.z);
				t2 = (1.0 - s) * sqrt(1.0 - t1 * t1) + s * t2;

				// Section 4.3: Reprojection onto hemisphere
				vec3 Nh = t1 * T1 + t2 * T2 + sqrt(max(0.0, 1.0 - t1 * t1 - t2 * t2)) * V;

				// Section 3.4: Transform back to ellipsoid configuration
				return normalize(vec3(alpha * Nh.x, alpha * Nh.y, max(0.0, Nh.z)));
			}

			void main() {
				vec3 N = normalize(vOutputDirection);
				vec3 V = N; // Assume view direction equals normal for pre-filtering

				vec3 prefilteredColor = vec3(0.0);
				float totalWeight = 0.0;

				// For very low roughness, just sample the environment directly
				if (roughness < 0.001) {
					gl_FragColor = vec4(bilinearCubeUV(envMap, N, mipInt), 1.0);
					return;
				}

				// Tangent space basis for VNDF sampling
				vec3 up = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);
				vec3 tangent = normalize(cross(up, N));
				vec3 bitangent = cross(N, tangent);

				for(uint i = 0u; i < uint(GGX_SAMPLES); i++) {
					vec2 Xi = hammersley(i, uint(GGX_SAMPLES));

					// For PMREM, V = N, so in tangent space V is always (0, 0, 1)
					vec3 H_tangent = importanceSampleGGX_VNDF(Xi, vec3(0.0, 0.0, 1.0), roughness);

					// Transform H back to world space
					vec3 H = normalize(tangent * H_tangent.x + bitangent * H_tangent.y + N * H_tangent.z);
					vec3 L = normalize(2.0 * dot(V, H) * H - V);

					float NdotL = max(dot(N, L), 0.0);

					if(NdotL > 0.0) {
						// Sample environment at fixed mip level
						// VNDF importance sampling handles the distribution filtering
						vec3 sampleColor = bilinearCubeUV(envMap, L, mipInt);

						// Weight by NdotL for the split-sum approximation
						// VNDF PDF naturally accounts for the visible microfacet distribution
						prefilteredColor += sampleColor * NdotL;
						totalWeight += NdotL;
					}
				}

				if (totalWeight > 0.0) {
					prefilteredColor = prefilteredColor / totalWeight;
				}

				gl_FragColor = vec4(prefilteredColor, 1.0);
			}
		`,
    blending: ql,
    depthTest: !1,
    depthWrite: !1,
  });
}
function _H(i, e, t) {
  const n = new Float32Array(vh),
    r = new te(0, 1, 0);
  return new ba({
    name: "SphericalGaussianBlur",
    defines: {
      n: vh,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / t,
      CUBEUV_MAX_MIP: `${i}.0`,
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: n },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: r },
    },
    vertexShader: Nb(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
    blending: ql,
    depthTest: !1,
    depthWrite: !1,
  });
}
function JC() {
  return new ba({
    name: "EquirectangularToCubeUV",
    uniforms: { envMap: { value: null } },
    vertexShader: Nb(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
    blending: ql,
    depthTest: !1,
    depthWrite: !1,
  });
}
function $C() {
  return new ba({
    name: "CubemapToCubeUV",
    uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
    vertexShader: Nb(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
    blending: ql,
    depthTest: !1,
    depthWrite: !1,
  });
}
function Nb() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
class bE extends Oa {
  constructor(e = 1, t = {}) {
    (super(e, e, t), (this.isWebGLCubeRenderTarget = !0));
    const n = { width: e, height: e, depth: 1 },
      r = [n, n, n, n, n, n];
    ((this.texture = new N0(r)),
      this._setTextureOptions(t),
      (this.texture.isRenderTargetTexture = !0));
  }
  fromEquirectangularTexture(e, t) {
    ((this.texture.type = t.type),
      (this.texture.colorSpace = t.colorSpace),
      (this.texture.generateMipmaps = t.generateMipmaps),
      (this.texture.minFilter = t.minFilter),
      (this.texture.magFilter = t.magFilter));
    const n = {
        uniforms: { tEquirect: { value: null } },
        vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
        fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
      },
      r = new Fh(5, 5, 5),
      s = new ba({
        name: "CubemapFromEquirect",
        uniforms: Dp(n.uniforms),
        vertexShader: n.vertexShader,
        fragmentShader: n.fragmentShader,
        side: js,
        blending: ql,
      });
    s.uniforms.tEquirect.value = t;
    const o = new wi(r, s),
      u = t.minFilter;
    return (
      t.minFilter === Hl && (t.minFilter = ni),
      new HN(1, 10, this).update(e, o),
      (t.minFilter = u),
      o.geometry.dispose(),
      o.material.dispose(),
      this
    );
  }
  clear(e, t = !0, n = !0, r = !0) {
    const s = e.getRenderTarget();
    for (let o = 0; o < 6; o++) (e.setRenderTarget(this, o), e.clear(t, n, r));
    e.setRenderTarget(s);
  }
}
function SH(i) {
  let e = new WeakMap(),
    t = new WeakMap(),
    n = null;
  function r(y, b = !1) {
    return y == null ? null : b ? o(y) : s(y);
  }
  function s(y) {
    if (y && y.isTexture) {
      const b = y.mapping;
      if (b === zg || b === Bg)
        if (e.has(y)) {
          const _ = e.get(y).texture;
          return u(_, y.mapping);
        } else {
          const _ = y.image;
          if (_ && _.height > 0) {
            const w = new bE(_.height);
            return (
              w.fromEquirectangularTexture(i, y),
              e.set(y, w),
              y.addEventListener("dispose", d),
              u(w.texture, y.mapping)
            );
          } else return null;
        }
    }
    return y;
  }
  function o(y) {
    if (y && y.isTexture) {
      const b = y.mapping,
        _ = b === zg || b === Bg,
        w = b === Zl || b === sf;
      if (_ || w) {
        let E = t.get(y);
        const T = E !== void 0 ? E.texture.pmremVersion : 0;
        if (y.isRenderTargetTexture && y.pmremVersion !== T)
          return (
            n === null && (n = new UM(i)),
            (E = _ ? n.fromEquirectangular(y, E) : n.fromCubemap(y, E)),
            (E.texture.pmremVersion = y.pmremVersion),
            t.set(y, E),
            E.texture
          );
        if (E !== void 0) return E.texture;
        {
          const C = y.image;
          return (_ && C && C.height > 0) || (w && C && h(C))
            ? (n === null && (n = new UM(i)),
              (E = _ ? n.fromEquirectangular(y) : n.fromCubemap(y)),
              (E.texture.pmremVersion = y.pmremVersion),
              t.set(y, E),
              y.addEventListener("dispose", m),
              E.texture)
            : null;
        }
      }
    }
    return y;
  }
  function u(y, b) {
    return (b === zg ? (y.mapping = Zl) : b === Bg && (y.mapping = sf), y);
  }
  function h(y) {
    let b = 0;
    const _ = 6;
    for (let w = 0; w < _; w++) y[w] !== void 0 && b++;
    return b === _;
  }
  function d(y) {
    const b = y.target;
    b.removeEventListener("dispose", d);
    const _ = e.get(b);
    _ !== void 0 && (e.delete(b), _.dispose());
  }
  function m(y) {
    const b = y.target;
    b.removeEventListener("dispose", m);
    const _ = t.get(b);
    _ !== void 0 && (t.delete(b), _.dispose());
  }
  function v() {
    ((e = new WeakMap()),
      (t = new WeakMap()),
      n !== null && (n.dispose(), (n = null)));
  }
  return { get: r, dispose: v };
}
function MH(i) {
  const e = {};
  function t(n) {
    if (e[n] !== void 0) return e[n];
    const r = i.getExtension(n);
    return ((e[n] = r), r);
  }
  return {
    has: function (n) {
      return t(n) !== null;
    },
    init: function () {
      (t("EXT_color_buffer_float"),
        t("WEBGL_clip_cull_distance"),
        t("OES_texture_float_linear"),
        t("EXT_color_buffer_half_float"),
        t("WEBGL_multisampled_render_to_texture"),
        t("WEBGL_render_shared_exponent"));
    },
    get: function (n) {
      const r = t(n);
      return (
        r === null && h0("WebGLRenderer: " + n + " extension not supported."),
        r
      );
    },
  };
}
function TH(i, e, t, n) {
  const r = {},
    s = new WeakMap();
  function o(v) {
    const y = v.target;
    y.index !== null && e.remove(y.index);
    for (const _ in y.attributes) e.remove(y.attributes[_]);
    (y.removeEventListener("dispose", o), delete r[y.id]);
    const b = s.get(y);
    (b && (e.remove(b), s.delete(y)),
      n.releaseStatesOfGeometry(y),
      y.isInstancedBufferGeometry === !0 && delete y._maxInstanceCount,
      t.memory.geometries--);
  }
  function u(v, y) {
    return (
      r[y.id] === !0 ||
        (y.addEventListener("dispose", o),
        (r[y.id] = !0),
        t.memory.geometries++),
      y
    );
  }
  function h(v) {
    const y = v.attributes;
    for (const b in y) e.update(y[b], i.ARRAY_BUFFER);
  }
  function d(v) {
    const y = [],
      b = v.index,
      _ = v.attributes.position;
    let w = 0;
    if (_ === void 0) return;
    if (b !== null) {
      const C = b.array;
      w = b.version;
      for (let R = 0, L = C.length; R < L; R += 3) {
        const I = C[R + 0],
          O = C[R + 1],
          B = C[R + 2];
        y.push(I, O, O, B, B, I);
      }
    } else {
      const C = _.array;
      w = _.version;
      for (let R = 0, L = C.length / 3 - 1; R < L; R += 3) {
        const I = R + 0,
          O = R + 1,
          B = R + 2;
        y.push(I, O, O, B, B, I);
      }
    }
    const E = new (_.count >= 65535 ? YT : qT)(y, 1);
    E.version = w;
    const T = s.get(v);
    (T && e.remove(T), s.set(v, E));
  }
  function m(v) {
    const y = s.get(v);
    if (y) {
      const b = v.index;
      b !== null && y.version < b.version && d(v);
    } else d(v);
    return s.get(v);
  }
  return { get: u, update: h, getWireframeAttribute: m };
}
function EH(i, e, t) {
  let n;
  function r(y) {
    n = y;
  }
  let s, o;
  function u(y) {
    ((s = y.type), (o = y.bytesPerElement));
  }
  function h(y, b) {
    (i.drawElements(n, b, s, y * o), t.update(b, n, 1));
  }
  function d(y, b, _) {
    _ !== 0 && (i.drawElementsInstanced(n, b, s, y * o, _), t.update(b, n, _));
  }
  function m(y, b, _) {
    if (_ === 0) return;
    e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(n, b, 0, s, y, 0, _);
    let E = 0;
    for (let T = 0; T < _; T++) E += b[T];
    t.update(E, n, 1);
  }
  function v(y, b, _, w) {
    if (_ === 0) return;
    const E = e.get("WEBGL_multi_draw");
    if (E === null) for (let T = 0; T < y.length; T++) d(y[T] / o, b[T], w[T]);
    else {
      E.multiDrawElementsInstancedWEBGL(n, b, 0, s, y, 0, w, 0, _);
      let T = 0;
      for (let C = 0; C < _; C++) T += b[C] * w[C];
      t.update(T, n, 1);
    }
  }
  ((this.setMode = r),
    (this.setIndex = u),
    (this.render = h),
    (this.renderInstances = d),
    (this.renderMultiDraw = m),
    (this.renderMultiDrawInstances = v));
}
function wH(i) {
  const e = { geometries: 0, textures: 0 },
    t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
  function n(s, o, u) {
    switch ((t.calls++, o)) {
      case i.TRIANGLES:
        t.triangles += u * (s / 3);
        break;
      case i.LINES:
        t.lines += u * (s / 2);
        break;
      case i.LINE_STRIP:
        t.lines += u * (s - 1);
        break;
      case i.LINE_LOOP:
        t.lines += u * s;
        break;
      case i.POINTS:
        t.points += u * s;
        break;
      default:
        Ft("WebGLInfo: Unknown draw mode:", o);
        break;
    }
  }
  function r() {
    ((t.calls = 0), (t.triangles = 0), (t.points = 0), (t.lines = 0));
  }
  return {
    memory: e,
    render: t,
    programs: null,
    autoReset: !0,
    reset: r,
    update: n,
  };
}
function AH(i, e, t) {
  const n = new WeakMap(),
    r = new Dn();
  function s(o, u, h) {
    const d = o.morphTargetInfluences,
      m =
        u.morphAttributes.position ||
        u.morphAttributes.normal ||
        u.morphAttributes.color,
      v = m !== void 0 ? m.length : 0;
    let y = n.get(u);
    if (y === void 0 || y.count !== v) {
      let j = function () {
        (N.dispose(), n.delete(u), u.removeEventListener("dispose", j));
      };
      var b = j;
      y !== void 0 && y.texture.dispose();
      const _ = u.morphAttributes.position !== void 0,
        w = u.morphAttributes.normal !== void 0,
        E = u.morphAttributes.color !== void 0,
        T = u.morphAttributes.position || [],
        C = u.morphAttributes.normal || [],
        R = u.morphAttributes.color || [];
      let L = 0;
      (_ === !0 && (L = 1), w === !0 && (L = 2), E === !0 && (L = 3));
      let I = u.attributes.position.count * L,
        O = 1;
      I > e.maxTextureSize &&
        ((O = Math.ceil(I / e.maxTextureSize)), (I = e.maxTextureSize));
      const B = new Float32Array(I * O * 4 * v),
        N = new ab(B, I, O, v);
      ((N.type = Hs), (N.needsUpdate = !0));
      const F = L * 4;
      for (let q = 0; q < v; q++) {
        const X = T[q],
          J = C[q],
          ee = R[q],
          ne = I * O * 4 * q;
        for (let W = 0; W < X.count; W++) {
          const $ = W * F;
          (_ === !0 &&
            (r.fromBufferAttribute(X, W),
            (B[ne + $ + 0] = r.x),
            (B[ne + $ + 1] = r.y),
            (B[ne + $ + 2] = r.z),
            (B[ne + $ + 3] = 0)),
            w === !0 &&
              (r.fromBufferAttribute(J, W),
              (B[ne + $ + 4] = r.x),
              (B[ne + $ + 5] = r.y),
              (B[ne + $ + 6] = r.z),
              (B[ne + $ + 7] = 0)),
            E === !0 &&
              (r.fromBufferAttribute(ee, W),
              (B[ne + $ + 8] = r.x),
              (B[ne + $ + 9] = r.y),
              (B[ne + $ + 10] = r.z),
              (B[ne + $ + 11] = ee.itemSize === 4 ? r.w : 1)));
        }
      }
      ((y = { count: v, texture: N, size: new nt(I, O) }),
        n.set(u, y),
        u.addEventListener("dispose", j));
    }
    if (o.isInstancedMesh === !0 && o.morphTexture !== null)
      h.getUniforms().setValue(i, "morphTexture", o.morphTexture, t);
    else {
      let _ = 0;
      for (let E = 0; E < d.length; E++) _ += d[E];
      const w = u.morphTargetsRelative ? 1 : 1 - _;
      (h.getUniforms().setValue(i, "morphTargetBaseInfluence", w),
        h.getUniforms().setValue(i, "morphTargetInfluences", d));
    }
    (h.getUniforms().setValue(i, "morphTargetsTexture", y.texture, t),
      h.getUniforms().setValue(i, "morphTargetsTextureSize", y.size));
  }
  return { update: s };
}
function CH(i, e, t, n, r) {
  let s = new WeakMap();
  function o(d) {
    const m = r.render.frame,
      v = d.geometry,
      y = e.get(d, v);
    if (
      (s.get(y) !== m && (e.update(y), s.set(y, m)),
      d.isInstancedMesh &&
        (d.hasEventListener("dispose", h) === !1 &&
          d.addEventListener("dispose", h),
        s.get(d) !== m &&
          (t.update(d.instanceMatrix, i.ARRAY_BUFFER),
          d.instanceColor !== null && t.update(d.instanceColor, i.ARRAY_BUFFER),
          s.set(d, m))),
      d.isSkinnedMesh)
    ) {
      const b = d.skeleton;
      s.get(b) !== m && (b.update(), s.set(b, m));
    }
    return y;
  }
  function u() {
    s = new WeakMap();
  }
  function h(d) {
    const m = d.target;
    (m.removeEventListener("dispose", h),
      n.releaseStatesOfObject(m),
      t.remove(m.instanceMatrix),
      m.instanceColor !== null && t.remove(m.instanceColor));
  }
  return { update: o, dispose: u };
}
const RH = {
  [RT]: "LINEAR_TONE_MAPPING",
  [DT]: "REINHARD_TONE_MAPPING",
  [LT]: "CINEON_TONE_MAPPING",
  [Z1]: "ACES_FILMIC_TONE_MAPPING",
  [UT]: "AGX_TONE_MAPPING",
  [PT]: "NEUTRAL_TONE_MAPPING",
  [NT]: "CUSTOM_TONE_MAPPING",
};
function DH(i, e, t, n, r) {
  const s = new Oa(e, t, { type: i, depthBuffer: n, stencilBuffer: r }),
    o = new Oa(e, t, { type: Kl, depthBuffer: !1, stencilBuffer: !1 }),
    u = new nn();
  (u.setAttribute("position", new Rt([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)),
    u.setAttribute("uv", new Rt([0, 2, 0, 0, 2, 0], 2)));
  const h = new aE({
      uniforms: { tDiffuse: { value: null } },
      vertexShader: `
			precision highp float;

			uniform mat4 modelViewMatrix;
			uniform mat4 projectionMatrix;

			attribute vec3 position;
			attribute vec2 uv;

			varying vec2 vUv;

			void main() {
				vUv = uv;
				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			}`,
      fragmentShader: `
			precision highp float;

			uniform sampler2D tDiffuse;

			varying vec2 vUv;

			#include <tonemapping_pars_fragment>
			#include <colorspace_pars_fragment>

			void main() {
				gl_FragColor = texture2D( tDiffuse, vUv );

				#ifdef LINEAR_TONE_MAPPING
					gl_FragColor.rgb = LinearToneMapping( gl_FragColor.rgb );
				#elif defined( REINHARD_TONE_MAPPING )
					gl_FragColor.rgb = ReinhardToneMapping( gl_FragColor.rgb );
				#elif defined( CINEON_TONE_MAPPING )
					gl_FragColor.rgb = CineonToneMapping( gl_FragColor.rgb );
				#elif defined( ACES_FILMIC_TONE_MAPPING )
					gl_FragColor.rgb = ACESFilmicToneMapping( gl_FragColor.rgb );
				#elif defined( AGX_TONE_MAPPING )
					gl_FragColor.rgb = AgXToneMapping( gl_FragColor.rgb );
				#elif defined( NEUTRAL_TONE_MAPPING )
					gl_FragColor.rgb = NeutralToneMapping( gl_FragColor.rgb );
				#elif defined( CUSTOM_TONE_MAPPING )
					gl_FragColor.rgb = CustomToneMapping( gl_FragColor.rgb );
				#endif

				#ifdef SRGB_TRANSFER
					gl_FragColor = sRGBTransferOETF( gl_FragColor );
				#endif
			}`,
      depthTest: !1,
      depthWrite: !1,
    }),
    d = new wi(u, h),
    m = new Wc(-1, 1, 1, -1, 0, 1);
  let v = null,
    y = null,
    b = !1,
    _,
    w = null,
    E = [],
    T = !1;
  ((this.setSize = function (C, R) {
    (s.setSize(C, R), o.setSize(C, R));
    for (let L = 0; L < E.length; L++) {
      const I = E[L];
      I.setSize && I.setSize(C, R);
    }
  }),
    (this.setEffects = function (C) {
      ((E = C), (T = E.length > 0 && E[0].isRenderPass === !0));
      const R = s.width,
        L = s.height;
      for (let I = 0; I < E.length; I++) {
        const O = E[I];
        O.setSize && O.setSize(R, L);
      }
    }),
    (this.begin = function (C, R) {
      if (b || (C.toneMapping === xo && E.length === 0)) return !1;
      if (((w = R), R !== null)) {
        const L = R.width,
          I = R.height;
        (s.width !== L || s.height !== I) && this.setSize(L, I);
      }
      return (
        T === !1 && C.setRenderTarget(s),
        (_ = C.toneMapping),
        (C.toneMapping = xo),
        !0
      );
    }),
    (this.hasRenderPass = function () {
      return T;
    }),
    (this.end = function (C, R) {
      ((C.toneMapping = _), (b = !0));
      let L = s,
        I = o;
      for (let O = 0; O < E.length; O++) {
        const B = E[O];
        if (B.enabled !== !1 && (B.render(C, I, L, R), B.needsSwap !== !1)) {
          const N = L;
          ((L = I), (I = N));
        }
      }
      if (v !== C.outputColorSpace || y !== C.toneMapping) {
        ((v = C.outputColorSpace),
          (y = C.toneMapping),
          (h.defines = {}),
          Cn.getTransfer(v) === Xn && (h.defines.SRGB_TRANSFER = ""));
        const O = RH[y];
        (O && (h.defines[O] = ""), (h.needsUpdate = !0));
      }
      ((h.uniforms.tDiffuse.value = L.texture),
        C.setRenderTarget(w),
        C.render(d, m),
        (w = null),
        (b = !1));
    }),
    (this.isCompositing = function () {
      return b;
    }),
    (this.dispose = function () {
      (s.dispose(), o.dispose(), u.dispose(), h.dispose());
    }));
}
const eU = new Fi(),
  PM = new Cp(1, 1),
  tU = new ab(),
  nU = new ob(),
  iU = new N0(),
  e3 = [],
  t3 = [],
  n3 = new Float32Array(16),
  i3 = new Float32Array(9),
  r3 = new Float32Array(4);
function Gp(i, e, t) {
  const n = i[0];
  if (n <= 0 || n > 0) return i;
  const r = e * t;
  let s = e3[r];
  if ((s === void 0 && ((s = new Float32Array(r)), (e3[r] = s)), e !== 0)) {
    n.toArray(s, 0);
    for (let o = 1, u = 0; o !== e; ++o) ((u += t), i[o].toArray(s, u));
  }
  return s;
}
function Tr(i, e) {
  if (i.length !== e.length) return !1;
  for (let t = 0, n = i.length; t < n; t++) if (i[t] !== e[t]) return !1;
  return !0;
}
function Er(i, e) {
  for (let t = 0, n = e.length; t < n; t++) i[t] = e[t];
}
function Ub(i, e) {
  let t = t3[e];
  t === void 0 && ((t = new Int32Array(e)), (t3[e] = t));
  for (let n = 0; n !== e; ++n) t[n] = i.allocateTextureUnit();
  return t;
}
function LH(i, e) {
  const t = this.cache;
  t[0] !== e && (i.uniform1f(this.addr, e), (t[0] = e));
}
function NH(i, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (i.uniform2f(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (Tr(t, e)) return;
    (i.uniform2fv(this.addr, e), Er(t, e));
  }
}
function UH(i, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (i.uniform3f(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else if (e.r !== void 0)
    (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) &&
      (i.uniform3f(this.addr, e.r, e.g, e.b),
      (t[0] = e.r),
      (t[1] = e.g),
      (t[2] = e.b));
  else {
    if (Tr(t, e)) return;
    (i.uniform3fv(this.addr, e), Er(t, e));
  }
}
function PH(i, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (i.uniform4f(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (Tr(t, e)) return;
    (i.uniform4fv(this.addr, e), Er(t, e));
  }
}
function IH(i, e) {
  const t = this.cache,
    n = e.elements;
  if (n === void 0) {
    if (Tr(t, e)) return;
    (i.uniformMatrix2fv(this.addr, !1, e), Er(t, e));
  } else {
    if (Tr(t, n)) return;
    (r3.set(n), i.uniformMatrix2fv(this.addr, !1, r3), Er(t, n));
  }
}
function OH(i, e) {
  const t = this.cache,
    n = e.elements;
  if (n === void 0) {
    if (Tr(t, e)) return;
    (i.uniformMatrix3fv(this.addr, !1, e), Er(t, e));
  } else {
    if (Tr(t, n)) return;
    (i3.set(n), i.uniformMatrix3fv(this.addr, !1, i3), Er(t, n));
  }
}
function FH(i, e) {
  const t = this.cache,
    n = e.elements;
  if (n === void 0) {
    if (Tr(t, e)) return;
    (i.uniformMatrix4fv(this.addr, !1, e), Er(t, e));
  } else {
    if (Tr(t, n)) return;
    (n3.set(n), i.uniformMatrix4fv(this.addr, !1, n3), Er(t, n));
  }
}
function zH(i, e) {
  const t = this.cache;
  t[0] !== e && (i.uniform1i(this.addr, e), (t[0] = e));
}
function BH(i, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (i.uniform2i(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (Tr(t, e)) return;
    (i.uniform2iv(this.addr, e), Er(t, e));
  }
}
function kH(i, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (i.uniform3i(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else {
    if (Tr(t, e)) return;
    (i.uniform3iv(this.addr, e), Er(t, e));
  }
}
function VH(i, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (i.uniform4i(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (Tr(t, e)) return;
    (i.uniform4iv(this.addr, e), Er(t, e));
  }
}
function GH(i, e) {
  const t = this.cache;
  t[0] !== e && (i.uniform1ui(this.addr, e), (t[0] = e));
}
function HH(i, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (i.uniform2ui(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (Tr(t, e)) return;
    (i.uniform2uiv(this.addr, e), Er(t, e));
  }
}
function jH(i, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (i.uniform3ui(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else {
    if (Tr(t, e)) return;
    (i.uniform3uiv(this.addr, e), Er(t, e));
  }
}
function WH(i, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (i.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (Tr(t, e)) return;
    (i.uniform4uiv(this.addr, e), Er(t, e));
  }
}
function XH(i, e, t) {
  const n = this.cache,
    r = t.allocateTextureUnit();
  n[0] !== r && (i.uniform1i(this.addr, r), (n[0] = r));
  let s;
  (this.type === i.SAMPLER_2D_SHADOW
    ? ((PM.compareFunction = t.isReversedDepthBuffer() ? sb : rb), (s = PM))
    : (s = eU),
    t.setTexture2D(e || s, r));
}
function qH(i, e, t) {
  const n = this.cache,
    r = t.allocateTextureUnit();
  (n[0] !== r && (i.uniform1i(this.addr, r), (n[0] = r)),
    t.setTexture3D(e || nU, r));
}
function YH(i, e, t) {
  const n = this.cache,
    r = t.allocateTextureUnit();
  (n[0] !== r && (i.uniform1i(this.addr, r), (n[0] = r)),
    t.setTextureCube(e || iU, r));
}
function ZH(i, e, t) {
  const n = this.cache,
    r = t.allocateTextureUnit();
  (n[0] !== r && (i.uniform1i(this.addr, r), (n[0] = r)),
    t.setTexture2DArray(e || tU, r));
}
function KH(i) {
  switch (i) {
    case 5126:
      return LH;
    case 35664:
      return NH;
    case 35665:
      return UH;
    case 35666:
      return PH;
    case 35674:
      return IH;
    case 35675:
      return OH;
    case 35676:
      return FH;
    case 5124:
    case 35670:
      return zH;
    case 35667:
    case 35671:
      return BH;
    case 35668:
    case 35672:
      return kH;
    case 35669:
    case 35673:
      return VH;
    case 5125:
      return GH;
    case 36294:
      return HH;
    case 36295:
      return jH;
    case 36296:
      return WH;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return XH;
    case 35679:
    case 36299:
    case 36307:
      return qH;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return YH;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return ZH;
  }
}
function QH(i, e) {
  i.uniform1fv(this.addr, e);
}
function JH(i, e) {
  const t = Gp(e, this.size, 2);
  i.uniform2fv(this.addr, t);
}
function $H(i, e) {
  const t = Gp(e, this.size, 3);
  i.uniform3fv(this.addr, t);
}
function ej(i, e) {
  const t = Gp(e, this.size, 4);
  i.uniform4fv(this.addr, t);
}
function tj(i, e) {
  const t = Gp(e, this.size, 4);
  i.uniformMatrix2fv(this.addr, !1, t);
}
function nj(i, e) {
  const t = Gp(e, this.size, 9);
  i.uniformMatrix3fv(this.addr, !1, t);
}
function ij(i, e) {
  const t = Gp(e, this.size, 16);
  i.uniformMatrix4fv(this.addr, !1, t);
}
function rj(i, e) {
  i.uniform1iv(this.addr, e);
}
function sj(i, e) {
  i.uniform2iv(this.addr, e);
}
function aj(i, e) {
  i.uniform3iv(this.addr, e);
}
function oj(i, e) {
  i.uniform4iv(this.addr, e);
}
function lj(i, e) {
  i.uniform1uiv(this.addr, e);
}
function cj(i, e) {
  i.uniform2uiv(this.addr, e);
}
function uj(i, e) {
  i.uniform3uiv(this.addr, e);
}
function fj(i, e) {
  i.uniform4uiv(this.addr, e);
}
function hj(i, e, t) {
  const n = this.cache,
    r = e.length,
    s = Ub(t, r);
  Tr(n, s) || (i.uniform1iv(this.addr, s), Er(n, s));
  let o;
  this.type === i.SAMPLER_2D_SHADOW ? (o = PM) : (o = eU);
  for (let u = 0; u !== r; ++u) t.setTexture2D(e[u] || o, s[u]);
}
function dj(i, e, t) {
  const n = this.cache,
    r = e.length,
    s = Ub(t, r);
  Tr(n, s) || (i.uniform1iv(this.addr, s), Er(n, s));
  for (let o = 0; o !== r; ++o) t.setTexture3D(e[o] || nU, s[o]);
}
function pj(i, e, t) {
  const n = this.cache,
    r = e.length,
    s = Ub(t, r);
  Tr(n, s) || (i.uniform1iv(this.addr, s), Er(n, s));
  for (let o = 0; o !== r; ++o) t.setTextureCube(e[o] || iU, s[o]);
}
function mj(i, e, t) {
  const n = this.cache,
    r = e.length,
    s = Ub(t, r);
  Tr(n, s) || (i.uniform1iv(this.addr, s), Er(n, s));
  for (let o = 0; o !== r; ++o) t.setTexture2DArray(e[o] || tU, s[o]);
}
function gj(i) {
  switch (i) {
    case 5126:
      return QH;
    case 35664:
      return JH;
    case 35665:
      return $H;
    case 35666:
      return ej;
    case 35674:
      return tj;
    case 35675:
      return nj;
    case 35676:
      return ij;
    case 5124:
    case 35670:
      return rj;
    case 35667:
    case 35671:
      return sj;
    case 35668:
    case 35672:
      return aj;
    case 35669:
    case 35673:
      return oj;
    case 5125:
      return lj;
    case 36294:
      return cj;
    case 36295:
      return uj;
    case 36296:
      return fj;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return hj;
    case 35679:
    case 36299:
    case 36307:
      return dj;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return pj;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return mj;
  }
}
class vj {
  constructor(e, t, n) {
    ((this.id = e),
      (this.addr = n),
      (this.cache = []),
      (this.type = t.type),
      (this.setValue = KH(t.type)));
  }
}
class yj {
  constructor(e, t, n) {
    ((this.id = e),
      (this.addr = n),
      (this.cache = []),
      (this.type = t.type),
      (this.size = t.size),
      (this.setValue = gj(t.type)));
  }
}
class xj {
  constructor(e) {
    ((this.id = e), (this.seq = []), (this.map = {}));
  }
  setValue(e, t, n) {
    const r = this.seq;
    for (let s = 0, o = r.length; s !== o; ++s) {
      const u = r[s];
      u.setValue(e, t[u.id], n);
    }
  }
}
const AS = /(\w+)(\])?(\[|\.)?/g;
function s3(i, e) {
  (i.seq.push(e), (i.map[e.id] = e));
}
function bj(i, e, t) {
  const n = i.name,
    r = n.length;
  for (AS.lastIndex = 0; ; ) {
    const s = AS.exec(n),
      o = AS.lastIndex;
    let u = s[1];
    const h = s[2] === "]",
      d = s[3];
    if ((h && (u = u | 0), d === void 0 || (d === "[" && o + 2 === r))) {
      s3(t, d === void 0 ? new vj(u, i, e) : new yj(u, i, e));
      break;
    } else {
      let v = t.map[u];
      (v === void 0 && ((v = new xj(u)), s3(t, v)), (t = v));
    }
  }
}
class Dx {
  constructor(e, t) {
    ((this.seq = []), (this.map = {}));
    const n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
    for (let o = 0; o < n; ++o) {
      const u = e.getActiveUniform(t, o),
        h = e.getUniformLocation(t, u.name);
      bj(u, h, this);
    }
    const r = [],
      s = [];
    for (const o of this.seq)
      o.type === e.SAMPLER_2D_SHADOW ||
      o.type === e.SAMPLER_CUBE_SHADOW ||
      o.type === e.SAMPLER_2D_ARRAY_SHADOW
        ? r.push(o)
        : s.push(o);
    r.length > 0 && (this.seq = r.concat(s));
  }
  setValue(e, t, n, r) {
    const s = this.map[t];
    s !== void 0 && s.setValue(e, n, r);
  }
  setOptional(e, t, n) {
    const r = t[n];
    r !== void 0 && this.setValue(e, n, r);
  }
  static upload(e, t, n, r) {
    for (let s = 0, o = t.length; s !== o; ++s) {
      const u = t[s],
        h = n[u.id];
      h.needsUpdate !== !1 && u.setValue(e, h.value, r);
    }
  }
  static seqWithValue(e, t) {
    const n = [];
    for (let r = 0, s = e.length; r !== s; ++r) {
      const o = e[r];
      o.id in t && n.push(o);
    }
    return n;
  }
}
function a3(i, e, t) {
  const n = i.createShader(e);
  return (i.shaderSource(n, t), i.compileShader(n), n);
}
const _j = 37297;
let Sj = 0;
function Mj(i, e) {
  const t = i.split(`
`),
    n = [],
    r = Math.max(e - 6, 0),
    s = Math.min(e + 6, t.length);
  for (let o = r; o < s; o++) {
    const u = o + 1;
    n.push(`${u === e ? ">" : " "} ${u}: ${t[o]}`);
  }
  return n.join(`
`);
}
const o3 = new tn();
function Tj(i) {
  Cn._getMatrix(o3, Cn.workingColorSpace, i);
  const e = `mat3( ${o3.elements.map((t) => t.toFixed(4))} )`;
  switch (Cn.getTransfer(i)) {
    case l0:
      return [e, "LinearTransferOETF"];
    case Xn:
      return [e, "sRGBTransferOETF"];
    default:
      return (
        Tt("WebGLProgram: Unsupported color space: ", i),
        [e, "LinearTransferOETF"]
      );
  }
}
function l3(i, e, t) {
  const n = i.getShaderParameter(e, i.COMPILE_STATUS),
    s = (i.getShaderInfoLog(e) || "").trim();
  if (n && s === "") return "";
  const o = /ERROR: 0:(\d+)/.exec(s);
  if (o) {
    const u = parseInt(o[1]);
    return (
      t.toUpperCase() +
      `

` +
      s +
      `

` +
      Mj(i.getShaderSource(e), u)
    );
  } else return s;
}
function Ej(i, e) {
  const t = Tj(e);
  return [
    `vec4 ${i}( vec4 value ) {`,
    `	return ${t[1]}( vec4( value.rgb * ${t[0]}, value.a ) );`,
    "}",
  ].join(`
`);
}
const wj = {
  [RT]: "Linear",
  [DT]: "Reinhard",
  [LT]: "Cineon",
  [Z1]: "ACESFilmic",
  [UT]: "AgX",
  [PT]: "Neutral",
  [NT]: "Custom",
};
function Aj(i, e) {
  const t = wj[e];
  return t === void 0
    ? (Tt("WebGLProgram: Unsupported toneMapping:", e),
      "vec3 " + i + "( vec3 color ) { return LinearToneMapping( color ); }")
    : "vec3 " + i + "( vec3 color ) { return " + t + "ToneMapping( color ); }";
}
const ux = new te();
function Cj() {
  Cn.getLuminanceCoefficients(ux);
  const i = ux.x.toFixed(4),
    e = ux.y.toFixed(4),
    t = ux.z.toFixed(4);
  return [
    "float luminance( const in vec3 rgb ) {",
    `	const vec3 weights = vec3( ${i}, ${e}, ${t} );`,
    "	return dot( weights, rgb );",
    "}",
  ].join(`
`);
}
function Rj(i) {
  return [
    i.extensionClipCullDistance
      ? "#extension GL_ANGLE_clip_cull_distance : require"
      : "",
    i.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : "",
  ].filter(Lg).join(`
`);
}
function Dj(i) {
  const e = [];
  for (const t in i) {
    const n = i[t];
    n !== !1 && e.push("#define " + t + " " + n);
  }
  return e.join(`
`);
}
function Lj(i, e) {
  const t = {},
    n = i.getProgramParameter(e, i.ACTIVE_ATTRIBUTES);
  for (let r = 0; r < n; r++) {
    const s = i.getActiveAttrib(e, r),
      o = s.name;
    let u = 1;
    (s.type === i.FLOAT_MAT2 && (u = 2),
      s.type === i.FLOAT_MAT3 && (u = 3),
      s.type === i.FLOAT_MAT4 && (u = 4),
      (t[o] = {
        type: s.type,
        location: i.getAttribLocation(e, o),
        locationSize: u,
      }));
  }
  return t;
}
function Lg(i) {
  return i !== "";
}
function c3(i, e) {
  const t =
    e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return i
    .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
    .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
    .replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps)
    .replace(/NUM_SPOT_LIGHT_COORDS/g, t)
    .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
    .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
    .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
    .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
    .replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps)
    .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
    .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function u3(i, e) {
  return i
    .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
    .replace(
      /UNION_CLIPPING_PLANES/g,
      e.numClippingPlanes - e.numClipIntersection,
    );
}
const Nj = /^[ \t]*#include +<([\w\d./]+)>/gm;
function IM(i) {
  return i.replace(Nj, Pj);
}
const Uj = new Map();
function Pj(i, e) {
  let t = cn[e];
  if (t === void 0) {
    const n = Uj.get(e);
    if (n !== void 0)
      ((t = cn[n]),
        Tt(
          'WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',
          e,
          n,
        ));
    else throw new Error("Can not resolve #include <" + e + ">");
  }
  return IM(t);
}
const Ij =
  /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function f3(i) {
  return i.replace(Ij, Oj);
}
function Oj(i, e, t, n) {
  let r = "";
  for (let s = parseInt(e); s < parseInt(t); s++)
    r += n
      .replace(/\[\s*i\s*\]/g, "[ " + s + " ]")
      .replace(/UNROLLED_LOOP_INDEX/g, s);
  return r;
}
function h3(i) {
  let e = `precision ${i.precision} float;
	precision ${i.precision} int;
	precision ${i.precision} sampler2D;
	precision ${i.precision} samplerCube;
	precision ${i.precision} sampler3D;
	precision ${i.precision} sampler2DArray;
	precision ${i.precision} sampler2DShadow;
	precision ${i.precision} samplerCubeShadow;
	precision ${i.precision} sampler2DArrayShadow;
	precision ${i.precision} isampler2D;
	precision ${i.precision} isampler3D;
	precision ${i.precision} isamplerCube;
	precision ${i.precision} isampler2DArray;
	precision ${i.precision} usampler2D;
	precision ${i.precision} usampler3D;
	precision ${i.precision} usamplerCube;
	precision ${i.precision} usampler2DArray;
	`;
  return (
    i.precision === "highp"
      ? (e += `
#define HIGH_PRECISION`)
      : i.precision === "mediump"
        ? (e += `
#define MEDIUM_PRECISION`)
        : i.precision === "lowp" &&
          (e += `
#define LOW_PRECISION`),
    e
  );
}
const Fj = { [_p]: "SHADOWMAP_TYPE_PCF", [bh]: "SHADOWMAP_TYPE_VSM" };
function zj(i) {
  return Fj[i.shadowMapType] || "SHADOWMAP_TYPE_BASIC";
}
const Bj = {
  [Zl]: "ENVMAP_TYPE_CUBE",
  [sf]: "ENVMAP_TYPE_CUBE",
  [Bp]: "ENVMAP_TYPE_CUBE_UV",
};
function kj(i) {
  return i.envMap === !1
    ? "ENVMAP_TYPE_CUBE"
    : Bj[i.envMapMode] || "ENVMAP_TYPE_CUBE";
}
const Vj = { [sf]: "ENVMAP_MODE_REFRACTION" };
function Gj(i) {
  return i.envMap === !1
    ? "ENVMAP_MODE_REFLECTION"
    : Vj[i.envMapMode] || "ENVMAP_MODE_REFLECTION";
}
const Hj = {
  [D0]: "ENVMAP_BLENDING_MULTIPLY",
  [IL]: "ENVMAP_BLENDING_MIX",
  [OL]: "ENVMAP_BLENDING_ADD",
};
function jj(i) {
  return i.envMap === !1
    ? "ENVMAP_BLENDING_NONE"
    : Hj[i.combine] || "ENVMAP_BLENDING_NONE";
}
function Wj(i) {
  const e = i.envMapCubeUVHeight;
  if (e === null) return null;
  const t = Math.log2(e) - 2,
    n = 1 / e;
  return {
    texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 112)),
    texelHeight: n,
    maxMip: t,
  };
}
function Xj(i, e, t, n) {
  const r = i.getContext(),
    s = t.defines;
  let o = t.vertexShader,
    u = t.fragmentShader;
  const h = zj(t),
    d = kj(t),
    m = Gj(t),
    v = jj(t),
    y = Wj(t),
    b = Rj(t),
    _ = Dj(s),
    w = r.createProgram();
  let E,
    T,
    C = t.glslVersion
      ? "#version " +
        t.glslVersion +
        `
`
      : "";
  (t.isRawShaderMaterial
    ? ((E = [
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        _,
      ].filter(Lg).join(`
`)),
      E.length > 0 &&
        (E += `
`),
      (T = [
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        _,
      ].filter(Lg).join(`
`)),
      T.length > 0 &&
        (T += `
`))
    : ((E = [
        h3(t),
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        _,
        t.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
        t.batching ? "#define USE_BATCHING" : "",
        t.batchingColor ? "#define USE_BATCHING_COLOR" : "",
        t.instancing ? "#define USE_INSTANCING" : "",
        t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
        t.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
        t.useFog && t.fog ? "#define USE_FOG" : "",
        t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
        t.map ? "#define USE_MAP" : "",
        t.envMap ? "#define USE_ENVMAP" : "",
        t.envMap ? "#define " + m : "",
        t.lightMap ? "#define USE_LIGHTMAP" : "",
        t.aoMap ? "#define USE_AOMAP" : "",
        t.bumpMap ? "#define USE_BUMPMAP" : "",
        t.normalMap ? "#define USE_NORMALMAP" : "",
        t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
        t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        t.anisotropy ? "#define USE_ANISOTROPY" : "",
        t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        t.specularMap ? "#define USE_SPECULARMAP" : "",
        t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        t.metalnessMap ? "#define USE_METALNESSMAP" : "",
        t.alphaMap ? "#define USE_ALPHAMAP" : "",
        t.alphaHash ? "#define USE_ALPHAHASH" : "",
        t.transmission ? "#define USE_TRANSMISSION" : "",
        t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        t.mapUv ? "#define MAP_UV " + t.mapUv : "",
        t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "",
        t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "",
        t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "",
        t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "",
        t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "",
        t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "",
        t.displacementMapUv
          ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv
          : "",
        t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "",
        t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "",
        t.anisotropyMapUv
          ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv
          : "",
        t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "",
        t.clearcoatNormalMapUv
          ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv
          : "",
        t.clearcoatRoughnessMapUv
          ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv
          : "",
        t.iridescenceMapUv
          ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv
          : "",
        t.iridescenceThicknessMapUv
          ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv
          : "",
        t.sheenColorMapUv
          ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv
          : "",
        t.sheenRoughnessMapUv
          ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv
          : "",
        t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "",
        t.specularColorMapUv
          ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv
          : "",
        t.specularIntensityMapUv
          ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv
          : "",
        t.transmissionMapUv
          ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv
          : "",
        t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "",
        t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
        t.vertexColors ? "#define USE_COLOR" : "",
        t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        t.vertexUv1s ? "#define USE_UV1" : "",
        t.vertexUv2s ? "#define USE_UV2" : "",
        t.vertexUv3s ? "#define USE_UV3" : "",
        t.pointsUvs ? "#define USE_POINTS_UV" : "",
        t.flatShading ? "#define FLAT_SHADED" : "",
        t.skinning ? "#define USE_SKINNING" : "",
        t.morphTargets ? "#define USE_MORPHTARGETS" : "",
        t.morphNormals && t.flatShading === !1
          ? "#define USE_MORPHNORMALS"
          : "",
        t.morphColors ? "#define USE_MORPHCOLORS" : "",
        t.morphTargetsCount > 0
          ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride
          : "",
        t.morphTargetsCount > 0
          ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount
          : "",
        t.doubleSided ? "#define DOUBLE_SIDED" : "",
        t.flipSided ? "#define FLIP_SIDED" : "",
        t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        t.shadowMapEnabled ? "#define " + h : "",
        t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
        t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
        t.logarithmicDepthBuffer ? "#define USE_LOGARITHMIC_DEPTH_BUFFER" : "",
        t.reversedDepthBuffer ? "#define USE_REVERSED_DEPTH_BUFFER" : "",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat4 projectionMatrix;",
        "uniform mat4 viewMatrix;",
        "uniform mat3 normalMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        "#ifdef USE_INSTANCING",
        "	attribute mat4 instanceMatrix;",
        "#endif",
        "#ifdef USE_INSTANCING_COLOR",
        "	attribute vec3 instanceColor;",
        "#endif",
        "#ifdef USE_INSTANCING_MORPH",
        "	uniform sampler2D morphTexture;",
        "#endif",
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec2 uv;",
        "#ifdef USE_UV1",
        "	attribute vec2 uv1;",
        "#endif",
        "#ifdef USE_UV2",
        "	attribute vec2 uv2;",
        "#endif",
        "#ifdef USE_UV3",
        "	attribute vec2 uv3;",
        "#endif",
        "#ifdef USE_TANGENT",
        "	attribute vec4 tangent;",
        "#endif",
        "#if defined( USE_COLOR_ALPHA )",
        "	attribute vec4 color;",
        "#elif defined( USE_COLOR )",
        "	attribute vec3 color;",
        "#endif",
        "#ifdef USE_SKINNING",
        "	attribute vec4 skinIndex;",
        "	attribute vec4 skinWeight;",
        "#endif",
        `
`,
      ].filter(Lg).join(`
`)),
      (T = [
        h3(t),
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        _,
        t.useFog && t.fog ? "#define USE_FOG" : "",
        t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
        t.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
        t.map ? "#define USE_MAP" : "",
        t.matcap ? "#define USE_MATCAP" : "",
        t.envMap ? "#define USE_ENVMAP" : "",
        t.envMap ? "#define " + d : "",
        t.envMap ? "#define " + m : "",
        t.envMap ? "#define " + v : "",
        y ? "#define CUBEUV_TEXEL_WIDTH " + y.texelWidth : "",
        y ? "#define CUBEUV_TEXEL_HEIGHT " + y.texelHeight : "",
        y ? "#define CUBEUV_MAX_MIP " + y.maxMip + ".0" : "",
        t.lightMap ? "#define USE_LIGHTMAP" : "",
        t.aoMap ? "#define USE_AOMAP" : "",
        t.bumpMap ? "#define USE_BUMPMAP" : "",
        t.normalMap ? "#define USE_NORMALMAP" : "",
        t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        t.anisotropy ? "#define USE_ANISOTROPY" : "",
        t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        t.clearcoat ? "#define USE_CLEARCOAT" : "",
        t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        t.dispersion ? "#define USE_DISPERSION" : "",
        t.iridescence ? "#define USE_IRIDESCENCE" : "",
        t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        t.specularMap ? "#define USE_SPECULARMAP" : "",
        t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        t.metalnessMap ? "#define USE_METALNESSMAP" : "",
        t.alphaMap ? "#define USE_ALPHAMAP" : "",
        t.alphaTest ? "#define USE_ALPHATEST" : "",
        t.alphaHash ? "#define USE_ALPHAHASH" : "",
        t.sheen ? "#define USE_SHEEN" : "",
        t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        t.transmission ? "#define USE_TRANSMISSION" : "",
        t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
        t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "",
        t.vertexAlphas || t.batchingColor ? "#define USE_COLOR_ALPHA" : "",
        t.vertexUv1s ? "#define USE_UV1" : "",
        t.vertexUv2s ? "#define USE_UV2" : "",
        t.vertexUv3s ? "#define USE_UV3" : "",
        t.pointsUvs ? "#define USE_POINTS_UV" : "",
        t.gradientMap ? "#define USE_GRADIENTMAP" : "",
        t.flatShading ? "#define FLAT_SHADED" : "",
        t.doubleSided ? "#define DOUBLE_SIDED" : "",
        t.flipSided ? "#define FLIP_SIDED" : "",
        t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        t.shadowMapEnabled ? "#define " + h : "",
        t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
        t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
        t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
        t.decodeVideoTextureEmissive
          ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE"
          : "",
        t.logarithmicDepthBuffer ? "#define USE_LOGARITHMIC_DEPTH_BUFFER" : "",
        t.reversedDepthBuffer ? "#define USE_REVERSED_DEPTH_BUFFER" : "",
        "uniform mat4 viewMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        t.toneMapping !== xo ? "#define TONE_MAPPING" : "",
        t.toneMapping !== xo ? cn.tonemapping_pars_fragment : "",
        t.toneMapping !== xo ? Aj("toneMapping", t.toneMapping) : "",
        t.dithering ? "#define DITHERING" : "",
        t.opaque ? "#define OPAQUE" : "",
        cn.colorspace_pars_fragment,
        Ej("linearToOutputTexel", t.outputColorSpace),
        Cj(),
        t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
        `
`,
      ].filter(Lg).join(`
`))),
    (o = IM(o)),
    (o = c3(o, t)),
    (o = u3(o, t)),
    (u = IM(u)),
    (u = c3(u, t)),
    (u = u3(u, t)),
    (o = f3(o)),
    (u = f3(u)),
    t.isRawShaderMaterial !== !0 &&
      ((C = `#version 300 es
`),
      (E =
        [
          b,
          "#define attribute in",
          "#define varying out",
          "#define texture2D texture",
        ].join(`
`) +
        `
` +
        E),
      (T =
        [
          "#define varying in",
          t.glslVersion === EM
            ? ""
            : "layout(location = 0) out highp vec4 pc_fragColor;",
          t.glslVersion === EM ? "" : "#define gl_FragColor pc_fragColor",
          "#define gl_FragDepthEXT gl_FragDepth",
          "#define texture2D texture",
          "#define textureCube texture",
          "#define texture2DProj textureProj",
          "#define texture2DLodEXT textureLod",
          "#define texture2DProjLodEXT textureProjLod",
          "#define textureCubeLodEXT textureLod",
          "#define texture2DGradEXT textureGrad",
          "#define texture2DProjGradEXT textureProjGrad",
          "#define textureCubeGradEXT textureGrad",
        ].join(`
`) +
        `
` +
        T)));
  const R = C + E + o,
    L = C + T + u,
    I = a3(r, r.VERTEX_SHADER, R),
    O = a3(r, r.FRAGMENT_SHADER, L);
  (r.attachShader(w, I),
    r.attachShader(w, O),
    t.index0AttributeName !== void 0
      ? r.bindAttribLocation(w, 0, t.index0AttributeName)
      : t.morphTargets === !0 && r.bindAttribLocation(w, 0, "position"),
    r.linkProgram(w));
  function B(q) {
    if (i.debug.checkShaderErrors) {
      const X = r.getProgramInfoLog(w) || "",
        J = r.getShaderInfoLog(I) || "",
        ee = r.getShaderInfoLog(O) || "",
        ne = X.trim(),
        W = J.trim(),
        $ = ee.trim();
      let de = !0,
        le = !0;
      if (r.getProgramParameter(w, r.LINK_STATUS) === !1)
        if (((de = !1), typeof i.debug.onShaderError == "function"))
          i.debug.onShaderError(r, w, I, O);
        else {
          const fe = l3(r, I, "vertex"),
            V = l3(r, O, "fragment");
          Ft(
            "THREE.WebGLProgram: Shader Error " +
              r.getError() +
              " - VALIDATE_STATUS " +
              r.getProgramParameter(w, r.VALIDATE_STATUS) +
              `

Material Name: ` +
              q.name +
              `
Material Type: ` +
              q.type +
              `

Program Info Log: ` +
              ne +
              `
` +
              fe +
              `
` +
              V,
          );
        }
      else
        ne !== ""
          ? Tt("WebGLProgram: Program Info Log:", ne)
          : (W === "" || $ === "") && (le = !1);
      le &&
        (q.diagnostics = {
          runnable: de,
          programLog: ne,
          vertexShader: { log: W, prefix: E },
          fragmentShader: { log: $, prefix: T },
        });
    }
    (r.deleteShader(I), r.deleteShader(O), (N = new Dx(r, w)), (F = Lj(r, w)));
  }
  let N;
  this.getUniforms = function () {
    return (N === void 0 && B(this), N);
  };
  let F;
  this.getAttributes = function () {
    return (F === void 0 && B(this), F);
  };
  let j = t.rendererExtensionParallelShaderCompile === !1;
  return (
    (this.isReady = function () {
      return (j === !1 && (j = r.getProgramParameter(w, _j)), j);
    }),
    (this.destroy = function () {
      (n.releaseStatesOfProgram(this),
        r.deleteProgram(w),
        (this.program = void 0));
    }),
    (this.type = t.shaderType),
    (this.name = t.shaderName),
    (this.id = Sj++),
    (this.cacheKey = e),
    (this.usedTimes = 1),
    (this.program = w),
    (this.vertexShader = I),
    (this.fragmentShader = O),
    this
  );
}
let qj = 0;
class Yj {
  constructor() {
    ((this.shaderCache = new Map()), (this.materialCache = new Map()));
  }
  update(e) {
    const t = e.vertexShader,
      n = e.fragmentShader,
      r = this._getShaderStage(t),
      s = this._getShaderStage(n),
      o = this._getShaderCacheForMaterial(e);
    return (
      o.has(r) === !1 && (o.add(r), r.usedTimes++),
      o.has(s) === !1 && (o.add(s), s.usedTimes++),
      this
    );
  }
  remove(e) {
    const t = this.materialCache.get(e);
    for (const n of t)
      (n.usedTimes--, n.usedTimes === 0 && this.shaderCache.delete(n.code));
    return (this.materialCache.delete(e), this);
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    (this.shaderCache.clear(), this.materialCache.clear());
  }
  _getShaderCacheForMaterial(e) {
    const t = this.materialCache;
    let n = t.get(e);
    return (n === void 0 && ((n = new Set()), t.set(e, n)), n);
  }
  _getShaderStage(e) {
    const t = this.shaderCache;
    let n = t.get(e);
    return (n === void 0 && ((n = new Zj(e)), t.set(e, n)), n);
  }
}
class Zj {
  constructor(e) {
    ((this.id = qj++), (this.code = e), (this.usedTimes = 0));
  }
}
function Kj(i, e, t, n, r, s) {
  const o = new Ap(),
    u = new Yj(),
    h = new Set(),
    d = [],
    m = new Map(),
    v = n.logarithmicDepthBuffer;
  let y = n.precision;
  const b = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distance",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite",
  };
  function _(N) {
    return (h.add(N), N === 0 ? "uv" : `uv${N}`);
  }
  function w(N, F, j, q, X) {
    const J = q.fog,
      ee = X.geometry,
      ne =
        N.isMeshStandardMaterial ||
        N.isMeshLambertMaterial ||
        N.isMeshPhongMaterial
          ? q.environment
          : null,
      W =
        N.isMeshStandardMaterial ||
        (N.isMeshLambertMaterial && !N.envMap) ||
        (N.isMeshPhongMaterial && !N.envMap),
      $ = e.get(N.envMap || ne, W),
      de = $ && $.mapping === Bp ? $.image.height : null,
      le = b[N.type];
    N.precision !== null &&
      ((y = n.getMaxPrecision(N.precision)),
      y !== N.precision &&
        Tt(
          "WebGLProgram.getParameters:",
          N.precision,
          "not supported, using",
          y,
          "instead.",
        ));
    const fe =
        ee.morphAttributes.position ||
        ee.morphAttributes.normal ||
        ee.morphAttributes.color,
      V = fe !== void 0 ? fe.length : 0;
    let Z = 0;
    (ee.morphAttributes.position !== void 0 && (Z = 1),
      ee.morphAttributes.normal !== void 0 && (Z = 2),
      ee.morphAttributes.color !== void 0 && (Z = 3));
    let se, ue, ge, ae;
    if (le) {
      const Dt = Xo[le];
      ((se = Dt.vertexShader), (ue = Dt.fragmentShader));
    } else
      ((se = N.vertexShader),
        (ue = N.fragmentShader),
        u.update(N),
        (ge = u.getVertexShaderID(N)),
        (ae = u.getFragmentShaderID(N)));
    const he = i.getRenderTarget(),
      ye = i.state.buffers.depth.getReversed(),
      ze = X.isInstancedMesh === !0,
      it = X.isBatchedMesh === !0,
      qe = !!N.map,
      Ye = !!N.matcap,
      ft = !!$,
      Re = !!N.aoMap,
      Ie = !!N.lightMap,
      De = !!N.bumpMap,
      Qe = !!N.normalMap,
      K = !!N.displacementMap,
      rt = !!N.emissiveMap,
      je = !!N.metalnessMap,
      Te = !!N.roughnessMap,
      ke = N.anisotropy > 0,
      H = N.clearcoat > 0,
      k = N.dispersion > 0,
      oe = N.iridescence > 0,
      Ae = N.sheen > 0,
      _e = N.transmission > 0,
      be = ke && !!N.anisotropyMap,
      et = H && !!N.clearcoatMap,
      $e = H && !!N.clearcoatNormalMap,
      ht = H && !!N.clearcoatRoughnessMap,
      yt = oe && !!N.iridescenceMap,
      Ge = oe && !!N.iridescenceThicknessMap,
      Ve = Ae && !!N.sheenColorMap,
      Ze = Ae && !!N.sheenRoughnessMap,
      re = !!N.specularMap,
      Se = !!N.specularColorMap,
      lt = !!N.specularIntensityMap,
      ce = _e && !!N.transmissionMap,
      Oe = _e && !!N.thicknessMap,
      Ke = !!N.gradientMap,
      dt = !!N.alphaMap,
      Je = N.alphaTest > 0,
      Ee = !!N.alphaHash,
      ct = !!N.extensions;
    let Mt = xo;
    N.toneMapped &&
      (he === null || he.isXRRenderTarget === !0) &&
      (Mt = i.toneMapping);
    const St = {
      shaderID: le,
      shaderType: N.type,
      shaderName: N.name,
      vertexShader: se,
      fragmentShader: ue,
      defines: N.defines,
      customVertexShaderID: ge,
      customFragmentShaderID: ae,
      isRawShaderMaterial: N.isRawShaderMaterial === !0,
      glslVersion: N.glslVersion,
      precision: y,
      batching: it,
      batchingColor: it && X._colorsTexture !== null,
      instancing: ze,
      instancingColor: ze && X.instanceColor !== null,
      instancingMorph: ze && X.morphTexture !== null,
      outputColorSpace:
        he === null
          ? i.outputColorSpace
          : he.isXRRenderTarget === !0
            ? he.texture.colorSpace
            : af,
      alphaToCoverage: !!N.alphaToCoverage,
      map: qe,
      matcap: Ye,
      envMap: ft,
      envMapMode: ft && $.mapping,
      envMapCubeUVHeight: de,
      aoMap: Re,
      lightMap: Ie,
      bumpMap: De,
      normalMap: Qe,
      displacementMap: K,
      emissiveMap: rt,
      normalMapObjectSpace: Qe && N.normalMapType === HL,
      normalMapTangentSpace: Qe && N.normalMapType === hf,
      metalnessMap: je,
      roughnessMap: Te,
      anisotropy: ke,
      anisotropyMap: be,
      clearcoat: H,
      clearcoatMap: et,
      clearcoatNormalMap: $e,
      clearcoatRoughnessMap: ht,
      dispersion: k,
      iridescence: oe,
      iridescenceMap: yt,
      iridescenceThicknessMap: Ge,
      sheen: Ae,
      sheenColorMap: Ve,
      sheenRoughnessMap: Ze,
      specularMap: re,
      specularColorMap: Se,
      specularIntensityMap: lt,
      transmission: _e,
      transmissionMap: ce,
      thicknessMap: Oe,
      gradientMap: Ke,
      opaque:
        N.transparent === !1 && N.blending === Eh && N.alphaToCoverage === !1,
      alphaMap: dt,
      alphaTest: Je,
      alphaHash: Ee,
      combine: N.combine,
      mapUv: qe && _(N.map.channel),
      aoMapUv: Re && _(N.aoMap.channel),
      lightMapUv: Ie && _(N.lightMap.channel),
      bumpMapUv: De && _(N.bumpMap.channel),
      normalMapUv: Qe && _(N.normalMap.channel),
      displacementMapUv: K && _(N.displacementMap.channel),
      emissiveMapUv: rt && _(N.emissiveMap.channel),
      metalnessMapUv: je && _(N.metalnessMap.channel),
      roughnessMapUv: Te && _(N.roughnessMap.channel),
      anisotropyMapUv: be && _(N.anisotropyMap.channel),
      clearcoatMapUv: et && _(N.clearcoatMap.channel),
      clearcoatNormalMapUv: $e && _(N.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: ht && _(N.clearcoatRoughnessMap.channel),
      iridescenceMapUv: yt && _(N.iridescenceMap.channel),
      iridescenceThicknessMapUv: Ge && _(N.iridescenceThicknessMap.channel),
      sheenColorMapUv: Ve && _(N.sheenColorMap.channel),
      sheenRoughnessMapUv: Ze && _(N.sheenRoughnessMap.channel),
      specularMapUv: re && _(N.specularMap.channel),
      specularColorMapUv: Se && _(N.specularColorMap.channel),
      specularIntensityMapUv: lt && _(N.specularIntensityMap.channel),
      transmissionMapUv: ce && _(N.transmissionMap.channel),
      thicknessMapUv: Oe && _(N.thicknessMap.channel),
      alphaMapUv: dt && _(N.alphaMap.channel),
      vertexTangents: !!ee.attributes.tangent && (Qe || ke),
      vertexColors: N.vertexColors,
      vertexAlphas:
        N.vertexColors === !0 &&
        !!ee.attributes.color &&
        ee.attributes.color.itemSize === 4,
      pointsUvs: X.isPoints === !0 && !!ee.attributes.uv && (qe || dt),
      fog: !!J,
      useFog: N.fog === !0,
      fogExp2: !!J && J.isFogExp2,
      flatShading:
        N.wireframe === !1 &&
        (N.flatShading === !0 ||
          (ee.attributes.normal === void 0 &&
            Qe === !1 &&
            (N.isMeshLambertMaterial ||
              N.isMeshPhongMaterial ||
              N.isMeshStandardMaterial ||
              N.isMeshPhysicalMaterial))),
      sizeAttenuation: N.sizeAttenuation === !0,
      logarithmicDepthBuffer: v,
      reversedDepthBuffer: ye,
      skinning: X.isSkinnedMesh === !0,
      morphTargets: ee.morphAttributes.position !== void 0,
      morphNormals: ee.morphAttributes.normal !== void 0,
      morphColors: ee.morphAttributes.color !== void 0,
      morphTargetsCount: V,
      morphTextureStride: Z,
      numDirLights: F.directional.length,
      numPointLights: F.point.length,
      numSpotLights: F.spot.length,
      numSpotLightMaps: F.spotLightMap.length,
      numRectAreaLights: F.rectArea.length,
      numHemiLights: F.hemi.length,
      numDirLightShadows: F.directionalShadowMap.length,
      numPointLightShadows: F.pointShadowMap.length,
      numSpotLightShadows: F.spotShadowMap.length,
      numSpotLightShadowsWithMaps: F.numSpotLightShadowsWithMaps,
      numLightProbes: F.numLightProbes,
      numClippingPlanes: s.numPlanes,
      numClipIntersection: s.numIntersection,
      dithering: N.dithering,
      shadowMapEnabled: i.shadowMap.enabled && j.length > 0,
      shadowMapType: i.shadowMap.type,
      toneMapping: Mt,
      decodeVideoTexture:
        qe &&
        N.map.isVideoTexture === !0 &&
        Cn.getTransfer(N.map.colorSpace) === Xn,
      decodeVideoTextureEmissive:
        rt &&
        N.emissiveMap.isVideoTexture === !0 &&
        Cn.getTransfer(N.emissiveMap.colorSpace) === Xn,
      premultipliedAlpha: N.premultipliedAlpha,
      doubleSided: N.side === Na,
      flipSided: N.side === js,
      useDepthPacking: N.depthPacking >= 0,
      depthPacking: N.depthPacking || 0,
      index0AttributeName: N.index0AttributeName,
      extensionClipCullDistance:
        ct &&
        N.extensions.clipCullDistance === !0 &&
        t.has("WEBGL_clip_cull_distance"),
      extensionMultiDraw:
        ((ct && N.extensions.multiDraw === !0) || it) &&
        t.has("WEBGL_multi_draw"),
      rendererExtensionParallelShaderCompile: t.has(
        "KHR_parallel_shader_compile",
      ),
      customProgramCacheKey: N.customProgramCacheKey(),
    };
    return (
      (St.vertexUv1s = h.has(1)),
      (St.vertexUv2s = h.has(2)),
      (St.vertexUv3s = h.has(3)),
      h.clear(),
      St
    );
  }
  function E(N) {
    const F = [];
    if (
      (N.shaderID
        ? F.push(N.shaderID)
        : (F.push(N.customVertexShaderID), F.push(N.customFragmentShaderID)),
      N.defines !== void 0)
    )
      for (const j in N.defines) (F.push(j), F.push(N.defines[j]));
    return (
      N.isRawShaderMaterial === !1 &&
        (T(F, N), C(F, N), F.push(i.outputColorSpace)),
      F.push(N.customProgramCacheKey),
      F.join()
    );
  }
  function T(N, F) {
    (N.push(F.precision),
      N.push(F.outputColorSpace),
      N.push(F.envMapMode),
      N.push(F.envMapCubeUVHeight),
      N.push(F.mapUv),
      N.push(F.alphaMapUv),
      N.push(F.lightMapUv),
      N.push(F.aoMapUv),
      N.push(F.bumpMapUv),
      N.push(F.normalMapUv),
      N.push(F.displacementMapUv),
      N.push(F.emissiveMapUv),
      N.push(F.metalnessMapUv),
      N.push(F.roughnessMapUv),
      N.push(F.anisotropyMapUv),
      N.push(F.clearcoatMapUv),
      N.push(F.clearcoatNormalMapUv),
      N.push(F.clearcoatRoughnessMapUv),
      N.push(F.iridescenceMapUv),
      N.push(F.iridescenceThicknessMapUv),
      N.push(F.sheenColorMapUv),
      N.push(F.sheenRoughnessMapUv),
      N.push(F.specularMapUv),
      N.push(F.specularColorMapUv),
      N.push(F.specularIntensityMapUv),
      N.push(F.transmissionMapUv),
      N.push(F.thicknessMapUv),
      N.push(F.combine),
      N.push(F.fogExp2),
      N.push(F.sizeAttenuation),
      N.push(F.morphTargetsCount),
      N.push(F.morphAttributeCount),
      N.push(F.numDirLights),
      N.push(F.numPointLights),
      N.push(F.numSpotLights),
      N.push(F.numSpotLightMaps),
      N.push(F.numHemiLights),
      N.push(F.numRectAreaLights),
      N.push(F.numDirLightShadows),
      N.push(F.numPointLightShadows),
      N.push(F.numSpotLightShadows),
      N.push(F.numSpotLightShadowsWithMaps),
      N.push(F.numLightProbes),
      N.push(F.shadowMapType),
      N.push(F.toneMapping),
      N.push(F.numClippingPlanes),
      N.push(F.numClipIntersection),
      N.push(F.depthPacking));
  }
  function C(N, F) {
    (o.disableAll(),
      F.instancing && o.enable(0),
      F.instancingColor && o.enable(1),
      F.instancingMorph && o.enable(2),
      F.matcap && o.enable(3),
      F.envMap && o.enable(4),
      F.normalMapObjectSpace && o.enable(5),
      F.normalMapTangentSpace && o.enable(6),
      F.clearcoat && o.enable(7),
      F.iridescence && o.enable(8),
      F.alphaTest && o.enable(9),
      F.vertexColors && o.enable(10),
      F.vertexAlphas && o.enable(11),
      F.vertexUv1s && o.enable(12),
      F.vertexUv2s && o.enable(13),
      F.vertexUv3s && o.enable(14),
      F.vertexTangents && o.enable(15),
      F.anisotropy && o.enable(16),
      F.alphaHash && o.enable(17),
      F.batching && o.enable(18),
      F.dispersion && o.enable(19),
      F.batchingColor && o.enable(20),
      F.gradientMap && o.enable(21),
      N.push(o.mask),
      o.disableAll(),
      F.fog && o.enable(0),
      F.useFog && o.enable(1),
      F.flatShading && o.enable(2),
      F.logarithmicDepthBuffer && o.enable(3),
      F.reversedDepthBuffer && o.enable(4),
      F.skinning && o.enable(5),
      F.morphTargets && o.enable(6),
      F.morphNormals && o.enable(7),
      F.morphColors && o.enable(8),
      F.premultipliedAlpha && o.enable(9),
      F.shadowMapEnabled && o.enable(10),
      F.doubleSided && o.enable(11),
      F.flipSided && o.enable(12),
      F.useDepthPacking && o.enable(13),
      F.dithering && o.enable(14),
      F.transmission && o.enable(15),
      F.sheen && o.enable(16),
      F.opaque && o.enable(17),
      F.pointsUvs && o.enable(18),
      F.decodeVideoTexture && o.enable(19),
      F.decodeVideoTextureEmissive && o.enable(20),
      F.alphaToCoverage && o.enable(21),
      N.push(o.mask));
  }
  function R(N) {
    const F = b[N.type];
    let j;
    if (F) {
      const q = Xo[F];
      j = g0.clone(q.uniforms);
    } else j = N.uniforms;
    return j;
  }
  function L(N, F) {
    let j = m.get(F);
    return (
      j !== void 0
        ? ++j.usedTimes
        : ((j = new Xj(i, F, N, r)), d.push(j), m.set(F, j)),
      j
    );
  }
  function I(N) {
    if (--N.usedTimes === 0) {
      const F = d.indexOf(N);
      ((d[F] = d[d.length - 1]), d.pop(), m.delete(N.cacheKey), N.destroy());
    }
  }
  function O(N) {
    u.remove(N);
  }
  function B() {
    u.dispose();
  }
  return {
    getParameters: w,
    getProgramCacheKey: E,
    getUniforms: R,
    acquireProgram: L,
    releaseProgram: I,
    releaseShaderCache: O,
    programs: d,
    dispose: B,
  };
}
function Qj() {
  let i = new WeakMap();
  function e(o) {
    return i.has(o);
  }
  function t(o) {
    let u = i.get(o);
    return (u === void 0 && ((u = {}), i.set(o, u)), u);
  }
  function n(o) {
    i.delete(o);
  }
  function r(o, u, h) {
    i.get(o)[u] = h;
  }
  function s() {
    i = new WeakMap();
  }
  return { has: e, get: t, remove: n, update: r, dispose: s };
}
function Jj(i, e) {
  return i.groupOrder !== e.groupOrder
    ? i.groupOrder - e.groupOrder
    : i.renderOrder !== e.renderOrder
      ? i.renderOrder - e.renderOrder
      : i.material.id !== e.material.id
        ? i.material.id - e.material.id
        : i.materialVariant !== e.materialVariant
          ? i.materialVariant - e.materialVariant
          : i.z !== e.z
            ? i.z - e.z
            : i.id - e.id;
}
function d3(i, e) {
  return i.groupOrder !== e.groupOrder
    ? i.groupOrder - e.groupOrder
    : i.renderOrder !== e.renderOrder
      ? i.renderOrder - e.renderOrder
      : i.z !== e.z
        ? e.z - i.z
        : i.id - e.id;
}
function p3() {
  const i = [];
  let e = 0;
  const t = [],
    n = [],
    r = [];
  function s() {
    ((e = 0), (t.length = 0), (n.length = 0), (r.length = 0));
  }
  function o(y) {
    let b = 0;
    return (y.isInstancedMesh && (b += 2), y.isSkinnedMesh && (b += 1), b);
  }
  function u(y, b, _, w, E, T) {
    let C = i[e];
    return (
      C === void 0
        ? ((C = {
            id: y.id,
            object: y,
            geometry: b,
            material: _,
            materialVariant: o(y),
            groupOrder: w,
            renderOrder: y.renderOrder,
            z: E,
            group: T,
          }),
          (i[e] = C))
        : ((C.id = y.id),
          (C.object = y),
          (C.geometry = b),
          (C.material = _),
          (C.materialVariant = o(y)),
          (C.groupOrder = w),
          (C.renderOrder = y.renderOrder),
          (C.z = E),
          (C.group = T)),
      e++,
      C
    );
  }
  function h(y, b, _, w, E, T) {
    const C = u(y, b, _, w, E, T);
    _.transmission > 0
      ? n.push(C)
      : _.transparent === !0
        ? r.push(C)
        : t.push(C);
  }
  function d(y, b, _, w, E, T) {
    const C = u(y, b, _, w, E, T);
    _.transmission > 0
      ? n.unshift(C)
      : _.transparent === !0
        ? r.unshift(C)
        : t.unshift(C);
  }
  function m(y, b) {
    (t.length > 1 && t.sort(y || Jj),
      n.length > 1 && n.sort(b || d3),
      r.length > 1 && r.sort(b || d3));
  }
  function v() {
    for (let y = e, b = i.length; y < b; y++) {
      const _ = i[y];
      if (_.id === null) break;
      ((_.id = null),
        (_.object = null),
        (_.geometry = null),
        (_.material = null),
        (_.group = null));
    }
  }
  return {
    opaque: t,
    transmissive: n,
    transparent: r,
    init: s,
    push: h,
    unshift: d,
    finish: v,
    sort: m,
  };
}
function $j() {
  let i = new WeakMap();
  function e(n, r) {
    const s = i.get(n);
    let o;
    return (
      s === void 0
        ? ((o = new p3()), i.set(n, [o]))
        : r >= s.length
          ? ((o = new p3()), s.push(o))
          : (o = s[r]),
      o
    );
  }
  function t() {
    i = new WeakMap();
  }
  return { get: e, dispose: t };
}
function e9() {
  const i = {};
  return {
    get: function (e) {
      if (i[e.id] !== void 0) return i[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = { direction: new te(), color: new wt() };
          break;
        case "SpotLight":
          t = {
            position: new te(),
            direction: new te(),
            color: new wt(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0,
          };
          break;
        case "PointLight":
          t = { position: new te(), color: new wt(), distance: 0, decay: 0 };
          break;
        case "HemisphereLight":
          t = {
            direction: new te(),
            skyColor: new wt(),
            groundColor: new wt(),
          };
          break;
        case "RectAreaLight":
          t = {
            color: new wt(),
            position: new te(),
            halfWidth: new te(),
            halfHeight: new te(),
          };
          break;
      }
      return ((i[e.id] = t), t);
    },
  };
}
function t9() {
  const i = {};
  return {
    get: function (e) {
      if (i[e.id] !== void 0) return i[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new nt(),
          };
          break;
        case "SpotLight":
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new nt(),
          };
          break;
        case "PointLight":
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new nt(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3,
          };
          break;
      }
      return ((i[e.id] = t), t);
    },
  };
}
let n9 = 0;
function i9(i, e) {
  return (
    (e.castShadow ? 2 : 0) -
    (i.castShadow ? 2 : 0) +
    (e.map ? 1 : 0) -
    (i.map ? 1 : 0)
  );
}
function r9(i) {
  const e = new e9(),
    t = t9(),
    n = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1,
        numSpotMaps: -1,
        numLightProbes: -1,
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotLightMap: [],
      spotShadow: [],
      spotShadowMap: [],
      spotLightMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
      numSpotLightShadowsWithMaps: 0,
      numLightProbes: 0,
    };
  for (let d = 0; d < 9; d++) n.probe.push(new te());
  const r = new te(),
    s = new qt(),
    o = new qt();
  function u(d) {
    let m = 0,
      v = 0,
      y = 0;
    for (let F = 0; F < 9; F++) n.probe[F].set(0, 0, 0);
    let b = 0,
      _ = 0,
      w = 0,
      E = 0,
      T = 0,
      C = 0,
      R = 0,
      L = 0,
      I = 0,
      O = 0,
      B = 0;
    d.sort(i9);
    for (let F = 0, j = d.length; F < j; F++) {
      const q = d[F],
        X = q.color,
        J = q.intensity,
        ee = q.distance;
      let ne = null;
      if (
        (q.shadow &&
          q.shadow.map &&
          (q.shadow.map.texture.format === Lh
            ? (ne = q.shadow.map.texture)
            : (ne = q.shadow.map.depthTexture || q.shadow.map.texture)),
        q.isAmbientLight)
      )
        ((m += X.r * J), (v += X.g * J), (y += X.b * J));
      else if (q.isLightProbe) {
        for (let W = 0; W < 9; W++)
          n.probe[W].addScaledVector(q.sh.coefficients[W], J);
        B++;
      } else if (q.isDirectionalLight) {
        const W = e.get(q);
        if ((W.color.copy(q.color).multiplyScalar(q.intensity), q.castShadow)) {
          const $ = q.shadow,
            de = t.get(q);
          ((de.shadowIntensity = $.intensity),
            (de.shadowBias = $.bias),
            (de.shadowNormalBias = $.normalBias),
            (de.shadowRadius = $.radius),
            (de.shadowMapSize = $.mapSize),
            (n.directionalShadow[b] = de),
            (n.directionalShadowMap[b] = ne),
            (n.directionalShadowMatrix[b] = q.shadow.matrix),
            C++);
        }
        ((n.directional[b] = W), b++);
      } else if (q.isSpotLight) {
        const W = e.get(q);
        (W.position.setFromMatrixPosition(q.matrixWorld),
          W.color.copy(X).multiplyScalar(J),
          (W.distance = ee),
          (W.coneCos = Math.cos(q.angle)),
          (W.penumbraCos = Math.cos(q.angle * (1 - q.penumbra))),
          (W.decay = q.decay),
          (n.spot[w] = W));
        const $ = q.shadow;
        if (
          (q.map &&
            ((n.spotLightMap[I] = q.map),
            I++,
            $.updateMatrices(q),
            q.castShadow && O++),
          (n.spotLightMatrix[w] = $.matrix),
          q.castShadow)
        ) {
          const de = t.get(q);
          ((de.shadowIntensity = $.intensity),
            (de.shadowBias = $.bias),
            (de.shadowNormalBias = $.normalBias),
            (de.shadowRadius = $.radius),
            (de.shadowMapSize = $.mapSize),
            (n.spotShadow[w] = de),
            (n.spotShadowMap[w] = ne),
            L++);
        }
        w++;
      } else if (q.isRectAreaLight) {
        const W = e.get(q);
        (W.color.copy(X).multiplyScalar(J),
          W.halfWidth.set(q.width * 0.5, 0, 0),
          W.halfHeight.set(0, q.height * 0.5, 0),
          (n.rectArea[E] = W),
          E++);
      } else if (q.isPointLight) {
        const W = e.get(q);
        if (
          (W.color.copy(q.color).multiplyScalar(q.intensity),
          (W.distance = q.distance),
          (W.decay = q.decay),
          q.castShadow)
        ) {
          const $ = q.shadow,
            de = t.get(q);
          ((de.shadowIntensity = $.intensity),
            (de.shadowBias = $.bias),
            (de.shadowNormalBias = $.normalBias),
            (de.shadowRadius = $.radius),
            (de.shadowMapSize = $.mapSize),
            (de.shadowCameraNear = $.camera.near),
            (de.shadowCameraFar = $.camera.far),
            (n.pointShadow[_] = de),
            (n.pointShadowMap[_] = ne),
            (n.pointShadowMatrix[_] = q.shadow.matrix),
            R++);
        }
        ((n.point[_] = W), _++);
      } else if (q.isHemisphereLight) {
        const W = e.get(q);
        (W.skyColor.copy(q.color).multiplyScalar(J),
          W.groundColor.copy(q.groundColor).multiplyScalar(J),
          (n.hemi[T] = W),
          T++);
      }
    }
    (E > 0 &&
      (i.has("OES_texture_float_linear") === !0
        ? ((n.rectAreaLTC1 = Et.LTC_FLOAT_1), (n.rectAreaLTC2 = Et.LTC_FLOAT_2))
        : ((n.rectAreaLTC1 = Et.LTC_HALF_1), (n.rectAreaLTC2 = Et.LTC_HALF_2))),
      (n.ambient[0] = m),
      (n.ambient[1] = v),
      (n.ambient[2] = y));
    const N = n.hash;
    (N.directionalLength !== b ||
      N.pointLength !== _ ||
      N.spotLength !== w ||
      N.rectAreaLength !== E ||
      N.hemiLength !== T ||
      N.numDirectionalShadows !== C ||
      N.numPointShadows !== R ||
      N.numSpotShadows !== L ||
      N.numSpotMaps !== I ||
      N.numLightProbes !== B) &&
      ((n.directional.length = b),
      (n.spot.length = w),
      (n.rectArea.length = E),
      (n.point.length = _),
      (n.hemi.length = T),
      (n.directionalShadow.length = C),
      (n.directionalShadowMap.length = C),
      (n.pointShadow.length = R),
      (n.pointShadowMap.length = R),
      (n.spotShadow.length = L),
      (n.spotShadowMap.length = L),
      (n.directionalShadowMatrix.length = C),
      (n.pointShadowMatrix.length = R),
      (n.spotLightMatrix.length = L + I - O),
      (n.spotLightMap.length = I),
      (n.numSpotLightShadowsWithMaps = O),
      (n.numLightProbes = B),
      (N.directionalLength = b),
      (N.pointLength = _),
      (N.spotLength = w),
      (N.rectAreaLength = E),
      (N.hemiLength = T),
      (N.numDirectionalShadows = C),
      (N.numPointShadows = R),
      (N.numSpotShadows = L),
      (N.numSpotMaps = I),
      (N.numLightProbes = B),
      (n.version = n9++));
  }
  function h(d, m) {
    let v = 0,
      y = 0,
      b = 0,
      _ = 0,
      w = 0;
    const E = m.matrixWorldInverse;
    for (let T = 0, C = d.length; T < C; T++) {
      const R = d[T];
      if (R.isDirectionalLight) {
        const L = n.directional[v];
        (L.direction.setFromMatrixPosition(R.matrixWorld),
          r.setFromMatrixPosition(R.target.matrixWorld),
          L.direction.sub(r),
          L.direction.transformDirection(E),
          v++);
      } else if (R.isSpotLight) {
        const L = n.spot[b];
        (L.position.setFromMatrixPosition(R.matrixWorld),
          L.position.applyMatrix4(E),
          L.direction.setFromMatrixPosition(R.matrixWorld),
          r.setFromMatrixPosition(R.target.matrixWorld),
          L.direction.sub(r),
          L.direction.transformDirection(E),
          b++);
      } else if (R.isRectAreaLight) {
        const L = n.rectArea[_];
        (L.position.setFromMatrixPosition(R.matrixWorld),
          L.position.applyMatrix4(E),
          o.identity(),
          s.copy(R.matrixWorld),
          s.premultiply(E),
          o.extractRotation(s),
          L.halfWidth.set(R.width * 0.5, 0, 0),
          L.halfHeight.set(0, R.height * 0.5, 0),
          L.halfWidth.applyMatrix4(o),
          L.halfHeight.applyMatrix4(o),
          _++);
      } else if (R.isPointLight) {
        const L = n.point[y];
        (L.position.setFromMatrixPosition(R.matrixWorld),
          L.position.applyMatrix4(E),
          y++);
      } else if (R.isHemisphereLight) {
        const L = n.hemi[w];
        (L.direction.setFromMatrixPosition(R.matrixWorld),
          L.direction.transformDirection(E),
          w++);
      }
    }
  }
  return { setup: u, setupView: h, state: n };
}
function m3(i) {
  const e = new r9(i),
    t = [],
    n = [];
  function r(m) {
    ((d.camera = m), (t.length = 0), (n.length = 0));
  }
  function s(m) {
    t.push(m);
  }
  function o(m) {
    n.push(m);
  }
  function u() {
    e.setup(t);
  }
  function h(m) {
    e.setupView(t, m);
  }
  const d = {
    lightsArray: t,
    shadowsArray: n,
    camera: null,
    lights: e,
    transmissionRenderTarget: {},
  };
  return {
    init: r,
    state: d,
    setupLights: u,
    setupLightsView: h,
    pushLight: s,
    pushShadow: o,
  };
}
function s9(i) {
  let e = new WeakMap();
  function t(r, s = 0) {
    const o = e.get(r);
    let u;
    return (
      o === void 0
        ? ((u = new m3(i)), e.set(r, [u]))
        : s >= o.length
          ? ((u = new m3(i)), o.push(u))
          : (u = o[s]),
      u
    );
  }
  function n() {
    e = new WeakMap();
  }
  return { get: t, dispose: n };
}
const a9 = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
  o9 = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ).rg;
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ).r;
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( max( 0.0, squared_mean - mean * mean ) );
	gl_FragColor = vec4( mean, std_dev, 0.0, 1.0 );
}`,
  l9 = [
    new te(1, 0, 0),
    new te(-1, 0, 0),
    new te(0, 1, 0),
    new te(0, -1, 0),
    new te(0, 0, 1),
    new te(0, 0, -1),
  ],
  c9 = [
    new te(0, -1, 0),
    new te(0, -1, 0),
    new te(0, 0, 1),
    new te(0, 0, -1),
    new te(0, -1, 0),
    new te(0, -1, 0),
  ],
  g3 = new qt(),
  wg = new te(),
  CS = new te();
function u9(i, e, t) {
  let n = new kp();
  const r = new nt(),
    s = new nt(),
    o = new Dn(),
    u = new Ab(),
    h = new Cb(),
    d = {},
    m = t.maxTextureSize,
    v = { [Zc]: js, [js]: Zc, [Na]: Na },
    y = new ba({
      defines: { VSM_SAMPLES: 8 },
      uniforms: {
        shadow_pass: { value: null },
        resolution: { value: new nt() },
        radius: { value: 4 },
      },
      vertexShader: a9,
      fragmentShader: o9,
    }),
    b = y.clone();
  b.defines.HORIZONTAL_PASS = 1;
  const _ = new nn();
  _.setAttribute(
    "position",
    new $n(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3),
  );
  const w = new wi(_, y),
    E = this;
  ((this.enabled = !1),
    (this.autoUpdate = !0),
    (this.needsUpdate = !1),
    (this.type = _p));
  let T = this.type;
  this.render = function (O, B, N) {
    if (
      E.enabled === !1 ||
      (E.autoUpdate === !1 && E.needsUpdate === !1) ||
      O.length === 0
    )
      return;
    this.type === Fg &&
      (Tt(
        "WebGLShadowMap: PCFSoftShadowMap has been deprecated. Using PCFShadowMap instead.",
      ),
      (this.type = _p));
    const F = i.getRenderTarget(),
      j = i.getActiveCubeFace(),
      q = i.getActiveMipmapLevel(),
      X = i.state;
    (X.setBlending(ql),
      X.buffers.depth.getReversed() === !0
        ? X.buffers.color.setClear(0, 0, 0, 0)
        : X.buffers.color.setClear(1, 1, 1, 1),
      X.buffers.depth.setTest(!0),
      X.setScissorTest(!1));
    const J = T !== this.type;
    J &&
      B.traverse(function (ee) {
        ee.material &&
          (Array.isArray(ee.material)
            ? ee.material.forEach((ne) => (ne.needsUpdate = !0))
            : (ee.material.needsUpdate = !0));
      });
    for (let ee = 0, ne = O.length; ee < ne; ee++) {
      const W = O[ee],
        $ = W.shadow;
      if ($ === void 0) {
        Tt("WebGLShadowMap:", W, "has no shadow.");
        continue;
      }
      if ($.autoUpdate === !1 && $.needsUpdate === !1) continue;
      r.copy($.mapSize);
      const de = $.getFrameExtents();
      (r.multiply(de),
        s.copy($.mapSize),
        (r.x > m || r.y > m) &&
          (r.x > m &&
            ((s.x = Math.floor(m / de.x)),
            (r.x = s.x * de.x),
            ($.mapSize.x = s.x)),
          r.y > m &&
            ((s.y = Math.floor(m / de.y)),
            (r.y = s.y * de.y),
            ($.mapSize.y = s.y))));
      const le = i.state.buffers.depth.getReversed();
      if ((($.camera._reversedDepth = le), $.map === null || J === !0)) {
        if (
          ($.map !== null &&
            ($.map.depthTexture !== null &&
              ($.map.depthTexture.dispose(), ($.map.depthTexture = null)),
            $.map.dispose()),
          this.type === bh)
        ) {
          if (W.isPointLight) {
            Tt(
              "WebGLShadowMap: VSM shadow maps are not supported for PointLights. Use PCF or BasicShadowMap instead.",
            );
            continue;
          }
          (($.map = new Oa(r.x, r.y, {
            format: Lh,
            type: Kl,
            minFilter: ni,
            magFilter: ni,
            generateMipmaps: !1,
          })),
            ($.map.texture.name = W.name + ".shadowMap"),
            ($.map.depthTexture = new Cp(r.x, r.y, Hs)),
            ($.map.depthTexture.name = W.name + ".shadowMapDepth"),
            ($.map.depthTexture.format = Ql),
            ($.map.depthTexture.compareFunction = null),
            ($.map.depthTexture.minFilter = rr),
            ($.map.depthTexture.magFilter = rr));
        } else
          (W.isPointLight
            ? (($.map = new bE(r.x)), ($.map.depthTexture = new uN(r.x, bo)))
            : (($.map = new Oa(r.x, r.y)),
              ($.map.depthTexture = new Cp(r.x, r.y, bo))),
            ($.map.depthTexture.name = W.name + ".shadowMap"),
            ($.map.depthTexture.format = Ql),
            this.type === _p
              ? (($.map.depthTexture.compareFunction = le ? sb : rb),
                ($.map.depthTexture.minFilter = ni),
                ($.map.depthTexture.magFilter = ni))
              : (($.map.depthTexture.compareFunction = null),
                ($.map.depthTexture.minFilter = rr),
                ($.map.depthTexture.magFilter = rr)));
        $.camera.updateProjectionMatrix();
      }
      const fe = $.map.isWebGLCubeRenderTarget ? 6 : 1;
      for (let V = 0; V < fe; V++) {
        if ($.map.isWebGLCubeRenderTarget)
          (i.setRenderTarget($.map, V), i.clear());
        else {
          V === 0 && (i.setRenderTarget($.map), i.clear());
          const Z = $.getViewport(V);
          (o.set(s.x * Z.x, s.y * Z.y, s.x * Z.z, s.y * Z.w), X.viewport(o));
        }
        if (W.isPointLight) {
          const Z = $.camera,
            se = $.matrix,
            ue = W.distance || Z.far;
          (ue !== Z.far && ((Z.far = ue), Z.updateProjectionMatrix()),
            wg.setFromMatrixPosition(W.matrixWorld),
            Z.position.copy(wg),
            CS.copy(Z.position),
            CS.add(l9[V]),
            Z.up.copy(c9[V]),
            Z.lookAt(CS),
            Z.updateMatrixWorld(),
            se.makeTranslation(-wg.x, -wg.y, -wg.z),
            g3.multiplyMatrices(Z.projectionMatrix, Z.matrixWorldInverse),
            $._frustum.setFromProjectionMatrix(
              g3,
              Z.coordinateSystem,
              Z.reversedDepth,
            ));
        } else $.updateMatrices(W);
        ((n = $.getFrustum()), L(B, N, $.camera, W, this.type));
      }
      ($.isPointLightShadow !== !0 && this.type === bh && C($, N),
        ($.needsUpdate = !1));
    }
    ((T = this.type), (E.needsUpdate = !1), i.setRenderTarget(F, j, q));
  };
  function C(O, B) {
    const N = e.update(w);
    (y.defines.VSM_SAMPLES !== O.blurSamples &&
      ((y.defines.VSM_SAMPLES = O.blurSamples),
      (b.defines.VSM_SAMPLES = O.blurSamples),
      (y.needsUpdate = !0),
      (b.needsUpdate = !0)),
      O.mapPass === null &&
        (O.mapPass = new Oa(r.x, r.y, { format: Lh, type: Kl })),
      (y.uniforms.shadow_pass.value = O.map.depthTexture),
      (y.uniforms.resolution.value = O.mapSize),
      (y.uniforms.radius.value = O.radius),
      i.setRenderTarget(O.mapPass),
      i.clear(),
      i.renderBufferDirect(B, null, N, y, w, null),
      (b.uniforms.shadow_pass.value = O.mapPass.texture),
      (b.uniforms.resolution.value = O.mapSize),
      (b.uniforms.radius.value = O.radius),
      i.setRenderTarget(O.map),
      i.clear(),
      i.renderBufferDirect(B, null, N, b, w, null));
  }
  function R(O, B, N, F) {
    let j = null;
    const q =
      N.isPointLight === !0 ? O.customDistanceMaterial : O.customDepthMaterial;
    if (q !== void 0) j = q;
    else if (
      ((j = N.isPointLight === !0 ? h : u),
      (i.localClippingEnabled &&
        B.clipShadows === !0 &&
        Array.isArray(B.clippingPlanes) &&
        B.clippingPlanes.length !== 0) ||
        (B.displacementMap && B.displacementScale !== 0) ||
        (B.alphaMap && B.alphaTest > 0) ||
        (B.map && B.alphaTest > 0) ||
        B.alphaToCoverage === !0)
    ) {
      const X = j.uuid,
        J = B.uuid;
      let ee = d[X];
      ee === void 0 && ((ee = {}), (d[X] = ee));
      let ne = ee[J];
      (ne === void 0 &&
        ((ne = j.clone()), (ee[J] = ne), B.addEventListener("dispose", I)),
        (j = ne));
    }
    if (
      ((j.visible = B.visible),
      (j.wireframe = B.wireframe),
      F === bh
        ? (j.side = B.shadowSide !== null ? B.shadowSide : B.side)
        : (j.side = B.shadowSide !== null ? B.shadowSide : v[B.side]),
      (j.alphaMap = B.alphaMap),
      (j.alphaTest = B.alphaToCoverage === !0 ? 0.5 : B.alphaTest),
      (j.map = B.map),
      (j.clipShadows = B.clipShadows),
      (j.clippingPlanes = B.clippingPlanes),
      (j.clipIntersection = B.clipIntersection),
      (j.displacementMap = B.displacementMap),
      (j.displacementScale = B.displacementScale),
      (j.displacementBias = B.displacementBias),
      (j.wireframeLinewidth = B.wireframeLinewidth),
      (j.linewidth = B.linewidth),
      N.isPointLight === !0 && j.isMeshDistanceMaterial === !0)
    ) {
      const X = i.properties.get(j);
      X.light = N;
    }
    return j;
  }
  function L(O, B, N, F, j) {
    if (O.visible === !1) return;
    if (
      O.layers.test(B.layers) &&
      (O.isMesh || O.isLine || O.isPoints) &&
      (O.castShadow || (O.receiveShadow && j === bh)) &&
      (!O.frustumCulled || n.intersectsObject(O))
    ) {
      O.modelViewMatrix.multiplyMatrices(N.matrixWorldInverse, O.matrixWorld);
      const J = e.update(O),
        ee = O.material;
      if (Array.isArray(ee)) {
        const ne = J.groups;
        for (let W = 0, $ = ne.length; W < $; W++) {
          const de = ne[W],
            le = ee[de.materialIndex];
          if (le && le.visible) {
            const fe = R(O, le, F, j);
            (O.onBeforeShadow(i, O, B, N, J, fe, de),
              i.renderBufferDirect(N, null, J, fe, O, de),
              O.onAfterShadow(i, O, B, N, J, fe, de));
          }
        }
      } else if (ee.visible) {
        const ne = R(O, ee, F, j);
        (O.onBeforeShadow(i, O, B, N, J, ne, null),
          i.renderBufferDirect(N, null, J, ne, O, null),
          O.onAfterShadow(i, O, B, N, J, ne, null));
      }
    }
    const X = O.children;
    for (let J = 0, ee = X.length; J < ee; J++) L(X[J], B, N, F, j);
  }
  function I(O) {
    O.target.removeEventListener("dispose", I);
    for (const N in d) {
      const F = d[N],
        j = O.target.uuid;
      j in F && (F[j].dispose(), delete F[j]);
    }
  }
}
function f9(i, e) {
  function t() {
    let ce = !1;
    const Oe = new Dn();
    let Ke = null;
    const dt = new Dn(0, 0, 0, 0);
    return {
      setMask: function (Je) {
        Ke !== Je && !ce && (i.colorMask(Je, Je, Je, Je), (Ke = Je));
      },
      setLocked: function (Je) {
        ce = Je;
      },
      setClear: function (Je, Ee, ct, Mt, St) {
        (St === !0 && ((Je *= Mt), (Ee *= Mt), (ct *= Mt)),
          Oe.set(Je, Ee, ct, Mt),
          dt.equals(Oe) === !1 && (i.clearColor(Je, Ee, ct, Mt), dt.copy(Oe)));
      },
      reset: function () {
        ((ce = !1), (Ke = null), dt.set(-1, 0, 0, 0));
      },
    };
  }
  function n() {
    let ce = !1,
      Oe = !1,
      Ke = null,
      dt = null,
      Je = null;
    return {
      setReversed: function (Ee) {
        if (Oe !== Ee) {
          const ct = e.get("EXT_clip_control");
          (Ee
            ? ct.clipControlEXT(ct.LOWER_LEFT_EXT, ct.ZERO_TO_ONE_EXT)
            : ct.clipControlEXT(ct.LOWER_LEFT_EXT, ct.NEGATIVE_ONE_TO_ONE_EXT),
            (Oe = Ee));
          const Mt = Je;
          ((Je = null), this.setClear(Mt));
        }
      },
      getReversed: function () {
        return Oe;
      },
      setTest: function (Ee) {
        Ee ? he(i.DEPTH_TEST) : ye(i.DEPTH_TEST);
      },
      setMask: function (Ee) {
        Ke !== Ee && !ce && (i.depthMask(Ee), (Ke = Ee));
      },
      setFunc: function (Ee) {
        if ((Oe && (Ee = OB[Ee]), dt !== Ee)) {
          switch (Ee) {
            case Xx:
              i.depthFunc(i.NEVER);
              break;
            case qx:
              i.depthFunc(i.ALWAYS);
              break;
            case Yx:
              i.depthFunc(i.LESS);
              break;
            case Dh:
              i.depthFunc(i.LEQUAL);
              break;
            case Zx:
              i.depthFunc(i.EQUAL);
              break;
            case Kx:
              i.depthFunc(i.GEQUAL);
              break;
            case Qx:
              i.depthFunc(i.GREATER);
              break;
            case Jx:
              i.depthFunc(i.NOTEQUAL);
              break;
            default:
              i.depthFunc(i.LEQUAL);
          }
          dt = Ee;
        }
      },
      setLocked: function (Ee) {
        ce = Ee;
      },
      setClear: function (Ee) {
        Je !== Ee && ((Je = Ee), Oe && (Ee = 1 - Ee), i.clearDepth(Ee));
      },
      reset: function () {
        ((ce = !1), (Ke = null), (dt = null), (Je = null), (Oe = !1));
      },
    };
  }
  function r() {
    let ce = !1,
      Oe = null,
      Ke = null,
      dt = null,
      Je = null,
      Ee = null,
      ct = null,
      Mt = null,
      St = null;
    return {
      setTest: function (Dt) {
        ce || (Dt ? he(i.STENCIL_TEST) : ye(i.STENCIL_TEST));
      },
      setMask: function (Dt) {
        Oe !== Dt && !ce && (i.stencilMask(Dt), (Oe = Dt));
      },
      setFunc: function (Dt, hn, bn) {
        (Ke !== Dt || dt !== hn || Je !== bn) &&
          (i.stencilFunc(Dt, hn, bn), (Ke = Dt), (dt = hn), (Je = bn));
      },
      setOp: function (Dt, hn, bn) {
        (Ee !== Dt || ct !== hn || Mt !== bn) &&
          (i.stencilOp(Dt, hn, bn), (Ee = Dt), (ct = hn), (Mt = bn));
      },
      setLocked: function (Dt) {
        ce = Dt;
      },
      setClear: function (Dt) {
        St !== Dt && (i.clearStencil(Dt), (St = Dt));
      },
      reset: function () {
        ((ce = !1),
          (Oe = null),
          (Ke = null),
          (dt = null),
          (Je = null),
          (Ee = null),
          (ct = null),
          (Mt = null),
          (St = null));
      },
    };
  }
  const s = new t(),
    o = new n(),
    u = new r(),
    h = new WeakMap(),
    d = new WeakMap();
  let m = {},
    v = {},
    y = new WeakMap(),
    b = [],
    _ = null,
    w = !1,
    E = null,
    T = null,
    C = null,
    R = null,
    L = null,
    I = null,
    O = null,
    B = new wt(0, 0, 0),
    N = 0,
    F = !1,
    j = null,
    q = null,
    X = null,
    J = null,
    ee = null;
  const ne = i.getParameter(i.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let W = !1,
    $ = 0;
  const de = i.getParameter(i.VERSION);
  de.indexOf("WebGL") !== -1
    ? (($ = parseFloat(/^WebGL (\d)/.exec(de)[1])), (W = $ >= 1))
    : de.indexOf("OpenGL ES") !== -1 &&
      (($ = parseFloat(/^OpenGL ES (\d)/.exec(de)[1])), (W = $ >= 2));
  let le = null,
    fe = {};
  const V = i.getParameter(i.SCISSOR_BOX),
    Z = i.getParameter(i.VIEWPORT),
    se = new Dn().fromArray(V),
    ue = new Dn().fromArray(Z);
  function ge(ce, Oe, Ke, dt) {
    const Je = new Uint8Array(4),
      Ee = i.createTexture();
    (i.bindTexture(ce, Ee),
      i.texParameteri(ce, i.TEXTURE_MIN_FILTER, i.NEAREST),
      i.texParameteri(ce, i.TEXTURE_MAG_FILTER, i.NEAREST));
    for (let ct = 0; ct < Ke; ct++)
      ce === i.TEXTURE_3D || ce === i.TEXTURE_2D_ARRAY
        ? i.texImage3D(Oe, 0, i.RGBA, 1, 1, dt, 0, i.RGBA, i.UNSIGNED_BYTE, Je)
        : i.texImage2D(
            Oe + ct,
            0,
            i.RGBA,
            1,
            1,
            0,
            i.RGBA,
            i.UNSIGNED_BYTE,
            Je,
          );
    return Ee;
  }
  const ae = {};
  ((ae[i.TEXTURE_2D] = ge(i.TEXTURE_2D, i.TEXTURE_2D, 1)),
    (ae[i.TEXTURE_CUBE_MAP] = ge(
      i.TEXTURE_CUBE_MAP,
      i.TEXTURE_CUBE_MAP_POSITIVE_X,
      6,
    )),
    (ae[i.TEXTURE_2D_ARRAY] = ge(i.TEXTURE_2D_ARRAY, i.TEXTURE_2D_ARRAY, 1, 1)),
    (ae[i.TEXTURE_3D] = ge(i.TEXTURE_3D, i.TEXTURE_3D, 1, 1)),
    s.setClear(0, 0, 0, 1),
    o.setClear(1),
    u.setClear(0),
    he(i.DEPTH_TEST),
    o.setFunc(Dh),
    De(!1),
    Qe(xM),
    he(i.CULL_FACE),
    Re(ql));
  function he(ce) {
    m[ce] !== !0 && (i.enable(ce), (m[ce] = !0));
  }
  function ye(ce) {
    m[ce] !== !1 && (i.disable(ce), (m[ce] = !1));
  }
  function ze(ce, Oe) {
    return v[ce] !== Oe
      ? (i.bindFramebuffer(ce, Oe),
        (v[ce] = Oe),
        ce === i.DRAW_FRAMEBUFFER && (v[i.FRAMEBUFFER] = Oe),
        ce === i.FRAMEBUFFER && (v[i.DRAW_FRAMEBUFFER] = Oe),
        !0)
      : !1;
  }
  function it(ce, Oe) {
    let Ke = b,
      dt = !1;
    if (ce) {
      ((Ke = y.get(Oe)), Ke === void 0 && ((Ke = []), y.set(Oe, Ke)));
      const Je = ce.textures;
      if (Ke.length !== Je.length || Ke[0] !== i.COLOR_ATTACHMENT0) {
        for (let Ee = 0, ct = Je.length; Ee < ct; Ee++)
          Ke[Ee] = i.COLOR_ATTACHMENT0 + Ee;
        ((Ke.length = Je.length), (dt = !0));
      }
    } else Ke[0] !== i.BACK && ((Ke[0] = i.BACK), (dt = !0));
    dt && i.drawBuffers(Ke);
  }
  function qe(ce) {
    return _ !== ce ? (i.useProgram(ce), (_ = ce), !0) : !1;
  }
  const Ye = {
    [Ku]: i.FUNC_ADD,
    [yL]: i.FUNC_SUBTRACT,
    [xL]: i.FUNC_REVERSE_SUBTRACT,
  };
  ((Ye[bL] = i.MIN), (Ye[_L] = i.MAX));
  const ft = {
    [SL]: i.ZERO,
    [ML]: i.ONE,
    [TL]: i.SRC_COLOR,
    [jx]: i.SRC_ALPHA,
    [DL]: i.SRC_ALPHA_SATURATE,
    [CL]: i.DST_COLOR,
    [wL]: i.DST_ALPHA,
    [EL]: i.ONE_MINUS_SRC_COLOR,
    [Wx]: i.ONE_MINUS_SRC_ALPHA,
    [RL]: i.ONE_MINUS_DST_COLOR,
    [AL]: i.ONE_MINUS_DST_ALPHA,
    [LL]: i.CONSTANT_COLOR,
    [NL]: i.ONE_MINUS_CONSTANT_COLOR,
    [UL]: i.CONSTANT_ALPHA,
    [PL]: i.ONE_MINUS_CONSTANT_ALPHA,
  };
  function Re(ce, Oe, Ke, dt, Je, Ee, ct, Mt, St, Dt) {
    if (ce === ql) {
      w === !0 && (ye(i.BLEND), (w = !1));
      return;
    }
    if ((w === !1 && (he(i.BLEND), (w = !0)), ce !== vL)) {
      if (ce !== E || Dt !== F) {
        if (
          ((T !== Ku || L !== Ku) &&
            (i.blendEquation(i.FUNC_ADD), (T = Ku), (L = Ku)),
          Dt)
        )
          switch (ce) {
            case Eh:
              i.blendFuncSeparate(
                i.ONE,
                i.ONE_MINUS_SRC_ALPHA,
                i.ONE,
                i.ONE_MINUS_SRC_ALPHA,
              );
              break;
            case Hx:
              i.blendFunc(i.ONE, i.ONE);
              break;
            case bM:
              i.blendFuncSeparate(i.ZERO, i.ONE_MINUS_SRC_COLOR, i.ZERO, i.ONE);
              break;
            case _M:
              i.blendFuncSeparate(
                i.DST_COLOR,
                i.ONE_MINUS_SRC_ALPHA,
                i.ZERO,
                i.ONE,
              );
              break;
            default:
              Ft("WebGLState: Invalid blending: ", ce);
              break;
          }
        else
          switch (ce) {
            case Eh:
              i.blendFuncSeparate(
                i.SRC_ALPHA,
                i.ONE_MINUS_SRC_ALPHA,
                i.ONE,
                i.ONE_MINUS_SRC_ALPHA,
              );
              break;
            case Hx:
              i.blendFuncSeparate(i.SRC_ALPHA, i.ONE, i.ONE, i.ONE);
              break;
            case bM:
              Ft(
                "WebGLState: SubtractiveBlending requires material.premultipliedAlpha = true",
              );
              break;
            case _M:
              Ft(
                "WebGLState: MultiplyBlending requires material.premultipliedAlpha = true",
              );
              break;
            default:
              Ft("WebGLState: Invalid blending: ", ce);
              break;
          }
        ((C = null),
          (R = null),
          (I = null),
          (O = null),
          B.set(0, 0, 0),
          (N = 0),
          (E = ce),
          (F = Dt));
      }
      return;
    }
    ((Je = Je || Oe),
      (Ee = Ee || Ke),
      (ct = ct || dt),
      (Oe !== T || Je !== L) &&
        (i.blendEquationSeparate(Ye[Oe], Ye[Je]), (T = Oe), (L = Je)),
      (Ke !== C || dt !== R || Ee !== I || ct !== O) &&
        (i.blendFuncSeparate(ft[Ke], ft[dt], ft[Ee], ft[ct]),
        (C = Ke),
        (R = dt),
        (I = Ee),
        (O = ct)),
      (Mt.equals(B) === !1 || St !== N) &&
        (i.blendColor(Mt.r, Mt.g, Mt.b, St), B.copy(Mt), (N = St)),
      (E = ce),
      (F = !1));
  }
  function Ie(ce, Oe) {
    ce.side === Na ? ye(i.CULL_FACE) : he(i.CULL_FACE);
    let Ke = ce.side === js;
    (Oe && (Ke = !Ke),
      De(Ke),
      ce.blending === Eh && ce.transparent === !1
        ? Re(ql)
        : Re(
            ce.blending,
            ce.blendEquation,
            ce.blendSrc,
            ce.blendDst,
            ce.blendEquationAlpha,
            ce.blendSrcAlpha,
            ce.blendDstAlpha,
            ce.blendColor,
            ce.blendAlpha,
            ce.premultipliedAlpha,
          ),
      o.setFunc(ce.depthFunc),
      o.setTest(ce.depthTest),
      o.setMask(ce.depthWrite),
      s.setMask(ce.colorWrite));
    const dt = ce.stencilWrite;
    (u.setTest(dt),
      dt &&
        (u.setMask(ce.stencilWriteMask),
        u.setFunc(ce.stencilFunc, ce.stencilRef, ce.stencilFuncMask),
        u.setOp(ce.stencilFail, ce.stencilZFail, ce.stencilZPass)),
      rt(ce.polygonOffset, ce.polygonOffsetFactor, ce.polygonOffsetUnits),
      ce.alphaToCoverage === !0
        ? he(i.SAMPLE_ALPHA_TO_COVERAGE)
        : ye(i.SAMPLE_ALPHA_TO_COVERAGE));
  }
  function De(ce) {
    j !== ce && (ce ? i.frontFace(i.CW) : i.frontFace(i.CCW), (j = ce));
  }
  function Qe(ce) {
    (ce !== pL
      ? (he(i.CULL_FACE),
        ce !== q &&
          (ce === xM
            ? i.cullFace(i.BACK)
            : ce === mL
              ? i.cullFace(i.FRONT)
              : i.cullFace(i.FRONT_AND_BACK)))
      : ye(i.CULL_FACE),
      (q = ce));
  }
  function K(ce) {
    ce !== X && (W && i.lineWidth(ce), (X = ce));
  }
  function rt(ce, Oe, Ke) {
    ce
      ? (he(i.POLYGON_OFFSET_FILL),
        (J !== Oe || ee !== Ke) &&
          ((J = Oe),
          (ee = Ke),
          o.getReversed() && (Oe = -Oe),
          i.polygonOffset(Oe, Ke)))
      : ye(i.POLYGON_OFFSET_FILL);
  }
  function je(ce) {
    ce ? he(i.SCISSOR_TEST) : ye(i.SCISSOR_TEST);
  }
  function Te(ce) {
    (ce === void 0 && (ce = i.TEXTURE0 + ne - 1),
      le !== ce && (i.activeTexture(ce), (le = ce)));
  }
  function ke(ce, Oe, Ke) {
    Ke === void 0 && (le === null ? (Ke = i.TEXTURE0 + ne - 1) : (Ke = le));
    let dt = fe[Ke];
    (dt === void 0 && ((dt = { type: void 0, texture: void 0 }), (fe[Ke] = dt)),
      (dt.type !== ce || dt.texture !== Oe) &&
        (le !== Ke && (i.activeTexture(Ke), (le = Ke)),
        i.bindTexture(ce, Oe || ae[ce]),
        (dt.type = ce),
        (dt.texture = Oe)));
  }
  function H() {
    const ce = fe[le];
    ce !== void 0 &&
      ce.type !== void 0 &&
      (i.bindTexture(ce.type, null), (ce.type = void 0), (ce.texture = void 0));
  }
  function k() {
    try {
      i.compressedTexImage2D(...arguments);
    } catch (ce) {
      Ft("WebGLState:", ce);
    }
  }
  function oe() {
    try {
      i.compressedTexImage3D(...arguments);
    } catch (ce) {
      Ft("WebGLState:", ce);
    }
  }
  function Ae() {
    try {
      i.texSubImage2D(...arguments);
    } catch (ce) {
      Ft("WebGLState:", ce);
    }
  }
  function _e() {
    try {
      i.texSubImage3D(...arguments);
    } catch (ce) {
      Ft("WebGLState:", ce);
    }
  }
  function be() {
    try {
      i.compressedTexSubImage2D(...arguments);
    } catch (ce) {
      Ft("WebGLState:", ce);
    }
  }
  function et() {
    try {
      i.compressedTexSubImage3D(...arguments);
    } catch (ce) {
      Ft("WebGLState:", ce);
    }
  }
  function $e() {
    try {
      i.texStorage2D(...arguments);
    } catch (ce) {
      Ft("WebGLState:", ce);
    }
  }
  function ht() {
    try {
      i.texStorage3D(...arguments);
    } catch (ce) {
      Ft("WebGLState:", ce);
    }
  }
  function yt() {
    try {
      i.texImage2D(...arguments);
    } catch (ce) {
      Ft("WebGLState:", ce);
    }
  }
  function Ge() {
    try {
      i.texImage3D(...arguments);
    } catch (ce) {
      Ft("WebGLState:", ce);
    }
  }
  function Ve(ce) {
    se.equals(ce) === !1 && (i.scissor(ce.x, ce.y, ce.z, ce.w), se.copy(ce));
  }
  function Ze(ce) {
    ue.equals(ce) === !1 && (i.viewport(ce.x, ce.y, ce.z, ce.w), ue.copy(ce));
  }
  function re(ce, Oe) {
    let Ke = d.get(Oe);
    Ke === void 0 && ((Ke = new WeakMap()), d.set(Oe, Ke));
    let dt = Ke.get(ce);
    dt === void 0 &&
      ((dt = i.getUniformBlockIndex(Oe, ce.name)), Ke.set(ce, dt));
  }
  function Se(ce, Oe) {
    const dt = d.get(Oe).get(ce);
    h.get(Oe) !== dt &&
      (i.uniformBlockBinding(Oe, dt, ce.__bindingPointIndex), h.set(Oe, dt));
  }
  function lt() {
    (i.disable(i.BLEND),
      i.disable(i.CULL_FACE),
      i.disable(i.DEPTH_TEST),
      i.disable(i.POLYGON_OFFSET_FILL),
      i.disable(i.SCISSOR_TEST),
      i.disable(i.STENCIL_TEST),
      i.disable(i.SAMPLE_ALPHA_TO_COVERAGE),
      i.blendEquation(i.FUNC_ADD),
      i.blendFunc(i.ONE, i.ZERO),
      i.blendFuncSeparate(i.ONE, i.ZERO, i.ONE, i.ZERO),
      i.blendColor(0, 0, 0, 0),
      i.colorMask(!0, !0, !0, !0),
      i.clearColor(0, 0, 0, 0),
      i.depthMask(!0),
      i.depthFunc(i.LESS),
      o.setReversed(!1),
      i.clearDepth(1),
      i.stencilMask(4294967295),
      i.stencilFunc(i.ALWAYS, 0, 4294967295),
      i.stencilOp(i.KEEP, i.KEEP, i.KEEP),
      i.clearStencil(0),
      i.cullFace(i.BACK),
      i.frontFace(i.CCW),
      i.polygonOffset(0, 0),
      i.activeTexture(i.TEXTURE0),
      i.bindFramebuffer(i.FRAMEBUFFER, null),
      i.bindFramebuffer(i.DRAW_FRAMEBUFFER, null),
      i.bindFramebuffer(i.READ_FRAMEBUFFER, null),
      i.useProgram(null),
      i.lineWidth(1),
      i.scissor(0, 0, i.canvas.width, i.canvas.height),
      i.viewport(0, 0, i.canvas.width, i.canvas.height),
      (m = {}),
      (le = null),
      (fe = {}),
      (v = {}),
      (y = new WeakMap()),
      (b = []),
      (_ = null),
      (w = !1),
      (E = null),
      (T = null),
      (C = null),
      (R = null),
      (L = null),
      (I = null),
      (O = null),
      (B = new wt(0, 0, 0)),
      (N = 0),
      (F = !1),
      (j = null),
      (q = null),
      (X = null),
      (J = null),
      (ee = null),
      se.set(0, 0, i.canvas.width, i.canvas.height),
      ue.set(0, 0, i.canvas.width, i.canvas.height),
      s.reset(),
      o.reset(),
      u.reset());
  }
  return {
    buffers: { color: s, depth: o, stencil: u },
    enable: he,
    disable: ye,
    bindFramebuffer: ze,
    drawBuffers: it,
    useProgram: qe,
    setBlending: Re,
    setMaterial: Ie,
    setFlipSided: De,
    setCullFace: Qe,
    setLineWidth: K,
    setPolygonOffset: rt,
    setScissorTest: je,
    activeTexture: Te,
    bindTexture: ke,
    unbindTexture: H,
    compressedTexImage2D: k,
    compressedTexImage3D: oe,
    texImage2D: yt,
    texImage3D: Ge,
    updateUBOMapping: re,
    uniformBlockBinding: Se,
    texStorage2D: $e,
    texStorage3D: ht,
    texSubImage2D: Ae,
    texSubImage3D: _e,
    compressedTexSubImage2D: be,
    compressedTexSubImage3D: et,
    scissor: Ve,
    viewport: Ze,
    reset: lt,
  };
}
function h9(i, e, t, n, r, s, o) {
  const u = e.has("WEBGL_multisampled_render_to_texture")
      ? e.get("WEBGL_multisampled_render_to_texture")
      : null,
    h =
      typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent),
    d = new nt(),
    m = new WeakMap();
  let v;
  const y = new WeakMap();
  let b = !1;
  try {
    b =
      typeof OffscreenCanvas < "u" &&
      new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {}
  function _(H, k) {
    return b ? new OffscreenCanvas(H, k) : u0("canvas");
  }
  function w(H, k, oe) {
    let Ae = 1;
    const _e = ke(H);
    if (
      ((_e.width > oe || _e.height > oe) &&
        (Ae = oe / Math.max(_e.width, _e.height)),
      Ae < 1)
    )
      if (
        (typeof HTMLImageElement < "u" && H instanceof HTMLImageElement) ||
        (typeof HTMLCanvasElement < "u" && H instanceof HTMLCanvasElement) ||
        (typeof ImageBitmap < "u" && H instanceof ImageBitmap) ||
        (typeof VideoFrame < "u" && H instanceof VideoFrame)
      ) {
        const be = Math.floor(Ae * _e.width),
          et = Math.floor(Ae * _e.height);
        v === void 0 && (v = _(be, et));
        const $e = k ? _(be, et) : v;
        return (
          ($e.width = be),
          ($e.height = et),
          $e.getContext("2d").drawImage(H, 0, 0, be, et),
          Tt(
            "WebGLRenderer: Texture has been resized from (" +
              _e.width +
              "x" +
              _e.height +
              ") to (" +
              be +
              "x" +
              et +
              ").",
          ),
          $e
        );
      } else
        return (
          "data" in H &&
            Tt(
              "WebGLRenderer: Image in DataTexture is too big (" +
                _e.width +
                "x" +
                _e.height +
                ").",
            ),
          H
        );
    return H;
  }
  function E(H) {
    return H.generateMipmaps;
  }
  function T(H) {
    i.generateMipmap(H);
  }
  function C(H) {
    return H.isWebGLCubeRenderTarget
      ? i.TEXTURE_CUBE_MAP
      : H.isWebGL3DRenderTarget
        ? i.TEXTURE_3D
        : H.isWebGLArrayRenderTarget || H.isCompressedArrayTexture
          ? i.TEXTURE_2D_ARRAY
          : i.TEXTURE_2D;
  }
  function R(H, k, oe, Ae, _e = !1) {
    if (H !== null) {
      if (i[H] !== void 0) return i[H];
      Tt(
        "WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
          H +
          "'",
      );
    }
    let be = k;
    if (
      (k === i.RED &&
        (oe === i.FLOAT && (be = i.R32F),
        oe === i.HALF_FLOAT && (be = i.R16F),
        oe === i.UNSIGNED_BYTE && (be = i.R8)),
      k === i.RED_INTEGER &&
        (oe === i.UNSIGNED_BYTE && (be = i.R8UI),
        oe === i.UNSIGNED_SHORT && (be = i.R16UI),
        oe === i.UNSIGNED_INT && (be = i.R32UI),
        oe === i.BYTE && (be = i.R8I),
        oe === i.SHORT && (be = i.R16I),
        oe === i.INT && (be = i.R32I)),
      k === i.RG &&
        (oe === i.FLOAT && (be = i.RG32F),
        oe === i.HALF_FLOAT && (be = i.RG16F),
        oe === i.UNSIGNED_BYTE && (be = i.RG8)),
      k === i.RG_INTEGER &&
        (oe === i.UNSIGNED_BYTE && (be = i.RG8UI),
        oe === i.UNSIGNED_SHORT && (be = i.RG16UI),
        oe === i.UNSIGNED_INT && (be = i.RG32UI),
        oe === i.BYTE && (be = i.RG8I),
        oe === i.SHORT && (be = i.RG16I),
        oe === i.INT && (be = i.RG32I)),
      k === i.RGB_INTEGER &&
        (oe === i.UNSIGNED_BYTE && (be = i.RGB8UI),
        oe === i.UNSIGNED_SHORT && (be = i.RGB16UI),
        oe === i.UNSIGNED_INT && (be = i.RGB32UI),
        oe === i.BYTE && (be = i.RGB8I),
        oe === i.SHORT && (be = i.RGB16I),
        oe === i.INT && (be = i.RGB32I)),
      k === i.RGBA_INTEGER &&
        (oe === i.UNSIGNED_BYTE && (be = i.RGBA8UI),
        oe === i.UNSIGNED_SHORT && (be = i.RGBA16UI),
        oe === i.UNSIGNED_INT && (be = i.RGBA32UI),
        oe === i.BYTE && (be = i.RGBA8I),
        oe === i.SHORT && (be = i.RGBA16I),
        oe === i.INT && (be = i.RGBA32I)),
      k === i.RGB &&
        (oe === i.UNSIGNED_INT_5_9_9_9_REV && (be = i.RGB9_E5),
        oe === i.UNSIGNED_INT_10F_11F_11F_REV && (be = i.R11F_G11F_B10F)),
      k === i.RGBA)
    ) {
      const et = _e ? l0 : Cn.getTransfer(Ae);
      (oe === i.FLOAT && (be = i.RGBA32F),
        oe === i.HALF_FLOAT && (be = i.RGBA16F),
        oe === i.UNSIGNED_BYTE && (be = et === Xn ? i.SRGB8_ALPHA8 : i.RGBA8),
        oe === i.UNSIGNED_SHORT_4_4_4_4 && (be = i.RGBA4),
        oe === i.UNSIGNED_SHORT_5_5_5_1 && (be = i.RGB5_A1));
    }
    return (
      (be === i.R16F ||
        be === i.R32F ||
        be === i.RG16F ||
        be === i.RG32F ||
        be === i.RGBA16F ||
        be === i.RGBA32F) &&
        e.get("EXT_color_buffer_float"),
      be
    );
  }
  function L(H, k) {
    let oe;
    return (
      H
        ? k === null || k === bo || k === Ep
          ? (oe = i.DEPTH24_STENCIL8)
          : k === Hs
            ? (oe = i.DEPTH32F_STENCIL8)
            : k === Tp &&
              ((oe = i.DEPTH24_STENCIL8),
              Tt(
                "DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.",
              ))
        : k === null || k === bo || k === Ep
          ? (oe = i.DEPTH_COMPONENT24)
          : k === Hs
            ? (oe = i.DEPTH_COMPONENT32F)
            : k === Tp && (oe = i.DEPTH_COMPONENT16),
      oe
    );
  }
  function I(H, k) {
    return E(H) === !0 ||
      (H.isFramebufferTexture && H.minFilter !== rr && H.minFilter !== ni)
      ? Math.log2(Math.max(k.width, k.height)) + 1
      : H.mipmaps !== void 0 && H.mipmaps.length > 0
        ? H.mipmaps.length
        : H.isCompressedTexture && Array.isArray(H.image)
          ? k.mipmaps.length
          : 1;
  }
  function O(H) {
    const k = H.target;
    (k.removeEventListener("dispose", O),
      N(k),
      k.isVideoTexture && m.delete(k));
  }
  function B(H) {
    const k = H.target;
    (k.removeEventListener("dispose", B), j(k));
  }
  function N(H) {
    const k = n.get(H);
    if (k.__webglInit === void 0) return;
    const oe = H.source,
      Ae = y.get(oe);
    if (Ae) {
      const _e = Ae[k.__cacheKey];
      (_e.usedTimes--,
        _e.usedTimes === 0 && F(H),
        Object.keys(Ae).length === 0 && y.delete(oe));
    }
    n.remove(H);
  }
  function F(H) {
    const k = n.get(H);
    i.deleteTexture(k.__webglTexture);
    const oe = H.source,
      Ae = y.get(oe);
    (delete Ae[k.__cacheKey], o.memory.textures--);
  }
  function j(H) {
    const k = n.get(H);
    if (
      (H.depthTexture && (H.depthTexture.dispose(), n.remove(H.depthTexture)),
      H.isWebGLCubeRenderTarget)
    )
      for (let Ae = 0; Ae < 6; Ae++) {
        if (Array.isArray(k.__webglFramebuffer[Ae]))
          for (let _e = 0; _e < k.__webglFramebuffer[Ae].length; _e++)
            i.deleteFramebuffer(k.__webglFramebuffer[Ae][_e]);
        else i.deleteFramebuffer(k.__webglFramebuffer[Ae]);
        k.__webglDepthbuffer && i.deleteRenderbuffer(k.__webglDepthbuffer[Ae]);
      }
    else {
      if (Array.isArray(k.__webglFramebuffer))
        for (let Ae = 0; Ae < k.__webglFramebuffer.length; Ae++)
          i.deleteFramebuffer(k.__webglFramebuffer[Ae]);
      else i.deleteFramebuffer(k.__webglFramebuffer);
      if (
        (k.__webglDepthbuffer && i.deleteRenderbuffer(k.__webglDepthbuffer),
        k.__webglMultisampledFramebuffer &&
          i.deleteFramebuffer(k.__webglMultisampledFramebuffer),
        k.__webglColorRenderbuffer)
      )
        for (let Ae = 0; Ae < k.__webglColorRenderbuffer.length; Ae++)
          k.__webglColorRenderbuffer[Ae] &&
            i.deleteRenderbuffer(k.__webglColorRenderbuffer[Ae]);
      k.__webglDepthRenderbuffer &&
        i.deleteRenderbuffer(k.__webglDepthRenderbuffer);
    }
    const oe = H.textures;
    for (let Ae = 0, _e = oe.length; Ae < _e; Ae++) {
      const be = n.get(oe[Ae]);
      (be.__webglTexture &&
        (i.deleteTexture(be.__webglTexture), o.memory.textures--),
        n.remove(oe[Ae]));
    }
    n.remove(H);
  }
  let q = 0;
  function X() {
    q = 0;
  }
  function J() {
    const H = q;
    return (
      H >= r.maxTextures &&
        Tt(
          "WebGLTextures: Trying to use " +
            H +
            " texture units while this GPU supports only " +
            r.maxTextures,
        ),
      (q += 1),
      H
    );
  }
  function ee(H) {
    const k = [];
    return (
      k.push(H.wrapS),
      k.push(H.wrapT),
      k.push(H.wrapR || 0),
      k.push(H.magFilter),
      k.push(H.minFilter),
      k.push(H.anisotropy),
      k.push(H.internalFormat),
      k.push(H.format),
      k.push(H.type),
      k.push(H.generateMipmaps),
      k.push(H.premultiplyAlpha),
      k.push(H.flipY),
      k.push(H.unpackAlignment),
      k.push(H.colorSpace),
      k.join()
    );
  }
  function ne(H, k) {
    const oe = n.get(H);
    if (
      (H.isVideoTexture && je(H),
      H.isRenderTargetTexture === !1 &&
        H.isExternalTexture !== !0 &&
        H.version > 0 &&
        oe.__version !== H.version)
    ) {
      const Ae = H.image;
      if (Ae === null)
        Tt("WebGLRenderer: Texture marked for update but no image data found.");
      else if (Ae.complete === !1)
        Tt("WebGLRenderer: Texture marked for update but image is incomplete");
      else {
        ae(oe, H, k);
        return;
      }
    } else
      H.isExternalTexture &&
        (oe.__webglTexture = H.sourceTexture ? H.sourceTexture : null);
    t.bindTexture(i.TEXTURE_2D, oe.__webglTexture, i.TEXTURE0 + k);
  }
  function W(H, k) {
    const oe = n.get(H);
    if (
      H.isRenderTargetTexture === !1 &&
      H.version > 0 &&
      oe.__version !== H.version
    ) {
      ae(oe, H, k);
      return;
    } else
      H.isExternalTexture &&
        (oe.__webglTexture = H.sourceTexture ? H.sourceTexture : null);
    t.bindTexture(i.TEXTURE_2D_ARRAY, oe.__webglTexture, i.TEXTURE0 + k);
  }
  function $(H, k) {
    const oe = n.get(H);
    if (
      H.isRenderTargetTexture === !1 &&
      H.version > 0 &&
      oe.__version !== H.version
    ) {
      ae(oe, H, k);
      return;
    }
    t.bindTexture(i.TEXTURE_3D, oe.__webglTexture, i.TEXTURE0 + k);
  }
  function de(H, k) {
    const oe = n.get(H);
    if (
      H.isCubeDepthTexture !== !0 &&
      H.version > 0 &&
      oe.__version !== H.version
    ) {
      he(oe, H, k);
      return;
    }
    t.bindTexture(i.TEXTURE_CUBE_MAP, oe.__webglTexture, i.TEXTURE0 + k);
  }
  const le = { [r0]: i.REPEAT, [xa]: i.CLAMP_TO_EDGE, [s0]: i.MIRRORED_REPEAT },
    fe = {
      [rr]: i.NEAREST,
      [IT]: i.NEAREST_MIPMAP_NEAREST,
      [vp]: i.NEAREST_MIPMAP_LINEAR,
      [ni]: i.LINEAR,
      [kg]: i.LINEAR_MIPMAP_NEAREST,
      [Hl]: i.LINEAR_MIPMAP_LINEAR,
    },
    V = {
      [jL]: i.NEVER,
      [ZL]: i.ALWAYS,
      [WL]: i.LESS,
      [rb]: i.LEQUAL,
      [XL]: i.EQUAL,
      [sb]: i.GEQUAL,
      [qL]: i.GREATER,
      [YL]: i.NOTEQUAL,
    };
  function Z(H, k) {
    if (
      (k.type === Hs &&
        e.has("OES_texture_float_linear") === !1 &&
        (k.magFilter === ni ||
          k.magFilter === kg ||
          k.magFilter === vp ||
          k.magFilter === Hl ||
          k.minFilter === ni ||
          k.minFilter === kg ||
          k.minFilter === vp ||
          k.minFilter === Hl) &&
        Tt(
          "WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device.",
        ),
      i.texParameteri(H, i.TEXTURE_WRAP_S, le[k.wrapS]),
      i.texParameteri(H, i.TEXTURE_WRAP_T, le[k.wrapT]),
      (H === i.TEXTURE_3D || H === i.TEXTURE_2D_ARRAY) &&
        i.texParameteri(H, i.TEXTURE_WRAP_R, le[k.wrapR]),
      i.texParameteri(H, i.TEXTURE_MAG_FILTER, fe[k.magFilter]),
      i.texParameteri(H, i.TEXTURE_MIN_FILTER, fe[k.minFilter]),
      k.compareFunction &&
        (i.texParameteri(H, i.TEXTURE_COMPARE_MODE, i.COMPARE_REF_TO_TEXTURE),
        i.texParameteri(H, i.TEXTURE_COMPARE_FUNC, V[k.compareFunction])),
      e.has("EXT_texture_filter_anisotropic") === !0)
    ) {
      if (
        k.magFilter === rr ||
        (k.minFilter !== vp && k.minFilter !== Hl) ||
        (k.type === Hs && e.has("OES_texture_float_linear") === !1)
      )
        return;
      if (k.anisotropy > 1 || n.get(k).__currentAnisotropy) {
        const oe = e.get("EXT_texture_filter_anisotropic");
        (i.texParameterf(
          H,
          oe.TEXTURE_MAX_ANISOTROPY_EXT,
          Math.min(k.anisotropy, r.getMaxAnisotropy()),
        ),
          (n.get(k).__currentAnisotropy = k.anisotropy));
      }
    }
  }
  function se(H, k) {
    let oe = !1;
    H.__webglInit === void 0 &&
      ((H.__webglInit = !0), k.addEventListener("dispose", O));
    const Ae = k.source;
    let _e = y.get(Ae);
    _e === void 0 && ((_e = {}), y.set(Ae, _e));
    const be = ee(k);
    if (be !== H.__cacheKey) {
      (_e[be] === void 0 &&
        ((_e[be] = { texture: i.createTexture(), usedTimes: 0 }),
        o.memory.textures++,
        (oe = !0)),
        _e[be].usedTimes++);
      const et = _e[H.__cacheKey];
      (et !== void 0 &&
        (_e[H.__cacheKey].usedTimes--, et.usedTimes === 0 && F(k)),
        (H.__cacheKey = be),
        (H.__webglTexture = _e[be].texture));
    }
    return oe;
  }
  function ue(H, k, oe) {
    return Math.floor(Math.floor(H / oe) / k);
  }
  function ge(H, k, oe, Ae) {
    const be = H.updateRanges;
    if (be.length === 0)
      t.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, k.width, k.height, oe, Ae, k.data);
    else {
      be.sort((Ge, Ve) => Ge.start - Ve.start);
      let et = 0;
      for (let Ge = 1; Ge < be.length; Ge++) {
        const Ve = be[et],
          Ze = be[Ge],
          re = Ve.start + Ve.count,
          Se = ue(Ze.start, k.width, 4),
          lt = ue(Ve.start, k.width, 4);
        Ze.start <= re + 1 &&
        Se === lt &&
        ue(Ze.start + Ze.count - 1, k.width, 4) === Se
          ? (Ve.count = Math.max(Ve.count, Ze.start + Ze.count - Ve.start))
          : (++et, (be[et] = Ze));
      }
      be.length = et + 1;
      const $e = i.getParameter(i.UNPACK_ROW_LENGTH),
        ht = i.getParameter(i.UNPACK_SKIP_PIXELS),
        yt = i.getParameter(i.UNPACK_SKIP_ROWS);
      i.pixelStorei(i.UNPACK_ROW_LENGTH, k.width);
      for (let Ge = 0, Ve = be.length; Ge < Ve; Ge++) {
        const Ze = be[Ge],
          re = Math.floor(Ze.start / 4),
          Se = Math.ceil(Ze.count / 4),
          lt = re % k.width,
          ce = Math.floor(re / k.width),
          Oe = Se,
          Ke = 1;
        (i.pixelStorei(i.UNPACK_SKIP_PIXELS, lt),
          i.pixelStorei(i.UNPACK_SKIP_ROWS, ce),
          t.texSubImage2D(i.TEXTURE_2D, 0, lt, ce, Oe, Ke, oe, Ae, k.data));
      }
      (H.clearUpdateRanges(),
        i.pixelStorei(i.UNPACK_ROW_LENGTH, $e),
        i.pixelStorei(i.UNPACK_SKIP_PIXELS, ht),
        i.pixelStorei(i.UNPACK_SKIP_ROWS, yt));
    }
  }
  function ae(H, k, oe) {
    let Ae = i.TEXTURE_2D;
    ((k.isDataArrayTexture || k.isCompressedArrayTexture) &&
      (Ae = i.TEXTURE_2D_ARRAY),
      k.isData3DTexture && (Ae = i.TEXTURE_3D));
    const _e = se(H, k),
      be = k.source;
    t.bindTexture(Ae, H.__webglTexture, i.TEXTURE0 + oe);
    const et = n.get(be);
    if (be.version !== et.__version || _e === !0) {
      t.activeTexture(i.TEXTURE0 + oe);
      const $e = Cn.getPrimaries(Cn.workingColorSpace),
        ht = k.colorSpace === Gc ? null : Cn.getPrimaries(k.colorSpace),
        yt =
          k.colorSpace === Gc || $e === ht ? i.NONE : i.BROWSER_DEFAULT_WEBGL;
      (i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL, k.flipY),
        i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, k.premultiplyAlpha),
        i.pixelStorei(i.UNPACK_ALIGNMENT, k.unpackAlignment),
        i.pixelStorei(i.UNPACK_COLORSPACE_CONVERSION_WEBGL, yt));
      let Ge = w(k.image, !1, r.maxTextureSize);
      Ge = Te(k, Ge);
      const Ve = s.convert(k.format, k.colorSpace),
        Ze = s.convert(k.type);
      let re = R(k.internalFormat, Ve, Ze, k.colorSpace, k.isVideoTexture);
      Z(Ae, k);
      let Se;
      const lt = k.mipmaps,
        ce = k.isVideoTexture !== !0,
        Oe = et.__version === void 0 || _e === !0,
        Ke = be.dataReady,
        dt = I(k, Ge);
      if (k.isDepthTexture)
        ((re = L(k.format === $u, k.type)),
          Oe &&
            (ce
              ? t.texStorage2D(i.TEXTURE_2D, 1, re, Ge.width, Ge.height)
              : t.texImage2D(
                  i.TEXTURE_2D,
                  0,
                  re,
                  Ge.width,
                  Ge.height,
                  0,
                  Ve,
                  Ze,
                  null,
                )));
      else if (k.isDataTexture)
        if (lt.length > 0) {
          ce &&
            Oe &&
            t.texStorage2D(i.TEXTURE_2D, dt, re, lt[0].width, lt[0].height);
          for (let Je = 0, Ee = lt.length; Je < Ee; Je++)
            ((Se = lt[Je]),
              ce
                ? Ke &&
                  t.texSubImage2D(
                    i.TEXTURE_2D,
                    Je,
                    0,
                    0,
                    Se.width,
                    Se.height,
                    Ve,
                    Ze,
                    Se.data,
                  )
                : t.texImage2D(
                    i.TEXTURE_2D,
                    Je,
                    re,
                    Se.width,
                    Se.height,
                    0,
                    Ve,
                    Ze,
                    Se.data,
                  ));
          k.generateMipmaps = !1;
        } else
          ce
            ? (Oe && t.texStorage2D(i.TEXTURE_2D, dt, re, Ge.width, Ge.height),
              Ke && ge(k, Ge, Ve, Ze))
            : t.texImage2D(
                i.TEXTURE_2D,
                0,
                re,
                Ge.width,
                Ge.height,
                0,
                Ve,
                Ze,
                Ge.data,
              );
      else if (k.isCompressedTexture)
        if (k.isCompressedArrayTexture) {
          ce &&
            Oe &&
            t.texStorage3D(
              i.TEXTURE_2D_ARRAY,
              dt,
              re,
              lt[0].width,
              lt[0].height,
              Ge.depth,
            );
          for (let Je = 0, Ee = lt.length; Je < Ee; Je++)
            if (((Se = lt[Je]), k.format !== xs))
              if (Ve !== null)
                if (ce) {
                  if (Ke)
                    if (k.layerUpdates.size > 0) {
                      const ct = NM(Se.width, Se.height, k.format, k.type);
                      for (const Mt of k.layerUpdates) {
                        const St = Se.data.subarray(
                          (Mt * ct) / Se.data.BYTES_PER_ELEMENT,
                          ((Mt + 1) * ct) / Se.data.BYTES_PER_ELEMENT,
                        );
                        t.compressedTexSubImage3D(
                          i.TEXTURE_2D_ARRAY,
                          Je,
                          0,
                          0,
                          Mt,
                          Se.width,
                          Se.height,
                          1,
                          Ve,
                          St,
                        );
                      }
                      k.clearLayerUpdates();
                    } else
                      t.compressedTexSubImage3D(
                        i.TEXTURE_2D_ARRAY,
                        Je,
                        0,
                        0,
                        0,
                        Se.width,
                        Se.height,
                        Ge.depth,
                        Ve,
                        Se.data,
                      );
                } else
                  t.compressedTexImage3D(
                    i.TEXTURE_2D_ARRAY,
                    Je,
                    re,
                    Se.width,
                    Se.height,
                    Ge.depth,
                    0,
                    Se.data,
                    0,
                    0,
                  );
              else
                Tt(
                  "WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()",
                );
            else
              ce
                ? Ke &&
                  t.texSubImage3D(
                    i.TEXTURE_2D_ARRAY,
                    Je,
                    0,
                    0,
                    0,
                    Se.width,
                    Se.height,
                    Ge.depth,
                    Ve,
                    Ze,
                    Se.data,
                  )
                : t.texImage3D(
                    i.TEXTURE_2D_ARRAY,
                    Je,
                    re,
                    Se.width,
                    Se.height,
                    Ge.depth,
                    0,
                    Ve,
                    Ze,
                    Se.data,
                  );
        } else {
          ce &&
            Oe &&
            t.texStorage2D(i.TEXTURE_2D, dt, re, lt[0].width, lt[0].height);
          for (let Je = 0, Ee = lt.length; Je < Ee; Je++)
            ((Se = lt[Je]),
              k.format !== xs
                ? Ve !== null
                  ? ce
                    ? Ke &&
                      t.compressedTexSubImage2D(
                        i.TEXTURE_2D,
                        Je,
                        0,
                        0,
                        Se.width,
                        Se.height,
                        Ve,
                        Se.data,
                      )
                    : t.compressedTexImage2D(
                        i.TEXTURE_2D,
                        Je,
                        re,
                        Se.width,
                        Se.height,
                        0,
                        Se.data,
                      )
                  : Tt(
                      "WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()",
                    )
                : ce
                  ? Ke &&
                    t.texSubImage2D(
                      i.TEXTURE_2D,
                      Je,
                      0,
                      0,
                      Se.width,
                      Se.height,
                      Ve,
                      Ze,
                      Se.data,
                    )
                  : t.texImage2D(
                      i.TEXTURE_2D,
                      Je,
                      re,
                      Se.width,
                      Se.height,
                      0,
                      Ve,
                      Ze,
                      Se.data,
                    ));
        }
      else if (k.isDataArrayTexture)
        if (ce) {
          if (
            (Oe &&
              t.texStorage3D(
                i.TEXTURE_2D_ARRAY,
                dt,
                re,
                Ge.width,
                Ge.height,
                Ge.depth,
              ),
            Ke)
          )
            if (k.layerUpdates.size > 0) {
              const Je = NM(Ge.width, Ge.height, k.format, k.type);
              for (const Ee of k.layerUpdates) {
                const ct = Ge.data.subarray(
                  (Ee * Je) / Ge.data.BYTES_PER_ELEMENT,
                  ((Ee + 1) * Je) / Ge.data.BYTES_PER_ELEMENT,
                );
                t.texSubImage3D(
                  i.TEXTURE_2D_ARRAY,
                  0,
                  0,
                  0,
                  Ee,
                  Ge.width,
                  Ge.height,
                  1,
                  Ve,
                  Ze,
                  ct,
                );
              }
              k.clearLayerUpdates();
            } else
              t.texSubImage3D(
                i.TEXTURE_2D_ARRAY,
                0,
                0,
                0,
                0,
                Ge.width,
                Ge.height,
                Ge.depth,
                Ve,
                Ze,
                Ge.data,
              );
        } else
          t.texImage3D(
            i.TEXTURE_2D_ARRAY,
            0,
            re,
            Ge.width,
            Ge.height,
            Ge.depth,
            0,
            Ve,
            Ze,
            Ge.data,
          );
      else if (k.isData3DTexture)
        ce
          ? (Oe &&
              t.texStorage3D(
                i.TEXTURE_3D,
                dt,
                re,
                Ge.width,
                Ge.height,
                Ge.depth,
              ),
            Ke &&
              t.texSubImage3D(
                i.TEXTURE_3D,
                0,
                0,
                0,
                0,
                Ge.width,
                Ge.height,
                Ge.depth,
                Ve,
                Ze,
                Ge.data,
              ))
          : t.texImage3D(
              i.TEXTURE_3D,
              0,
              re,
              Ge.width,
              Ge.height,
              Ge.depth,
              0,
              Ve,
              Ze,
              Ge.data,
            );
      else if (k.isFramebufferTexture) {
        if (Oe)
          if (ce) t.texStorage2D(i.TEXTURE_2D, dt, re, Ge.width, Ge.height);
          else {
            let Je = Ge.width,
              Ee = Ge.height;
            for (let ct = 0; ct < dt; ct++)
              (t.texImage2D(i.TEXTURE_2D, ct, re, Je, Ee, 0, Ve, Ze, null),
                (Je >>= 1),
                (Ee >>= 1));
          }
      } else if (lt.length > 0) {
        if (ce && Oe) {
          const Je = ke(lt[0]);
          t.texStorage2D(i.TEXTURE_2D, dt, re, Je.width, Je.height);
        }
        for (let Je = 0, Ee = lt.length; Je < Ee; Je++)
          ((Se = lt[Je]),
            ce
              ? Ke && t.texSubImage2D(i.TEXTURE_2D, Je, 0, 0, Ve, Ze, Se)
              : t.texImage2D(i.TEXTURE_2D, Je, re, Ve, Ze, Se));
        k.generateMipmaps = !1;
      } else if (ce) {
        if (Oe) {
          const Je = ke(Ge);
          t.texStorage2D(i.TEXTURE_2D, dt, re, Je.width, Je.height);
        }
        Ke && t.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, Ve, Ze, Ge);
      } else t.texImage2D(i.TEXTURE_2D, 0, re, Ve, Ze, Ge);
      (E(k) && T(Ae), (et.__version = be.version), k.onUpdate && k.onUpdate(k));
    }
    H.__version = k.version;
  }
  function he(H, k, oe) {
    if (k.image.length !== 6) return;
    const Ae = se(H, k),
      _e = k.source;
    t.bindTexture(i.TEXTURE_CUBE_MAP, H.__webglTexture, i.TEXTURE0 + oe);
    const be = n.get(_e);
    if (_e.version !== be.__version || Ae === !0) {
      t.activeTexture(i.TEXTURE0 + oe);
      const et = Cn.getPrimaries(Cn.workingColorSpace),
        $e = k.colorSpace === Gc ? null : Cn.getPrimaries(k.colorSpace),
        ht =
          k.colorSpace === Gc || et === $e ? i.NONE : i.BROWSER_DEFAULT_WEBGL;
      (i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL, k.flipY),
        i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, k.premultiplyAlpha),
        i.pixelStorei(i.UNPACK_ALIGNMENT, k.unpackAlignment),
        i.pixelStorei(i.UNPACK_COLORSPACE_CONVERSION_WEBGL, ht));
      const yt = k.isCompressedTexture || k.image[0].isCompressedTexture,
        Ge = k.image[0] && k.image[0].isDataTexture,
        Ve = [];
      for (let Ee = 0; Ee < 6; Ee++)
        (!yt && !Ge
          ? (Ve[Ee] = w(k.image[Ee], !0, r.maxCubemapSize))
          : (Ve[Ee] = Ge ? k.image[Ee].image : k.image[Ee]),
          (Ve[Ee] = Te(k, Ve[Ee])));
      const Ze = Ve[0],
        re = s.convert(k.format, k.colorSpace),
        Se = s.convert(k.type),
        lt = R(k.internalFormat, re, Se, k.colorSpace),
        ce = k.isVideoTexture !== !0,
        Oe = be.__version === void 0 || Ae === !0,
        Ke = _e.dataReady;
      let dt = I(k, Ze);
      Z(i.TEXTURE_CUBE_MAP, k);
      let Je;
      if (yt) {
        ce &&
          Oe &&
          t.texStorage2D(i.TEXTURE_CUBE_MAP, dt, lt, Ze.width, Ze.height);
        for (let Ee = 0; Ee < 6; Ee++) {
          Je = Ve[Ee].mipmaps;
          for (let ct = 0; ct < Je.length; ct++) {
            const Mt = Je[ct];
            k.format !== xs
              ? re !== null
                ? ce
                  ? Ke &&
                    t.compressedTexSubImage2D(
                      i.TEXTURE_CUBE_MAP_POSITIVE_X + Ee,
                      ct,
                      0,
                      0,
                      Mt.width,
                      Mt.height,
                      re,
                      Mt.data,
                    )
                  : t.compressedTexImage2D(
                      i.TEXTURE_CUBE_MAP_POSITIVE_X + Ee,
                      ct,
                      lt,
                      Mt.width,
                      Mt.height,
                      0,
                      Mt.data,
                    )
                : Tt(
                    "WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()",
                  )
              : ce
                ? Ke &&
                  t.texSubImage2D(
                    i.TEXTURE_CUBE_MAP_POSITIVE_X + Ee,
                    ct,
                    0,
                    0,
                    Mt.width,
                    Mt.height,
                    re,
                    Se,
                    Mt.data,
                  )
                : t.texImage2D(
                    i.TEXTURE_CUBE_MAP_POSITIVE_X + Ee,
                    ct,
                    lt,
                    Mt.width,
                    Mt.height,
                    0,
                    re,
                    Se,
                    Mt.data,
                  );
          }
        }
      } else {
        if (((Je = k.mipmaps), ce && Oe)) {
          Je.length > 0 && dt++;
          const Ee = ke(Ve[0]);
          t.texStorage2D(i.TEXTURE_CUBE_MAP, dt, lt, Ee.width, Ee.height);
        }
        for (let Ee = 0; Ee < 6; Ee++)
          if (Ge) {
            ce
              ? Ke &&
                t.texSubImage2D(
                  i.TEXTURE_CUBE_MAP_POSITIVE_X + Ee,
                  0,
                  0,
                  0,
                  Ve[Ee].width,
                  Ve[Ee].height,
                  re,
                  Se,
                  Ve[Ee].data,
                )
              : t.texImage2D(
                  i.TEXTURE_CUBE_MAP_POSITIVE_X + Ee,
                  0,
                  lt,
                  Ve[Ee].width,
                  Ve[Ee].height,
                  0,
                  re,
                  Se,
                  Ve[Ee].data,
                );
            for (let ct = 0; ct < Je.length; ct++) {
              const St = Je[ct].image[Ee].image;
              ce
                ? Ke &&
                  t.texSubImage2D(
                    i.TEXTURE_CUBE_MAP_POSITIVE_X + Ee,
                    ct + 1,
                    0,
                    0,
                    St.width,
                    St.height,
                    re,
                    Se,
                    St.data,
                  )
                : t.texImage2D(
                    i.TEXTURE_CUBE_MAP_POSITIVE_X + Ee,
                    ct + 1,
                    lt,
                    St.width,
                    St.height,
                    0,
                    re,
                    Se,
                    St.data,
                  );
            }
          } else {
            ce
              ? Ke &&
                t.texSubImage2D(
                  i.TEXTURE_CUBE_MAP_POSITIVE_X + Ee,
                  0,
                  0,
                  0,
                  re,
                  Se,
                  Ve[Ee],
                )
              : t.texImage2D(
                  i.TEXTURE_CUBE_MAP_POSITIVE_X + Ee,
                  0,
                  lt,
                  re,
                  Se,
                  Ve[Ee],
                );
            for (let ct = 0; ct < Je.length; ct++) {
              const Mt = Je[ct];
              ce
                ? Ke &&
                  t.texSubImage2D(
                    i.TEXTURE_CUBE_MAP_POSITIVE_X + Ee,
                    ct + 1,
                    0,
                    0,
                    re,
                    Se,
                    Mt.image[Ee],
                  )
                : t.texImage2D(
                    i.TEXTURE_CUBE_MAP_POSITIVE_X + Ee,
                    ct + 1,
                    lt,
                    re,
                    Se,
                    Mt.image[Ee],
                  );
            }
          }
      }
      (E(k) && T(i.TEXTURE_CUBE_MAP),
        (be.__version = _e.version),
        k.onUpdate && k.onUpdate(k));
    }
    H.__version = k.version;
  }
  function ye(H, k, oe, Ae, _e, be) {
    const et = s.convert(oe.format, oe.colorSpace),
      $e = s.convert(oe.type),
      ht = R(oe.internalFormat, et, $e, oe.colorSpace),
      yt = n.get(k),
      Ge = n.get(oe);
    if (((Ge.__renderTarget = k), !yt.__hasExternalTextures)) {
      const Ve = Math.max(1, k.width >> be),
        Ze = Math.max(1, k.height >> be);
      _e === i.TEXTURE_3D || _e === i.TEXTURE_2D_ARRAY
        ? t.texImage3D(_e, be, ht, Ve, Ze, k.depth, 0, et, $e, null)
        : t.texImage2D(_e, be, ht, Ve, Ze, 0, et, $e, null);
    }
    (t.bindFramebuffer(i.FRAMEBUFFER, H),
      rt(k)
        ? u.framebufferTexture2DMultisampleEXT(
            i.FRAMEBUFFER,
            Ae,
            _e,
            Ge.__webglTexture,
            0,
            K(k),
          )
        : (_e === i.TEXTURE_2D ||
            (_e >= i.TEXTURE_CUBE_MAP_POSITIVE_X &&
              _e <= i.TEXTURE_CUBE_MAP_NEGATIVE_Z)) &&
          i.framebufferTexture2D(i.FRAMEBUFFER, Ae, _e, Ge.__webglTexture, be),
      t.bindFramebuffer(i.FRAMEBUFFER, null));
  }
  function ze(H, k, oe) {
    if ((i.bindRenderbuffer(i.RENDERBUFFER, H), k.depthBuffer)) {
      const Ae = k.depthTexture,
        _e = Ae && Ae.isDepthTexture ? Ae.type : null,
        be = L(k.stencilBuffer, _e),
        et = k.stencilBuffer ? i.DEPTH_STENCIL_ATTACHMENT : i.DEPTH_ATTACHMENT;
      (rt(k)
        ? u.renderbufferStorageMultisampleEXT(
            i.RENDERBUFFER,
            K(k),
            be,
            k.width,
            k.height,
          )
        : oe
          ? i.renderbufferStorageMultisample(
              i.RENDERBUFFER,
              K(k),
              be,
              k.width,
              k.height,
            )
          : i.renderbufferStorage(i.RENDERBUFFER, be, k.width, k.height),
        i.framebufferRenderbuffer(i.FRAMEBUFFER, et, i.RENDERBUFFER, H));
    } else {
      const Ae = k.textures;
      for (let _e = 0; _e < Ae.length; _e++) {
        const be = Ae[_e],
          et = s.convert(be.format, be.colorSpace),
          $e = s.convert(be.type),
          ht = R(be.internalFormat, et, $e, be.colorSpace);
        rt(k)
          ? u.renderbufferStorageMultisampleEXT(
              i.RENDERBUFFER,
              K(k),
              ht,
              k.width,
              k.height,
            )
          : oe
            ? i.renderbufferStorageMultisample(
                i.RENDERBUFFER,
                K(k),
                ht,
                k.width,
                k.height,
              )
            : i.renderbufferStorage(i.RENDERBUFFER, ht, k.width, k.height);
      }
    }
    i.bindRenderbuffer(i.RENDERBUFFER, null);
  }
  function it(H, k, oe) {
    const Ae = k.isWebGLCubeRenderTarget === !0;
    if (
      (t.bindFramebuffer(i.FRAMEBUFFER, H),
      !(k.depthTexture && k.depthTexture.isDepthTexture))
    )
      throw new Error(
        "renderTarget.depthTexture must be an instance of THREE.DepthTexture",
      );
    const _e = n.get(k.depthTexture);
    if (
      ((_e.__renderTarget = k),
      (!_e.__webglTexture ||
        k.depthTexture.image.width !== k.width ||
        k.depthTexture.image.height !== k.height) &&
        ((k.depthTexture.image.width = k.width),
        (k.depthTexture.image.height = k.height),
        (k.depthTexture.needsUpdate = !0)),
      Ae)
    ) {
      if (
        (_e.__webglInit === void 0 &&
          ((_e.__webglInit = !0),
          k.depthTexture.addEventListener("dispose", O)),
        _e.__webglTexture === void 0)
      ) {
        ((_e.__webglTexture = i.createTexture()),
          t.bindTexture(i.TEXTURE_CUBE_MAP, _e.__webglTexture),
          Z(i.TEXTURE_CUBE_MAP, k.depthTexture));
        const yt = s.convert(k.depthTexture.format),
          Ge = s.convert(k.depthTexture.type);
        let Ve;
        k.depthTexture.format === Ql
          ? (Ve = i.DEPTH_COMPONENT24)
          : k.depthTexture.format === $u && (Ve = i.DEPTH24_STENCIL8);
        for (let Ze = 0; Ze < 6; Ze++)
          i.texImage2D(
            i.TEXTURE_CUBE_MAP_POSITIVE_X + Ze,
            0,
            Ve,
            k.width,
            k.height,
            0,
            yt,
            Ge,
            null,
          );
      }
    } else ne(k.depthTexture, 0);
    const be = _e.__webglTexture,
      et = K(k),
      $e = Ae ? i.TEXTURE_CUBE_MAP_POSITIVE_X + oe : i.TEXTURE_2D,
      ht =
        k.depthTexture.format === $u
          ? i.DEPTH_STENCIL_ATTACHMENT
          : i.DEPTH_ATTACHMENT;
    if (k.depthTexture.format === Ql)
      rt(k)
        ? u.framebufferTexture2DMultisampleEXT(i.FRAMEBUFFER, ht, $e, be, 0, et)
        : i.framebufferTexture2D(i.FRAMEBUFFER, ht, $e, be, 0);
    else if (k.depthTexture.format === $u)
      rt(k)
        ? u.framebufferTexture2DMultisampleEXT(i.FRAMEBUFFER, ht, $e, be, 0, et)
        : i.framebufferTexture2D(i.FRAMEBUFFER, ht, $e, be, 0);
    else throw new Error("Unknown depthTexture format");
  }
  function qe(H) {
    const k = n.get(H),
      oe = H.isWebGLCubeRenderTarget === !0;
    if (k.__boundDepthTexture !== H.depthTexture) {
      const Ae = H.depthTexture;
      if ((k.__depthDisposeCallback && k.__depthDisposeCallback(), Ae)) {
        const _e = () => {
          (delete k.__boundDepthTexture,
            delete k.__depthDisposeCallback,
            Ae.removeEventListener("dispose", _e));
        };
        (Ae.addEventListener("dispose", _e), (k.__depthDisposeCallback = _e));
      }
      k.__boundDepthTexture = Ae;
    }
    if (H.depthTexture && !k.__autoAllocateDepthBuffer)
      if (oe)
        for (let Ae = 0; Ae < 6; Ae++) it(k.__webglFramebuffer[Ae], H, Ae);
      else {
        const Ae = H.texture.mipmaps;
        Ae && Ae.length > 0
          ? it(k.__webglFramebuffer[0], H, 0)
          : it(k.__webglFramebuffer, H, 0);
      }
    else if (oe) {
      k.__webglDepthbuffer = [];
      for (let Ae = 0; Ae < 6; Ae++)
        if (
          (t.bindFramebuffer(i.FRAMEBUFFER, k.__webglFramebuffer[Ae]),
          k.__webglDepthbuffer[Ae] === void 0)
        )
          ((k.__webglDepthbuffer[Ae] = i.createRenderbuffer()),
            ze(k.__webglDepthbuffer[Ae], H, !1));
        else {
          const _e = H.stencilBuffer
              ? i.DEPTH_STENCIL_ATTACHMENT
              : i.DEPTH_ATTACHMENT,
            be = k.__webglDepthbuffer[Ae];
          (i.bindRenderbuffer(i.RENDERBUFFER, be),
            i.framebufferRenderbuffer(i.FRAMEBUFFER, _e, i.RENDERBUFFER, be));
        }
    } else {
      const Ae = H.texture.mipmaps;
      if (
        (Ae && Ae.length > 0
          ? t.bindFramebuffer(i.FRAMEBUFFER, k.__webglFramebuffer[0])
          : t.bindFramebuffer(i.FRAMEBUFFER, k.__webglFramebuffer),
        k.__webglDepthbuffer === void 0)
      )
        ((k.__webglDepthbuffer = i.createRenderbuffer()),
          ze(k.__webglDepthbuffer, H, !1));
      else {
        const _e = H.stencilBuffer
            ? i.DEPTH_STENCIL_ATTACHMENT
            : i.DEPTH_ATTACHMENT,
          be = k.__webglDepthbuffer;
        (i.bindRenderbuffer(i.RENDERBUFFER, be),
          i.framebufferRenderbuffer(i.FRAMEBUFFER, _e, i.RENDERBUFFER, be));
      }
    }
    t.bindFramebuffer(i.FRAMEBUFFER, null);
  }
  function Ye(H, k, oe) {
    const Ae = n.get(H);
    (k !== void 0 &&
      ye(
        Ae.__webglFramebuffer,
        H,
        H.texture,
        i.COLOR_ATTACHMENT0,
        i.TEXTURE_2D,
        0,
      ),
      oe !== void 0 && qe(H));
  }
  function ft(H) {
    const k = H.texture,
      oe = n.get(H),
      Ae = n.get(k);
    H.addEventListener("dispose", B);
    const _e = H.textures,
      be = H.isWebGLCubeRenderTarget === !0,
      et = _e.length > 1;
    if (
      (et ||
        (Ae.__webglTexture === void 0 &&
          (Ae.__webglTexture = i.createTexture()),
        (Ae.__version = k.version),
        o.memory.textures++),
      be)
    ) {
      oe.__webglFramebuffer = [];
      for (let $e = 0; $e < 6; $e++)
        if (k.mipmaps && k.mipmaps.length > 0) {
          oe.__webglFramebuffer[$e] = [];
          for (let ht = 0; ht < k.mipmaps.length; ht++)
            oe.__webglFramebuffer[$e][ht] = i.createFramebuffer();
        } else oe.__webglFramebuffer[$e] = i.createFramebuffer();
    } else {
      if (k.mipmaps && k.mipmaps.length > 0) {
        oe.__webglFramebuffer = [];
        for (let $e = 0; $e < k.mipmaps.length; $e++)
          oe.__webglFramebuffer[$e] = i.createFramebuffer();
      } else oe.__webglFramebuffer = i.createFramebuffer();
      if (et)
        for (let $e = 0, ht = _e.length; $e < ht; $e++) {
          const yt = n.get(_e[$e]);
          yt.__webglTexture === void 0 &&
            ((yt.__webglTexture = i.createTexture()), o.memory.textures++);
        }
      if (H.samples > 0 && rt(H) === !1) {
        ((oe.__webglMultisampledFramebuffer = i.createFramebuffer()),
          (oe.__webglColorRenderbuffer = []),
          t.bindFramebuffer(i.FRAMEBUFFER, oe.__webglMultisampledFramebuffer));
        for (let $e = 0; $e < _e.length; $e++) {
          const ht = _e[$e];
          ((oe.__webglColorRenderbuffer[$e] = i.createRenderbuffer()),
            i.bindRenderbuffer(
              i.RENDERBUFFER,
              oe.__webglColorRenderbuffer[$e],
            ));
          const yt = s.convert(ht.format, ht.colorSpace),
            Ge = s.convert(ht.type),
            Ve = R(
              ht.internalFormat,
              yt,
              Ge,
              ht.colorSpace,
              H.isXRRenderTarget === !0,
            ),
            Ze = K(H);
          (i.renderbufferStorageMultisample(
            i.RENDERBUFFER,
            Ze,
            Ve,
            H.width,
            H.height,
          ),
            i.framebufferRenderbuffer(
              i.FRAMEBUFFER,
              i.COLOR_ATTACHMENT0 + $e,
              i.RENDERBUFFER,
              oe.__webglColorRenderbuffer[$e],
            ));
        }
        (i.bindRenderbuffer(i.RENDERBUFFER, null),
          H.depthBuffer &&
            ((oe.__webglDepthRenderbuffer = i.createRenderbuffer()),
            ze(oe.__webglDepthRenderbuffer, H, !0)),
          t.bindFramebuffer(i.FRAMEBUFFER, null));
      }
    }
    if (be) {
      (t.bindTexture(i.TEXTURE_CUBE_MAP, Ae.__webglTexture),
        Z(i.TEXTURE_CUBE_MAP, k));
      for (let $e = 0; $e < 6; $e++)
        if (k.mipmaps && k.mipmaps.length > 0)
          for (let ht = 0; ht < k.mipmaps.length; ht++)
            ye(
              oe.__webglFramebuffer[$e][ht],
              H,
              k,
              i.COLOR_ATTACHMENT0,
              i.TEXTURE_CUBE_MAP_POSITIVE_X + $e,
              ht,
            );
        else
          ye(
            oe.__webglFramebuffer[$e],
            H,
            k,
            i.COLOR_ATTACHMENT0,
            i.TEXTURE_CUBE_MAP_POSITIVE_X + $e,
            0,
          );
      (E(k) && T(i.TEXTURE_CUBE_MAP), t.unbindTexture());
    } else if (et) {
      for (let $e = 0, ht = _e.length; $e < ht; $e++) {
        const yt = _e[$e],
          Ge = n.get(yt);
        let Ve = i.TEXTURE_2D;
        ((H.isWebGL3DRenderTarget || H.isWebGLArrayRenderTarget) &&
          (Ve = H.isWebGL3DRenderTarget ? i.TEXTURE_3D : i.TEXTURE_2D_ARRAY),
          t.bindTexture(Ve, Ge.__webglTexture),
          Z(Ve, yt),
          ye(oe.__webglFramebuffer, H, yt, i.COLOR_ATTACHMENT0 + $e, Ve, 0),
          E(yt) && T(Ve));
      }
      t.unbindTexture();
    } else {
      let $e = i.TEXTURE_2D;
      if (
        ((H.isWebGL3DRenderTarget || H.isWebGLArrayRenderTarget) &&
          ($e = H.isWebGL3DRenderTarget ? i.TEXTURE_3D : i.TEXTURE_2D_ARRAY),
        t.bindTexture($e, Ae.__webglTexture),
        Z($e, k),
        k.mipmaps && k.mipmaps.length > 0)
      )
        for (let ht = 0; ht < k.mipmaps.length; ht++)
          ye(oe.__webglFramebuffer[ht], H, k, i.COLOR_ATTACHMENT0, $e, ht);
      else ye(oe.__webglFramebuffer, H, k, i.COLOR_ATTACHMENT0, $e, 0);
      (E(k) && T($e), t.unbindTexture());
    }
    H.depthBuffer && qe(H);
  }
  function Re(H) {
    const k = H.textures;
    for (let oe = 0, Ae = k.length; oe < Ae; oe++) {
      const _e = k[oe];
      if (E(_e)) {
        const be = C(H),
          et = n.get(_e).__webglTexture;
        (t.bindTexture(be, et), T(be), t.unbindTexture());
      }
    }
  }
  const Ie = [],
    De = [];
  function Qe(H) {
    if (H.samples > 0) {
      if (rt(H) === !1) {
        const k = H.textures,
          oe = H.width,
          Ae = H.height;
        let _e = i.COLOR_BUFFER_BIT;
        const be = H.stencilBuffer
            ? i.DEPTH_STENCIL_ATTACHMENT
            : i.DEPTH_ATTACHMENT,
          et = n.get(H),
          $e = k.length > 1;
        if ($e)
          for (let yt = 0; yt < k.length; yt++)
            (t.bindFramebuffer(
              i.FRAMEBUFFER,
              et.__webglMultisampledFramebuffer,
            ),
              i.framebufferRenderbuffer(
                i.FRAMEBUFFER,
                i.COLOR_ATTACHMENT0 + yt,
                i.RENDERBUFFER,
                null,
              ),
              t.bindFramebuffer(i.FRAMEBUFFER, et.__webglFramebuffer),
              i.framebufferTexture2D(
                i.DRAW_FRAMEBUFFER,
                i.COLOR_ATTACHMENT0 + yt,
                i.TEXTURE_2D,
                null,
                0,
              ));
        t.bindFramebuffer(
          i.READ_FRAMEBUFFER,
          et.__webglMultisampledFramebuffer,
        );
        const ht = H.texture.mipmaps;
        ht && ht.length > 0
          ? t.bindFramebuffer(i.DRAW_FRAMEBUFFER, et.__webglFramebuffer[0])
          : t.bindFramebuffer(i.DRAW_FRAMEBUFFER, et.__webglFramebuffer);
        for (let yt = 0; yt < k.length; yt++) {
          if (
            (H.resolveDepthBuffer &&
              (H.depthBuffer && (_e |= i.DEPTH_BUFFER_BIT),
              H.stencilBuffer &&
                H.resolveStencilBuffer &&
                (_e |= i.STENCIL_BUFFER_BIT)),
            $e)
          ) {
            i.framebufferRenderbuffer(
              i.READ_FRAMEBUFFER,
              i.COLOR_ATTACHMENT0,
              i.RENDERBUFFER,
              et.__webglColorRenderbuffer[yt],
            );
            const Ge = n.get(k[yt]).__webglTexture;
            i.framebufferTexture2D(
              i.DRAW_FRAMEBUFFER,
              i.COLOR_ATTACHMENT0,
              i.TEXTURE_2D,
              Ge,
              0,
            );
          }
          (i.blitFramebuffer(0, 0, oe, Ae, 0, 0, oe, Ae, _e, i.NEAREST),
            h === !0 &&
              ((Ie.length = 0),
              (De.length = 0),
              Ie.push(i.COLOR_ATTACHMENT0 + yt),
              H.depthBuffer &&
                H.resolveDepthBuffer === !1 &&
                (Ie.push(be),
                De.push(be),
                i.invalidateFramebuffer(i.DRAW_FRAMEBUFFER, De)),
              i.invalidateFramebuffer(i.READ_FRAMEBUFFER, Ie)));
        }
        if (
          (t.bindFramebuffer(i.READ_FRAMEBUFFER, null),
          t.bindFramebuffer(i.DRAW_FRAMEBUFFER, null),
          $e)
        )
          for (let yt = 0; yt < k.length; yt++) {
            (t.bindFramebuffer(
              i.FRAMEBUFFER,
              et.__webglMultisampledFramebuffer,
            ),
              i.framebufferRenderbuffer(
                i.FRAMEBUFFER,
                i.COLOR_ATTACHMENT0 + yt,
                i.RENDERBUFFER,
                et.__webglColorRenderbuffer[yt],
              ));
            const Ge = n.get(k[yt]).__webglTexture;
            (t.bindFramebuffer(i.FRAMEBUFFER, et.__webglFramebuffer),
              i.framebufferTexture2D(
                i.DRAW_FRAMEBUFFER,
                i.COLOR_ATTACHMENT0 + yt,
                i.TEXTURE_2D,
                Ge,
                0,
              ));
          }
        t.bindFramebuffer(
          i.DRAW_FRAMEBUFFER,
          et.__webglMultisampledFramebuffer,
        );
      } else if (H.depthBuffer && H.resolveDepthBuffer === !1 && h) {
        const k = H.stencilBuffer
          ? i.DEPTH_STENCIL_ATTACHMENT
          : i.DEPTH_ATTACHMENT;
        i.invalidateFramebuffer(i.DRAW_FRAMEBUFFER, [k]);
      }
    }
  }
  function K(H) {
    return Math.min(r.maxSamples, H.samples);
  }
  function rt(H) {
    const k = n.get(H);
    return (
      H.samples > 0 &&
      e.has("WEBGL_multisampled_render_to_texture") === !0 &&
      k.__useRenderToTexture !== !1
    );
  }
  function je(H) {
    const k = o.render.frame;
    m.get(H) !== k && (m.set(H, k), H.update());
  }
  function Te(H, k) {
    const oe = H.colorSpace,
      Ae = H.format,
      _e = H.type;
    return (
      H.isCompressedTexture === !0 ||
        H.isVideoTexture === !0 ||
        (oe !== af &&
          oe !== Gc &&
          (Cn.getTransfer(oe) === Xn
            ? (Ae !== xs || _e !== Bs) &&
              Tt(
                "WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.",
              )
            : Ft("WebGLTextures: Unsupported texture color space:", oe))),
      k
    );
  }
  function ke(H) {
    return (
      typeof HTMLImageElement < "u" && H instanceof HTMLImageElement
        ? ((d.width = H.naturalWidth || H.width),
          (d.height = H.naturalHeight || H.height))
        : typeof VideoFrame < "u" && H instanceof VideoFrame
          ? ((d.width = H.displayWidth), (d.height = H.displayHeight))
          : ((d.width = H.width), (d.height = H.height)),
      d
    );
  }
  ((this.allocateTextureUnit = J),
    (this.resetTextureUnits = X),
    (this.setTexture2D = ne),
    (this.setTexture2DArray = W),
    (this.setTexture3D = $),
    (this.setTextureCube = de),
    (this.rebindTextures = Ye),
    (this.setupRenderTarget = ft),
    (this.updateRenderTargetMipmap = Re),
    (this.updateMultisampleRenderTarget = Qe),
    (this.setupDepthRenderbuffer = qe),
    (this.setupFrameBufferTexture = ye),
    (this.useMultisampledRTT = rt),
    (this.isReversedDepthBuffer = function () {
      return t.buffers.depth.getReversed();
    }));
}
function rU(i, e) {
  function t(n, r = Gc) {
    let s;
    const o = Cn.getTransfer(r);
    if (n === Bs) return i.UNSIGNED_BYTE;
    if (n === J1) return i.UNSIGNED_SHORT_4_4_4_4;
    if (n === $1) return i.UNSIGNED_SHORT_5_5_5_1;
    if (n === zT) return i.UNSIGNED_INT_5_9_9_9_REV;
    if (n === BT) return i.UNSIGNED_INT_10F_11F_11F_REV;
    if (n === OT) return i.BYTE;
    if (n === FT) return i.SHORT;
    if (n === Tp) return i.UNSIGNED_SHORT;
    if (n === Q1) return i.INT;
    if (n === bo) return i.UNSIGNED_INT;
    if (n === Hs) return i.FLOAT;
    if (n === Kl) return i.HALF_FLOAT;
    if (n === kT) return i.ALPHA;
    if (n === VT) return i.RGB;
    if (n === xs) return i.RGBA;
    if (n === Ql) return i.DEPTH_COMPONENT;
    if (n === $u) return i.DEPTH_STENCIL;
    if (n === eb) return i.RED;
    if (n === L0) return i.RED_INTEGER;
    if (n === Lh) return i.RG;
    if (n === tb) return i.RG_INTEGER;
    if (n === nb) return i.RGBA_INTEGER;
    if (n === Vg || n === Gg || n === Hg || n === jg)
      if (o === Xn)
        if (((s = e.get("WEBGL_compressed_texture_s3tc_srgb")), s !== null)) {
          if (n === Vg) return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (n === Gg) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (n === Hg) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (n === jg) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else return null;
      else if (((s = e.get("WEBGL_compressed_texture_s3tc")), s !== null)) {
        if (n === Vg) return s.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (n === Gg) return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (n === Hg) return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (n === jg) return s.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else return null;
    if (n === $x || n === e1 || n === t1 || n === n1)
      if (((s = e.get("WEBGL_compressed_texture_pvrtc")), s !== null)) {
        if (n === $x) return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (n === e1) return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (n === t1) return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (n === n1) return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else return null;
    if (
      n === i1 ||
      n === r1 ||
      n === s1 ||
      n === a1 ||
      n === o1 ||
      n === l1 ||
      n === c1
    )
      if (((s = e.get("WEBGL_compressed_texture_etc")), s !== null)) {
        if (n === i1 || n === r1)
          return o === Xn ? s.COMPRESSED_SRGB8_ETC2 : s.COMPRESSED_RGB8_ETC2;
        if (n === s1)
          return o === Xn
            ? s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
            : s.COMPRESSED_RGBA8_ETC2_EAC;
        if (n === a1) return s.COMPRESSED_R11_EAC;
        if (n === o1) return s.COMPRESSED_SIGNED_R11_EAC;
        if (n === l1) return s.COMPRESSED_RG11_EAC;
        if (n === c1) return s.COMPRESSED_SIGNED_RG11_EAC;
      } else return null;
    if (
      n === u1 ||
      n === f1 ||
      n === h1 ||
      n === d1 ||
      n === p1 ||
      n === m1 ||
      n === g1 ||
      n === v1 ||
      n === y1 ||
      n === x1 ||
      n === b1 ||
      n === _1 ||
      n === S1 ||
      n === M1
    )
      if (((s = e.get("WEBGL_compressed_texture_astc")), s !== null)) {
        if (n === u1)
          return o === Xn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
            : s.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (n === f1)
          return o === Xn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
            : s.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (n === h1)
          return o === Xn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
            : s.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (n === d1)
          return o === Xn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
            : s.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (n === p1)
          return o === Xn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
            : s.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (n === m1)
          return o === Xn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
            : s.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (n === g1)
          return o === Xn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
            : s.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (n === v1)
          return o === Xn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
            : s.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (n === y1)
          return o === Xn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
            : s.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (n === x1)
          return o === Xn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
            : s.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (n === b1)
          return o === Xn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
            : s.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (n === _1)
          return o === Xn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
            : s.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (n === S1)
          return o === Xn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
            : s.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (n === M1)
          return o === Xn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
            : s.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else return null;
    if (n === T1 || n === E1 || n === w1)
      if (((s = e.get("EXT_texture_compression_bptc")), s !== null)) {
        if (n === T1)
          return o === Xn
            ? s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
            : s.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (n === E1) return s.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (n === w1) return s.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else return null;
    if (n === A1 || n === C1 || n === R1 || n === D1)
      if (((s = e.get("EXT_texture_compression_rgtc")), s !== null)) {
        if (n === A1) return s.COMPRESSED_RED_RGTC1_EXT;
        if (n === C1) return s.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (n === R1) return s.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (n === D1) return s.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else return null;
    return n === Ep ? i.UNSIGNED_INT_24_8 : i[n] !== void 0 ? i[n] : null;
  }
  return { convert: t };
}
const d9 = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`,
  p9 = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class m9 {
  constructor() {
    ((this.texture = null),
      (this.mesh = null),
      (this.depthNear = 0),
      (this.depthFar = 0));
  }
  init(e, t) {
    if (this.texture === null) {
      const n = new JT(e.texture);
      ((e.depthNear !== t.depthNear || e.depthFar !== t.depthFar) &&
        ((this.depthNear = e.depthNear), (this.depthFar = e.depthFar)),
        (this.texture = n));
    }
  }
  getMesh(e) {
    if (this.texture !== null && this.mesh === null) {
      const t = e.cameras[0].viewport,
        n = new ba({
          vertexShader: d9,
          fragmentShader: p9,
          uniforms: {
            depthColor: { value: this.texture },
            depthWidth: { value: t.z },
            depthHeight: { value: t.w },
          },
        });
      this.mesh = new wi(new $c(20, 20), n);
    }
    return this.mesh;
  }
  reset() {
    ((this.texture = null), (this.mesh = null));
  }
  getDepthTexture() {
    return this.texture;
  }
}
class g9 extends ec {
  constructor(e, t) {
    super();
    const n = this;
    let r = null,
      s = 1,
      o = null,
      u = "local-floor",
      h = 1,
      d = null,
      m = null,
      v = null,
      y = null,
      b = null,
      _ = null;
    const w = typeof XRWebGLBinding < "u",
      E = new m9(),
      T = {},
      C = t.getContextAttributes();
    let R = null,
      L = null;
    const I = [],
      O = [],
      B = new nt();
    let N = null;
    const F = new ir();
    F.viewport = new Dn();
    const j = new ir();
    j.viewport = new Dn();
    const q = [F, j],
      X = new jN();
    let J = null,
      ee = null;
    ((this.cameraAutoUpdate = !0),
      (this.enabled = !1),
      (this.isPresenting = !1),
      (this.getController = function (ae) {
        let he = I[ae];
        return (
          he === void 0 && ((he = new Rx()), (I[ae] = he)),
          he.getTargetRaySpace()
        );
      }),
      (this.getControllerGrip = function (ae) {
        let he = I[ae];
        return (
          he === void 0 && ((he = new Rx()), (I[ae] = he)),
          he.getGripSpace()
        );
      }),
      (this.getHand = function (ae) {
        let he = I[ae];
        return (
          he === void 0 && ((he = new Rx()), (I[ae] = he)),
          he.getHandSpace()
        );
      }));
    function ne(ae) {
      const he = O.indexOf(ae.inputSource);
      if (he === -1) return;
      const ye = I[he];
      ye !== void 0 &&
        (ye.update(ae.inputSource, ae.frame, d || o),
        ye.dispatchEvent({ type: ae.type, data: ae.inputSource }));
    }
    function W() {
      (r.removeEventListener("select", ne),
        r.removeEventListener("selectstart", ne),
        r.removeEventListener("selectend", ne),
        r.removeEventListener("squeeze", ne),
        r.removeEventListener("squeezestart", ne),
        r.removeEventListener("squeezeend", ne),
        r.removeEventListener("end", W),
        r.removeEventListener("inputsourceschange", $));
      for (let ae = 0; ae < I.length; ae++) {
        const he = O[ae];
        he !== null && ((O[ae] = null), I[ae].disconnect(he));
      }
      ((J = null), (ee = null), E.reset());
      for (const ae in T) delete T[ae];
      (e.setRenderTarget(R),
        (b = null),
        (y = null),
        (v = null),
        (r = null),
        (L = null),
        ge.stop(),
        (n.isPresenting = !1),
        e.setPixelRatio(N),
        e.setSize(B.width, B.height, !1),
        n.dispatchEvent({ type: "sessionend" }));
    }
    ((this.setFramebufferScaleFactor = function (ae) {
      ((s = ae),
        n.isPresenting === !0 &&
          Tt(
            "WebXRManager: Cannot change framebuffer scale while presenting.",
          ));
    }),
      (this.setReferenceSpaceType = function (ae) {
        ((u = ae),
          n.isPresenting === !0 &&
            Tt(
              "WebXRManager: Cannot change reference space type while presenting.",
            ));
      }),
      (this.getReferenceSpace = function () {
        return d || o;
      }),
      (this.setReferenceSpace = function (ae) {
        d = ae;
      }),
      (this.getBaseLayer = function () {
        return y !== null ? y : b;
      }),
      (this.getBinding = function () {
        return (v === null && w && (v = new XRWebGLBinding(r, t)), v);
      }),
      (this.getFrame = function () {
        return _;
      }),
      (this.getSession = function () {
        return r;
      }),
      (this.setSession = async function (ae) {
        if (((r = ae), r !== null)) {
          if (
            ((R = e.getRenderTarget()),
            r.addEventListener("select", ne),
            r.addEventListener("selectstart", ne),
            r.addEventListener("selectend", ne),
            r.addEventListener("squeeze", ne),
            r.addEventListener("squeezestart", ne),
            r.addEventListener("squeezeend", ne),
            r.addEventListener("end", W),
            r.addEventListener("inputsourceschange", $),
            C.xrCompatible !== !0 && (await t.makeXRCompatible()),
            (N = e.getPixelRatio()),
            e.getSize(B),
            w && "createProjectionLayer" in XRWebGLBinding.prototype)
          ) {
            let ye = null,
              ze = null,
              it = null;
            C.depth &&
              ((it = C.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24),
              (ye = C.stencil ? $u : Ql),
              (ze = C.stencil ? Ep : bo));
            const qe = {
              colorFormat: t.RGBA8,
              depthFormat: it,
              scaleFactor: s,
            };
            ((v = this.getBinding()),
              (y = v.createProjectionLayer(qe)),
              r.updateRenderState({ layers: [y] }),
              e.setPixelRatio(1),
              e.setSize(y.textureWidth, y.textureHeight, !1),
              (L = new Oa(y.textureWidth, y.textureHeight, {
                format: xs,
                type: Bs,
                depthTexture: new Cp(
                  y.textureWidth,
                  y.textureHeight,
                  ze,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  ye,
                ),
                stencilBuffer: C.stencil,
                colorSpace: e.outputColorSpace,
                samples: C.antialias ? 4 : 0,
                resolveDepthBuffer: y.ignoreDepthValues === !1,
                resolveStencilBuffer: y.ignoreDepthValues === !1,
              })));
          } else {
            const ye = {
              antialias: C.antialias,
              alpha: !0,
              depth: C.depth,
              stencil: C.stencil,
              framebufferScaleFactor: s,
            };
            ((b = new XRWebGLLayer(r, t, ye)),
              r.updateRenderState({ baseLayer: b }),
              e.setPixelRatio(1),
              e.setSize(b.framebufferWidth, b.framebufferHeight, !1),
              (L = new Oa(b.framebufferWidth, b.framebufferHeight, {
                format: xs,
                type: Bs,
                colorSpace: e.outputColorSpace,
                stencilBuffer: C.stencil,
                resolveDepthBuffer: b.ignoreDepthValues === !1,
                resolveStencilBuffer: b.ignoreDepthValues === !1,
              })));
          }
          ((L.isXRRenderTarget = !0),
            this.setFoveation(h),
            (d = null),
            (o = await r.requestReferenceSpace(u)),
            ge.setContext(r),
            ge.start(),
            (n.isPresenting = !0),
            n.dispatchEvent({ type: "sessionstart" }));
        }
      }),
      (this.getEnvironmentBlendMode = function () {
        if (r !== null) return r.environmentBlendMode;
      }),
      (this.getDepthTexture = function () {
        return E.getDepthTexture();
      }));
    function $(ae) {
      for (let he = 0; he < ae.removed.length; he++) {
        const ye = ae.removed[he],
          ze = O.indexOf(ye);
        ze >= 0 && ((O[ze] = null), I[ze].disconnect(ye));
      }
      for (let he = 0; he < ae.added.length; he++) {
        const ye = ae.added[he];
        let ze = O.indexOf(ye);
        if (ze === -1) {
          for (let qe = 0; qe < I.length; qe++)
            if (qe >= O.length) {
              (O.push(ye), (ze = qe));
              break;
            } else if (O[qe] === null) {
              ((O[qe] = ye), (ze = qe));
              break;
            }
          if (ze === -1) break;
        }
        const it = I[ze];
        it && it.connect(ye);
      }
    }
    const de = new te(),
      le = new te();
    function fe(ae, he, ye) {
      (de.setFromMatrixPosition(he.matrixWorld),
        le.setFromMatrixPosition(ye.matrixWorld));
      const ze = de.distanceTo(le),
        it = he.projectionMatrix.elements,
        qe = ye.projectionMatrix.elements,
        Ye = it[14] / (it[10] - 1),
        ft = it[14] / (it[10] + 1),
        Re = (it[9] + 1) / it[5],
        Ie = (it[9] - 1) / it[5],
        De = (it[8] - 1) / it[0],
        Qe = (qe[8] + 1) / qe[0],
        K = Ye * De,
        rt = Ye * Qe,
        je = ze / (-De + Qe),
        Te = je * -De;
      if (
        (he.matrixWorld.decompose(ae.position, ae.quaternion, ae.scale),
        ae.translateX(Te),
        ae.translateZ(je),
        ae.matrixWorld.compose(ae.position, ae.quaternion, ae.scale),
        ae.matrixWorldInverse.copy(ae.matrixWorld).invert(),
        it[10] === -1)
      )
        (ae.projectionMatrix.copy(he.projectionMatrix),
          ae.projectionMatrixInverse.copy(he.projectionMatrixInverse));
      else {
        const ke = Ye + je,
          H = ft + je,
          k = K - Te,
          oe = rt + (ze - Te),
          Ae = ((Re * ft) / H) * ke,
          _e = ((Ie * ft) / H) * ke;
        (ae.projectionMatrix.makePerspective(k, oe, Ae, _e, ke, H),
          ae.projectionMatrixInverse.copy(ae.projectionMatrix).invert());
      }
    }
    function V(ae, he) {
      (he === null
        ? ae.matrixWorld.copy(ae.matrix)
        : ae.matrixWorld.multiplyMatrices(he.matrixWorld, ae.matrix),
        ae.matrixWorldInverse.copy(ae.matrixWorld).invert());
    }
    this.updateCamera = function (ae) {
      if (r === null) return;
      let he = ae.near,
        ye = ae.far;
      (E.texture !== null &&
        (E.depthNear > 0 && (he = E.depthNear),
        E.depthFar > 0 && (ye = E.depthFar)),
        (X.near = j.near = F.near = he),
        (X.far = j.far = F.far = ye),
        (J !== X.near || ee !== X.far) &&
          (r.updateRenderState({ depthNear: X.near, depthFar: X.far }),
          (J = X.near),
          (ee = X.far)),
        (X.layers.mask = ae.layers.mask | 6),
        (F.layers.mask = X.layers.mask & -5),
        (j.layers.mask = X.layers.mask & -3));
      const ze = ae.parent,
        it = X.cameras;
      V(X, ze);
      for (let qe = 0; qe < it.length; qe++) V(it[qe], ze);
      (it.length === 2
        ? fe(X, F, j)
        : X.projectionMatrix.copy(F.projectionMatrix),
        Z(ae, X, ze));
    };
    function Z(ae, he, ye) {
      (ye === null
        ? ae.matrix.copy(he.matrixWorld)
        : (ae.matrix.copy(ye.matrixWorld),
          ae.matrix.invert(),
          ae.matrix.multiply(he.matrixWorld)),
        ae.matrix.decompose(ae.position, ae.quaternion, ae.scale),
        ae.updateMatrixWorld(!0),
        ae.projectionMatrix.copy(he.projectionMatrix),
        ae.projectionMatrixInverse.copy(he.projectionMatrixInverse),
        ae.isPerspectiveCamera &&
          ((ae.fov = wp * 2 * Math.atan(1 / ae.projectionMatrix.elements[5])),
          (ae.zoom = 1)));
    }
    ((this.getCamera = function () {
      return X;
    }),
      (this.getFoveation = function () {
        if (!(y === null && b === null)) return h;
      }),
      (this.setFoveation = function (ae) {
        ((h = ae),
          y !== null && (y.fixedFoveation = ae),
          b !== null && b.fixedFoveation !== void 0 && (b.fixedFoveation = ae));
      }),
      (this.hasDepthSensing = function () {
        return E.texture !== null;
      }),
      (this.getDepthSensingMesh = function () {
        return E.getMesh(X);
      }),
      (this.getCameraTexture = function (ae) {
        return T[ae];
      }));
    let se = null;
    function ue(ae, he) {
      if (((m = he.getViewerPose(d || o)), (_ = he), m !== null)) {
        const ye = m.views;
        b !== null &&
          (e.setRenderTargetFramebuffer(L, b.framebuffer),
          e.setRenderTarget(L));
        let ze = !1;
        ye.length !== X.cameras.length && ((X.cameras.length = 0), (ze = !0));
        for (let ft = 0; ft < ye.length; ft++) {
          const Re = ye[ft];
          let Ie = null;
          if (b !== null) Ie = b.getViewport(Re);
          else {
            const Qe = v.getViewSubImage(y, Re);
            ((Ie = Qe.viewport),
              ft === 0 &&
                (e.setRenderTargetTextures(
                  L,
                  Qe.colorTexture,
                  Qe.depthStencilTexture,
                ),
                e.setRenderTarget(L)));
          }
          let De = q[ft];
          (De === void 0 &&
            ((De = new ir()),
            De.layers.enable(ft),
            (De.viewport = new Dn()),
            (q[ft] = De)),
            De.matrix.fromArray(Re.transform.matrix),
            De.matrix.decompose(De.position, De.quaternion, De.scale),
            De.projectionMatrix.fromArray(Re.projectionMatrix),
            De.projectionMatrixInverse.copy(De.projectionMatrix).invert(),
            De.viewport.set(Ie.x, Ie.y, Ie.width, Ie.height),
            ft === 0 &&
              (X.matrix.copy(De.matrix),
              X.matrix.decompose(X.position, X.quaternion, X.scale)),
            ze === !0 && X.cameras.push(De));
        }
        const it = r.enabledFeatures;
        if (
          it &&
          it.includes("depth-sensing") &&
          r.depthUsage == "gpu-optimized" &&
          w
        ) {
          v = n.getBinding();
          const ft = v.getDepthInformation(ye[0]);
          ft && ft.isValid && ft.texture && E.init(ft, r.renderState);
        }
        if (it && it.includes("camera-access") && w) {
          (e.state.unbindTexture(), (v = n.getBinding()));
          for (let ft = 0; ft < ye.length; ft++) {
            const Re = ye[ft].camera;
            if (Re) {
              let Ie = T[Re];
              Ie || ((Ie = new JT()), (T[Re] = Ie));
              const De = v.getCameraImage(Re);
              Ie.sourceTexture = De;
            }
          }
        }
      }
      for (let ye = 0; ye < I.length; ye++) {
        const ze = O[ye],
          it = I[ye];
        ze !== null && it !== void 0 && it.update(ze, he, d || o);
      }
      (se && se(ae, he),
        he.detectedPlanes &&
          n.dispatchEvent({ type: "planesdetected", data: he }),
        (_ = null));
    }
    const ge = new $N();
    (ge.setAnimationLoop(ue),
      (this.setAnimationLoop = function (ae) {
        se = ae;
      }),
      (this.dispose = function () {}));
  }
}
const fh = new Fa(),
  v9 = new qt();
function y9(i, e) {
  function t(E, T) {
    (E.matrixAutoUpdate === !0 && E.updateMatrix(), T.value.copy(E.matrix));
  }
  function n(E, T) {
    (T.color.getRGB(E.fogColor.value, SN(i)),
      T.isFog
        ? ((E.fogNear.value = T.near), (E.fogFar.value = T.far))
        : T.isFogExp2 && (E.fogDensity.value = T.density));
  }
  function r(E, T, C, R, L) {
    T.isMeshBasicMaterial
      ? s(E, T)
      : T.isMeshLambertMaterial
        ? (s(E, T), T.envMap && (E.envMapIntensity.value = T.envMapIntensity))
        : T.isMeshToonMaterial
          ? (s(E, T), v(E, T))
          : T.isMeshPhongMaterial
            ? (s(E, T),
              m(E, T),
              T.envMap && (E.envMapIntensity.value = T.envMapIntensity))
            : T.isMeshStandardMaterial
              ? (s(E, T), y(E, T), T.isMeshPhysicalMaterial && b(E, T, L))
              : T.isMeshMatcapMaterial
                ? (s(E, T), _(E, T))
                : T.isMeshDepthMaterial
                  ? s(E, T)
                  : T.isMeshDistanceMaterial
                    ? (s(E, T), w(E, T))
                    : T.isMeshNormalMaterial
                      ? s(E, T)
                      : T.isLineBasicMaterial
                        ? (o(E, T), T.isLineDashedMaterial && u(E, T))
                        : T.isPointsMaterial
                          ? h(E, T, C, R)
                          : T.isSpriteMaterial
                            ? d(E, T)
                            : T.isShadowMaterial
                              ? (E.color.value.copy(T.color),
                                (E.opacity.value = T.opacity))
                              : T.isShaderMaterial &&
                                (T.uniformsNeedUpdate = !1);
  }
  function s(E, T) {
    ((E.opacity.value = T.opacity),
      T.color && E.diffuse.value.copy(T.color),
      T.emissive &&
        E.emissive.value.copy(T.emissive).multiplyScalar(T.emissiveIntensity),
      T.map && ((E.map.value = T.map), t(T.map, E.mapTransform)),
      T.alphaMap &&
        ((E.alphaMap.value = T.alphaMap), t(T.alphaMap, E.alphaMapTransform)),
      T.bumpMap &&
        ((E.bumpMap.value = T.bumpMap),
        t(T.bumpMap, E.bumpMapTransform),
        (E.bumpScale.value = T.bumpScale),
        T.side === js && (E.bumpScale.value *= -1)),
      T.normalMap &&
        ((E.normalMap.value = T.normalMap),
        t(T.normalMap, E.normalMapTransform),
        E.normalScale.value.copy(T.normalScale),
        T.side === js && E.normalScale.value.negate()),
      T.displacementMap &&
        ((E.displacementMap.value = T.displacementMap),
        t(T.displacementMap, E.displacementMapTransform),
        (E.displacementScale.value = T.displacementScale),
        (E.displacementBias.value = T.displacementBias)),
      T.emissiveMap &&
        ((E.emissiveMap.value = T.emissiveMap),
        t(T.emissiveMap, E.emissiveMapTransform)),
      T.specularMap &&
        ((E.specularMap.value = T.specularMap),
        t(T.specularMap, E.specularMapTransform)),
      T.alphaTest > 0 && (E.alphaTest.value = T.alphaTest));
    const C = e.get(T),
      R = C.envMap,
      L = C.envMapRotation;
    (R &&
      ((E.envMap.value = R),
      fh.copy(L),
      (fh.x *= -1),
      (fh.y *= -1),
      (fh.z *= -1),
      R.isCubeTexture &&
        R.isRenderTargetTexture === !1 &&
        ((fh.y *= -1), (fh.z *= -1)),
      E.envMapRotation.value.setFromMatrix4(v9.makeRotationFromEuler(fh)),
      (E.flipEnvMap.value =
        R.isCubeTexture && R.isRenderTargetTexture === !1 ? -1 : 1),
      (E.reflectivity.value = T.reflectivity),
      (E.ior.value = T.ior),
      (E.refractionRatio.value = T.refractionRatio)),
      T.lightMap &&
        ((E.lightMap.value = T.lightMap),
        (E.lightMapIntensity.value = T.lightMapIntensity),
        t(T.lightMap, E.lightMapTransform)),
      T.aoMap &&
        ((E.aoMap.value = T.aoMap),
        (E.aoMapIntensity.value = T.aoMapIntensity),
        t(T.aoMap, E.aoMapTransform)));
  }
  function o(E, T) {
    (E.diffuse.value.copy(T.color),
      (E.opacity.value = T.opacity),
      T.map && ((E.map.value = T.map), t(T.map, E.mapTransform)));
  }
  function u(E, T) {
    ((E.dashSize.value = T.dashSize),
      (E.totalSize.value = T.dashSize + T.gapSize),
      (E.scale.value = T.scale));
  }
  function h(E, T, C, R) {
    (E.diffuse.value.copy(T.color),
      (E.opacity.value = T.opacity),
      (E.size.value = T.size * C),
      (E.scale.value = R * 0.5),
      T.map && ((E.map.value = T.map), t(T.map, E.uvTransform)),
      T.alphaMap &&
        ((E.alphaMap.value = T.alphaMap), t(T.alphaMap, E.alphaMapTransform)),
      T.alphaTest > 0 && (E.alphaTest.value = T.alphaTest));
  }
  function d(E, T) {
    (E.diffuse.value.copy(T.color),
      (E.opacity.value = T.opacity),
      (E.rotation.value = T.rotation),
      T.map && ((E.map.value = T.map), t(T.map, E.mapTransform)),
      T.alphaMap &&
        ((E.alphaMap.value = T.alphaMap), t(T.alphaMap, E.alphaMapTransform)),
      T.alphaTest > 0 && (E.alphaTest.value = T.alphaTest));
  }
  function m(E, T) {
    (E.specular.value.copy(T.specular),
      (E.shininess.value = Math.max(T.shininess, 1e-4)));
  }
  function v(E, T) {
    T.gradientMap && (E.gradientMap.value = T.gradientMap);
  }
  function y(E, T) {
    ((E.metalness.value = T.metalness),
      T.metalnessMap &&
        ((E.metalnessMap.value = T.metalnessMap),
        t(T.metalnessMap, E.metalnessMapTransform)),
      (E.roughness.value = T.roughness),
      T.roughnessMap &&
        ((E.roughnessMap.value = T.roughnessMap),
        t(T.roughnessMap, E.roughnessMapTransform)),
      T.envMap && (E.envMapIntensity.value = T.envMapIntensity));
  }
  function b(E, T, C) {
    ((E.ior.value = T.ior),
      T.sheen > 0 &&
        (E.sheenColor.value.copy(T.sheenColor).multiplyScalar(T.sheen),
        (E.sheenRoughness.value = T.sheenRoughness),
        T.sheenColorMap &&
          ((E.sheenColorMap.value = T.sheenColorMap),
          t(T.sheenColorMap, E.sheenColorMapTransform)),
        T.sheenRoughnessMap &&
          ((E.sheenRoughnessMap.value = T.sheenRoughnessMap),
          t(T.sheenRoughnessMap, E.sheenRoughnessMapTransform))),
      T.clearcoat > 0 &&
        ((E.clearcoat.value = T.clearcoat),
        (E.clearcoatRoughness.value = T.clearcoatRoughness),
        T.clearcoatMap &&
          ((E.clearcoatMap.value = T.clearcoatMap),
          t(T.clearcoatMap, E.clearcoatMapTransform)),
        T.clearcoatRoughnessMap &&
          ((E.clearcoatRoughnessMap.value = T.clearcoatRoughnessMap),
          t(T.clearcoatRoughnessMap, E.clearcoatRoughnessMapTransform)),
        T.clearcoatNormalMap &&
          ((E.clearcoatNormalMap.value = T.clearcoatNormalMap),
          t(T.clearcoatNormalMap, E.clearcoatNormalMapTransform),
          E.clearcoatNormalScale.value.copy(T.clearcoatNormalScale),
          T.side === js && E.clearcoatNormalScale.value.negate())),
      T.dispersion > 0 && (E.dispersion.value = T.dispersion),
      T.iridescence > 0 &&
        ((E.iridescence.value = T.iridescence),
        (E.iridescenceIOR.value = T.iridescenceIOR),
        (E.iridescenceThicknessMinimum.value = T.iridescenceThicknessRange[0]),
        (E.iridescenceThicknessMaximum.value = T.iridescenceThicknessRange[1]),
        T.iridescenceMap &&
          ((E.iridescenceMap.value = T.iridescenceMap),
          t(T.iridescenceMap, E.iridescenceMapTransform)),
        T.iridescenceThicknessMap &&
          ((E.iridescenceThicknessMap.value = T.iridescenceThicknessMap),
          t(T.iridescenceThicknessMap, E.iridescenceThicknessMapTransform))),
      T.transmission > 0 &&
        ((E.transmission.value = T.transmission),
        (E.transmissionSamplerMap.value = C.texture),
        E.transmissionSamplerSize.value.set(C.width, C.height),
        T.transmissionMap &&
          ((E.transmissionMap.value = T.transmissionMap),
          t(T.transmissionMap, E.transmissionMapTransform)),
        (E.thickness.value = T.thickness),
        T.thicknessMap &&
          ((E.thicknessMap.value = T.thicknessMap),
          t(T.thicknessMap, E.thicknessMapTransform)),
        (E.attenuationDistance.value = T.attenuationDistance),
        E.attenuationColor.value.copy(T.attenuationColor)),
      T.anisotropy > 0 &&
        (E.anisotropyVector.value.set(
          T.anisotropy * Math.cos(T.anisotropyRotation),
          T.anisotropy * Math.sin(T.anisotropyRotation),
        ),
        T.anisotropyMap &&
          ((E.anisotropyMap.value = T.anisotropyMap),
          t(T.anisotropyMap, E.anisotropyMapTransform))),
      (E.specularIntensity.value = T.specularIntensity),
      E.specularColor.value.copy(T.specularColor),
      T.specularColorMap &&
        ((E.specularColorMap.value = T.specularColorMap),
        t(T.specularColorMap, E.specularColorMapTransform)),
      T.specularIntensityMap &&
        ((E.specularIntensityMap.value = T.specularIntensityMap),
        t(T.specularIntensityMap, E.specularIntensityMapTransform)));
  }
  function _(E, T) {
    T.matcap && (E.matcap.value = T.matcap);
  }
  function w(E, T) {
    const C = e.get(T).light;
    (E.referencePosition.value.setFromMatrixPosition(C.matrixWorld),
      (E.nearDistance.value = C.shadow.camera.near),
      (E.farDistance.value = C.shadow.camera.far));
  }
  return { refreshFogUniforms: n, refreshMaterialUniforms: r };
}
function x9(i, e, t, n) {
  let r = {},
    s = {},
    o = [];
  const u = i.getParameter(i.MAX_UNIFORM_BUFFER_BINDINGS);
  function h(C, R) {
    const L = R.program;
    n.uniformBlockBinding(C, L);
  }
  function d(C, R) {
    let L = r[C.id];
    L === void 0 &&
      (_(C), (L = m(C)), (r[C.id] = L), C.addEventListener("dispose", E));
    const I = R.program;
    n.updateUBOMapping(C, I);
    const O = e.render.frame;
    s[C.id] !== O && (y(C), (s[C.id] = O));
  }
  function m(C) {
    const R = v();
    C.__bindingPointIndex = R;
    const L = i.createBuffer(),
      I = C.__size,
      O = C.usage;
    return (
      i.bindBuffer(i.UNIFORM_BUFFER, L),
      i.bufferData(i.UNIFORM_BUFFER, I, O),
      i.bindBuffer(i.UNIFORM_BUFFER, null),
      i.bindBufferBase(i.UNIFORM_BUFFER, R, L),
      L
    );
  }
  function v() {
    for (let C = 0; C < u; C++) if (o.indexOf(C) === -1) return (o.push(C), C);
    return (
      Ft(
        "WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.",
      ),
      0
    );
  }
  function y(C) {
    const R = r[C.id],
      L = C.uniforms,
      I = C.__cache;
    i.bindBuffer(i.UNIFORM_BUFFER, R);
    for (let O = 0, B = L.length; O < B; O++) {
      const N = Array.isArray(L[O]) ? L[O] : [L[O]];
      for (let F = 0, j = N.length; F < j; F++) {
        const q = N[F];
        if (b(q, O, F, I) === !0) {
          const X = q.__offset,
            J = Array.isArray(q.value) ? q.value : [q.value];
          let ee = 0;
          for (let ne = 0; ne < J.length; ne++) {
            const W = J[ne],
              $ = w(W);
            typeof W == "number" || typeof W == "boolean"
              ? ((q.__data[0] = W),
                i.bufferSubData(i.UNIFORM_BUFFER, X + ee, q.__data))
              : W.isMatrix3
                ? ((q.__data[0] = W.elements[0]),
                  (q.__data[1] = W.elements[1]),
                  (q.__data[2] = W.elements[2]),
                  (q.__data[3] = 0),
                  (q.__data[4] = W.elements[3]),
                  (q.__data[5] = W.elements[4]),
                  (q.__data[6] = W.elements[5]),
                  (q.__data[7] = 0),
                  (q.__data[8] = W.elements[6]),
                  (q.__data[9] = W.elements[7]),
                  (q.__data[10] = W.elements[8]),
                  (q.__data[11] = 0))
                : (W.toArray(q.__data, ee),
                  (ee += $.storage / Float32Array.BYTES_PER_ELEMENT));
          }
          i.bufferSubData(i.UNIFORM_BUFFER, X, q.__data);
        }
      }
    }
    i.bindBuffer(i.UNIFORM_BUFFER, null);
  }
  function b(C, R, L, I) {
    const O = C.value,
      B = R + "_" + L;
    if (I[B] === void 0)
      return (
        typeof O == "number" || typeof O == "boolean"
          ? (I[B] = O)
          : (I[B] = O.clone()),
        !0
      );
    {
      const N = I[B];
      if (typeof O == "number" || typeof O == "boolean") {
        if (N !== O) return ((I[B] = O), !0);
      } else if (N.equals(O) === !1) return (N.copy(O), !0);
    }
    return !1;
  }
  function _(C) {
    const R = C.uniforms;
    let L = 0;
    const I = 16;
    for (let B = 0, N = R.length; B < N; B++) {
      const F = Array.isArray(R[B]) ? R[B] : [R[B]];
      for (let j = 0, q = F.length; j < q; j++) {
        const X = F[j],
          J = Array.isArray(X.value) ? X.value : [X.value];
        for (let ee = 0, ne = J.length; ee < ne; ee++) {
          const W = J[ee],
            $ = w(W),
            de = L % I,
            le = de % $.boundary,
            fe = de + le;
          ((L += le),
            fe !== 0 && I - fe < $.storage && (L += I - fe),
            (X.__data = new Float32Array(
              $.storage / Float32Array.BYTES_PER_ELEMENT,
            )),
            (X.__offset = L),
            (L += $.storage));
        }
      }
    }
    const O = L % I;
    return (O > 0 && (L += I - O), (C.__size = L), (C.__cache = {}), this);
  }
  function w(C) {
    const R = { boundary: 0, storage: 0 };
    return (
      typeof C == "number" || typeof C == "boolean"
        ? ((R.boundary = 4), (R.storage = 4))
        : C.isVector2
          ? ((R.boundary = 8), (R.storage = 8))
          : C.isVector3 || C.isColor
            ? ((R.boundary = 16), (R.storage = 12))
            : C.isVector4
              ? ((R.boundary = 16), (R.storage = 16))
              : C.isMatrix3
                ? ((R.boundary = 48), (R.storage = 48))
                : C.isMatrix4
                  ? ((R.boundary = 64), (R.storage = 64))
                  : C.isTexture
                    ? Tt(
                        "WebGLRenderer: Texture samplers can not be part of an uniforms group.",
                      )
                    : Tt("WebGLRenderer: Unsupported uniform value type.", C),
      R
    );
  }
  function E(C) {
    const R = C.target;
    R.removeEventListener("dispose", E);
    const L = o.indexOf(R.__bindingPointIndex);
    (o.splice(L, 1), i.deleteBuffer(r[R.id]), delete r[R.id], delete s[R.id]);
  }
  function T() {
    for (const C in r) i.deleteBuffer(r[C]);
    ((o = []), (r = {}), (s = {}));
  }
  return { bind: h, update: d, dispose: T };
}
const b9 = new Uint16Array([
  12469, 15057, 12620, 14925, 13266, 14620, 13807, 14376, 14323, 13990, 14545,
  13625, 14713, 13328, 14840, 12882, 14931, 12528, 14996, 12233, 15039, 11829,
  15066, 11525, 15080, 11295, 15085, 10976, 15082, 10705, 15073, 10495, 13880,
  14564, 13898, 14542, 13977, 14430, 14158, 14124, 14393, 13732, 14556, 13410,
  14702, 12996, 14814, 12596, 14891, 12291, 14937, 11834, 14957, 11489, 14958,
  11194, 14943, 10803, 14921, 10506, 14893, 10278, 14858, 9960, 14484, 14039,
  14487, 14025, 14499, 13941, 14524, 13740, 14574, 13468, 14654, 13106, 14743,
  12678, 14818, 12344, 14867, 11893, 14889, 11509, 14893, 11180, 14881, 10751,
  14852, 10428, 14812, 10128, 14765, 9754, 14712, 9466, 14764, 13480, 14764,
  13475, 14766, 13440, 14766, 13347, 14769, 13070, 14786, 12713, 14816, 12387,
  14844, 11957, 14860, 11549, 14868, 11215, 14855, 10751, 14825, 10403, 14782,
  10044, 14729, 9651, 14666, 9352, 14599, 9029, 14967, 12835, 14966, 12831,
  14963, 12804, 14954, 12723, 14936, 12564, 14917, 12347, 14900, 11958, 14886,
  11569, 14878, 11247, 14859, 10765, 14828, 10401, 14784, 10011, 14727, 9600,
  14660, 9289, 14586, 8893, 14508, 8533, 15111, 12234, 15110, 12234, 15104,
  12216, 15092, 12156, 15067, 12010, 15028, 11776, 14981, 11500, 14942, 11205,
  14902, 10752, 14861, 10393, 14812, 9991, 14752, 9570, 14682, 9252, 14603,
  8808, 14519, 8445, 14431, 8145, 15209, 11449, 15208, 11451, 15202, 11451,
  15190, 11438, 15163, 11384, 15117, 11274, 15055, 10979, 14994, 10648, 14932,
  10343, 14871, 9936, 14803, 9532, 14729, 9218, 14645, 8742, 14556, 8381, 14461,
  8020, 14365, 7603, 15273, 10603, 15272, 10607, 15267, 10619, 15256, 10631,
  15231, 10614, 15182, 10535, 15118, 10389, 15042, 10167, 14963, 9787, 14883,
  9447, 14800, 9115, 14710, 8665, 14615, 8318, 14514, 7911, 14411, 7507, 14279,
  7198, 15314, 9675, 15313, 9683, 15309, 9712, 15298, 9759, 15277, 9797, 15229,
  9773, 15166, 9668, 15084, 9487, 14995, 9274, 14898, 8910, 14800, 8539, 14697,
  8234, 14590, 7790, 14479, 7409, 14367, 7067, 14178, 6621, 15337, 8619, 15337,
  8631, 15333, 8677, 15325, 8769, 15305, 8871, 15264, 8940, 15202, 8909, 15119,
  8775, 15022, 8565, 14916, 8328, 14804, 8009, 14688, 7614, 14569, 7287, 14448,
  6888, 14321, 6483, 14088, 6171, 15350, 7402, 15350, 7419, 15347, 7480, 15340,
  7613, 15322, 7804, 15287, 7973, 15229, 8057, 15148, 8012, 15046, 7846, 14933,
  7611, 14810, 7357, 14682, 7069, 14552, 6656, 14421, 6316, 14251, 5948, 14007,
  5528, 15356, 5942, 15356, 5977, 15353, 6119, 15348, 6294, 15332, 6551, 15302,
  6824, 15249, 7044, 15171, 7122, 15070, 7050, 14949, 6861, 14818, 6611, 14679,
  6349, 14538, 6067, 14398, 5651, 14189, 5311, 13935, 4958, 15359, 4123, 15359,
  4153, 15356, 4296, 15353, 4646, 15338, 5160, 15311, 5508, 15263, 5829, 15188,
  6042, 15088, 6094, 14966, 6001, 14826, 5796, 14678, 5543, 14527, 5287, 14377,
  4985, 14133, 4586, 13869, 4257, 15360, 1563, 15360, 1642, 15358, 2076, 15354,
  2636, 15341, 3350, 15317, 4019, 15273, 4429, 15203, 4732, 15105, 4911, 14981,
  4932, 14836, 4818, 14679, 4621, 14517, 4386, 14359, 4156, 14083, 3795, 13808,
  3437, 15360, 122, 15360, 137, 15358, 285, 15355, 636, 15344, 1274, 15322,
  2177, 15281, 2765, 15215, 3223, 15120, 3451, 14995, 3569, 14846, 3567, 14681,
  3466, 14511, 3305, 14344, 3121, 14037, 2800, 13753, 2467, 15360, 0, 15360, 1,
  15359, 21, 15355, 89, 15346, 253, 15325, 479, 15287, 796, 15225, 1148, 15133,
  1492, 15008, 1749, 14856, 1882, 14685, 1886, 14506, 1783, 14324, 1608, 13996,
  1398, 13702, 1183,
]);
let Fl = null;
function _9() {
  return (
    Fl === null &&
      ((Fl = new Ko(b9, 16, 16, Lh, Kl)),
      (Fl.name = "DFG_LUT"),
      (Fl.minFilter = ni),
      (Fl.magFilter = ni),
      (Fl.wrapS = xa),
      (Fl.wrapT = xa),
      (Fl.generateMipmaps = !1),
      (Fl.needsUpdate = !0)),
    Fl
  );
}
class sU {
  constructor(e = {}) {
    const {
      canvas: t = QL(),
      context: n = null,
      depth: r = !0,
      stencil: s = !1,
      alpha: o = !1,
      antialias: u = !1,
      premultipliedAlpha: h = !0,
      preserveDrawingBuffer: d = !1,
      powerPreference: m = "default",
      failIfMajorPerformanceCaveat: v = !1,
      reversedDepthBuffer: y = !1,
      outputBufferType: b = Bs,
    } = e;
    this.isWebGLRenderer = !0;
    let _;
    if (n !== null) {
      if (
        typeof WebGLRenderingContext < "u" &&
        n instanceof WebGLRenderingContext
      )
        throw new Error(
          "THREE.WebGLRenderer: WebGL 1 is not supported since r163.",
        );
      _ = n.getContextAttributes().alpha;
    } else _ = o;
    const w = b,
      E = new Set([nb, tb, L0]),
      T = new Set([Bs, bo, Tp, Ep, J1, $1]),
      C = new Uint32Array(4),
      R = new Int32Array(4);
    let L = null,
      I = null;
    const O = [],
      B = [];
    let N = null;
    ((this.domElement = t),
      (this.debug = { checkShaderErrors: !0, onShaderError: null }),
      (this.autoClear = !0),
      (this.autoClearColor = !0),
      (this.autoClearDepth = !0),
      (this.autoClearStencil = !0),
      (this.sortObjects = !0),
      (this.clippingPlanes = []),
      (this.localClippingEnabled = !1),
      (this.toneMapping = xo),
      (this.toneMappingExposure = 1),
      (this.transmissionResolutionScale = 1));
    const F = this;
    let j = !1;
    this._outputColorSpace = vs;
    let q = 0,
      X = 0,
      J = null,
      ee = -1,
      ne = null;
    const W = new Dn(),
      $ = new Dn();
    let de = null;
    const le = new wt(0);
    let fe = 0,
      V = t.width,
      Z = t.height,
      se = 1,
      ue = null,
      ge = null;
    const ae = new Dn(0, 0, V, Z),
      he = new Dn(0, 0, V, Z);
    let ye = !1;
    const ze = new kp();
    let it = !1,
      qe = !1;
    const Ye = new qt(),
      ft = new te(),
      Re = new Dn(),
      Ie = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: !0,
      };
    let De = !1;
    function Qe() {
      return J === null ? se : 1;
    }
    let K = n;
    function rt(G, ve) {
      return t.getContext(G, ve);
    }
    try {
      const G = {
        alpha: !0,
        depth: r,
        stencil: s,
        antialias: u,
        premultipliedAlpha: h,
        preserveDrawingBuffer: d,
        powerPreference: m,
        failIfMajorPerformanceCaveat: v,
      };
      if (
        ("setAttribute" in t &&
          t.setAttribute("data-engine", `three.js r${zp}`),
        t.addEventListener("webglcontextlost", ct, !1),
        t.addEventListener("webglcontextrestored", Mt, !1),
        t.addEventListener("webglcontextcreationerror", St, !1),
        K === null)
      ) {
        const ve = "webgl2";
        if (((K = rt(ve, G)), K === null))
          throw rt(ve)
            ? new Error(
                "Error creating WebGL context with your selected attributes.",
              )
            : new Error("Error creating WebGL context.");
      }
    } catch (G) {
      throw (Ft("WebGLRenderer: " + G.message), G);
    }
    let je,
      Te,
      ke,
      H,
      k,
      oe,
      Ae,
      _e,
      be,
      et,
      $e,
      ht,
      yt,
      Ge,
      Ve,
      Ze,
      re,
      Se,
      lt,
      ce,
      Oe,
      Ke,
      dt;
    function Je() {
      ((je = new MH(K)),
        je.init(),
        (Oe = new rU(K, je)),
        (Te = new mH(K, je, e, Oe)),
        (ke = new f9(K, je)),
        Te.reversedDepthBuffer && y && ke.buffers.depth.setReversed(!0),
        (H = new wH(K)),
        (k = new Qj()),
        (oe = new h9(K, je, ke, k, Te, Oe, H)),
        (Ae = new SH(F)),
        (_e = new LV(K)),
        (Ke = new dH(K, _e)),
        (be = new TH(K, _e, H, Ke)),
        (et = new CH(K, be, _e, Ke, H)),
        (Se = new AH(K, Te, oe)),
        (Ve = new gH(k)),
        ($e = new Kj(F, Ae, je, Te, Ke, Ve)),
        (ht = new y9(F, k)),
        (yt = new $j()),
        (Ge = new s9(je)),
        (re = new hH(F, Ae, ke, et, _, h)),
        (Ze = new u9(F, et, Te)),
        (dt = new x9(K, H, Te, ke)),
        (lt = new pH(K, je, H)),
        (ce = new EH(K, je, H)),
        (H.programs = $e.programs),
        (F.capabilities = Te),
        (F.extensions = je),
        (F.properties = k),
        (F.renderLists = yt),
        (F.shadowMap = Ze),
        (F.state = ke),
        (F.info = H));
    }
    (Je(), w !== Bs && (N = new DH(w, t.width, t.height, r, s)));
    const Ee = new g9(F, K);
    ((this.xr = Ee),
      (this.getContext = function () {
        return K;
      }),
      (this.getContextAttributes = function () {
        return K.getContextAttributes();
      }),
      (this.forceContextLoss = function () {
        const G = je.get("WEBGL_lose_context");
        G && G.loseContext();
      }),
      (this.forceContextRestore = function () {
        const G = je.get("WEBGL_lose_context");
        G && G.restoreContext();
      }),
      (this.getPixelRatio = function () {
        return se;
      }),
      (this.setPixelRatio = function (G) {
        G !== void 0 && ((se = G), this.setSize(V, Z, !1));
      }),
      (this.getSize = function (G) {
        return G.set(V, Z);
      }),
      (this.setSize = function (G, ve, Fe = !0) {
        if (Ee.isPresenting) {
          Tt("WebGLRenderer: Can't change size while VR device is presenting.");
          return;
        }
        ((V = G),
          (Z = ve),
          (t.width = Math.floor(G * se)),
          (t.height = Math.floor(ve * se)),
          Fe === !0 &&
            ((t.style.width = G + "px"), (t.style.height = ve + "px")),
          N !== null && N.setSize(t.width, t.height),
          this.setViewport(0, 0, G, ve));
      }),
      (this.getDrawingBufferSize = function (G) {
        return G.set(V * se, Z * se).floor();
      }),
      (this.setDrawingBufferSize = function (G, ve, Fe) {
        ((V = G),
          (Z = ve),
          (se = Fe),
          (t.width = Math.floor(G * Fe)),
          (t.height = Math.floor(ve * Fe)),
          this.setViewport(0, 0, G, ve));
      }),
      (this.setEffects = function (G) {
        if (w === Bs) {
          console.error(
            "THREE.WebGLRenderer: setEffects() requires outputBufferType set to HalfFloatType or FloatType.",
          );
          return;
        }
        if (G) {
          for (let ve = 0; ve < G.length; ve++)
            if (G[ve].isOutputPass === !0) {
              console.warn(
                "THREE.WebGLRenderer: OutputPass is not needed in setEffects(). Tone mapping and color space conversion are applied automatically.",
              );
              break;
            }
        }
        N.setEffects(G || []);
      }),
      (this.getCurrentViewport = function (G) {
        return G.copy(W);
      }),
      (this.getViewport = function (G) {
        return G.copy(ae);
      }),
      (this.setViewport = function (G, ve, Fe, Le) {
        (G.isVector4 ? ae.set(G.x, G.y, G.z, G.w) : ae.set(G, ve, Fe, Le),
          ke.viewport(W.copy(ae).multiplyScalar(se).round()));
      }),
      (this.getScissor = function (G) {
        return G.copy(he);
      }),
      (this.setScissor = function (G, ve, Fe, Le) {
        (G.isVector4 ? he.set(G.x, G.y, G.z, G.w) : he.set(G, ve, Fe, Le),
          ke.scissor($.copy(he).multiplyScalar(se).round()));
      }),
      (this.getScissorTest = function () {
        return ye;
      }),
      (this.setScissorTest = function (G) {
        ke.setScissorTest((ye = G));
      }),
      (this.setOpaqueSort = function (G) {
        ue = G;
      }),
      (this.setTransparentSort = function (G) {
        ge = G;
      }),
      (this.getClearColor = function (G) {
        return G.copy(re.getClearColor());
      }),
      (this.setClearColor = function () {
        re.setClearColor(...arguments);
      }),
      (this.getClearAlpha = function () {
        return re.getClearAlpha();
      }),
      (this.setClearAlpha = function () {
        re.setClearAlpha(...arguments);
      }),
      (this.clear = function (G = !0, ve = !0, Fe = !0) {
        let Le = 0;
        if (G) {
          let Ce = !1;
          if (J !== null) {
            const pt = J.texture.format;
            Ce = E.has(pt);
          }
          if (Ce) {
            const pt = J.texture.type,
              bt = T.has(pt),
              _t = re.getClearColor(),
              gt = re.getClearAlpha(),
              Lt = _t.r,
              zt = _t.g,
              Wt = _t.b;
            bt
              ? ((C[0] = Lt),
                (C[1] = zt),
                (C[2] = Wt),
                (C[3] = gt),
                K.clearBufferuiv(K.COLOR, 0, C))
              : ((R[0] = Lt),
                (R[1] = zt),
                (R[2] = Wt),
                (R[3] = gt),
                K.clearBufferiv(K.COLOR, 0, R));
          } else Le |= K.COLOR_BUFFER_BIT;
        }
        (ve && (Le |= K.DEPTH_BUFFER_BIT),
          Fe &&
            ((Le |= K.STENCIL_BUFFER_BIT),
            this.state.buffers.stencil.setMask(4294967295)),
          Le !== 0 && K.clear(Le));
      }),
      (this.clearColor = function () {
        this.clear(!0, !1, !1);
      }),
      (this.clearDepth = function () {
        this.clear(!1, !0, !1);
      }),
      (this.clearStencil = function () {
        this.clear(!1, !1, !0);
      }),
      (this.dispose = function () {
        (t.removeEventListener("webglcontextlost", ct, !1),
          t.removeEventListener("webglcontextrestored", Mt, !1),
          t.removeEventListener("webglcontextcreationerror", St, !1),
          re.dispose(),
          yt.dispose(),
          Ge.dispose(),
          k.dispose(),
          Ae.dispose(),
          et.dispose(),
          Ke.dispose(),
          dt.dispose(),
          $e.dispose(),
          Ee.dispose(),
          Ee.removeEventListener("sessionstart", Zi),
          Ee.removeEventListener("sessionend", ar),
          zi.stop());
      }));
    function ct(G) {
      (G.preventDefault(), f0("WebGLRenderer: Context Lost."), (j = !0));
    }
    function Mt() {
      (f0("WebGLRenderer: Context Restored."), (j = !1));
      const G = H.autoReset,
        ve = Ze.enabled,
        Fe = Ze.autoUpdate,
        Le = Ze.needsUpdate,
        Ce = Ze.type;
      (Je(),
        (H.autoReset = G),
        (Ze.enabled = ve),
        (Ze.autoUpdate = Fe),
        (Ze.needsUpdate = Le),
        (Ze.type = Ce));
    }
    function St(G) {
      Ft(
        "WebGLRenderer: A WebGL context could not be created. Reason: ",
        G.statusMessage,
      );
    }
    function Dt(G) {
      const ve = G.target;
      (ve.removeEventListener("dispose", Dt), hn(ve));
    }
    function hn(G) {
      (bn(G), k.remove(G));
    }
    function bn(G) {
      const ve = k.get(G).programs;
      ve !== void 0 &&
        (ve.forEach(function (Fe) {
          $e.releaseProgram(Fe);
        }),
        G.isShaderMaterial && $e.releaseShaderCache(G));
    }
    this.renderBufferDirect = function (G, ve, Fe, Le, Ce, pt) {
      ve === null && (ve = Ie);
      const bt = Ce.isMesh && Ce.matrixWorld.determinant() < 0,
        _t = Ba(G, ve, Fe, Le, Ce);
      ke.setMaterial(Le, bt);
      let gt = Fe.index,
        Lt = 1;
      if (Le.wireframe === !0) {
        if (((gt = be.getWireframeAttribute(Fe)), gt === void 0)) return;
        Lt = 2;
      }
      const zt = Fe.drawRange,
        Wt = Fe.attributes.position;
      let At = zt.start * Lt,
        Kt = (zt.start + zt.count) * Lt;
      (pt !== null &&
        ((At = Math.max(At, pt.start * Lt)),
        (Kt = Math.min(Kt, (pt.start + pt.count) * Lt))),
        gt !== null
          ? ((At = Math.max(At, 0)), (Kt = Math.min(Kt, gt.count)))
          : Wt != null &&
            ((At = Math.max(At, 0)), (Kt = Math.min(Kt, Wt.count))));
      const Ln = Kt - At;
      if (Ln < 0 || Ln === 1 / 0) return;
      Ke.setup(Ce, Le, _t, Fe, gt);
      let On,
        rn = lt;
      if (
        (gt !== null && ((On = _e.get(gt)), (rn = ce), rn.setIndex(On)),
        Ce.isMesh)
      )
        Le.wireframe === !0
          ? (ke.setLineWidth(Le.wireframeLinewidth * Qe()), rn.setMode(K.LINES))
          : rn.setMode(K.TRIANGLES);
      else if (Ce.isLine) {
        let mn = Le.linewidth;
        (mn === void 0 && (mn = 1),
          ke.setLineWidth(mn * Qe()),
          Ce.isLineSegments
            ? rn.setMode(K.LINES)
            : Ce.isLineLoop
              ? rn.setMode(K.LINE_LOOP)
              : rn.setMode(K.LINE_STRIP));
      } else
        Ce.isPoints
          ? rn.setMode(K.POINTS)
          : Ce.isSprite && rn.setMode(K.TRIANGLES);
      if (Ce.isBatchedMesh)
        if (Ce._multiDrawInstances !== null)
          (h0(
            "WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection.",
          ),
            rn.renderMultiDrawInstances(
              Ce._multiDrawStarts,
              Ce._multiDrawCounts,
              Ce._multiDrawCount,
              Ce._multiDrawInstances,
            ));
        else if (je.get("WEBGL_multi_draw"))
          rn.renderMultiDraw(
            Ce._multiDrawStarts,
            Ce._multiDrawCounts,
            Ce._multiDrawCount,
          );
        else {
          const mn = Ce._multiDrawStarts,
            vt = Ce._multiDrawCounts,
            bi = Ce._multiDrawCount,
            Pt = gt ? _e.get(gt).bytesPerElement : 1,
            Bi = k.get(Le).currentProgram.getUniforms();
          for (let ki = 0; ki < bi; ki++)
            (Bi.setValue(K, "_gl_DrawID", ki), rn.render(mn[ki] / Pt, vt[ki]));
        }
      else if (Ce.isInstancedMesh) rn.renderInstances(At, Ln, Ce.count);
      else if (Fe.isInstancedBufferGeometry) {
        const mn =
            Fe._maxInstanceCount !== void 0 ? Fe._maxInstanceCount : 1 / 0,
          vt = Math.min(Fe.instanceCount, mn);
        rn.renderInstances(At, Ln, vt);
      } else rn.render(At, Ln);
    };
    function Bn(G, ve, Fe) {
      G.transparent === !0 && G.side === Na && G.forceSinglePass === !1
        ? ((G.side = js),
          (G.needsUpdate = !0),
          gr(G, ve, Fe),
          (G.side = Zc),
          (G.needsUpdate = !0),
          gr(G, ve, Fe),
          (G.side = Na))
        : gr(G, ve, Fe);
    }
    ((this.compile = function (G, ve, Fe = null) {
      (Fe === null && (Fe = G),
        (I = Ge.get(Fe)),
        I.init(ve),
        B.push(I),
        Fe.traverseVisible(function (Ce) {
          Ce.isLight &&
            Ce.layers.test(ve.layers) &&
            (I.pushLight(Ce), Ce.castShadow && I.pushShadow(Ce));
        }),
        G !== Fe &&
          G.traverseVisible(function (Ce) {
            Ce.isLight &&
              Ce.layers.test(ve.layers) &&
              (I.pushLight(Ce), Ce.castShadow && I.pushShadow(Ce));
          }),
        I.setupLights());
      const Le = new Set();
      return (
        G.traverse(function (Ce) {
          if (!(Ce.isMesh || Ce.isPoints || Ce.isLine || Ce.isSprite)) return;
          const pt = Ce.material;
          if (pt)
            if (Array.isArray(pt))
              for (let bt = 0; bt < pt.length; bt++) {
                const _t = pt[bt];
                (Bn(_t, Fe, Ce), Le.add(_t));
              }
            else (Bn(pt, Fe, Ce), Le.add(pt));
        }),
        (I = B.pop()),
        Le
      );
    }),
      (this.compileAsync = function (G, ve, Fe = null) {
        const Le = this.compile(G, ve, Fe);
        return new Promise((Ce) => {
          function pt() {
            if (
              (Le.forEach(function (bt) {
                k.get(bt).currentProgram.isReady() && Le.delete(bt);
              }),
              Le.size === 0)
            ) {
              Ce(G);
              return;
            }
            setTimeout(pt, 10);
          }
          je.get("KHR_parallel_shader_compile") !== null
            ? pt()
            : setTimeout(pt, 10);
        });
      }));
    let Ai = null;
    function $r(G) {
      Ai && Ai(G);
    }
    function Zi() {
      zi.stop();
    }
    function ar() {
      zi.start();
    }
    const zi = new $N();
    (zi.setAnimationLoop($r),
      typeof self < "u" && zi.setContext(self),
      (this.setAnimationLoop = function (G) {
        ((Ai = G), Ee.setAnimationLoop(G), G === null ? zi.stop() : zi.start());
      }),
      Ee.addEventListener("sessionstart", Zi),
      Ee.addEventListener("sessionend", ar),
      (this.render = function (G, ve) {
        if (ve !== void 0 && ve.isCamera !== !0) {
          Ft(
            "WebGLRenderer.render: camera is not an instance of THREE.Camera.",
          );
          return;
        }
        if (j === !0) return;
        const Fe = Ee.enabled === !0 && Ee.isPresenting === !0,
          Le = N !== null && (J === null || Fe) && N.begin(F, J);
        if (
          (G.matrixWorldAutoUpdate === !0 && G.updateMatrixWorld(),
          ve.parent === null &&
            ve.matrixWorldAutoUpdate === !0 &&
            ve.updateMatrixWorld(),
          Ee.enabled === !0 &&
            Ee.isPresenting === !0 &&
            (N === null || N.isCompositing() === !1) &&
            (Ee.cameraAutoUpdate === !0 && Ee.updateCamera(ve),
            (ve = Ee.getCamera())),
          G.isScene === !0 && G.onBeforeRender(F, G, ve, J),
          (I = Ge.get(G, B.length)),
          I.init(ve),
          B.push(I),
          Ye.multiplyMatrices(ve.projectionMatrix, ve.matrixWorldInverse),
          ze.setFromProjectionMatrix(Ye, Ua, ve.reversedDepth),
          (qe = this.localClippingEnabled),
          (it = Ve.init(this.clippingPlanes, qe)),
          (L = yt.get(G, O.length)),
          L.init(),
          O.push(L),
          Ee.enabled === !0 && Ee.isPresenting === !0)
        ) {
          const bt = F.xr.getDepthSensingMesh();
          bt !== null && xi(bt, ve, -1 / 0, F.sortObjects);
        }
        (xi(G, ve, 0, F.sortObjects),
          L.finish(),
          F.sortObjects === !0 && L.sort(ue, ge),
          (De =
            Ee.enabled === !1 ||
            Ee.isPresenting === !1 ||
            Ee.hasDepthSensing() === !1),
          De && re.addToRenderList(L, G),
          this.info.render.frame++,
          it === !0 && Ve.beginShadows());
        const Ce = I.state.shadowsArray;
        if (
          (Ze.render(Ce, G, ve),
          it === !0 && Ve.endShadows(),
          this.info.autoReset === !0 && this.info.reset(),
          (Le && N.hasRenderPass()) === !1)
        ) {
          const bt = L.opaque,
            _t = L.transmissive;
          if ((I.setupLights(), ve.isArrayCamera)) {
            const gt = ve.cameras;
            if (_t.length > 0)
              for (let Lt = 0, zt = gt.length; Lt < zt; Lt++) {
                const Wt = gt[Lt];
                Un(bt, _t, G, Wt);
              }
            De && re.render(G);
            for (let Lt = 0, zt = gt.length; Lt < zt; Lt++) {
              const Wt = gt[Lt];
              Hn(L, G, Wt, Wt.viewport);
            }
          } else
            (_t.length > 0 && Un(bt, _t, G, ve),
              De && re.render(G),
              Hn(L, G, ve));
        }
        (J !== null &&
          X === 0 &&
          (oe.updateMultisampleRenderTarget(J), oe.updateRenderTargetMipmap(J)),
          Le && N.end(F),
          G.isScene === !0 && G.onAfterRender(F, G, ve),
          Ke.resetDefaultState(),
          (ee = -1),
          (ne = null),
          B.pop(),
          B.length > 0
            ? ((I = B[B.length - 1]),
              it === !0 && Ve.setGlobalState(F.clippingPlanes, I.state.camera))
            : (I = null),
          O.pop(),
          O.length > 0 ? (L = O[O.length - 1]) : (L = null));
      }));
    function xi(G, ve, Fe, Le) {
      if (G.visible === !1) return;
      if (G.layers.test(ve.layers)) {
        if (G.isGroup) Fe = G.renderOrder;
        else if (G.isLOD) G.autoUpdate === !0 && G.update(ve);
        else if (G.isLight) (I.pushLight(G), G.castShadow && I.pushShadow(G));
        else if (G.isSprite) {
          if (!G.frustumCulled || ze.intersectsSprite(G)) {
            Le && Re.setFromMatrixPosition(G.matrixWorld).applyMatrix4(Ye);
            const bt = et.update(G),
              _t = G.material;
            _t.visible && L.push(G, bt, _t, Fe, Re.z, null);
          }
        } else if (
          (G.isMesh || G.isLine || G.isPoints) &&
          (!G.frustumCulled || ze.intersectsObject(G))
        ) {
          const bt = et.update(G),
            _t = G.material;
          if (
            (Le &&
              (G.boundingSphere !== void 0
                ? (G.boundingSphere === null && G.computeBoundingSphere(),
                  Re.copy(G.boundingSphere.center))
                : (bt.boundingSphere === null && bt.computeBoundingSphere(),
                  Re.copy(bt.boundingSphere.center)),
              Re.applyMatrix4(G.matrixWorld).applyMatrix4(Ye)),
            Array.isArray(_t))
          ) {
            const gt = bt.groups;
            for (let Lt = 0, zt = gt.length; Lt < zt; Lt++) {
              const Wt = gt[Lt],
                At = _t[Wt.materialIndex];
              At && At.visible && L.push(G, bt, At, Fe, Re.z, Wt);
            }
          } else _t.visible && L.push(G, bt, _t, Fe, Re.z, null);
        }
      }
      const pt = G.children;
      for (let bt = 0, _t = pt.length; bt < _t; bt++) xi(pt[bt], ve, Fe, Le);
    }
    function Hn(G, ve, Fe, Le) {
      const { opaque: Ce, transmissive: pt, transparent: bt } = G;
      (I.setupLightsView(Fe),
        it === !0 && Ve.setGlobalState(F.clippingPlanes, Fe),
        Le && ke.viewport(W.copy(Le)),
        Ce.length > 0 && ii(Ce, ve, Fe),
        pt.length > 0 && ii(pt, ve, Fe),
        bt.length > 0 && ii(bt, ve, Fe),
        ke.buffers.depth.setTest(!0),
        ke.buffers.depth.setMask(!0),
        ke.buffers.color.setMask(!0),
        ke.setPolygonOffset(!1));
    }
    function Un(G, ve, Fe, Le) {
      if ((Fe.isScene === !0 ? Fe.overrideMaterial : null) !== null) return;
      if (I.state.transmissionRenderTarget[Le.id] === void 0) {
        const At =
          je.has("EXT_color_buffer_half_float") ||
          je.has("EXT_color_buffer_float");
        I.state.transmissionRenderTarget[Le.id] = new Oa(1, 1, {
          generateMipmaps: !0,
          type: At ? Kl : Bs,
          minFilter: Hl,
          samples: Te.samples,
          stencilBuffer: s,
          resolveDepthBuffer: !1,
          resolveStencilBuffer: !1,
          colorSpace: Cn.workingColorSpace,
        });
      }
      const pt = I.state.transmissionRenderTarget[Le.id],
        bt = Le.viewport || W;
      pt.setSize(
        bt.z * F.transmissionResolutionScale,
        bt.w * F.transmissionResolutionScale,
      );
      const _t = F.getRenderTarget(),
        gt = F.getActiveCubeFace(),
        Lt = F.getActiveMipmapLevel();
      (F.setRenderTarget(pt),
        F.getClearColor(le),
        (fe = F.getClearAlpha()),
        fe < 1 && F.setClearColor(16777215, 0.5),
        F.clear(),
        De && re.render(Fe));
      const zt = F.toneMapping;
      F.toneMapping = xo;
      const Wt = Le.viewport;
      if (
        (Le.viewport !== void 0 && (Le.viewport = void 0),
        I.setupLightsView(Le),
        it === !0 && Ve.setGlobalState(F.clippingPlanes, Le),
        ii(G, Fe, Le),
        oe.updateMultisampleRenderTarget(pt),
        oe.updateRenderTargetMipmap(pt),
        je.has("WEBGL_multisampled_render_to_texture") === !1)
      ) {
        let At = !1;
        for (let Kt = 0, Ln = ve.length; Kt < Ln; Kt++) {
          const On = ve[Kt],
            { object: rn, geometry: mn, material: vt, group: bi } = On;
          if (vt.side === Na && rn.layers.test(Le.layers)) {
            const Pt = vt.side;
            ((vt.side = js),
              (vt.needsUpdate = !0),
              Ir(rn, Fe, Le, mn, vt, bi),
              (vt.side = Pt),
              (vt.needsUpdate = !0),
              (At = !0));
          }
        }
        At === !0 &&
          (oe.updateMultisampleRenderTarget(pt),
          oe.updateRenderTargetMipmap(pt));
      }
      (F.setRenderTarget(_t, gt, Lt),
        F.setClearColor(le, fe),
        Wt !== void 0 && (Le.viewport = Wt),
        (F.toneMapping = zt));
    }
    function ii(G, ve, Fe) {
      const Le = ve.isScene === !0 ? ve.overrideMaterial : null;
      for (let Ce = 0, pt = G.length; Ce < pt; Ce++) {
        const bt = G[Ce],
          { object: _t, geometry: gt, group: Lt } = bt;
        let zt = bt.material;
        (zt.allowOverride === !0 && Le !== null && (zt = Le),
          _t.layers.test(Fe.layers) && Ir(_t, ve, Fe, gt, zt, Lt));
      }
    }
    function Ir(G, ve, Fe, Le, Ce, pt) {
      (G.onBeforeRender(F, ve, Fe, Le, Ce, pt),
        G.modelViewMatrix.multiplyMatrices(
          Fe.matrixWorldInverse,
          G.matrixWorld,
        ),
        G.normalMatrix.getNormalMatrix(G.modelViewMatrix),
        Ce.onBeforeRender(F, ve, Fe, Le, G, pt),
        Ce.transparent === !0 && Ce.side === Na && Ce.forceSinglePass === !1
          ? ((Ce.side = js),
            (Ce.needsUpdate = !0),
            F.renderBufferDirect(Fe, ve, Le, Ce, G, pt),
            (Ce.side = Zc),
            (Ce.needsUpdate = !0),
            F.renderBufferDirect(Fe, ve, Le, Ce, G, pt),
            (Ce.side = Na))
          : F.renderBufferDirect(Fe, ve, Le, Ce, G, pt),
        G.onAfterRender(F, ve, Fe, Le, Ce, pt));
    }
    function gr(G, ve, Fe) {
      ve.isScene !== !0 && (ve = Ie);
      const Le = k.get(G),
        Ce = I.state.lights,
        pt = I.state.shadowsArray,
        bt = Ce.state.version,
        _t = $e.getParameters(G, Ce.state, pt, ve, Fe),
        gt = $e.getProgramCacheKey(_t);
      let Lt = Le.programs;
      ((Le.environment =
        G.isMeshStandardMaterial ||
        G.isMeshLambertMaterial ||
        G.isMeshPhongMaterial
          ? ve.environment
          : null),
        (Le.fog = ve.fog));
      const zt =
        G.isMeshStandardMaterial ||
        (G.isMeshLambertMaterial && !G.envMap) ||
        (G.isMeshPhongMaterial && !G.envMap);
      ((Le.envMap = Ae.get(G.envMap || Le.environment, zt)),
        (Le.envMapRotation =
          Le.environment !== null && G.envMap === null
            ? ve.environmentRotation
            : G.envMapRotation),
        Lt === void 0 &&
          (G.addEventListener("dispose", Dt),
          (Lt = new Map()),
          (Le.programs = Lt)));
      let Wt = Lt.get(gt);
      if (Wt !== void 0) {
        if (Le.currentProgram === Wt && Le.lightsStateVersion === bt)
          return (_s(G, _t), Wt);
      } else
        ((_t.uniforms = $e.getUniforms(G)),
          G.onBeforeCompile(_t, F),
          (Wt = $e.acquireProgram(_t, gt)),
          Lt.set(gt, Wt),
          (Le.uniforms = _t.uniforms));
      const At = Le.uniforms;
      return (
        ((!G.isShaderMaterial && !G.isRawShaderMaterial) ||
          G.clipping === !0) &&
          (At.clippingPlanes = Ve.uniform),
        _s(G, _t),
        (Le.needsLights = Xs(G)),
        (Le.lightsStateVersion = bt),
        Le.needsLights &&
          ((At.ambientLightColor.value = Ce.state.ambient),
          (At.lightProbe.value = Ce.state.probe),
          (At.directionalLights.value = Ce.state.directional),
          (At.directionalLightShadows.value = Ce.state.directionalShadow),
          (At.spotLights.value = Ce.state.spot),
          (At.spotLightShadows.value = Ce.state.spotShadow),
          (At.rectAreaLights.value = Ce.state.rectArea),
          (At.ltc_1.value = Ce.state.rectAreaLTC1),
          (At.ltc_2.value = Ce.state.rectAreaLTC2),
          (At.pointLights.value = Ce.state.point),
          (At.pointLightShadows.value = Ce.state.pointShadow),
          (At.hemisphereLights.value = Ce.state.hemi),
          (At.directionalShadowMatrix.value = Ce.state.directionalShadowMatrix),
          (At.spotLightMatrix.value = Ce.state.spotLightMatrix),
          (At.spotLightMap.value = Ce.state.spotLightMap),
          (At.pointShadowMatrix.value = Ce.state.pointShadowMatrix)),
        (Le.currentProgram = Wt),
        (Le.uniformsList = null),
        Wt
      );
    }
    function es(G) {
      if (G.uniformsList === null) {
        const ve = G.currentProgram.getUniforms();
        G.uniformsList = Dx.seqWithValue(ve.seq, G.uniforms);
      }
      return G.uniformsList;
    }
    function _s(G, ve) {
      const Fe = k.get(G);
      ((Fe.outputColorSpace = ve.outputColorSpace),
        (Fe.batching = ve.batching),
        (Fe.batchingColor = ve.batchingColor),
        (Fe.instancing = ve.instancing),
        (Fe.instancingColor = ve.instancingColor),
        (Fe.instancingMorph = ve.instancingMorph),
        (Fe.skinning = ve.skinning),
        (Fe.morphTargets = ve.morphTargets),
        (Fe.morphNormals = ve.morphNormals),
        (Fe.morphColors = ve.morphColors),
        (Fe.morphTargetsCount = ve.morphTargetsCount),
        (Fe.numClippingPlanes = ve.numClippingPlanes),
        (Fe.numIntersection = ve.numClipIntersection),
        (Fe.vertexAlphas = ve.vertexAlphas),
        (Fe.vertexTangents = ve.vertexTangents),
        (Fe.toneMapping = ve.toneMapping));
    }
    function Ba(G, ve, Fe, Le, Ce) {
      (ve.isScene !== !0 && (ve = Ie), oe.resetTextureUnits());
      const pt = ve.fog,
        bt =
          Le.isMeshStandardMaterial ||
          Le.isMeshLambertMaterial ||
          Le.isMeshPhongMaterial
            ? ve.environment
            : null,
        _t =
          J === null
            ? F.outputColorSpace
            : J.isXRRenderTarget === !0
              ? J.texture.colorSpace
              : af,
        gt =
          Le.isMeshStandardMaterial ||
          (Le.isMeshLambertMaterial && !Le.envMap) ||
          (Le.isMeshPhongMaterial && !Le.envMap),
        Lt = Ae.get(Le.envMap || bt, gt),
        zt =
          Le.vertexColors === !0 &&
          !!Fe.attributes.color &&
          Fe.attributes.color.itemSize === 4,
        Wt = !!Fe.attributes.tangent && (!!Le.normalMap || Le.anisotropy > 0),
        At = !!Fe.morphAttributes.position,
        Kt = !!Fe.morphAttributes.normal,
        Ln = !!Fe.morphAttributes.color;
      let On = xo;
      Le.toneMapped &&
        (J === null || J.isXRRenderTarget === !0) &&
        (On = F.toneMapping);
      const rn =
          Fe.morphAttributes.position ||
          Fe.morphAttributes.normal ||
          Fe.morphAttributes.color,
        mn = rn !== void 0 ? rn.length : 0,
        vt = k.get(Le),
        bi = I.state.lights;
      if (it === !0 && (qe === !0 || G !== ne)) {
        const ri = G === ne && Le.id === ee;
        Ve.setState(Le, G, ri);
      }
      let Pt = !1;
      Le.version === vt.__version
        ? ((vt.needsLights && vt.lightsStateVersion !== bi.state.version) ||
            vt.outputColorSpace !== _t ||
            (Ce.isBatchedMesh && vt.batching === !1) ||
            (!Ce.isBatchedMesh && vt.batching === !0) ||
            (Ce.isBatchedMesh &&
              vt.batchingColor === !0 &&
              Ce.colorTexture === null) ||
            (Ce.isBatchedMesh &&
              vt.batchingColor === !1 &&
              Ce.colorTexture !== null) ||
            (Ce.isInstancedMesh && vt.instancing === !1) ||
            (!Ce.isInstancedMesh && vt.instancing === !0) ||
            (Ce.isSkinnedMesh && vt.skinning === !1) ||
            (!Ce.isSkinnedMesh && vt.skinning === !0) ||
            (Ce.isInstancedMesh &&
              vt.instancingColor === !0 &&
              Ce.instanceColor === null) ||
            (Ce.isInstancedMesh &&
              vt.instancingColor === !1 &&
              Ce.instanceColor !== null) ||
            (Ce.isInstancedMesh &&
              vt.instancingMorph === !0 &&
              Ce.morphTexture === null) ||
            (Ce.isInstancedMesh &&
              vt.instancingMorph === !1 &&
              Ce.morphTexture !== null) ||
            vt.envMap !== Lt ||
            (Le.fog === !0 && vt.fog !== pt) ||
            (vt.numClippingPlanes !== void 0 &&
              (vt.numClippingPlanes !== Ve.numPlanes ||
                vt.numIntersection !== Ve.numIntersection)) ||
            vt.vertexAlphas !== zt ||
            vt.vertexTangents !== Wt ||
            vt.morphTargets !== At ||
            vt.morphNormals !== Kt ||
            vt.morphColors !== Ln ||
            vt.toneMapping !== On ||
            vt.morphTargetsCount !== mn) &&
          (Pt = !0)
        : ((Pt = !0), (vt.__version = Le.version));
      let Bi = vt.currentProgram;
      Pt === !0 && (Bi = gr(Le, ve, Ce));
      let ki = !1,
        ei = !1,
        Ki = !1;
      const gn = Bi.getUniforms(),
        qn = vt.uniforms;
      if (
        (ke.useProgram(Bi.program) && ((ki = !0), (ei = !0), (Ki = !0)),
        Le.id !== ee && ((ee = Le.id), (ei = !0)),
        ki || ne !== G)
      ) {
        (ke.buffers.depth.getReversed() &&
          G.reversedDepth !== !0 &&
          ((G._reversedDepth = !0), G.updateProjectionMatrix()),
          gn.setValue(K, "projectionMatrix", G.projectionMatrix),
          gn.setValue(K, "viewMatrix", G.matrixWorldInverse));
        const Or = gn.map.cameraPosition;
        (Or !== void 0 &&
          Or.setValue(K, ft.setFromMatrixPosition(G.matrixWorld)),
          Te.logarithmicDepthBuffer &&
            gn.setValue(
              K,
              "logDepthBufFC",
              2 / (Math.log(G.far + 1) / Math.LN2),
            ),
          (Le.isMeshPhongMaterial ||
            Le.isMeshToonMaterial ||
            Le.isMeshLambertMaterial ||
            Le.isMeshBasicMaterial ||
            Le.isMeshStandardMaterial ||
            Le.isShaderMaterial) &&
            gn.setValue(K, "isOrthographic", G.isOrthographicCamera === !0),
          ne !== G && ((ne = G), (ei = !0), (Ki = !0)));
      }
      if (
        (vt.needsLights &&
          (bi.state.directionalShadowMap.length > 0 &&
            gn.setValue(
              K,
              "directionalShadowMap",
              bi.state.directionalShadowMap,
              oe,
            ),
          bi.state.spotShadowMap.length > 0 &&
            gn.setValue(K, "spotShadowMap", bi.state.spotShadowMap, oe),
          bi.state.pointShadowMap.length > 0 &&
            gn.setValue(K, "pointShadowMap", bi.state.pointShadowMap, oe)),
        Ce.isSkinnedMesh)
      ) {
        (gn.setOptional(K, Ce, "bindMatrix"),
          gn.setOptional(K, Ce, "bindMatrixInverse"));
        const ri = Ce.skeleton;
        ri &&
          (ri.boneTexture === null && ri.computeBoneTexture(),
          gn.setValue(K, "boneTexture", ri.boneTexture, oe));
      }
      Ce.isBatchedMesh &&
        (gn.setOptional(K, Ce, "batchingTexture"),
        gn.setValue(K, "batchingTexture", Ce._matricesTexture, oe),
        gn.setOptional(K, Ce, "batchingIdTexture"),
        gn.setValue(K, "batchingIdTexture", Ce._indirectTexture, oe),
        gn.setOptional(K, Ce, "batchingColorTexture"),
        Ce._colorsTexture !== null &&
          gn.setValue(K, "batchingColorTexture", Ce._colorsTexture, oe));
      const Vi = Fe.morphAttributes;
      if (
        ((Vi.position !== void 0 ||
          Vi.normal !== void 0 ||
          Vi.color !== void 0) &&
          Se.update(Ce, Fe, Bi),
        (ei || vt.receiveShadow !== Ce.receiveShadow) &&
          ((vt.receiveShadow = Ce.receiveShadow),
          gn.setValue(K, "receiveShadow", Ce.receiveShadow)),
        (Le.isMeshStandardMaterial ||
          Le.isMeshLambertMaterial ||
          Le.isMeshPhongMaterial) &&
          Le.envMap === null &&
          ve.environment !== null &&
          (qn.envMapIntensity.value = ve.environmentIntensity),
        qn.dfgLUT !== void 0 && (qn.dfgLUT.value = _9()),
        ei &&
          (gn.setValue(K, "toneMappingExposure", F.toneMappingExposure),
          vt.needsLights && Ss(qn, Ki),
          pt && Le.fog === !0 && ht.refreshFogUniforms(qn, pt),
          ht.refreshMaterialUniforms(
            qn,
            Le,
            se,
            Z,
            I.state.transmissionRenderTarget[G.id],
          ),
          Dx.upload(K, es(vt), qn, oe)),
        Le.isShaderMaterial &&
          Le.uniformsNeedUpdate === !0 &&
          (Dx.upload(K, es(vt), qn, oe), (Le.uniformsNeedUpdate = !1)),
        Le.isSpriteMaterial && gn.setValue(K, "center", Ce.center),
        gn.setValue(K, "modelViewMatrix", Ce.modelViewMatrix),
        gn.setValue(K, "normalMatrix", Ce.normalMatrix),
        gn.setValue(K, "modelMatrix", Ce.matrixWorld),
        Le.isShaderMaterial || Le.isRawShaderMaterial)
      ) {
        const ri = Le.uniformsGroups;
        for (let Or = 0, ns = ri.length; Or < ns; Or++) {
          const Ts = ri[Or];
          (dt.update(Ts, Bi), dt.bind(Ts, Bi));
        }
      }
      return Bi;
    }
    function Ss(G, ve) {
      ((G.ambientLightColor.needsUpdate = ve),
        (G.lightProbe.needsUpdate = ve),
        (G.directionalLights.needsUpdate = ve),
        (G.directionalLightShadows.needsUpdate = ve),
        (G.pointLights.needsUpdate = ve),
        (G.pointLightShadows.needsUpdate = ve),
        (G.spotLights.needsUpdate = ve),
        (G.spotLightShadows.needsUpdate = ve),
        (G.rectAreaLights.needsUpdate = ve),
        (G.hemisphereLights.needsUpdate = ve));
    }
    function Xs(G) {
      return (
        G.isMeshLambertMaterial ||
        G.isMeshToonMaterial ||
        G.isMeshPhongMaterial ||
        G.isMeshStandardMaterial ||
        G.isShadowMaterial ||
        (G.isShaderMaterial && G.lights === !0)
      );
    }
    ((this.getActiveCubeFace = function () {
      return q;
    }),
      (this.getActiveMipmapLevel = function () {
        return X;
      }),
      (this.getRenderTarget = function () {
        return J;
      }),
      (this.setRenderTargetTextures = function (G, ve, Fe) {
        const Le = k.get(G);
        ((Le.__autoAllocateDepthBuffer = G.resolveDepthBuffer === !1),
          Le.__autoAllocateDepthBuffer === !1 && (Le.__useRenderToTexture = !1),
          (k.get(G.texture).__webglTexture = ve),
          (k.get(G.depthTexture).__webglTexture = Le.__autoAllocateDepthBuffer
            ? void 0
            : Fe),
          (Le.__hasExternalTextures = !0));
      }),
      (this.setRenderTargetFramebuffer = function (G, ve) {
        const Fe = k.get(G);
        ((Fe.__webglFramebuffer = ve),
          (Fe.__useDefaultFramebuffer = ve === void 0));
      }));
    const ts = K.createFramebuffer();
    ((this.setRenderTarget = function (G, ve = 0, Fe = 0) {
      ((J = G), (q = ve), (X = Fe));
      let Le = null,
        Ce = !1,
        pt = !1;
      if (G) {
        const _t = k.get(G);
        if (_t.__useDefaultFramebuffer !== void 0) {
          (ke.bindFramebuffer(K.FRAMEBUFFER, _t.__webglFramebuffer),
            W.copy(G.viewport),
            $.copy(G.scissor),
            (de = G.scissorTest),
            ke.viewport(W),
            ke.scissor($),
            ke.setScissorTest(de),
            (ee = -1));
          return;
        } else if (_t.__webglFramebuffer === void 0) oe.setupRenderTarget(G);
        else if (_t.__hasExternalTextures)
          oe.rebindTextures(
            G,
            k.get(G.texture).__webglTexture,
            k.get(G.depthTexture).__webglTexture,
          );
        else if (G.depthBuffer) {
          const zt = G.depthTexture;
          if (_t.__boundDepthTexture !== zt) {
            if (
              zt !== null &&
              k.has(zt) &&
              (G.width !== zt.image.width || G.height !== zt.image.height)
            )
              throw new Error(
                "WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.",
              );
            oe.setupDepthRenderbuffer(G);
          }
        }
        const gt = G.texture;
        (gt.isData3DTexture ||
          gt.isDataArrayTexture ||
          gt.isCompressedArrayTexture) &&
          (pt = !0);
        const Lt = k.get(G).__webglFramebuffer;
        (G.isWebGLCubeRenderTarget
          ? (Array.isArray(Lt[ve]) ? (Le = Lt[ve][Fe]) : (Le = Lt[ve]),
            (Ce = !0))
          : G.samples > 0 && oe.useMultisampledRTT(G) === !1
            ? (Le = k.get(G).__webglMultisampledFramebuffer)
            : Array.isArray(Lt)
              ? (Le = Lt[Fe])
              : (Le = Lt),
          W.copy(G.viewport),
          $.copy(G.scissor),
          (de = G.scissorTest));
      } else
        (W.copy(ae).multiplyScalar(se).floor(),
          $.copy(he).multiplyScalar(se).floor(),
          (de = ye));
      if (
        (Fe !== 0 && (Le = ts),
        ke.bindFramebuffer(K.FRAMEBUFFER, Le) && ke.drawBuffers(G, Le),
        ke.viewport(W),
        ke.scissor($),
        ke.setScissorTest(de),
        Ce)
      ) {
        const _t = k.get(G.texture);
        K.framebufferTexture2D(
          K.FRAMEBUFFER,
          K.COLOR_ATTACHMENT0,
          K.TEXTURE_CUBE_MAP_POSITIVE_X + ve,
          _t.__webglTexture,
          Fe,
        );
      } else if (pt) {
        const _t = ve;
        for (let gt = 0; gt < G.textures.length; gt++) {
          const Lt = k.get(G.textures[gt]);
          K.framebufferTextureLayer(
            K.FRAMEBUFFER,
            K.COLOR_ATTACHMENT0 + gt,
            Lt.__webglTexture,
            Fe,
            _t,
          );
        }
      } else if (G !== null && Fe !== 0) {
        const _t = k.get(G.texture);
        K.framebufferTexture2D(
          K.FRAMEBUFFER,
          K.COLOR_ATTACHMENT0,
          K.TEXTURE_2D,
          _t.__webglTexture,
          Fe,
        );
      }
      ee = -1;
    }),
      (this.readRenderTargetPixels = function (
        G,
        ve,
        Fe,
        Le,
        Ce,
        pt,
        bt,
        _t = 0,
      ) {
        if (!(G && G.isWebGLRenderTarget)) {
          Ft(
            "WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.",
          );
          return;
        }
        let gt = k.get(G).__webglFramebuffer;
        if ((G.isWebGLCubeRenderTarget && bt !== void 0 && (gt = gt[bt]), gt)) {
          ke.bindFramebuffer(K.FRAMEBUFFER, gt);
          try {
            const Lt = G.textures[_t],
              zt = Lt.format,
              Wt = Lt.type;
            if (
              (G.textures.length > 1 && K.readBuffer(K.COLOR_ATTACHMENT0 + _t),
              !Te.textureFormatReadable(zt))
            ) {
              Ft(
                "WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.",
              );
              return;
            }
            if (!Te.textureTypeReadable(Wt)) {
              Ft(
                "WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.",
              );
              return;
            }
            ve >= 0 &&
              ve <= G.width - Le &&
              Fe >= 0 &&
              Fe <= G.height - Ce &&
              K.readPixels(ve, Fe, Le, Ce, Oe.convert(zt), Oe.convert(Wt), pt);
          } finally {
            const Lt = J !== null ? k.get(J).__webglFramebuffer : null;
            ke.bindFramebuffer(K.FRAMEBUFFER, Lt);
          }
        }
      }),
      (this.readRenderTargetPixelsAsync = async function (
        G,
        ve,
        Fe,
        Le,
        Ce,
        pt,
        bt,
        _t = 0,
      ) {
        if (!(G && G.isWebGLRenderTarget))
          throw new Error(
            "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.",
          );
        let gt = k.get(G).__webglFramebuffer;
        if ((G.isWebGLCubeRenderTarget && bt !== void 0 && (gt = gt[bt]), gt))
          if (ve >= 0 && ve <= G.width - Le && Fe >= 0 && Fe <= G.height - Ce) {
            ke.bindFramebuffer(K.FRAMEBUFFER, gt);
            const Lt = G.textures[_t],
              zt = Lt.format,
              Wt = Lt.type;
            if (
              (G.textures.length > 1 && K.readBuffer(K.COLOR_ATTACHMENT0 + _t),
              !Te.textureFormatReadable(zt))
            )
              throw new Error(
                "THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.",
              );
            if (!Te.textureTypeReadable(Wt))
              throw new Error(
                "THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.",
              );
            const At = K.createBuffer();
            (K.bindBuffer(K.PIXEL_PACK_BUFFER, At),
              K.bufferData(K.PIXEL_PACK_BUFFER, pt.byteLength, K.STREAM_READ),
              K.readPixels(ve, Fe, Le, Ce, Oe.convert(zt), Oe.convert(Wt), 0));
            const Kt = J !== null ? k.get(J).__webglFramebuffer : null;
            ke.bindFramebuffer(K.FRAMEBUFFER, Kt);
            const Ln = K.fenceSync(K.SYNC_GPU_COMMANDS_COMPLETE, 0);
            return (
              K.flush(),
              await IB(K, Ln, 4),
              K.bindBuffer(K.PIXEL_PACK_BUFFER, At),
              K.getBufferSubData(K.PIXEL_PACK_BUFFER, 0, pt),
              K.deleteBuffer(At),
              K.deleteSync(Ln),
              pt
            );
          } else
            throw new Error(
              "THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.",
            );
      }),
      (this.copyFramebufferToTexture = function (G, ve = null, Fe = 0) {
        const Le = Math.pow(2, -Fe),
          Ce = Math.floor(G.image.width * Le),
          pt = Math.floor(G.image.height * Le),
          bt = ve !== null ? ve.x : 0,
          _t = ve !== null ? ve.y : 0;
        (oe.setTexture2D(G, 0),
          K.copyTexSubImage2D(K.TEXTURE_2D, Fe, 0, 0, bt, _t, Ce, pt),
          ke.unbindTexture());
      }));
    const Ms = K.createFramebuffer(),
      qs = K.createFramebuffer();
    ((this.copyTextureToTexture = function (
      G,
      ve,
      Fe = null,
      Le = null,
      Ce = 0,
      pt = 0,
    ) {
      let bt, _t, gt, Lt, zt, Wt, At, Kt, Ln;
      const On = G.isCompressedTexture ? G.mipmaps[pt] : G.image;
      if (Fe !== null)
        ((bt = Fe.max.x - Fe.min.x),
          (_t = Fe.max.y - Fe.min.y),
          (gt = Fe.isBox3 ? Fe.max.z - Fe.min.z : 1),
          (Lt = Fe.min.x),
          (zt = Fe.min.y),
          (Wt = Fe.isBox3 ? Fe.min.z : 0));
      else {
        const qn = Math.pow(2, -Ce);
        ((bt = Math.floor(On.width * qn)),
          (_t = Math.floor(On.height * qn)),
          G.isDataArrayTexture
            ? (gt = On.depth)
            : G.isData3DTexture
              ? (gt = Math.floor(On.depth * qn))
              : (gt = 1),
          (Lt = 0),
          (zt = 0),
          (Wt = 0));
      }
      Le !== null
        ? ((At = Le.x), (Kt = Le.y), (Ln = Le.z))
        : ((At = 0), (Kt = 0), (Ln = 0));
      const rn = Oe.convert(ve.format),
        mn = Oe.convert(ve.type);
      let vt;
      (ve.isData3DTexture
        ? (oe.setTexture3D(ve, 0), (vt = K.TEXTURE_3D))
        : ve.isDataArrayTexture || ve.isCompressedArrayTexture
          ? (oe.setTexture2DArray(ve, 0), (vt = K.TEXTURE_2D_ARRAY))
          : (oe.setTexture2D(ve, 0), (vt = K.TEXTURE_2D)),
        K.pixelStorei(K.UNPACK_FLIP_Y_WEBGL, ve.flipY),
        K.pixelStorei(K.UNPACK_PREMULTIPLY_ALPHA_WEBGL, ve.premultiplyAlpha),
        K.pixelStorei(K.UNPACK_ALIGNMENT, ve.unpackAlignment));
      const bi = K.getParameter(K.UNPACK_ROW_LENGTH),
        Pt = K.getParameter(K.UNPACK_IMAGE_HEIGHT),
        Bi = K.getParameter(K.UNPACK_SKIP_PIXELS),
        ki = K.getParameter(K.UNPACK_SKIP_ROWS),
        ei = K.getParameter(K.UNPACK_SKIP_IMAGES);
      (K.pixelStorei(K.UNPACK_ROW_LENGTH, On.width),
        K.pixelStorei(K.UNPACK_IMAGE_HEIGHT, On.height),
        K.pixelStorei(K.UNPACK_SKIP_PIXELS, Lt),
        K.pixelStorei(K.UNPACK_SKIP_ROWS, zt),
        K.pixelStorei(K.UNPACK_SKIP_IMAGES, Wt));
      const Ki = G.isDataArrayTexture || G.isData3DTexture,
        gn = ve.isDataArrayTexture || ve.isData3DTexture;
      if (G.isDepthTexture) {
        const qn = k.get(G),
          Vi = k.get(ve),
          ri = k.get(qn.__renderTarget),
          Or = k.get(Vi.__renderTarget);
        (ke.bindFramebuffer(K.READ_FRAMEBUFFER, ri.__webglFramebuffer),
          ke.bindFramebuffer(K.DRAW_FRAMEBUFFER, Or.__webglFramebuffer));
        for (let ns = 0; ns < gt; ns++)
          (Ki &&
            (K.framebufferTextureLayer(
              K.READ_FRAMEBUFFER,
              K.COLOR_ATTACHMENT0,
              k.get(G).__webglTexture,
              Ce,
              Wt + ns,
            ),
            K.framebufferTextureLayer(
              K.DRAW_FRAMEBUFFER,
              K.COLOR_ATTACHMENT0,
              k.get(ve).__webglTexture,
              pt,
              Ln + ns,
            )),
            K.blitFramebuffer(
              Lt,
              zt,
              bt,
              _t,
              At,
              Kt,
              bt,
              _t,
              K.DEPTH_BUFFER_BIT,
              K.NEAREST,
            ));
        (ke.bindFramebuffer(K.READ_FRAMEBUFFER, null),
          ke.bindFramebuffer(K.DRAW_FRAMEBUFFER, null));
      } else if (Ce !== 0 || G.isRenderTargetTexture || k.has(G)) {
        const qn = k.get(G),
          Vi = k.get(ve);
        (ke.bindFramebuffer(K.READ_FRAMEBUFFER, Ms),
          ke.bindFramebuffer(K.DRAW_FRAMEBUFFER, qs));
        for (let ri = 0; ri < gt; ri++)
          (Ki
            ? K.framebufferTextureLayer(
                K.READ_FRAMEBUFFER,
                K.COLOR_ATTACHMENT0,
                qn.__webglTexture,
                Ce,
                Wt + ri,
              )
            : K.framebufferTexture2D(
                K.READ_FRAMEBUFFER,
                K.COLOR_ATTACHMENT0,
                K.TEXTURE_2D,
                qn.__webglTexture,
                Ce,
              ),
            gn
              ? K.framebufferTextureLayer(
                  K.DRAW_FRAMEBUFFER,
                  K.COLOR_ATTACHMENT0,
                  Vi.__webglTexture,
                  pt,
                  Ln + ri,
                )
              : K.framebufferTexture2D(
                  K.DRAW_FRAMEBUFFER,
                  K.COLOR_ATTACHMENT0,
                  K.TEXTURE_2D,
                  Vi.__webglTexture,
                  pt,
                ),
            Ce !== 0
              ? K.blitFramebuffer(
                  Lt,
                  zt,
                  bt,
                  _t,
                  At,
                  Kt,
                  bt,
                  _t,
                  K.COLOR_BUFFER_BIT,
                  K.NEAREST,
                )
              : gn
                ? K.copyTexSubImage3D(vt, pt, At, Kt, Ln + ri, Lt, zt, bt, _t)
                : K.copyTexSubImage2D(vt, pt, At, Kt, Lt, zt, bt, _t));
        (ke.bindFramebuffer(K.READ_FRAMEBUFFER, null),
          ke.bindFramebuffer(K.DRAW_FRAMEBUFFER, null));
      } else
        gn
          ? G.isDataTexture || G.isData3DTexture
            ? K.texSubImage3D(vt, pt, At, Kt, Ln, bt, _t, gt, rn, mn, On.data)
            : ve.isCompressedArrayTexture
              ? K.compressedTexSubImage3D(
                  vt,
                  pt,
                  At,
                  Kt,
                  Ln,
                  bt,
                  _t,
                  gt,
                  rn,
                  On.data,
                )
              : K.texSubImage3D(vt, pt, At, Kt, Ln, bt, _t, gt, rn, mn, On)
          : G.isDataTexture
            ? K.texSubImage2D(K.TEXTURE_2D, pt, At, Kt, bt, _t, rn, mn, On.data)
            : G.isCompressedTexture
              ? K.compressedTexSubImage2D(
                  K.TEXTURE_2D,
                  pt,
                  At,
                  Kt,
                  On.width,
                  On.height,
                  rn,
                  On.data,
                )
              : K.texSubImage2D(K.TEXTURE_2D, pt, At, Kt, bt, _t, rn, mn, On);
      (K.pixelStorei(K.UNPACK_ROW_LENGTH, bi),
        K.pixelStorei(K.UNPACK_IMAGE_HEIGHT, Pt),
        K.pixelStorei(K.UNPACK_SKIP_PIXELS, Bi),
        K.pixelStorei(K.UNPACK_SKIP_ROWS, ki),
        K.pixelStorei(K.UNPACK_SKIP_IMAGES, ei),
        pt === 0 && ve.generateMipmaps && K.generateMipmap(vt),
        ke.unbindTexture());
    }),
      (this.initRenderTarget = function (G) {
        k.get(G).__webglFramebuffer === void 0 && oe.setupRenderTarget(G);
      }),
      (this.initTexture = function (G) {
        (G.isCubeTexture
          ? oe.setTextureCube(G, 0)
          : G.isData3DTexture
            ? oe.setTexture3D(G, 0)
            : G.isDataArrayTexture || G.isCompressedArrayTexture
              ? oe.setTexture2DArray(G, 0)
              : oe.setTexture2D(G, 0),
          ke.unbindTexture());
      }),
      (this.resetState = function () {
        ((q = 0), (X = 0), (J = null), ke.reset(), Ke.reset());
      }),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this }),
        ));
  }
  get coordinateSystem() {
    return Ua;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(e) {
    this._outputColorSpace = e;
    const t = this.getContext();
    ((t.drawingBufferColorSpace = Cn._getDrawingBufferColorSpace(e)),
      (t.unpackColorSpace = Cn._getUnpackColorSpace()));
  }
}
const S9 = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      ACESFilmicToneMapping: Z1,
      AddEquation: Ku,
      AddOperation: OL,
      AdditiveAnimationBlendMode: GT,
      AdditiveBlending: Hx,
      AgXToneMapping: UT,
      AlphaFormat: kT,
      AlwaysCompare: ZL,
      AlwaysDepth: qx,
      AlwaysStencilFunc: TM,
      AmbientLight: BN,
      AnimationAction: YN,
      AnimationClip: x0,
      AnimationLoader: E6,
      AnimationMixer: tV,
      AnimationObjectGroup: $6,
      AnimationUtils: _6,
      ArcCurve: hN,
      ArrayCamera: jN,
      ArrowHelper: SV,
      AttachedBindMode: SM,
      Audio: XN,
      AudioAnalyser: H6,
      AudioContext: mE,
      AudioListener: k6,
      AudioLoader: O6,
      AxesHelper: MV,
      BackSide: js,
      BasicDepthPacking: VL,
      BasicShadowMap: gL,
      BatchedMesh: aN,
      BezierInterpolant: NN,
      Bone: KT,
      BooleanKeyframeTrack: zh,
      Box2: oV,
      Box3: sr,
      Box3Helper: bV,
      BoxGeometry: Fh,
      BoxHelper: xV,
      BufferAttribute: $n,
      BufferGeometry: nn,
      BufferGeometryLoader: GN,
      ByteType: OT,
      Cache: jl,
      Camera: Rb,
      CameraHelper: yV,
      CanvasTexture: Vk,
      CapsuleGeometry: pb,
      CatmullRomCurve3: dN,
      CineonToneMapping: LT,
      CircleGeometry: mb,
      ClampToEdgeWrapping: xa,
      Clock: KN,
      Color: wt,
      ColorKeyframeTrack: fE,
      ColorManagement: Cn,
      Compatibility: DB,
      CompressedArrayTexture: Bk,
      CompressedCubeTexture: kk,
      CompressedTexture: db,
      CompressedTextureLoader: w6,
      ConeGeometry: P0,
      ConstantAlphaFactor: UL,
      ConstantColorFactor: LL,
      Controls: EV,
      CubeCamera: HN,
      CubeDepthTexture: uN,
      CubeReflectionMapping: Zl,
      CubeRefractionMapping: sf,
      CubeTexture: N0,
      CubeTextureLoader: A6,
      CubeUVReflectionMapping: Bp,
      CubicBezierCurve: eE,
      CubicBezierCurve3: pN,
      CubicInterpolant: DN,
      CullFaceBack: xM,
      CullFaceFront: mL,
      CullFaceFrontBack: Hz,
      CullFaceNone: pL,
      Curve: $o,
      CurvePath: gN,
      CustomBlending: vL,
      CustomToneMapping: NT,
      CylinderGeometry: U0,
      Cylindrical: aV,
      Data3DTexture: ob,
      DataArrayTexture: ab,
      DataTexture: Ko,
      DataTextureLoader: C6,
      DataUtils: hk,
      DecrementStencilOp: oB,
      DecrementWrapStencilOp: cB,
      DefaultLoadingManager: PN,
      DepthFormat: Ql,
      DepthStencilFormat: $u,
      DepthTexture: Cp,
      DetachedBindMode: FL,
      DirectionalLight: zN,
      DirectionalLightHelper: vV,
      DiscreteInterpolant: LN,
      DodecahedronGeometry: gb,
      DoubleSide: Na,
      DstAlphaFactor: wL,
      DstColorFactor: CL,
      DynamicCopyUsage: TB,
      DynamicDrawUsage: yB,
      DynamicReadUsage: _B,
      EdgesGeometry: fN,
      EllipseCurve: vb,
      EqualCompare: XL,
      EqualDepth: Zx,
      EqualStencilFunc: dB,
      EquirectangularReflectionMapping: zg,
      EquirectangularRefractionMapping: Bg,
      Euler: Fa,
      EventDispatcher: ec,
      ExternalTexture: JT,
      ExtrudeGeometry: yb,
      FileLoader: Kc,
      Float16BufferAttribute: xk,
      Float32BufferAttribute: Rt,
      FloatType: Hs,
      Fog: cb,
      FogExp2: lb,
      FramebufferTexture: zk,
      FrontSide: Zc,
      Frustum: kp,
      FrustumArray: hb,
      GLBufferAttribute: sV,
      GLSL1: wB,
      GLSL3: EM,
      GreaterCompare: qL,
      GreaterDepth: Qx,
      GreaterEqualCompare: sb,
      GreaterEqualDepth: Kx,
      GreaterEqualStencilFunc: vB,
      GreaterStencilFunc: mB,
      GridHelper: mV,
      Group: xp,
      HalfFloatType: Kl,
      HemisphereLight: IN,
      HemisphereLightHelper: pV,
      IcosahedronGeometry: xb,
      ImageBitmapLoader: I6,
      ImageLoader: b0,
      ImageUtils: $L,
      IncrementStencilOp: aB,
      IncrementWrapStencilOp: lB,
      InstancedBufferAttribute: Uh,
      InstancedBufferGeometry: Lb,
      InstancedInterleavedBuffer: O1,
      InstancedMesh: sN,
      Int16BufferAttribute: vk,
      Int32BufferAttribute: yk,
      Int8BufferAttribute: pk,
      IntType: Q1,
      InterleavedBuffer: ub,
      InterleavedBufferAttribute: Pa,
      Interpolant: Vp,
      InterpolateBezier: MM,
      InterpolateDiscrete: a0,
      InterpolateLinear: L1,
      InterpolateSmooth: Cx,
      InterpolationSamplingMode: RB,
      InterpolationSamplingType: CB,
      InvertStencilOp: uB,
      KeepStencilOp: gh,
      KeyframeTrack: _o,
      LOD: iN,
      LatheGeometry: bb,
      Layers: Ap,
      LessCompare: WL,
      LessDepth: Yx,
      LessEqualCompare: rb,
      LessEqualDepth: Dh,
      LessEqualStencilFunc: pB,
      LessStencilFunc: hB,
      Light: pf,
      LightProbe: VN,
      Line: lf,
      Line3: QN,
      LineBasicMaterial: Ws,
      LineCurve: tE,
      LineCurve3: mN,
      LineDashedMaterial: CN,
      LineLoop: oN,
      LineSegments: tc,
      LinearFilter: ni,
      LinearInterpolant: uE,
      LinearMipMapLinearFilter: Yz,
      LinearMipMapNearestFilter: qz,
      LinearMipmapLinearFilter: Hl,
      LinearMipmapNearestFilter: kg,
      LinearSRGBColorSpace: af,
      LinearToneMapping: RT,
      LinearTransfer: l0,
      Loader: _a,
      LoaderUtils: DM,
      LoadingManager: hE,
      LoopOnce: zL,
      LoopPingPong: kL,
      LoopRepeat: BL,
      MOUSE: ph,
      Material: bs,
      MaterialBlending: jz,
      MaterialLoader: Db,
      MathUtils: jT,
      Matrix2: xE,
      Matrix3: tn,
      Matrix4: qt,
      MaxEquation: _L,
      Mesh: wi,
      MeshBasicMaterial: Jc,
      MeshDepthMaterial: Ab,
      MeshDistanceMaterial: Cb,
      MeshLambertMaterial: wN,
      MeshMatcapMaterial: AN,
      MeshNormalMaterial: EN,
      MeshPhongMaterial: MN,
      MeshPhysicalMaterial: lE,
      MeshStandardMaterial: oE,
      MeshToonMaterial: TN,
      MinEquation: bL,
      MirroredRepeatWrapping: s0,
      MixOperation: IL,
      MultiplyBlending: _M,
      MultiplyOperation: D0,
      NearestFilter: rr,
      NearestMipMapLinearFilter: Xz,
      NearestMipMapNearestFilter: Wz,
      NearestMipmapLinearFilter: vp,
      NearestMipmapNearestFilter: IT,
      NeutralToneMapping: PT,
      NeverCompare: jL,
      NeverDepth: Xx,
      NeverStencilFunc: fB,
      NoBlending: ql,
      NoColorSpace: Gc,
      NoNormalPacking: tB,
      NoToneMapping: xo,
      NormalAnimationBlendMode: ib,
      NormalBlending: Eh,
      NormalGAPacking: iB,
      NormalRGPacking: nB,
      NotEqualCompare: YL,
      NotEqualDepth: Jx,
      NotEqualStencilFunc: gB,
      NumberKeyframeTrack: v0,
      Object3D: In,
      ObjectLoader: U6,
      ObjectSpaceNormalMap: HL,
      OctahedronGeometry: I0,
      OneFactor: ML,
      OneMinusConstantAlphaFactor: PL,
      OneMinusConstantColorFactor: NL,
      OneMinusDstAlphaFactor: AL,
      OneMinusDstColorFactor: RL,
      OneMinusSrcAlphaFactor: Wx,
      OneMinusSrcColorFactor: EL,
      OrthographicCamera: Wc,
      PCFShadowMap: _p,
      PCFSoftShadowMap: Fg,
      PMREMGenerator: UM,
      Path: I1,
      PerspectiveCamera: ir,
      Plane: Vc,
      PlaneGeometry: $c,
      PlaneHelper: _V,
      PointLight: FN,
      PointLightHelper: hV,
      Points: lN,
      PointsMaterial: QT,
      PolarGridHelper: gV,
      PolyhedronGeometry: df,
      PositionalAudio: G6,
      PropertyBinding: Pn,
      PropertyMixer: qN,
      QuadraticBezierCurve: nE,
      QuadraticBezierCurve3: iE,
      Quaternion: Jr,
      QuaternionKeyframeTrack: F0,
      QuaternionLinearInterpolant: UN,
      R11_EAC_Format: a1,
      RED_GREEN_RGTC2_Format: R1,
      RED_RGTC1_Format: A1,
      REVISION: zp,
      RG11_EAC_Format: l1,
      RGBADepthPacking: GL,
      RGBAFormat: xs,
      RGBAIntegerFormat: nb,
      RGBA_ASTC_10x10_Format: _1,
      RGBA_ASTC_10x5_Format: y1,
      RGBA_ASTC_10x6_Format: x1,
      RGBA_ASTC_10x8_Format: b1,
      RGBA_ASTC_12x10_Format: S1,
      RGBA_ASTC_12x12_Format: M1,
      RGBA_ASTC_4x4_Format: u1,
      RGBA_ASTC_5x4_Format: f1,
      RGBA_ASTC_5x5_Format: h1,
      RGBA_ASTC_6x5_Format: d1,
      RGBA_ASTC_6x6_Format: p1,
      RGBA_ASTC_8x5_Format: m1,
      RGBA_ASTC_8x6_Format: g1,
      RGBA_ASTC_8x8_Format: v1,
      RGBA_BPTC_Format: T1,
      RGBA_ETC2_EAC_Format: s1,
      RGBA_PVRTC_2BPPV1_Format: n1,
      RGBA_PVRTC_4BPPV1_Format: t1,
      RGBA_S3TC_DXT1_Format: Gg,
      RGBA_S3TC_DXT3_Format: Hg,
      RGBA_S3TC_DXT5_Format: jg,
      RGBDepthPacking: $z,
      RGBFormat: VT,
      RGBIntegerFormat: Zz,
      RGB_BPTC_SIGNED_Format: E1,
      RGB_BPTC_UNSIGNED_Format: w1,
      RGB_ETC1_Format: i1,
      RGB_ETC2_Format: r1,
      RGB_PVRTC_2BPPV1_Format: e1,
      RGB_PVRTC_4BPPV1_Format: $x,
      RGB_S3TC_DXT1_Format: Vg,
      RGDepthPacking: eB,
      RGFormat: Lh,
      RGIntegerFormat: tb,
      RawShaderMaterial: aE,
      Ray: Oh,
      Raycaster: ZN,
      RectAreaLight: kN,
      RedFormat: eb,
      RedIntegerFormat: L0,
      ReinhardToneMapping: DT,
      RenderTarget: WT,
      RenderTarget3D: nV,
      RepeatWrapping: r0,
      ReplaceStencilOp: sB,
      ReverseSubtractEquation: xL,
      RingGeometry: _b,
      SIGNED_R11_EAC_Format: o1,
      SIGNED_RED_GREEN_RGTC2_Format: D1,
      SIGNED_RED_RGTC1_Format: C1,
      SIGNED_RG11_EAC_Format: c1,
      SRGBColorSpace: vs,
      SRGBTransfer: Xn,
      Scene: XT,
      ShaderChunk: cn,
      ShaderLib: Xo,
      ShaderMaterial: ba,
      ShadowMaterial: _N,
      Shape: Ah,
      ShapeGeometry: Sb,
      ShapePath: TV,
      ShapeUtils: qo,
      ShortType: FT,
      Skeleton: fb,
      SkeletonHelper: fV,
      SkinnedMesh: rN,
      Source: ef,
      Sphere: mr,
      SphereGeometry: O0,
      Spherical: F1,
      SphericalHarmonics3: pE,
      SplineCurve: rE,
      SpotLight: ON,
      SpotLightHelper: uV,
      Sprite: nN,
      SpriteMaterial: ZT,
      SrcAlphaFactor: jx,
      SrcAlphaSaturateFactor: DL,
      SrcColorFactor: TL,
      StaticCopyUsage: MB,
      StaticDrawUsage: c0,
      StaticReadUsage: bB,
      StereoCamera: F6,
      StreamCopyUsage: EB,
      StreamDrawUsage: xB,
      StreamReadUsage: SB,
      StringKeyframeTrack: Bh,
      SubtractEquation: yL,
      SubtractiveBlending: bM,
      TOUCH: mh,
      TangentSpaceNormalMap: hf,
      TetrahedronGeometry: Mb,
      Texture: Fi,
      TextureLoader: R6,
      TextureUtils: DV,
      Timer: WN,
      TimestampQuery: AB,
      TorusGeometry: Tb,
      TorusKnotGeometry: Eb,
      Triangle: ya,
      TriangleFanDrawMode: Jz,
      TriangleStripDrawMode: Qz,
      TrianglesDrawMode: Kz,
      TubeGeometry: wb,
      UVMapping: K1,
      Uint16BufferAttribute: qT,
      Uint32BufferAttribute: YT,
      Uint8BufferAttribute: mk,
      Uint8ClampedBufferAttribute: gk,
      Uniform: yE,
      UniformsGroup: rV,
      UniformsLib: Et,
      UniformsUtils: g0,
      UnsignedByteType: Bs,
      UnsignedInt101111Type: BT,
      UnsignedInt248Type: Ep,
      UnsignedInt5999Type: zT,
      UnsignedIntType: bo,
      UnsignedShort4444Type: J1,
      UnsignedShort5551Type: $1,
      UnsignedShortType: Tp,
      VSMShadowMap: bh,
      Vector2: nt,
      Vector3: te,
      Vector4: Dn,
      VectorKeyframeTrack: y0,
      VideoFrameTexture: Fk,
      VideoTexture: cN,
      WebGL3DRenderTarget: ik,
      WebGLArrayRenderTarget: nk,
      WebGLCoordinateSystem: Ua,
      WebGLCubeRenderTarget: bE,
      WebGLRenderTarget: Oa,
      WebGLRenderer: sU,
      WebGLUtils: rU,
      WebGPUCoordinateSystem: Nh,
      WebXRController: Rx,
      WireframeGeometry: sE,
      WrapAroundEnding: o0,
      ZeroCurvatureEnding: _h,
      ZeroFactor: SL,
      ZeroSlopeEnding: Sh,
      ZeroStencilOp: rB,
      createCanvasElement: QL,
      error: Ft,
      getConsoleFunction: PB,
      log: f0,
      setConsoleFunction: UB,
      warn: Tt,
      warnOnce: h0,
    },
    Symbol.toStringTag,
    { value: "Module" },
  ),
);
var RS = { exports: {} },
  DS = {},
  LS = { exports: {} },
  NS = {};
/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var v3;
function M9() {
  if (v3) return NS;
  v3 = 1;
  var i = S0();
  function e(v, y) {
    return (v === y && (v !== 0 || 1 / v === 1 / y)) || (v !== v && y !== y);
  }
  var t = typeof Object.is == "function" ? Object.is : e,
    n = i.useState,
    r = i.useEffect,
    s = i.useLayoutEffect,
    o = i.useDebugValue;
  function u(v, y) {
    var b = y(),
      _ = n({ inst: { value: b, getSnapshot: y } }),
      w = _[0].inst,
      E = _[1];
    return (
      s(
        function () {
          ((w.value = b), (w.getSnapshot = y), h(w) && E({ inst: w }));
        },
        [v, b, y],
      ),
      r(
        function () {
          return (
            h(w) && E({ inst: w }),
            v(function () {
              h(w) && E({ inst: w });
            })
          );
        },
        [v],
      ),
      o(b),
      b
    );
  }
  function h(v) {
    var y = v.getSnapshot;
    v = v.value;
    try {
      var b = y();
      return !t(v, b);
    } catch {
      return !0;
    }
  }
  function d(v, y) {
    return y();
  }
  var m =
    typeof window > "u" ||
    typeof window.document > "u" ||
    typeof window.document.createElement > "u"
      ? d
      : u;
  return (
    (NS.useSyncExternalStore =
      i.useSyncExternalStore !== void 0 ? i.useSyncExternalStore : m),
    NS
  );
}
var y3;
function T9() {
  return (y3 || ((y3 = 1), (LS.exports = M9())), LS.exports);
}
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var x3;
function E9() {
  if (x3) return DS;
  x3 = 1;
  var i = S0(),
    e = T9();
  function t(d, m) {
    return (d === m && (d !== 0 || 1 / d === 1 / m)) || (d !== d && m !== m);
  }
  var n = typeof Object.is == "function" ? Object.is : t,
    r = e.useSyncExternalStore,
    s = i.useRef,
    o = i.useEffect,
    u = i.useMemo,
    h = i.useDebugValue;
  return (
    (DS.useSyncExternalStoreWithSelector = function (d, m, v, y, b) {
      var _ = s(null);
      if (_.current === null) {
        var w = { hasValue: !1, value: null };
        _.current = w;
      } else w = _.current;
      _ = u(
        function () {
          function T(O) {
            if (!C) {
              if (((C = !0), (R = O), (O = y(O)), b !== void 0 && w.hasValue)) {
                var B = w.value;
                if (b(B, O)) return (L = B);
              }
              return (L = O);
            }
            if (((B = L), n(R, O))) return B;
            var N = y(O);
            return b !== void 0 && b(B, N) ? ((R = O), B) : ((R = O), (L = N));
          }
          var C = !1,
            R,
            L,
            I = v === void 0 ? null : v;
          return [
            function () {
              return T(m());
            },
            I === null
              ? void 0
              : function () {
                  return T(I());
                },
          ];
        },
        [m, v, y, b],
      );
      var E = r(d, _[0], _[1]);
      return (
        o(
          function () {
            ((w.hasValue = !0), (w.value = E));
          },
          [E],
        ),
        h(E),
        E
      );
    }),
    DS
  );
}
var b3;
function w9() {
  return (b3 || ((b3 = 1), (RS.exports = E9())), RS.exports);
}
var A9 = w9();
const C9 = qM(A9),
  _3 = (i) => {
    let e;
    const t = new Set(),
      n = (d, m) => {
        const v = typeof d == "function" ? d(e) : d;
        if (!Object.is(v, e)) {
          const y = e;
          ((e =
            (m ?? (typeof v != "object" || v === null))
              ? v
              : Object.assign({}, e, v)),
            t.forEach((b) => b(e, y)));
        }
      },
      r = () => e,
      u = {
        setState: n,
        getState: r,
        getInitialState: () => h,
        subscribe: (d) => (t.add(d), () => t.delete(d)),
      },
      h = (e = i(n, r, u));
    return u;
  },
  R9 = (i) => (i ? _3(i) : _3),
  { useSyncExternalStoreWithSelector: D9 } = C9,
  L9 = (i) => i;
function N9(i, e = L9, t) {
  const n = D9(i.subscribe, i.getState, i.getInitialState, e, t);
  return (M0.useDebugValue(n), n);
}
const S3 = (i, e) => {
    const t = R9(i),
      n = (r, s = e) => N9(t, r, s);
    return (Object.assign(n, t), n);
  },
  U9 = (i, e) => (i ? S3(i, e) : S3),
  P9 = (i) => typeof i == "object" && typeof i.then == "function",
  fx = [];
function I9(i, e, t = (n, r) => n === r) {
  if (i === e) return !0;
  if (!i || !e) return !1;
  const n = i.length;
  if (e.length !== n) return !1;
  for (let r = 0; r < n; r++) if (!t(i[r], e[r])) return !1;
  return !0;
}
function O9(i, e = null, t = !1, n = {}) {
  e === null && (e = [i]);
  for (const s of fx)
    if (I9(e, s.keys, s.equal)) {
      if (t) return;
      if (Object.prototype.hasOwnProperty.call(s, "error")) throw s.error;
      if (Object.prototype.hasOwnProperty.call(s, "response"))
        return (
          n.lifespan &&
            n.lifespan > 0 &&
            (s.timeout && clearTimeout(s.timeout),
            (s.timeout = setTimeout(s.remove, n.lifespan))),
          s.response
        );
      if (!t) throw s.promise;
    }
  const r = {
    keys: e,
    equal: n.equal,
    remove: () => {
      const s = fx.indexOf(r);
      s !== -1 && fx.splice(s, 1);
    },
    promise: (P9(i) ? i : i(...e))
      .then((s) => {
        ((r.response = s),
          n.lifespan &&
            n.lifespan > 0 &&
            (r.timeout = setTimeout(r.remove, n.lifespan)));
      })
      .catch((s) => (r.error = s)),
  };
  if ((fx.push(r), !t)) throw r.promise;
}
const F9 = (i, e, t) => O9(i, e, !1, t);
var OM = nR();
const z9 = qM(OM);
function _E(i, e, t) {
  if (!i) return;
  if (t(i) === !0) return i;
  let n = e ? i.return : i.child;
  for (; n; ) {
    const r = _E(n, e, t);
    if (r) return r;
    n = e ? null : n.sibling;
  }
}
function aU(i) {
  try {
    return Object.defineProperties(i, {
      _currentRenderer: {
        get() {
          return null;
        },
        set() {},
      },
      _currentRenderer2: {
        get() {
          return null;
        },
        set() {},
      },
    });
  } catch {
    return i;
  }
}
const SE = aU(ie.createContext(null));
class oU extends ie.Component {
  render() {
    return ie.createElement(
      SE.Provider,
      { value: this._reactInternals },
      this.props.children,
    );
  }
}
function lU() {
  const i = ie.useContext(SE);
  if (i === null)
    throw new Error(
      "its-fine: useFiber must be called within a <FiberProvider />!",
    );
  const e = ie.useId();
  return ie.useMemo(() => {
    for (const t of [i, i == null ? void 0 : i.alternate]) {
      if (!t) continue;
      const n = _E(t, !1, (r) => {
        let s = r.memoizedState;
        for (; s; ) {
          if (s.memoizedState === e) return !0;
          s = s.next;
        }
      });
      if (n) return n;
    }
  }, [i, e]);
}
const B9 = Symbol.for("react.context"),
  k9 = (i) =>
    i !== null && typeof i == "object" && "$$typeof" in i && i.$$typeof === B9;
function V9() {
  const i = lU(),
    [e] = ie.useState(() => new Map());
  e.clear();
  let t = i;
  for (; t; ) {
    const n = t.type;
    (k9(n) && n !== SE && !e.has(n) && e.set(n, ie.use(aU(n))), (t = t.return));
  }
  return e;
}
function G9() {
  const i = V9();
  return ie.useMemo(
    () =>
      Array.from(i.keys()).reduce(
        (e, t) => (n) =>
          ie.createElement(
            e,
            null,
            ie.createElement(t.Provider, { ...n, value: i.get(t) }),
          ),
        (e) => ie.createElement(oU, { ...e }),
      ),
    [i],
  );
}
function cU(i) {
  let e = i.root;
  for (; e.getState().previousRoot; ) e = e.getState().previousRoot;
  return e;
}
const uU = (i) => i && i.isOrthographicCamera,
  H9 = (i) => i && i.hasOwnProperty("current"),
  j9 = (i) =>
    i != null && (typeof i == "string" || typeof i == "number" || i.isColor),
  z0 = ((i, e) =>
    typeof window < "u" &&
    (((i = window.document) == null ? void 0 : i.createElement) ||
      ((e = window.navigator) == null ? void 0 : e.product) ===
        "ReactNative"))()
    ? ie.useLayoutEffect
    : ie.useEffect;
function fU(i) {
  const e = ie.useRef(i);
  return (z0(() => void (e.current = i), [i]), e);
}
function W9() {
  const i = lU(),
    e = G9();
  return ie.useMemo(
    () =>
      ({ children: t }) => {
        const r = !!_E(i, !0, (s) => s.type === ie.StrictMode)
          ? ie.StrictMode
          : ie.Fragment;
        return P.jsx(r, { children: P.jsx(e, { children: t }) });
      },
    [i, e],
  );
}
function X9({ set: i }) {
  return (z0(() => (i(new Promise(() => null)), () => i(!1)), [i]), null);
}
const q9 = ((i) => (
  (i = class extends ie.Component {
    constructor(...t) {
      (super(...t), (this.state = { error: !1 }));
    }
    componentDidCatch(t) {
      this.props.set(t);
    }
    render() {
      return this.state.error ? null : this.props.children;
    }
  }),
  (i.getDerivedStateFromError = () => ({ error: !0 })),
  i
))();
function hU(i) {
  var e;
  const t =
    typeof window < "u" ? ((e = window.devicePixelRatio) != null ? e : 2) : 1;
  return Array.isArray(i) ? Math.min(Math.max(i[0], t), i[1]) : i;
}
function op(i) {
  var e;
  return (e = i.__r3f) == null ? void 0 : e.root.getState();
}
const Pi = {
  obj: (i) => i === Object(i) && !Pi.arr(i) && typeof i != "function",
  fun: (i) => typeof i == "function",
  str: (i) => typeof i == "string",
  num: (i) => typeof i == "number",
  boo: (i) => typeof i == "boolean",
  und: (i) => i === void 0,
  nul: (i) => i === null,
  arr: (i) => Array.isArray(i),
  equ(
    i,
    e,
    { arrays: t = "shallow", objects: n = "reference", strict: r = !0 } = {},
  ) {
    if (typeof i != typeof e || !!i != !!e) return !1;
    if (Pi.str(i) || Pi.num(i) || Pi.boo(i)) return i === e;
    const s = Pi.obj(i);
    if (s && n === "reference") return i === e;
    const o = Pi.arr(i);
    if (o && t === "reference") return i === e;
    if ((o || s) && i === e) return !0;
    let u;
    for (u in i) if (!(u in e)) return !1;
    if (s && t === "shallow" && n === "shallow") {
      for (u in r ? e : i)
        if (!Pi.equ(i[u], e[u], { strict: r, objects: "reference" })) return !1;
    } else for (u in r ? e : i) if (i[u] !== e[u]) return !1;
    if (Pi.und(u)) {
      if (
        (o && i.length === 0 && e.length === 0) ||
        (s && Object.keys(i).length === 0 && Object.keys(e).length === 0)
      )
        return !0;
      if (i !== e) return !1;
    }
    return !0;
  },
};
function Y9(i) {
  i.type !== "Scene" && (i.dispose == null || i.dispose());
  for (const e in i) {
    const t = i[e];
    (t == null ? void 0 : t.type) !== "Scene" &&
      (t == null || t.dispose == null || t.dispose());
  }
}
const dU = ["children", "key", "ref"];
function Z9(i) {
  const e = {};
  for (const t in i) dU.includes(t) || (e[t] = i[t]);
  return e;
}
function z1(i, e, t, n) {
  const r = i;
  let s = r == null ? void 0 : r.__r3f;
  return (
    s ||
      ((s = {
        root: e,
        type: t,
        parent: null,
        children: [],
        props: Z9(n),
        object: r,
        eventCount: 0,
        handlers: {},
        isHidden: !1,
      }),
      r && (r.__r3f = s)),
    s
  );
}
function _0(i, e) {
  if (!e.includes("-")) return { root: i, key: e, target: i[e] };
  if (e in i) return { root: i, key: e, target: i[e] };
  let t = i;
  const n = e.split("-");
  for (const r of n) {
    if (typeof t != "object" || t === null) {
      if (t !== void 0) {
        const s = n.slice(n.indexOf(r)).join("-");
        return { root: t, key: s, target: void 0 };
      }
      return { root: i, key: e, target: void 0 };
    }
    ((e = r), (i = t), (t = t[e]));
  }
  return { root: i, key: e, target: t };
}
const M3 = /-\d+$/;
function B1(i, e) {
  if (Pi.str(e.props.attach)) {
    if (M3.test(e.props.attach)) {
      const r = e.props.attach.replace(M3, ""),
        { root: s, key: o } = _0(i.object, r);
      Array.isArray(s[o]) || (s[o] = []);
    }
    const { root: t, key: n } = _0(i.object, e.props.attach);
    ((e.previousAttach = t[n]), (t[n] = e.object));
  } else
    Pi.fun(e.props.attach) &&
      (e.previousAttach = e.props.attach(i.object, e.object));
}
function k1(i, e) {
  if (Pi.str(e.props.attach)) {
    const { root: t, key: n } = _0(i.object, e.props.attach),
      r = e.previousAttach;
    r === void 0 ? delete t[n] : (t[n] = r);
  } else e.previousAttach == null || e.previousAttach(i.object, e.object);
  delete e.previousAttach;
}
const FM = [
    ...dU,
    "args",
    "dispose",
    "attach",
    "object",
    "onUpdate",
    "dispose",
  ],
  T3 = new Map();
function K9(i) {
  let e = T3.get(i.constructor);
  try {
    e || ((e = new i.constructor()), T3.set(i.constructor, e));
  } catch {}
  return e;
}
function Q9(i, e) {
  const t = {};
  for (const n in e)
    if (!FM.includes(n) && !Pi.equ(e[n], i.props[n])) {
      t[n] = e[n];
      for (const r in e) r.startsWith(`${n}-`) && (t[r] = e[r]);
    }
  for (const n in i.props) {
    if (FM.includes(n) || e.hasOwnProperty(n)) continue;
    const { root: r, key: s } = _0(i.object, n);
    if (r.constructor && r.constructor.length === 0) {
      const o = K9(r);
      Pi.und(o) || (t[s] = o[s]);
    } else t[s] = 0;
  }
  return t;
}
const J9 = [
    "map",
    "emissiveMap",
    "sheenColorMap",
    "specularColorMap",
    "envMap",
  ],
  $9 = /^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/;
function Qu(i, e) {
  var t;
  const n = i.__r3f,
    r = n && cU(n).getState(),
    s = n == null ? void 0 : n.eventCount;
  for (const u in e) {
    let h = e[u];
    if (FM.includes(u)) continue;
    if (n && $9.test(u)) {
      (typeof h == "function" ? (n.handlers[u] = h) : delete n.handlers[u],
        (n.eventCount = Object.keys(n.handlers).length));
      continue;
    }
    if (h === void 0) continue;
    let { root: d, key: m, target: v } = _0(i, u);
    if (v === void 0 && (typeof d != "object" || d === null))
      throw Error(
        `R3F: Cannot set "${u}". Ensure it is an object before setting "${m}".`,
      );
    if (v instanceof Ap && h instanceof Ap) v.mask = h.mask;
    else if (v instanceof wt && j9(h)) v.set(h);
    else if (
      v !== null &&
      typeof v == "object" &&
      typeof v.set == "function" &&
      typeof v.copy == "function" &&
      h != null &&
      h.constructor &&
      v.constructor === h.constructor
    )
      v.copy(h);
    else if (
      v !== null &&
      typeof v == "object" &&
      typeof v.set == "function" &&
      Array.isArray(h)
    )
      typeof v.fromArray == "function" ? v.fromArray(h) : v.set(...h);
    else if (
      v !== null &&
      typeof v == "object" &&
      typeof v.set == "function" &&
      typeof h == "number"
    )
      typeof v.setScalar == "function" ? v.setScalar(h) : v.set(h);
    else {
      var o;
      ((d[m] = h),
        r &&
          !r.linear &&
          J9.includes(m) &&
          (o = d[m]) != null &&
          o.isTexture &&
          d[m].format === xs &&
          d[m].type === Bs &&
          (d[m].colorSpace = vs));
    }
  }
  if (
    n != null &&
    n.parent &&
    r != null &&
    r.internal &&
    (t = n.object) != null &&
    t.isObject3D &&
    s !== n.eventCount
  ) {
    const u = n.object,
      h = r.internal.interaction.indexOf(u);
    (h > -1 && r.internal.interaction.splice(h, 1),
      n.eventCount && u.raycast !== null && r.internal.interaction.push(u));
  }
  return (
    n &&
      n.props.attach === void 0 &&
      (n.object.isBufferGeometry
        ? (n.props.attach = "geometry")
        : n.object.isMaterial && (n.props.attach = "material")),
    n && Hp(n),
    i
  );
}
function Hp(i) {
  var e;
  if (!i.parent) return;
  i.props.onUpdate == null || i.props.onUpdate(i.object);
  const t = (e = i.root) == null || e.getState == null ? void 0 : e.getState();
  t && t.internal.frames === 0 && t.invalidate();
}
function e7(i, e) {
  i.manual ||
    (uU(i)
      ? ((i.left = e.width / -2),
        (i.right = e.width / 2),
        (i.top = e.height / 2),
        (i.bottom = e.height / -2))
      : (i.aspect = e.width / e.height),
    i.updateProjectionMatrix());
}
const va = (i) => (i == null ? void 0 : i.isObject3D);
function hx(i) {
  return (i.eventObject || i.object).uuid + "/" + i.index + i.instanceId;
}
function pU(i, e, t, n) {
  const r = t.get(e);
  r &&
    (t.delete(e),
    t.size === 0 && (i.delete(n), r.target.releasePointerCapture(n)));
}
function t7(i, e) {
  const { internal: t } = i.getState();
  ((t.interaction = t.interaction.filter((n) => n !== e)),
    (t.initialHits = t.initialHits.filter((n) => n !== e)),
    t.hovered.forEach((n, r) => {
      (n.eventObject === e || n.object === e) && t.hovered.delete(r);
    }),
    t.capturedMap.forEach((n, r) => {
      pU(t.capturedMap, e, n, r);
    }));
}
function n7(i) {
  function e(h) {
    const { internal: d } = i.getState(),
      m = h.offsetX - d.initialClick[0],
      v = h.offsetY - d.initialClick[1];
    return Math.round(Math.sqrt(m * m + v * v));
  }
  function t(h) {
    return h.filter((d) =>
      ["Move", "Over", "Enter", "Out", "Leave"].some((m) => {
        var v;
        return (v = d.__r3f) == null ? void 0 : v.handlers["onPointer" + m];
      }),
    );
  }
  function n(h, d) {
    const m = i.getState(),
      v = new Set(),
      y = [],
      b = d ? d(m.internal.interaction) : m.internal.interaction;
    for (let T = 0; T < b.length; T++) {
      const C = op(b[T]);
      C && (C.raycaster.camera = void 0);
    }
    m.previousRoot || m.events.compute == null || m.events.compute(h, m);
    function _(T) {
      const C = op(T);
      if (!C || !C.events.enabled || C.raycaster.camera === null) return [];
      if (C.raycaster.camera === void 0) {
        var R;
        (C.events.compute == null ||
          C.events.compute(
            h,
            C,
            (R = C.previousRoot) == null ? void 0 : R.getState(),
          ),
          C.raycaster.camera === void 0 && (C.raycaster.camera = null));
      }
      return C.raycaster.camera ? C.raycaster.intersectObject(T, !0) : [];
    }
    let w = b
      .flatMap(_)
      .sort((T, C) => {
        const R = op(T.object),
          L = op(C.object);
        return !R || !L
          ? T.distance - C.distance
          : L.events.priority - R.events.priority || T.distance - C.distance;
      })
      .filter((T) => {
        const C = hx(T);
        return v.has(C) ? !1 : (v.add(C), !0);
      });
    m.events.filter && (w = m.events.filter(w, m));
    for (const T of w) {
      let C = T.object;
      for (; C; ) {
        var E;
        ((E = C.__r3f) != null &&
          E.eventCount &&
          y.push({ ...T, eventObject: C }),
          (C = C.parent));
      }
    }
    if ("pointerId" in h && m.internal.capturedMap.has(h.pointerId))
      for (let T of m.internal.capturedMap.get(h.pointerId).values())
        v.has(hx(T.intersection)) || y.push(T.intersection);
    return y;
  }
  function r(h, d, m, v) {
    if (h.length) {
      const y = { stopped: !1 };
      for (const b of h) {
        let _ = op(b.object);
        if (
          (_ ||
            b.object.traverseAncestors((w) => {
              const E = op(w);
              if (E) return ((_ = E), !1);
            }),
          _)
        ) {
          const { raycaster: w, pointer: E, camera: T, internal: C } = _,
            R = new te(E.x, E.y, 0).unproject(T),
            L = (F) => {
              var j, q;
              return (j =
                (q = C.capturedMap.get(F)) == null
                  ? void 0
                  : q.has(b.eventObject)) != null
                ? j
                : !1;
            },
            I = (F) => {
              const j = { intersection: b, target: d.target };
              (C.capturedMap.has(F)
                ? C.capturedMap.get(F).set(b.eventObject, j)
                : C.capturedMap.set(F, new Map([[b.eventObject, j]])),
                d.target.setPointerCapture(F));
            },
            O = (F) => {
              const j = C.capturedMap.get(F);
              j && pU(C.capturedMap, b.eventObject, j, F);
            };
          let B = {};
          for (let F in d) {
            let j = d[F];
            typeof j != "function" && (B[F] = j);
          }
          let N = {
            ...b,
            ...B,
            pointer: E,
            intersections: h,
            stopped: y.stopped,
            delta: m,
            unprojectedPoint: R,
            ray: w.ray,
            camera: T,
            stopPropagation() {
              const F = "pointerId" in d && C.capturedMap.get(d.pointerId);
              if (
                (!F || F.has(b.eventObject)) &&
                ((N.stopped = y.stopped = !0),
                C.hovered.size &&
                  Array.from(C.hovered.values()).find(
                    (j) => j.eventObject === b.eventObject,
                  ))
              ) {
                const j = h.slice(0, h.indexOf(b));
                s([...j, b]);
              }
            },
            target: {
              hasPointerCapture: L,
              setPointerCapture: I,
              releasePointerCapture: O,
            },
            currentTarget: {
              hasPointerCapture: L,
              setPointerCapture: I,
              releasePointerCapture: O,
            },
            nativeEvent: d,
          };
          if ((v(N), y.stopped === !0)) break;
        }
      }
    }
    return h;
  }
  function s(h) {
    const { internal: d } = i.getState();
    for (const m of d.hovered.values())
      if (
        !h.length ||
        !h.find(
          (v) =>
            v.object === m.object &&
            v.index === m.index &&
            v.instanceId === m.instanceId,
        )
      ) {
        const y = m.eventObject.__r3f;
        if ((d.hovered.delete(hx(m)), y != null && y.eventCount)) {
          const b = y.handlers,
            _ = { ...m, intersections: h };
          (b.onPointerOut == null || b.onPointerOut(_),
            b.onPointerLeave == null || b.onPointerLeave(_));
        }
      }
  }
  function o(h, d) {
    for (let m = 0; m < d.length; m++) {
      const v = d[m].__r3f;
      v == null ||
        v.handlers.onPointerMissed == null ||
        v.handlers.onPointerMissed(h);
    }
  }
  function u(h) {
    switch (h) {
      case "onPointerLeave":
      case "onPointerCancel":
        return () => s([]);
      case "onLostPointerCapture":
        return (d) => {
          const { internal: m } = i.getState();
          "pointerId" in d &&
            m.capturedMap.has(d.pointerId) &&
            requestAnimationFrame(() => {
              m.capturedMap.has(d.pointerId) &&
                (m.capturedMap.delete(d.pointerId), s([]));
            });
        };
    }
    return function (m) {
      const { onPointerMissed: v, internal: y } = i.getState();
      y.lastEvent.current = m;
      const b = h === "onPointerMove",
        _ = h === "onClick" || h === "onContextMenu" || h === "onDoubleClick",
        E = n(m, b ? t : void 0),
        T = _ ? e(m) : 0;
      (h === "onPointerDown" &&
        ((y.initialClick = [m.offsetX, m.offsetY]),
        (y.initialHits = E.map((R) => R.eventObject))),
        _ && !E.length && T <= 2 && (o(m, y.interaction), v && v(m)),
        b && s(E));
      function C(R) {
        const L = R.eventObject,
          I = L.__r3f;
        if (!(I != null && I.eventCount)) return;
        const O = I.handlers;
        if (b) {
          if (
            O.onPointerOver ||
            O.onPointerEnter ||
            O.onPointerOut ||
            O.onPointerLeave
          ) {
            const B = hx(R),
              N = y.hovered.get(B);
            N
              ? N.stopped && R.stopPropagation()
              : (y.hovered.set(B, R),
                O.onPointerOver == null || O.onPointerOver(R),
                O.onPointerEnter == null || O.onPointerEnter(R));
          }
          O.onPointerMove == null || O.onPointerMove(R);
        } else {
          const B = O[h];
          B
            ? (!_ || y.initialHits.includes(L)) &&
              (o(
                m,
                y.interaction.filter((N) => !y.initialHits.includes(N)),
              ),
              B(R))
            : _ &&
              y.initialHits.includes(L) &&
              o(
                m,
                y.interaction.filter((N) => !y.initialHits.includes(N)),
              );
        }
      }
      r(E, m, T, C);
    };
  }
  return { handlePointer: u };
}
const E3 = (i) => !!(i != null && i.render),
  mU = ie.createContext(null),
  i7 = (i, e) => {
    const t = U9((u, h) => {
        const d = new te(),
          m = new te(),
          v = new te();
        function y(T = h().camera, C = m, R = h().size) {
          const { width: L, height: I, top: O, left: B } = R,
            N = L / I;
          C.isVector3 ? v.copy(C) : v.set(...C);
          const F = T.getWorldPosition(d).distanceTo(v);
          if (uU(T))
            return {
              width: L / T.zoom,
              height: I / T.zoom,
              top: O,
              left: B,
              factor: 1,
              distance: F,
              aspect: N,
            };
          {
            const j = (T.fov * Math.PI) / 180,
              q = 2 * Math.tan(j / 2) * F,
              X = q * (L / I);
            return {
              width: X,
              height: q,
              top: O,
              left: B,
              factor: L / X,
              distance: F,
              aspect: N,
            };
          }
        }
        let b;
        const _ = (T) =>
            u((C) => ({ performance: { ...C.performance, current: T } })),
          w = new nt();
        return {
          set: u,
          get: h,
          gl: null,
          camera: null,
          raycaster: null,
          events: { priority: 1, enabled: !0, connected: !1 },
          scene: null,
          xr: null,
          invalidate: (T = 1) => i(h(), T),
          advance: (T, C) => e(T, C, h()),
          legacy: !1,
          linear: !1,
          flat: !1,
          controls: null,
          clock: new KN(),
          pointer: w,
          mouse: w,
          frameloop: "always",
          onPointerMissed: void 0,
          performance: {
            current: 1,
            min: 0.5,
            max: 1,
            debounce: 200,
            regress: () => {
              const T = h();
              (b && clearTimeout(b),
                T.performance.current !== T.performance.min &&
                  _(T.performance.min),
                (b = setTimeout(
                  () => _(h().performance.max),
                  T.performance.debounce,
                )));
            },
          },
          size: { width: 0, height: 0, top: 0, left: 0 },
          viewport: {
            initialDpr: 0,
            dpr: 0,
            width: 0,
            height: 0,
            top: 0,
            left: 0,
            aspect: 0,
            distance: 0,
            factor: 0,
            getCurrentViewport: y,
          },
          setEvents: (T) => u((C) => ({ ...C, events: { ...C.events, ...T } })),
          setSize: (T, C, R = 0, L = 0) => {
            const I = h().camera,
              O = { width: T, height: C, top: R, left: L };
            u((B) => ({ size: O, viewport: { ...B.viewport, ...y(I, m, O) } }));
          },
          setDpr: (T) =>
            u((C) => {
              const R = hU(T);
              return {
                viewport: {
                  ...C.viewport,
                  dpr: R,
                  initialDpr: C.viewport.initialDpr || R,
                },
              };
            }),
          setFrameloop: (T = "always") => {
            const C = h().clock;
            (C.stop(),
              (C.elapsedTime = 0),
              T !== "never" && (C.start(), (C.elapsedTime = 0)),
              u(() => ({ frameloop: T })));
          },
          previousRoot: void 0,
          internal: {
            interaction: [],
            hovered: new Map(),
            subscribers: [],
            initialClick: [0, 0],
            initialHits: [],
            capturedMap: new Map(),
            lastEvent: ie.createRef(),
            active: !1,
            frames: 0,
            priority: 0,
            subscribe: (T, C, R) => {
              const L = h().internal;
              return (
                (L.priority = L.priority + (C > 0 ? 1 : 0)),
                L.subscribers.push({ ref: T, priority: C, store: R }),
                (L.subscribers = L.subscribers.sort(
                  (I, O) => I.priority - O.priority,
                )),
                () => {
                  const I = h().internal;
                  I != null &&
                    I.subscribers &&
                    ((I.priority = I.priority - (C > 0 ? 1 : 0)),
                    (I.subscribers = I.subscribers.filter((O) => O.ref !== T)));
                }
              );
            },
          },
        };
      }),
      n = t.getState();
    let r = n.size,
      s = n.viewport.dpr,
      o = n.camera;
    return (
      t.subscribe(() => {
        const { camera: u, size: h, viewport: d, gl: m, set: v } = t.getState();
        if (h.width !== r.width || h.height !== r.height || d.dpr !== s) {
          ((r = h), (s = d.dpr), e7(u, h), d.dpr > 0 && m.setPixelRatio(d.dpr));
          const y =
            typeof HTMLCanvasElement < "u" &&
            m.domElement instanceof HTMLCanvasElement;
          m.setSize(h.width, h.height, y);
        }
        u !== o &&
          ((o = u),
          v((y) => ({
            viewport: { ...y.viewport, ...y.viewport.getCurrentViewport(u) },
          })));
      }),
      t.subscribe((u) => i(u)),
      t
    );
  };
function gU() {
  const i = ie.useContext(mU);
  if (!i)
    throw new Error("R3F: Hooks can only be used within the Canvas component!");
  return i;
}
function Vl(i = (t) => t, e) {
  return gU()(i, e);
}
function Pr(i, e = 0) {
  const t = gU(),
    n = t.getState().internal.subscribe,
    r = fU(i);
  return (z0(() => n(r, e, t), [e, n, t]), null);
}
/**
 * @license React
 * react-reconciler-constants.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ const r7 = 1,
  s7 = 8,
  a7 = 32,
  o7 = 2;
var l7 = { version: "9.5.0" };
function c7(i) {
  return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default")
    ? i.default
    : i;
}
var w3 = { exports: {} },
  A3 = { exports: {} },
  C3;
function u7() {
  return (
    C3 ||
      ((C3 = 1),
      (function (i) {
        ((i.exports = function (e) {
          function t(c, f, x, S) {
            return new um(c, f, x, S);
          }
          function n() {}
          function r(c) {
            var f = "https://react.dev/errors/" + c;
            if (1 < arguments.length) {
              f += "?args[]=" + encodeURIComponent(arguments[1]);
              for (var x = 2; x < arguments.length; x++)
                f += "&args[]=" + encodeURIComponent(arguments[x]);
            }
            return (
              "Minified React error #" +
              c +
              "; visit " +
              f +
              " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
            );
          }
          function s(c) {
            var f = c,
              x = c;
            if (c.alternate) for (; f.return; ) f = f.return;
            else {
              c = f;
              do
                ((f = c),
                  (f.flags & 4098) !== 0 && (x = f.return),
                  (c = f.return));
              while (c);
            }
            return f.tag === 3 ? x : null;
          }
          function o(c) {
            if (s(c) !== c) throw Error(r(188));
          }
          function u(c) {
            var f = c.alternate;
            if (!f) {
              if (((f = s(c)), f === null)) throw Error(r(188));
              return f !== c ? null : c;
            }
            for (var x = c, S = f; ; ) {
              var D = x.return;
              if (D === null) break;
              var U = D.alternate;
              if (U === null) {
                if (((S = D.return), S !== null)) {
                  x = S;
                  continue;
                }
                break;
              }
              if (D.child === U.child) {
                for (U = D.child; U; ) {
                  if (U === x) return (o(D), c);
                  if (U === S) return (o(D), f);
                  U = U.sibling;
                }
                throw Error(r(188));
              }
              if (x.return !== S.return) ((x = D), (S = U));
              else {
                for (var Y = !1, me = D.child; me; ) {
                  if (me === x) {
                    ((Y = !0), (x = D), (S = U));
                    break;
                  }
                  if (me === S) {
                    ((Y = !0), (S = D), (x = U));
                    break;
                  }
                  me = me.sibling;
                }
                if (!Y) {
                  for (me = U.child; me; ) {
                    if (me === x) {
                      ((Y = !0), (x = U), (S = D));
                      break;
                    }
                    if (me === S) {
                      ((Y = !0), (S = U), (x = D));
                      break;
                    }
                    me = me.sibling;
                  }
                  if (!Y) throw Error(r(189));
                }
              }
              if (x.alternate !== S) throw Error(r(190));
            }
            if (x.tag !== 3) throw Error(r(188));
            return x.stateNode.current === x ? c : f;
          }
          function h(c) {
            var f = c.tag;
            if (f === 5 || f === 26 || f === 27 || f === 6) return c;
            for (c = c.child; c !== null; ) {
              if (((f = h(c)), f !== null)) return f;
              c = c.sibling;
            }
            return null;
          }
          function d(c) {
            var f = c.tag;
            if (f === 5 || f === 26 || f === 27 || f === 6) return c;
            for (c = c.child; c !== null; ) {
              if (c.tag !== 4 && ((f = d(c)), f !== null)) return f;
              c = c.sibling;
            }
            return null;
          }
          function m(c) {
            return c === null || typeof c != "object"
              ? null
              : ((c = (Do && c[Do]) || c["@@iterator"]),
                typeof c == "function" ? c : null);
          }
          function v(c) {
            if (c == null) return null;
            if (typeof c == "function")
              return c.$$typeof === yl ? null : c.displayName || c.name || null;
            if (typeof c == "string") return c;
            switch (c) {
              case vc:
                return "Fragment";
              case xc:
                return "Profiler";
              case yc:
                return "StrictMode";
              case ld:
                return "Suspense";
              case Ro:
                return "SuspenseList";
              case Nf:
                return "Activity";
            }
            if (typeof c == "object")
              switch (c.$$typeof) {
                case gc:
                  return "Portal";
                case ia:
                  return c.displayName || "Context";
                case Lf:
                  return (c._context.displayName || "Context") + ".Consumer";
                case yu:
                  var f = c.render;
                  return (
                    (c = c.displayName),
                    c ||
                      ((c = f.displayName || f.name || ""),
                      (c = c !== "" ? "ForwardRef(" + c + ")" : "ForwardRef")),
                    c
                  );
                case cd:
                  return (
                    (f = c.displayName || null),
                    f !== null ? f : v(c.type) || "Memo"
                  );
                case kr:
                  ((f = c._payload), (c = c._init));
                  try {
                    return v(c(f));
                  } catch {}
              }
            return null;
          }
          function y(c) {
            return { current: c };
          }
          function b(c) {
            0 > Tc || ((c.current = Sd[Tc]), (Sd[Tc] = null), Tc--);
          }
          function _(c, f) {
            (Tc++, (Sd[Tc] = c.current), (c.current = f));
          }
          function w(c) {
            return ((c >>>= 0), c === 0 ? 32 : (31 - ((Md(c) / Yv) | 0)) | 0);
          }
          function E(c) {
            var f = c & 42;
            if (f !== 0) return f;
            switch (c & -c) {
              case 1:
                return 1;
              case 2:
                return 2;
              case 4:
                return 4;
              case 8:
                return 8;
              case 16:
                return 16;
              case 32:
                return 32;
              case 64:
                return 64;
              case 128:
                return 128;
              case 256:
              case 512:
              case 1024:
              case 2048:
              case 4096:
              case 8192:
              case 16384:
              case 32768:
              case 65536:
              case 131072:
                return c & 261888;
              case 262144:
              case 524288:
              case 1048576:
              case 2097152:
                return c & 3932160;
              case 4194304:
              case 8388608:
              case 16777216:
              case 33554432:
                return c & 62914560;
              case 67108864:
                return 67108864;
              case 134217728:
                return 134217728;
              case 268435456:
                return 268435456;
              case 536870912:
                return 536870912;
              case 1073741824:
                return 0;
              default:
                return c;
            }
          }
          function T(c, f, x) {
            var S = c.pendingLanes;
            if (S === 0) return 0;
            var D = 0,
              U = c.suspendedLanes,
              Y = c.pingedLanes;
            c = c.warmLanes;
            var me = S & 134217727;
            return (
              me !== 0
                ? ((S = me & ~U),
                  S !== 0
                    ? (D = E(S))
                    : ((Y &= me),
                      Y !== 0
                        ? (D = E(Y))
                        : x || ((x = me & ~c), x !== 0 && (D = E(x)))))
                : ((me = S & ~U),
                  me !== 0
                    ? (D = E(me))
                    : Y !== 0
                      ? (D = E(Y))
                      : x || ((x = S & ~c), x !== 0 && (D = E(x)))),
              D === 0
                ? 0
                : f !== 0 &&
                    f !== D &&
                    (f & U) === 0 &&
                    ((U = D & -D),
                    (x = f & -f),
                    U >= x || (U === 32 && (x & 4194048) !== 0))
                  ? f
                  : D
            );
          }
          function C(c, f) {
            return (
              (c.pendingLanes & ~(c.suspendedLanes & ~c.pingedLanes) & f) === 0
            );
          }
          function R(c, f) {
            switch (c) {
              case 1:
              case 2:
              case 4:
              case 8:
              case 64:
                return f + 250;
              case 16:
              case 32:
              case 128:
              case 256:
              case 512:
              case 1024:
              case 2048:
              case 4096:
              case 8192:
              case 16384:
              case 32768:
              case 65536:
              case 131072:
              case 262144:
              case 524288:
              case 1048576:
              case 2097152:
                return f + 5e3;
              case 4194304:
              case 8388608:
              case 16777216:
              case 33554432:
                return -1;
              case 67108864:
              case 134217728:
              case 268435456:
              case 536870912:
              case 1073741824:
                return -1;
              default:
                return -1;
            }
          }
          function L() {
            var c = Eu;
            return ((Eu <<= 1), (Eu & 62914560) === 0 && (Eu = 4194304), c);
          }
          function I(c) {
            for (var f = [], x = 0; 31 > x; x++) f.push(c);
            return f;
          }
          function O(c, f) {
            ((c.pendingLanes |= f),
              f !== 268435456 &&
                ((c.suspendedLanes = 0),
                (c.pingedLanes = 0),
                (c.warmLanes = 0)));
          }
          function B(c, f, x, S, D, U) {
            var Y = c.pendingLanes;
            ((c.pendingLanes = x),
              (c.suspendedLanes = 0),
              (c.pingedLanes = 0),
              (c.warmLanes = 0),
              (c.expiredLanes &= x),
              (c.entangledLanes &= x),
              (c.errorRecoveryDisabledLanes &= x),
              (c.shellSuspendCounter = 0));
            var me = c.entanglements,
              We = c.expirationTimes,
              ot = c.hiddenUpdates;
            for (x = Y & ~x; 0 < x; ) {
              var xt = 31 - ls(x),
                ut = 1 << xt;
              ((me[xt] = 0), (We[xt] = -1));
              var Ct = ot[xt];
              if (Ct !== null)
                for (ot[xt] = null, xt = 0; xt < Ct.length; xt++) {
                  var Qt = Ct[xt];
                  Qt !== null && (Qt.lane &= -536870913);
                }
              x &= ~ut;
            }
            (S !== 0 && N(c, S, 0),
              U !== 0 &&
                D === 0 &&
                c.tag !== 0 &&
                (c.suspendedLanes |= U & ~(Y & ~f)));
          }
          function N(c, f, x) {
            ((c.pendingLanes |= f), (c.suspendedLanes &= ~f));
            var S = 31 - ls(f);
            ((c.entangledLanes |= f),
              (c.entanglements[S] =
                c.entanglements[S] | 1073741824 | (x & 261930)));
          }
          function F(c, f) {
            var x = (c.entangledLanes |= f);
            for (c = c.entanglements; x; ) {
              var S = 31 - ls(x),
                D = 1 << S;
              ((D & f) | (c[S] & f) && (c[S] |= f), (x &= ~D));
            }
          }
          function j(c, f) {
            var x = f & -f;
            return (
              (x = (x & 42) !== 0 ? 1 : q(x)),
              (x & (c.suspendedLanes | f)) !== 0 ? 0 : x
            );
          }
          function q(c) {
            switch (c) {
              case 2:
                c = 1;
                break;
              case 8:
                c = 4;
                break;
              case 32:
                c = 16;
                break;
              case 256:
              case 512:
              case 1024:
              case 2048:
              case 4096:
              case 8192:
              case 16384:
              case 32768:
              case 65536:
              case 131072:
              case 262144:
              case 524288:
              case 1048576:
              case 2097152:
              case 4194304:
              case 8388608:
              case 16777216:
              case 33554432:
                c = 128;
                break;
              case 268435456:
                c = 134217728;
                break;
              default:
                c = 0;
            }
            return c;
          }
          function X(c) {
            return (
              (c &= -c),
              2 < c ? (8 < c ? ((c & 134217727) !== 0 ? 32 : 268435456) : 8) : 2
            );
          }
          function J(c) {
            if (
              (typeof Zm == "function" && Qv(c),
              cs && typeof cs.setStrictMode == "function")
            )
              try {
                cs.setStrictMode(wc, c);
              } catch {}
          }
          function ee(c, f) {
            return (
              (c === f && (c !== 0 || 1 / c === 1 / f)) || (c !== c && f !== f)
            );
          }
          function ne(c) {
            if (Rd === void 0)
              try {
                throw Error();
              } catch (x) {
                var f = x.stack.trim().match(/\n( *(at )?)/);
                ((Rd = (f && f[1]) || ""),
                  (so =
                    -1 <
                    x.stack.indexOf(`
    at`)
                      ? " (<anonymous>)"
                      : -1 < x.stack.indexOf("@")
                        ? "@unknown:0:0"
                        : ""));
              }
            return (
              `
` +
              Rd +
              c +
              so
            );
          }
          function W(c, f) {
            if (!c || Vf) return "";
            Vf = !0;
            var x = Error.prepareStackTrace;
            Error.prepareStackTrace = void 0;
            try {
              var S = {
                DetermineComponentFrameRoot: function () {
                  try {
                    if (f) {
                      var ut = function () {
                        throw Error();
                      };
                      if (
                        (Object.defineProperty(ut.prototype, "props", {
                          set: function () {
                            throw Error();
                          },
                        }),
                        typeof Reflect == "object" && Reflect.construct)
                      ) {
                        try {
                          Reflect.construct(ut, []);
                        } catch (Qt) {
                          var Ct = Qt;
                        }
                        Reflect.construct(c, [], ut);
                      } else {
                        try {
                          ut.call();
                        } catch (Qt) {
                          Ct = Qt;
                        }
                        c.call(ut.prototype);
                      }
                    } else {
                      try {
                        throw Error();
                      } catch (Qt) {
                        Ct = Qt;
                      }
                      (ut = c()) &&
                        typeof ut.catch == "function" &&
                        ut.catch(function () {});
                    }
                  } catch (Qt) {
                    if (Qt && Ct && typeof Qt.stack == "string")
                      return [Qt.stack, Ct.stack];
                  }
                  return [null, null];
                },
              };
              S.DetermineComponentFrameRoot.displayName =
                "DetermineComponentFrameRoot";
              var D = Object.getOwnPropertyDescriptor(
                S.DetermineComponentFrameRoot,
                "name",
              );
              D &&
                D.configurable &&
                Object.defineProperty(S.DetermineComponentFrameRoot, "name", {
                  value: "DetermineComponentFrameRoot",
                });
              var U = S.DetermineComponentFrameRoot(),
                Y = U[0],
                me = U[1];
              if (Y && me) {
                var We = Y.split(`
`),
                  ot = me.split(`
`);
                for (
                  D = S = 0;
                  S < We.length &&
                  !We[S].includes("DetermineComponentFrameRoot");
                )
                  S++;
                for (
                  ;
                  D < ot.length &&
                  !ot[D].includes("DetermineComponentFrameRoot");
                )
                  D++;
                if (S === We.length || D === ot.length)
                  for (
                    S = We.length - 1, D = ot.length - 1;
                    1 <= S && 0 <= D && We[S] !== ot[D];
                  )
                    D--;
                for (; 1 <= S && 0 <= D; S--, D--)
                  if (We[S] !== ot[D]) {
                    if (S !== 1 || D !== 1)
                      do
                        if ((S--, D--, 0 > D || We[S] !== ot[D])) {
                          var xt =
                            `
` + We[S].replace(" at new ", " at ");
                          return (
                            c.displayName &&
                              xt.includes("<anonymous>") &&
                              (xt = xt.replace("<anonymous>", c.displayName)),
                            xt
                          );
                        }
                      while (1 <= S && 0 <= D);
                    break;
                  }
              }
            } finally {
              ((Vf = !1), (Error.prepareStackTrace = x));
            }
            return (x = c ? c.displayName || c.name : "") ? ne(x) : "";
          }
          function $(c, f) {
            switch (c.tag) {
              case 26:
              case 27:
              case 5:
                return ne(c.type);
              case 16:
                return ne("Lazy");
              case 13:
                return c.child !== f && f !== null
                  ? ne("Suspense Fallback")
                  : ne("Suspense");
              case 19:
                return ne("SuspenseList");
              case 0:
              case 15:
                return W(c.type, !1);
              case 11:
                return W(c.type.render, !1);
              case 1:
                return W(c.type, !0);
              case 31:
                return ne("Activity");
              default:
                return "";
            }
          }
          function de(c) {
            try {
              var f = "",
                x = null;
              do ((f += $(c, x)), (x = c), (c = c.return));
              while (c);
              return f;
            } catch (S) {
              return (
                `
Error generating stack: ` +
                S.message +
                `
` +
                S.stack
              );
            }
          }
          function le(c, f) {
            if (typeof c == "object" && c !== null) {
              var x = Km.get(c);
              return x !== void 0
                ? x
                : ((f = { value: c, source: f, stack: de(f) }),
                  Km.set(c, f),
                  f);
            }
            return { value: c, source: f, stack: de(f) };
          }
          function fe(c, f) {
            ((Uo[ao++] = Gf), (Uo[ao++] = Wn), (Wn = c), (Gf = f));
          }
          function V(c, f, x) {
            ((aa[Ns++] = xr), (aa[Ns++] = wa), (aa[Ns++] = oa), (oa = c));
            var S = xr;
            c = wa;
            var D = 32 - ls(S) - 1;
            ((S &= ~(1 << D)), (x += 1));
            var U = 32 - ls(f) + D;
            if (30 < U) {
              var Y = D - (D % 5);
              ((U = (S & ((1 << Y) - 1)).toString(32)),
                (S >>= Y),
                (D -= Y),
                (xr = (1 << (32 - ls(f) + D)) | (x << D) | S),
                (wa = U + c));
            } else ((xr = (1 << U) | (x << D) | S), (wa = c));
          }
          function Z(c) {
            c.return !== null && (fe(c, 1), V(c, 1, 0));
          }
          function se(c) {
            for (; c === Wn; )
              ((Wn = Uo[--ao]),
                (Uo[ao] = null),
                (Gf = Uo[--ao]),
                (Uo[ao] = null));
            for (; c === oa; )
              ((oa = aa[--Ns]),
                (aa[Ns] = null),
                (wa = aa[--Ns]),
                (aa[Ns] = null),
                (xr = aa[--Ns]),
                (aa[Ns] = null));
          }
          function ue(c, f) {
            ((aa[Ns++] = xr),
              (aa[Ns++] = wa),
              (aa[Ns++] = oa),
              (xr = f.id),
              (wa = f.overflow),
              (oa = c));
          }
          function ge(c, f) {
            (_(br, f), _(Po, c), _(ur, null), (c = uv(f)), b(ur), _(ur, c));
          }
          function ae() {
            (b(ur), b(Po), b(br));
          }
          function he(c) {
            c.memoizedState !== null && _(Hf, c);
            var f = ur.current,
              x = _u(f, c.type);
            f !== x && (_(Po, c), _(ur, x));
          }
          function ye(c) {
            (Po.current === c && (b(ur), b(Po)),
              Hf.current === c &&
                (b(Hf),
                Ci ? (Sc._currentValue = _c) : (Sc._currentValue2 = _c)));
          }
          function ze(c) {
            var f = Error(
              r(
                418,
                1 < arguments.length && arguments[1] !== void 0 && arguments[1]
                  ? "text"
                  : "HTML",
                "",
              ),
            );
            throw (Ie(le(f, c)), Dd);
          }
          function it(c, f) {
            if (!oi) throw Error(r(175));
            Ov(c.stateNode, c.type, c.memoizedProps, f, c) || ze(c, !0);
          }
          function qe(c) {
            for ($i = c.return; $i; )
              switch ($i.tag) {
                case 5:
                case 31:
                case 13:
                  Gr = !1;
                  return;
                case 27:
                case 3:
                  Gr = !0;
                  return;
                default:
                  $i = $i.return;
              }
          }
          function Ye(c) {
            if (!oi || c !== $i) return !1;
            if (!yn) return (qe(c), (yn = !0), !1);
            var f = c.tag;
            if (
              (Ji
                ? f !== 3 &&
                  f !== 27 &&
                  (f !== 5 || (Tu(c.type) && !Vr(c.type, c.memoizedProps))) &&
                  li &&
                  ze(c)
                : f !== 3 &&
                  (f !== 5 || (Tu(c.type) && !Vr(c.type, c.memoizedProps))) &&
                  li &&
                  ze(c),
              qe(c),
              f === 13)
            ) {
              if (!oi) throw Error(r(316));
              if (
                ((c = c.memoizedState),
                (c = c !== null ? c.dehydrated : null),
                !c)
              )
                throw Error(r(317));
              li = zm(c);
            } else if (f === 31) {
              if (
                ((c = c.memoizedState),
                (c = c !== null ? c.dehydrated : null),
                !c)
              )
                throw Error(r(317));
              li = zv(c);
            } else
              li =
                Ji && f === 27 ? Cv(c.type, li) : $i ? Av(c.stateNode) : null;
            return !0;
          }
          function ft() {
            oi && ((li = $i = null), (yn = !1));
          }
          function Re() {
            var c = oo;
            return (
              c !== null &&
                (hs === null ? (hs = c) : hs.push.apply(hs, c), (oo = null)),
              c
            );
          }
          function Ie(c) {
            oo === null ? (oo = [c]) : oo.push(c);
          }
          function De(c, f, x) {
            Ci
              ? (_(la, f._currentValue), (f._currentValue = x))
              : (_(la, f._currentValue2), (f._currentValue2 = x));
          }
          function Qe(c) {
            var f = la.current;
            (Ci ? (c._currentValue = f) : (c._currentValue2 = f), b(la));
          }
          function K(c, f, x) {
            for (; c !== null; ) {
              var S = c.alternate;
              if (
                ((c.childLanes & f) !== f
                  ? ((c.childLanes |= f), S !== null && (S.childLanes |= f))
                  : S !== null &&
                    (S.childLanes & f) !== f &&
                    (S.childLanes |= f),
                c === x)
              )
                break;
              c = c.return;
            }
          }
          function rt(c, f, x, S) {
            var D = c.child;
            for (D !== null && (D.return = c); D !== null; ) {
              var U = D.dependencies;
              if (U !== null) {
                var Y = D.child;
                U = U.firstContext;
                e: for (; U !== null; ) {
                  var me = U;
                  U = D;
                  for (var We = 0; We < f.length; We++)
                    if (me.context === f[We]) {
                      ((U.lanes |= x),
                        (me = U.alternate),
                        me !== null && (me.lanes |= x),
                        K(U.return, x, c),
                        S || (Y = null));
                      break e;
                    }
                  U = me.next;
                }
              } else if (D.tag === 18) {
                if (((Y = D.return), Y === null)) throw Error(r(341));
                ((Y.lanes |= x),
                  (U = Y.alternate),
                  U !== null && (U.lanes |= x),
                  K(Y, x, c),
                  (Y = null));
              } else Y = D.child;
              if (Y !== null) Y.return = D;
              else
                for (Y = D; Y !== null; ) {
                  if (Y === c) {
                    Y = null;
                    break;
                  }
                  if (((D = Y.sibling), D !== null)) {
                    ((D.return = Y.return), (Y = D));
                    break;
                  }
                  Y = Y.return;
                }
              D = Y;
            }
          }
          function je(c, f, x, S) {
            c = null;
            for (var D = f, U = !1; D !== null; ) {
              if (!U) {
                if ((D.flags & 524288) !== 0) U = !0;
                else if ((D.flags & 262144) !== 0) break;
              }
              if (D.tag === 10) {
                var Y = D.alternate;
                if (Y === null) throw Error(r(387));
                if (((Y = Y.memoizedProps), Y !== null)) {
                  var me = D.type;
                  Di(D.pendingProps.value, Y.value) ||
                    (c !== null ? c.push(me) : (c = [me]));
                }
              } else if (D === Hf.current) {
                if (((Y = D.alternate), Y === null)) throw Error(r(387));
                Y.memoizedState.memoizedState !==
                  D.memoizedState.memoizedState &&
                  (c !== null ? c.push(Sc) : (c = [Sc]));
              }
              D = D.return;
            }
            (c !== null && rt(f, c, x, S), (f.flags |= 262144));
          }
          function Te(c) {
            for (c = c.firstContext; c !== null; ) {
              var f = c.context;
              if (!Di(Ci ? f._currentValue : f._currentValue2, c.memoizedValue))
                return !0;
              c = c.next;
            }
            return !1;
          }
          function ke(c) {
            ((Kn = c),
              (Aa = null),
              (c = c.dependencies),
              c !== null && (c.firstContext = null));
          }
          function H(c) {
            return oe(Kn, c);
          }
          function k(c, f) {
            return (Kn === null && ke(c), oe(c, f));
          }
          function oe(c, f) {
            var x = Ci ? f._currentValue : f._currentValue2;
            if (
              ((f = { context: f, memoizedValue: x, next: null }), Aa === null)
            ) {
              if (c === null) throw Error(r(308));
              ((Aa = f),
                (c.dependencies = { lanes: 0, firstContext: f }),
                (c.flags |= 524288));
            } else Aa = Aa.next = f;
            return x;
          }
          function Ae() {
            return { controller: new Jv(), data: new Map(), refCount: 0 };
          }
          function _e(c) {
            (c.refCount--,
              c.refCount === 0 &&
                fr(Wb, function () {
                  c.controller.abort();
                }));
          }
          function be() {}
          function et(c) {
            (c !== kn &&
              c.next === null &&
              (kn === null ? (jf = kn = c) : (kn = kn.next = c)),
              (ca = !0),
              Lr || ((Lr = !0), re()));
          }
          function $e(c, f) {
            if (!Ld && ca) {
              Ld = !0;
              do
                for (var x = !1, S = jf; S !== null; ) {
                  if (c !== 0) {
                    var D = S.pendingLanes;
                    if (D === 0) var U = 0;
                    else {
                      var Y = S.suspendedLanes,
                        me = S.pingedLanes;
                      ((U = (1 << (31 - ls(42 | c) + 1)) - 1),
                        (U &= D & ~(Y & ~me)),
                        (U =
                          U & 201326741 ? (U & 201326741) | 1 : U ? U | 2 : 0));
                    }
                    U !== 0 && ((x = !0), Ze(S, U));
                  } else
                    ((U = xn),
                      (U = T(
                        S,
                        S === ln ? U : 0,
                        S.cancelPendingCommit !== null ||
                          S.timeoutHandle !== os,
                      )),
                      (U & 3) === 0 || C(S, U) || ((x = !0), Ze(S, U)));
                  S = S.next;
                }
              while (x);
              Ld = !1;
            }
          }
          function ht() {
            yt();
          }
          function yt() {
            ca = Lr = !1;
            var c = 0;
            Ml !== 0 && bc() && (c = Ml);
            for (var f = Dr(), x = null, S = jf; S !== null; ) {
              var D = S.next,
                U = Ge(S, f);
              (U === 0
                ? ((S.next = null),
                  x === null ? (jf = D) : (x.next = D),
                  D === null && (kn = x))
                : ((x = S), (c !== 0 || (U & 3) !== 0) && (ca = !0)),
                (S = D));
            }
            ((Xi !== 0 && Xi !== 5) || $e(c), Ml !== 0 && (Ml = 0));
          }
          function Ge(c, f) {
            for (
              var x = c.suspendedLanes,
                S = c.pingedLanes,
                D = c.expirationTimes,
                U = c.pendingLanes & -62914561;
              0 < U;
            ) {
              var Y = 31 - ls(U),
                me = 1 << Y,
                We = D[Y];
              (We === -1
                ? ((me & x) === 0 || (me & S) !== 0) && (D[Y] = R(me, f))
                : We <= f && (c.expiredLanes |= me),
                (U &= ~me));
            }
            if (
              ((f = ln),
              (x = xn),
              (x = T(
                c,
                c === f ? x : 0,
                c.cancelPendingCommit !== null || c.timeoutHandle !== os,
              )),
              (S = c.callbackNode),
              x === 0 ||
                (c === f && (Gn === 2 || Gn === 9)) ||
                c.cancelPendingCommit !== null)
            )
              return (
                S !== null && S !== null && Ed(S),
                (c.callbackNode = null),
                (c.callbackPriority = 0)
              );
            if ((x & 3) === 0 || C(c, x)) {
              if (((f = x & -x), f === c.callbackPriority)) return f;
              switch ((S !== null && Ed(S), X(x))) {
                case 2:
                case 8:
                  x = Kv;
                  break;
                case 32:
                  x = kf;
                  break;
                case 268435456:
                  x = Ad;
                  break;
                default:
                  x = kf;
              }
              return (
                (S = Ve.bind(null, c)),
                (x = Bf(x, S)),
                (c.callbackPriority = f),
                (c.callbackNode = x),
                f
              );
            }
            return (
              S !== null && S !== null && Ed(S),
              (c.callbackPriority = 2),
              (c.callbackNode = null),
              2
            );
          }
          function Ve(c, f) {
            if (Xi !== 0 && Xi !== 5)
              return ((c.callbackNode = null), (c.callbackPriority = 0), null);
            var x = c.callbackNode;
            if (no() && c.callbackNode !== x) return null;
            var S = xn;
            return (
              (S = T(
                c,
                c === ln ? S : 0,
                c.cancelPendingCommit !== null || c.timeoutHandle !== os,
              )),
              S === 0
                ? null
                : (Ea(c, S, f),
                  Ge(c, Dr()),
                  c.callbackNode != null && c.callbackNode === x
                    ? Ve.bind(null, c)
                    : null)
            );
          }
          function Ze(c, f) {
            if (no()) return null;
            Ea(c, f, !0);
          }
          function re() {
            Sm
              ? Mm(function () {
                  (dn & 6) !== 0 ? Bf(wd, ht) : yt();
                })
              : Bf(wd, ht);
          }
          function Se() {
            if (Ml === 0) {
              var c = Io;
              (c === 0 &&
                ((c = Td), (Td <<= 1), (Td & 261888) === 0 && (Td = 256)),
                (Ml = c));
            }
            return Ml;
          }
          function lt(c, f) {
            if (wu === null) {
              var x = (wu = []);
              ((Qm = 0),
                (Io = Se()),
                (er = {
                  status: "pending",
                  value: void 0,
                  then: function (S) {
                    x.push(S);
                  },
                }));
            }
            return (Qm++, f.then(ce, ce), f);
          }
          function ce() {
            if (--Qm === 0 && wu !== null) {
              er !== null && (er.status = "fulfilled");
              var c = wu;
              ((wu = null), (Io = 0), (er = null));
              for (var f = 0; f < c.length; f++) (0, c[f])();
            }
          }
          function Oe(c, f) {
            var x = [],
              S = {
                status: "pending",
                value: null,
                reason: null,
                then: function (D) {
                  x.push(D);
                },
              };
            return (
              c.then(
                function () {
                  ((S.status = "fulfilled"), (S.value = f));
                  for (var D = 0; D < x.length; D++) (0, x[D])(f);
                },
                function (D) {
                  for (
                    S.status = "rejected", S.reason = D, D = 0;
                    D < x.length;
                    D++
                  )
                    (0, x[D])(void 0);
                },
              ),
              S
            );
          }
          function Ke() {
            var c = Tl.current;
            return c !== null ? c : ln.pooledCache;
          }
          function dt(c, f) {
            f === null ? _(Tl, Tl.current) : _(Tl, f.pool);
          }
          function Je() {
            var c = Ke();
            return c === null
              ? null
              : { parent: Ci ? ci._currentValue : ci._currentValue2, pool: c };
          }
          function Ee(c, f) {
            if (Di(c, f)) return !0;
            if (
              typeof c != "object" ||
              c === null ||
              typeof f != "object" ||
              f === null
            )
              return !1;
            var x = Object.keys(c),
              S = Object.keys(f);
            if (x.length !== S.length) return !1;
            for (S = 0; S < x.length; S++) {
              var D = x[S];
              if (!jb.call(f, D) || !Di(c[D], f[D])) return !1;
            }
            return !0;
          }
          function ct(c) {
            return ((c = c.status), c === "fulfilled" || c === "rejected");
          }
          function Mt(c, f, x) {
            switch (
              ((x = c[x]),
              x === void 0 ? c.push(f) : x !== f && (f.then(be, be), (f = x)),
              f.status)
            ) {
              case "fulfilled":
                return f.value;
              case "rejected":
                throw ((c = f.reason), hn(c), c);
              default:
                if (typeof f.status == "string") f.then(be, be);
                else {
                  if (((c = ln), c !== null && 100 < c.shellSuspendCounter))
                    throw Error(r(482));
                  ((c = f),
                    (c.status = "pending"),
                    c.then(
                      function (S) {
                        if (f.status === "pending") {
                          var D = f;
                          ((D.status = "fulfilled"), (D.value = S));
                        }
                      },
                      function (S) {
                        if (f.status === "pending") {
                          var D = f;
                          ((D.status = "rejected"), (D.reason = S));
                        }
                      },
                    ));
                }
                switch (f.status) {
                  case "fulfilled":
                    return f.value;
                  case "rejected":
                    throw ((c = f.reason), hn(c), c);
                }
                throw ((Hr = f), tr);
            }
          }
          function St(c) {
            try {
              var f = c._init;
              return f(c._payload);
            } catch (x) {
              throw x !== null &&
                typeof x == "object" &&
                typeof x.then == "function"
                ? ((Hr = x), tr)
                : x;
            }
          }
          function Dt() {
            if (Hr === null) throw Error(r(459));
            var c = Hr;
            return ((Hr = null), c);
          }
          function hn(c) {
            if (c === tr || c === fa) throw Error(r(483));
          }
          function bn(c) {
            var f = Ac;
            return ((Ac += 1), El === null && (El = []), Mt(El, c, f));
          }
          function Bn(c, f) {
            ((f = f.props.ref), (c.ref = f !== void 0 ? f : null));
          }
          function Ai(c, f) {
            throw f.$$typeof === mc
              ? Error(r(525))
              : ((c = Object.prototype.toString.call(f)),
                Error(
                  r(
                    31,
                    c === "[object Object]"
                      ? "object with keys {" + Object.keys(f).join(", ") + "}"
                      : c,
                  ),
                ));
          }
          function $r(c) {
            function f(Pe, we) {
              if (c) {
                var He = Pe.deletions;
                He === null
                  ? ((Pe.deletions = [we]), (Pe.flags |= 16))
                  : He.push(we);
              }
            }
            function x(Pe, we) {
              if (!c) return null;
              for (; we !== null; ) (f(Pe, we), (we = we.sibling));
              return null;
            }
            function S(Pe) {
              for (var we = new Map(); Pe !== null; )
                (Pe.key !== null ? we.set(Pe.key, Pe) : we.set(Pe.index, Pe),
                  (Pe = Pe.sibling));
              return we;
            }
            function D(Pe, we) {
              return (
                (Pe = Ds(Pe, we)),
                (Pe.index = 0),
                (Pe.sibling = null),
                Pe
              );
            }
            function U(Pe, we, He) {
              return (
                (Pe.index = He),
                c
                  ? ((He = Pe.alternate),
                    He !== null
                      ? ((He = He.index),
                        He < we ? ((Pe.flags |= 67108866), we) : He)
                      : ((Pe.flags |= 67108866), we))
                  : ((Pe.flags |= 1048576), we)
              );
            }
            function Y(Pe) {
              return (c && Pe.alternate === null && (Pe.flags |= 67108866), Pe);
            }
            function me(Pe, we, He, mt) {
              return we === null || we.tag !== 6
                ? ((we = fm(He, Pe.mode, mt)), (we.return = Pe), we)
                : ((we = D(we, He)), (we.return = Pe), we);
            }
            function We(Pe, we, He, mt) {
              var Vt = He.type;
              return Vt === vc
                ? xt(Pe, we, He.props.children, mt, He.key)
                : we !== null &&
                    (we.elementType === Vt ||
                      (typeof Vt == "object" &&
                        Vt !== null &&
                        Vt.$$typeof === kr &&
                        St(Vt) === we.type))
                  ? ((we = D(we, He.props)), Bn(we, He), (we.return = Pe), we)
                  : ((we = Co(He.type, He.key, He.props, null, Pe.mode, mt)),
                    Bn(we, He),
                    (we.return = Pe),
                    we);
            }
            function ot(Pe, we, He, mt) {
              return we === null ||
                we.tag !== 4 ||
                we.stateNode.containerInfo !== He.containerInfo ||
                we.stateNode.implementation !== He.implementation
                ? ((we = dm(He, Pe.mode, mt)), (we.return = Pe), we)
                : ((we = D(we, He.children || [])), (we.return = Pe), we);
            }
            function xt(Pe, we, He, mt, Vt) {
              return we === null || we.tag !== 7
                ? ((we = na(He, Pe.mode, mt, Vt)), (we.return = Pe), we)
                : ((we = D(we, He)), (we.return = Pe), we);
            }
            function ut(Pe, we, He) {
              if (
                (typeof we == "string" && we !== "") ||
                typeof we == "number" ||
                typeof we == "bigint"
              )
                return ((we = fm("" + we, Pe.mode, He)), (we.return = Pe), we);
              if (typeof we == "object" && we !== null) {
                switch (we.$$typeof) {
                  case io:
                    return (
                      (He = Co(we.type, we.key, we.props, null, Pe.mode, He)),
                      Bn(He, we),
                      (He.return = Pe),
                      He
                    );
                  case gc:
                    return ((we = dm(we, Pe.mode, He)), (we.return = Pe), we);
                  case kr:
                    return ((we = St(we)), ut(Pe, we, He));
                }
                if (xl(we) || m(we))
                  return (
                    (we = na(we, Pe.mode, He, null)),
                    (we.return = Pe),
                    we
                  );
                if (typeof we.then == "function") return ut(Pe, bn(we), He);
                if (we.$$typeof === ia) return ut(Pe, k(Pe, we), He);
                Ai(Pe, we);
              }
              return null;
            }
            function Ct(Pe, we, He, mt) {
              var Vt = we !== null ? we.key : null;
              if (
                (typeof He == "string" && He !== "") ||
                typeof He == "number" ||
                typeof He == "bigint"
              )
                return Vt !== null ? null : me(Pe, we, "" + He, mt);
              if (typeof He == "object" && He !== null) {
                switch (He.$$typeof) {
                  case io:
                    return He.key === Vt ? We(Pe, we, He, mt) : null;
                  case gc:
                    return He.key === Vt ? ot(Pe, we, He, mt) : null;
                  case kr:
                    return ((He = St(He)), Ct(Pe, we, He, mt));
                }
                if (xl(He) || m(He))
                  return Vt !== null ? null : xt(Pe, we, He, mt, null);
                if (typeof He.then == "function") return Ct(Pe, we, bn(He), mt);
                if (He.$$typeof === ia) return Ct(Pe, we, k(Pe, He), mt);
                Ai(Pe, He);
              }
              return null;
            }
            function Qt(Pe, we, He, mt, Vt) {
              if (
                (typeof mt == "string" && mt !== "") ||
                typeof mt == "number" ||
                typeof mt == "bigint"
              )
                return ((Pe = Pe.get(He) || null), me(we, Pe, "" + mt, Vt));
              if (typeof mt == "object" && mt !== null) {
                switch (mt.$$typeof) {
                  case io:
                    return (
                      (Pe = Pe.get(mt.key === null ? He : mt.key) || null),
                      We(we, Pe, mt, Vt)
                    );
                  case gc:
                    return (
                      (Pe = Pe.get(mt.key === null ? He : mt.key) || null),
                      ot(we, Pe, mt, Vt)
                    );
                  case kr:
                    return ((mt = St(mt)), Qt(Pe, we, He, mt, Vt));
                }
                if (xl(mt) || m(mt))
                  return ((Pe = Pe.get(He) || null), xt(we, Pe, mt, Vt, null));
                if (typeof mt.then == "function")
                  return Qt(Pe, we, He, bn(mt), Vt);
                if (mt.$$typeof === ia) return Qt(Pe, we, He, k(we, mt), Vt);
                Ai(we, mt);
              }
              return null;
            }
            function Ui(Pe, we, He, mt) {
              for (
                var Vt = null, vi = null, Gt = we, wn = (we = 0), hr = null;
                Gt !== null && wn < He.length;
                wn++
              ) {
                Gt.index > wn ? ((hr = Gt), (Gt = null)) : (hr = Gt.sibling);
                var Nn = Ct(Pe, Gt, He[wn], mt);
                if (Nn === null) {
                  Gt === null && (Gt = hr);
                  break;
                }
                (c && Gt && Nn.alternate === null && f(Pe, Gt),
                  (we = U(Nn, we, wn)),
                  vi === null ? (Vt = Nn) : (vi.sibling = Nn),
                  (vi = Nn),
                  (Gt = hr));
              }
              if (wn === He.length) return (x(Pe, Gt), yn && fe(Pe, wn), Vt);
              if (Gt === null) {
                for (; wn < He.length; wn++)
                  ((Gt = ut(Pe, He[wn], mt)),
                    Gt !== null &&
                      ((we = U(Gt, we, wn)),
                      vi === null ? (Vt = Gt) : (vi.sibling = Gt),
                      (vi = Gt)));
                return (yn && fe(Pe, wn), Vt);
              }
              for (Gt = S(Gt); wn < He.length; wn++)
                ((hr = Qt(Gt, Pe, wn, He[wn], mt)),
                  hr !== null &&
                    (c &&
                      hr.alternate !== null &&
                      Gt.delete(hr.key === null ? wn : hr.key),
                    (we = U(hr, we, wn)),
                    vi === null ? (Vt = hr) : (vi.sibling = hr),
                    (vi = hr)));
              return (
                c &&
                  Gt.forEach(function (pa) {
                    return f(Pe, pa);
                  }),
                yn && fe(Pe, wn),
                Vt
              );
            }
            function Pu(Pe, we, He, mt) {
              if (He == null) throw Error(r(151));
              for (
                var Vt = null,
                  vi = null,
                  Gt = we,
                  wn = (we = 0),
                  hr = null,
                  Nn = He.next();
                Gt !== null && !Nn.done;
                wn++, Nn = He.next()
              ) {
                Gt.index > wn ? ((hr = Gt), (Gt = null)) : (hr = Gt.sibling);
                var pa = Ct(Pe, Gt, Nn.value, mt);
                if (pa === null) {
                  Gt === null && (Gt = hr);
                  break;
                }
                (c && Gt && pa.alternate === null && f(Pe, Gt),
                  (we = U(pa, we, wn)),
                  vi === null ? (Vt = pa) : (vi.sibling = pa),
                  (vi = pa),
                  (Gt = hr));
              }
              if (Nn.done) return (x(Pe, Gt), yn && fe(Pe, wn), Vt);
              if (Gt === null) {
                for (; !Nn.done; wn++, Nn = He.next())
                  ((Nn = ut(Pe, Nn.value, mt)),
                    Nn !== null &&
                      ((we = U(Nn, we, wn)),
                      vi === null ? (Vt = Nn) : (vi.sibling = Nn),
                      (vi = Nn)));
                return (yn && fe(Pe, wn), Vt);
              }
              for (Gt = S(Gt); !Nn.done; wn++, Nn = He.next())
                ((Nn = Qt(Gt, Pe, wn, Nn.value, mt)),
                  Nn !== null &&
                    (c &&
                      Nn.alternate !== null &&
                      Gt.delete(Nn.key === null ? wn : Nn.key),
                    (we = U(Nn, we, wn)),
                    vi === null ? (Vt = Nn) : (vi.sibling = Nn),
                    (vi = Nn)));
              return (
                c &&
                  Gt.forEach(function (Xb) {
                    return f(Pe, Xb);
                  }),
                yn && fe(Pe, wn),
                Vt
              );
            }
            function Ul(Pe, we, He, mt) {
              if (
                (typeof He == "object" &&
                  He !== null &&
                  He.type === vc &&
                  He.key === null &&
                  (He = He.props.children),
                typeof He == "object" && He !== null)
              ) {
                switch (He.$$typeof) {
                  case io:
                    e: {
                      for (var Vt = He.key; we !== null; ) {
                        if (we.key === Vt) {
                          if (((Vt = He.type), Vt === vc)) {
                            if (we.tag === 7) {
                              (x(Pe, we.sibling),
                                (mt = D(we, He.props.children)),
                                (mt.return = Pe),
                                (Pe = mt));
                              break e;
                            }
                          } else if (
                            we.elementType === Vt ||
                            (typeof Vt == "object" &&
                              Vt !== null &&
                              Vt.$$typeof === kr &&
                              St(Vt) === we.type)
                          ) {
                            (x(Pe, we.sibling),
                              (mt = D(we, He.props)),
                              Bn(mt, He),
                              (mt.return = Pe),
                              (Pe = mt));
                            break e;
                          }
                          x(Pe, we);
                          break;
                        } else f(Pe, we);
                        we = we.sibling;
                      }
                      He.type === vc
                        ? ((mt = na(He.props.children, Pe.mode, mt, He.key)),
                          (mt.return = Pe),
                          (Pe = mt))
                        : ((mt = Co(
                            He.type,
                            He.key,
                            He.props,
                            null,
                            Pe.mode,
                            mt,
                          )),
                          Bn(mt, He),
                          (mt.return = Pe),
                          (Pe = mt));
                    }
                    return Y(Pe);
                  case gc:
                    e: {
                      for (Vt = He.key; we !== null; ) {
                        if (we.key === Vt)
                          if (
                            we.tag === 4 &&
                            we.stateNode.containerInfo === He.containerInfo &&
                            we.stateNode.implementation === He.implementation
                          ) {
                            (x(Pe, we.sibling),
                              (mt = D(we, He.children || [])),
                              (mt.return = Pe),
                              (Pe = mt));
                            break e;
                          } else {
                            x(Pe, we);
                            break;
                          }
                        else f(Pe, we);
                        we = we.sibling;
                      }
                      ((mt = dm(He, Pe.mode, mt)), (mt.return = Pe), (Pe = mt));
                    }
                    return Y(Pe);
                  case kr:
                    return ((He = St(He)), Ul(Pe, we, He, mt));
                }
                if (xl(He)) return Ui(Pe, we, He, mt);
                if (m(He)) {
                  if (((Vt = m(He)), typeof Vt != "function"))
                    throw Error(r(150));
                  return ((He = Vt.call(He)), Pu(Pe, we, He, mt));
                }
                if (typeof He.then == "function") return Ul(Pe, we, bn(He), mt);
                if (He.$$typeof === ia) return Ul(Pe, we, k(Pe, He), mt);
                Ai(Pe, He);
              }
              return (typeof He == "string" && He !== "") ||
                typeof He == "number" ||
                typeof He == "bigint"
                ? ((He = "" + He),
                  we !== null && we.tag === 6
                    ? (x(Pe, we.sibling),
                      (mt = D(we, He)),
                      (mt.return = Pe),
                      (Pe = mt))
                    : (x(Pe, we),
                      (mt = fm(He, Pe.mode, mt)),
                      (mt.return = Pe),
                      (Pe = mt)),
                  Y(Pe))
                : x(Pe, we);
            }
            return function (Pe, we, He, mt) {
              try {
                Ac = 0;
                var Vt = Ul(Pe, we, He, mt);
                return ((El = null), Vt);
              } catch (Gt) {
                if (Gt === tr || Gt === fa) throw Gt;
                var vi = t(29, Gt, null, Pe.mode);
                return ((vi.lanes = mt), (vi.return = Pe), vi);
              } finally {
              }
            };
          }
          function Zi() {
            for (var c = co, f = (Cc = co = 0); f < c; ) {
              var x = Sr[f];
              Sr[f++] = null;
              var S = Sr[f];
              Sr[f++] = null;
              var D = Sr[f];
              Sr[f++] = null;
              var U = Sr[f];
              if (((Sr[f++] = null), S !== null && D !== null)) {
                var Y = S.pending;
                (Y === null ? (D.next = D) : ((D.next = Y.next), (Y.next = D)),
                  (S.pending = D));
              }
              U !== 0 && Hn(x, D, U);
            }
          }
          function ar(c, f, x, S) {
            ((Sr[co++] = c),
              (Sr[co++] = f),
              (Sr[co++] = x),
              (Sr[co++] = S),
              (Cc |= S),
              (c.lanes |= S),
              (c = c.alternate),
              c !== null && (c.lanes |= S));
          }
          function zi(c, f, x, S) {
            return (ar(c, f, x, S), Un(c));
          }
          function xi(c, f) {
            return (ar(c, null, null, f), Un(c));
          }
          function Hn(c, f, x) {
            c.lanes |= x;
            var S = c.alternate;
            S !== null && (S.lanes |= x);
            for (var D = !1, U = c.return; U !== null; )
              ((U.childLanes |= x),
                (S = U.alternate),
                S !== null && (S.childLanes |= x),
                U.tag === 22 &&
                  ((c = U.stateNode),
                  c === null || c._visibility & 1 || (D = !0)),
                (c = U),
                (U = U.return));
            return c.tag === 3
              ? ((U = c.stateNode),
                D &&
                  f !== null &&
                  ((D = 31 - ls(x)),
                  (c = U.hiddenUpdates),
                  (S = c[D]),
                  S === null ? (c[D] = [f]) : S.push(f),
                  (f.lane = x | 536870912)),
                U)
              : null;
          }
          function Un(c) {
            if (50 < Rn) throw ((Rn = 0), (Kf = null), Error(r(185)));
            for (var f = c.return; f !== null; ) ((c = f), (f = c.return));
            return c.tag === 3 ? c.stateNode : null;
          }
          function ii(c) {
            c.updateQueue = {
              baseState: c.memoizedState,
              firstBaseUpdate: null,
              lastBaseUpdate: null,
              shared: { pending: null, lanes: 0, hiddenCallbacks: null },
              callbacks: null,
            };
          }
          function Ir(c, f) {
            ((c = c.updateQueue),
              f.updateQueue === c &&
                (f.updateQueue = {
                  baseState: c.baseState,
                  firstBaseUpdate: c.firstBaseUpdate,
                  lastBaseUpdate: c.lastBaseUpdate,
                  shared: c.shared,
                  callbacks: null,
                }));
          }
          function gr(c) {
            return {
              lane: c,
              tag: 0,
              payload: null,
              callback: null,
              next: null,
            };
          }
          function es(c, f, x) {
            var S = c.updateQueue;
            if (S === null) return null;
            if (((S = S.shared), (dn & 2) !== 0)) {
              var D = S.pending;
              return (
                D === null ? (f.next = f) : ((f.next = D.next), (D.next = f)),
                (S.pending = f),
                (f = Un(c)),
                Hn(c, null, x),
                f
              );
            }
            return (ar(c, S, f, x), Un(c));
          }
          function _s(c, f, x) {
            if (
              ((f = f.updateQueue),
              f !== null && ((f = f.shared), (x & 4194048) !== 0))
            ) {
              var S = f.lanes;
              ((S &= c.pendingLanes), (x |= S), (f.lanes = x), F(c, x));
            }
          }
          function Ba(c, f) {
            var x = c.updateQueue,
              S = c.alternate;
            if (S !== null && ((S = S.updateQueue), x === S)) {
              var D = null,
                U = null;
              if (((x = x.firstBaseUpdate), x !== null)) {
                do {
                  var Y = {
                    lane: x.lane,
                    tag: x.tag,
                    payload: x.payload,
                    callback: null,
                    next: null,
                  };
                  (U === null ? (D = U = Y) : (U = U.next = Y), (x = x.next));
                } while (x !== null);
                U === null ? (D = U = f) : (U = U.next = f);
              } else D = U = f;
              ((x = {
                baseState: S.baseState,
                firstBaseUpdate: D,
                lastBaseUpdate: U,
                shared: S.shared,
                callbacks: S.callbacks,
              }),
                (c.updateQueue = x));
              return;
            }
            ((c = x.lastBaseUpdate),
              c === null ? (x.firstBaseUpdate = f) : (c.next = f),
              (x.lastBaseUpdate = f));
          }
          function Ss() {
            if (Ud) {
              var c = er;
              if (c !== null) throw c;
            }
          }
          function Xs(c, f, x, S) {
            Ud = !1;
            var D = c.updateQueue;
            Us = !1;
            var U = D.firstBaseUpdate,
              Y = D.lastBaseUpdate,
              me = D.shared.pending;
            if (me !== null) {
              D.shared.pending = null;
              var We = me,
                ot = We.next;
              ((We.next = null),
                Y === null ? (U = ot) : (Y.next = ot),
                (Y = We));
              var xt = c.alternate;
              xt !== null &&
                ((xt = xt.updateQueue),
                (me = xt.lastBaseUpdate),
                me !== Y &&
                  (me === null ? (xt.firstBaseUpdate = ot) : (me.next = ot),
                  (xt.lastBaseUpdate = We)));
            }
            if (U !== null) {
              var ut = D.baseState;
              ((Y = 0), (xt = ot = We = null), (me = U));
              do {
                var Ct = me.lane & -536870913,
                  Qt = Ct !== me.lane;
                if (Qt ? (xn & Ct) === Ct : (S & Ct) === Ct) {
                  (Ct !== 0 && Ct === Io && (Ud = !0),
                    xt !== null &&
                      (xt = xt.next =
                        {
                          lane: 0,
                          tag: me.tag,
                          payload: me.payload,
                          callback: null,
                          next: null,
                        }));
                  e: {
                    var Ui = c,
                      Pu = me;
                    Ct = f;
                    var Ul = x;
                    switch (Pu.tag) {
                      case 1:
                        if (((Ui = Pu.payload), typeof Ui == "function")) {
                          ut = Ui.call(Ul, ut, Ct);
                          break e;
                        }
                        ut = Ui;
                        break e;
                      case 3:
                        Ui.flags = (Ui.flags & -65537) | 128;
                      case 0:
                        if (
                          ((Ui = Pu.payload),
                          (Ct =
                            typeof Ui == "function" ? Ui.call(Ul, ut, Ct) : Ui),
                          Ct == null)
                        )
                          break e;
                        ut = od({}, ut, Ct);
                        break e;
                      case 2:
                        Us = !0;
                    }
                  }
                  ((Ct = me.callback),
                    Ct !== null &&
                      ((c.flags |= 64),
                      Qt && (c.flags |= 8192),
                      (Qt = D.callbacks),
                      Qt === null ? (D.callbacks = [Ct]) : Qt.push(Ct)));
                } else
                  ((Qt = {
                    lane: Ct,
                    tag: me.tag,
                    payload: me.payload,
                    callback: me.callback,
                    next: null,
                  }),
                    xt === null
                      ? ((ot = xt = Qt), (We = ut))
                      : (xt = xt.next = Qt),
                    (Y |= Ct));
                if (((me = me.next), me === null)) {
                  if (((me = D.shared.pending), me === null)) break;
                  ((Qt = me),
                    (me = Qt.next),
                    (Qt.next = null),
                    (D.lastBaseUpdate = Qt),
                    (D.shared.pending = null));
                }
              } while (!0);
              (xt === null && (We = ut),
                (D.baseState = We),
                (D.firstBaseUpdate = ot),
                (D.lastBaseUpdate = xt),
                U === null && (D.shared.lanes = 0),
                (Fo |= Y),
                (c.lanes = Y),
                (c.memoizedState = ut));
            }
          }
          function ts(c, f) {
            if (typeof c != "function") throw Error(r(191, c));
            c.call(f);
          }
          function Ms(c, f) {
            var x = c.callbacks;
            if (x !== null)
              for (c.callbacks = null, c = 0; c < x.length; c++) ts(x[c], f);
          }
          function qs(c, f) {
            ((c = fo), _(wl, c), _(Rc, f), (fo = c | f.baseLanes));
          }
          function G() {
            (_(wl, fo), _(Rc, Rc.current));
          }
          function ve() {
            ((fo = wl.current), b(Rc), b(wl));
          }
          function Fe(c) {
            var f = c.alternate;
            (_(Si, Si.current & 1),
              _(us, c),
              fs === null &&
                (f === null ||
                  Rc.current !== null ||
                  f.memoizedState !== null) &&
                (fs = c));
          }
          function Le(c) {
            (_(Si, Si.current), _(us, c), fs === null && (fs = c));
          }
          function Ce(c) {
            c.tag === 22
              ? (_(Si, Si.current), _(us, c), fs === null && (fs = c))
              : pt();
          }
          function pt() {
            (_(Si, Si.current), _(us, us.current));
          }
          function bt(c) {
            (b(us), fs === c && (fs = null), b(Si));
          }
          function _t(c) {
            for (var f = c; f !== null; ) {
              if (f.tag === 13) {
                var x = f.memoizedState;
                if (
                  x !== null &&
                  ((x = x.dehydrated), x === null || _l(x) || md(x))
                )
                  return f;
              } else if (
                f.tag === 19 &&
                (f.memoizedProps.revealOrder === "forwards" ||
                  f.memoizedProps.revealOrder === "backwards" ||
                  f.memoizedProps.revealOrder === "unstable_legacy-backwards" ||
                  f.memoizedProps.revealOrder === "together")
              ) {
                if ((f.flags & 128) !== 0) return f;
              } else if (f.child !== null) {
                ((f.child.return = f), (f = f.child));
                continue;
              }
              if (f === c) break;
              for (; f.sibling === null; ) {
                if (f.return === null || f.return === c) return null;
                f = f.return;
              }
              ((f.sibling.return = f.return), (f = f.sibling));
            }
            return null;
          }
          function gt() {
            throw Error(r(321));
          }
          function Lt(c, f) {
            if (f === null) return !1;
            for (var x = 0; x < f.length && x < c.length; x++)
              if (!Di(c[x], f[x])) return !1;
            return !0;
          }
          function zt(c, f, x, S, D, U) {
            return (
              (Oo = U),
              ($t = f),
              (f.memoizedState = null),
              (f.updateQueue = null),
              (f.lanes = 0),
              (Bt.H = c === null || c.memoizedState === null ? pi : uo),
              (Mn = !1),
              (U = x(S, D)),
              (Mn = !1),
              sn && (U = At(f, x, S, D)),
              Wt(c),
              U
            );
          }
          function Wt(c) {
            Bt.H = Ps;
            var f = Ot !== null && Ot.next !== null;
            if (
              ((Oo = 0),
              (Zt = Ot = $t = null),
              (on = !1),
              (ha = 0),
              (Ca = null),
              f)
            )
              throw Error(r(300));
            c === null ||
              ti ||
              ((c = c.dependencies), c !== null && Te(c) && (ti = !0));
          }
          function At(c, f, x, S) {
            $t = c;
            var D = 0;
            do {
              if ((sn && (Ca = null), (ha = 0), (sn = !1), 25 <= D))
                throw Error(r(301));
              if (((D += 1), (Zt = Ot = null), c.updateQueue != null)) {
                var U = c.updateQueue;
                ((U.lastEffect = null),
                  (U.events = null),
                  (U.stores = null),
                  U.memoCache != null && (U.memoCache.index = 0));
              }
              ((Bt.H = Al), (U = f(x, S)));
            } while (sn);
            return U;
          }
          function Kt() {
            var c = Bt.H,
              f = c.useState()[0];
            return (
              (f = typeof f.then == "function" ? Pt(f) : f),
              (c = c.useState()[0]),
              (Ot !== null ? Ot.memoizedState : null) !== c &&
                ($t.flags |= 1024),
              f
            );
          }
          function Ln() {
            var c = Nr !== 0;
            return ((Nr = 0), c);
          }
          function On(c, f, x) {
            ((f.updateQueue = c.updateQueue),
              (f.flags &= -2053),
              (c.lanes &= ~x));
          }
          function rn(c) {
            if (on) {
              for (c = c.memoizedState; c !== null; ) {
                var f = c.queue;
                (f !== null && (f.pending = null), (c = c.next));
              }
              on = !1;
            }
            ((Oo = 0),
              (Zt = Ot = $t = null),
              (sn = !1),
              (ha = Nr = 0),
              (Ca = null));
          }
          function mn() {
            var c = {
              memoizedState: null,
              baseState: null,
              baseQueue: null,
              queue: null,
              next: null,
            };
            return (
              Zt === null ? ($t.memoizedState = Zt = c) : (Zt = Zt.next = c),
              Zt
            );
          }
          function vt() {
            if (Ot === null) {
              var c = $t.alternate;
              c = c !== null ? c.memoizedState : null;
            } else c = Ot.next;
            var f = Zt === null ? $t.memoizedState : Zt.next;
            if (f !== null) ((Zt = f), (Ot = c));
            else {
              if (c === null)
                throw $t.alternate === null ? Error(r(467)) : Error(r(310));
              ((Ot = c),
                (c = {
                  memoizedState: Ot.memoizedState,
                  baseState: Ot.baseState,
                  baseQueue: Ot.baseQueue,
                  queue: Ot.queue,
                  next: null,
                }),
                Zt === null ? ($t.memoizedState = Zt = c) : (Zt = Zt.next = c));
            }
            return Zt;
          }
          function bi() {
            return {
              lastEffect: null,
              events: null,
              stores: null,
              memoCache: null,
            };
          }
          function Pt(c) {
            var f = ha;
            return (
              (ha += 1),
              Ca === null && (Ca = []),
              (c = Mt(Ca, c, f)),
              (f = $t),
              (Zt === null ? f.memoizedState : Zt.next) === null &&
                ((f = f.alternate),
                (Bt.H = f === null || f.memoizedState === null ? pi : uo)),
              c
            );
          }
          function Bi(c) {
            if (c !== null && typeof c == "object") {
              if (typeof c.then == "function") return Pt(c);
              if (c.$$typeof === ia) return H(c);
            }
            throw Error(r(438, String(c)));
          }
          function ki(c) {
            var f = null,
              x = $t.updateQueue;
            if ((x !== null && (f = x.memoCache), f == null)) {
              var S = $t.alternate;
              S !== null &&
                ((S = S.updateQueue),
                S !== null &&
                  ((S = S.memoCache),
                  S != null &&
                    (f = {
                      data: S.data.map(function (D) {
                        return D.slice();
                      }),
                      index: 0,
                    })));
            }
            if (
              (f == null && (f = { data: [], index: 0 }),
              x === null && ((x = bi()), ($t.updateQueue = x)),
              (x.memoCache = f),
              (x = f.data[f.index]),
              x === void 0)
            )
              for (x = f.data[f.index] = Array(c), S = 0; S < c; S++) x[S] = mm;
            return (f.index++, x);
          }
          function ei(c, f) {
            return typeof f == "function" ? f(c) : f;
          }
          function Ki(c) {
            var f = vt();
            return gn(f, Ot, c);
          }
          function gn(c, f, x) {
            var S = c.queue;
            if (S === null) throw Error(r(311));
            S.lastRenderedReducer = x;
            var D = c.baseQueue,
              U = S.pending;
            if (U !== null) {
              if (D !== null) {
                var Y = D.next;
                ((D.next = U.next), (U.next = Y));
              }
              ((f.baseQueue = D = U), (S.pending = null));
            }
            if (((U = c.baseState), D === null)) c.memoizedState = U;
            else {
              f = D.next;
              var me = (Y = null),
                We = null,
                ot = f,
                xt = !1;
              do {
                var ut = ot.lane & -536870913;
                if (ut !== ot.lane ? (xn & ut) === ut : (Oo & ut) === ut) {
                  var Ct = ot.revertLane;
                  if (Ct === 0)
                    (We !== null &&
                      (We = We.next =
                        {
                          lane: 0,
                          revertLane: 0,
                          gesture: null,
                          action: ot.action,
                          hasEagerState: ot.hasEagerState,
                          eagerState: ot.eagerState,
                          next: null,
                        }),
                      ut === Io && (xt = !0));
                  else if ((Oo & Ct) === Ct) {
                    ((ot = ot.next), Ct === Io && (xt = !0));
                    continue;
                  } else
                    ((ut = {
                      lane: 0,
                      revertLane: ot.revertLane,
                      gesture: null,
                      action: ot.action,
                      hasEagerState: ot.hasEagerState,
                      eagerState: ot.eagerState,
                      next: null,
                    }),
                      We === null
                        ? ((me = We = ut), (Y = U))
                        : (We = We.next = ut),
                      ($t.lanes |= Ct),
                      (Fo |= Ct));
                  ((ut = ot.action),
                    Mn && x(U, ut),
                    (U = ot.hasEagerState ? ot.eagerState : x(U, ut)));
                } else
                  ((Ct = {
                    lane: ut,
                    revertLane: ot.revertLane,
                    gesture: ot.gesture,
                    action: ot.action,
                    hasEagerState: ot.hasEagerState,
                    eagerState: ot.eagerState,
                    next: null,
                  }),
                    We === null
                      ? ((me = We = Ct), (Y = U))
                      : (We = We.next = Ct),
                    ($t.lanes |= ut),
                    (Fo |= ut));
                ot = ot.next;
              } while (ot !== null && ot !== f);
              if (
                (We === null ? (Y = U) : (We.next = me),
                !Di(U, c.memoizedState) &&
                  ((ti = !0), xt && ((x = er), x !== null)))
              )
                throw x;
              ((c.memoizedState = U),
                (c.baseState = Y),
                (c.baseQueue = We),
                (S.lastRenderedState = U));
            }
            return (D === null && (S.lanes = 0), [c.memoizedState, S.dispatch]);
          }
          function qn(c) {
            var f = vt(),
              x = f.queue;
            if (x === null) throw Error(r(311));
            x.lastRenderedReducer = c;
            var S = x.dispatch,
              D = x.pending,
              U = f.memoizedState;
            if (D !== null) {
              x.pending = null;
              var Y = (D = D.next);
              do ((U = c(U, Y.action)), (Y = Y.next));
              while (Y !== D);
              (Di(U, f.memoizedState) || (ti = !0),
                (f.memoizedState = U),
                f.baseQueue === null && (f.baseState = U),
                (x.lastRenderedState = U));
            }
            return [U, S];
          }
          function Vi(c, f, x) {
            var S = $t,
              D = vt(),
              U = yn;
            if (U) {
              if (x === void 0) throw Error(r(407));
              x = x();
            } else x = f();
            var Y = !Di((Ot || D).memoizedState, x);
            if (
              (Y && ((D.memoizedState = x), (ti = !0)),
              (D = D.queue),
              Ks(ns.bind(null, S, D, c), [c]),
              D.getSnapshot !== f ||
                Y ||
                (Zt !== null && Zt.memoizedState.tag & 1))
            ) {
              if (
                ((S.flags |= 2048),
                Ar(9, { destroy: void 0 }, Or.bind(null, S, D, x, f), null),
                ln === null)
              )
                throw Error(r(349));
              U || (Oo & 127) !== 0 || ri(S, f, x);
            }
            return x;
          }
          function ri(c, f, x) {
            ((c.flags |= 16384),
              (c = { getSnapshot: f, value: x }),
              (f = $t.updateQueue),
              f === null
                ? ((f = bi()), ($t.updateQueue = f), (f.stores = [c]))
                : ((x = f.stores), x === null ? (f.stores = [c]) : x.push(c)));
          }
          function Or(c, f, x, S) {
            ((f.value = x), (f.getSnapshot = S), Ts(f) && gf(c));
          }
          function ns(c, f, x) {
            return x(function () {
              Ts(f) && gf(c);
            });
          }
          function Ts(c) {
            var f = c.getSnapshot;
            c = c.value;
            try {
              var x = f();
              return !Di(c, x);
            } catch {
              return !0;
            }
          }
          function gf(c) {
            var f = xi(c, 2);
            f !== null && hi(f, c, 2);
          }
          function el(c) {
            var f = mn();
            if (typeof c == "function") {
              var x = c;
              if (((c = x()), Mn)) {
                J(!0);
                try {
                  x();
                } finally {
                  J(!1);
                }
              }
            }
            return (
              (f.memoizedState = f.baseState = c),
              (f.queue = {
                pending: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: ei,
                lastRenderedState: c,
              }),
              f
            );
          }
          function Ys(c, f, x, S) {
            return (
              (c.baseState = x),
              gn(c, Ot, typeof S == "function" ? S : ei)
            );
          }
          function wr(c, f, x, S, D) {
            if (Vh(c)) throw Error(r(485));
            if (((c = f.action), c !== null)) {
              var U = {
                payload: D,
                action: c,
                next: null,
                isTransition: !0,
                status: "pending",
                value: null,
                reason: null,
                listeners: [],
                then: function (Y) {
                  U.listeners.push(Y);
                },
              };
              (Bt.T !== null ? x(!0) : (U.isTransition = !1),
                S(U),
                (x = f.pending),
                x === null
                  ? ((U.next = f.pending = U), ka(f, U))
                  : ((U.next = x.next), (f.pending = x.next = U)));
            }
          }
          function ka(c, f) {
            var x = f.action,
              S = f.payload,
              D = c.state;
            if (f.isTransition) {
              var U = Bt.T,
                Y = {};
              Bt.T = Y;
              try {
                var me = x(D, S),
                  We = Bt.S;
                (We !== null && We(Y, me), nc(c, f, me));
              } catch (ot) {
                Zs(c, f, ot);
              } finally {
                (U !== null && Y.types !== null && (U.types = Y.types),
                  (Bt.T = U));
              }
            } else
              try {
                ((U = x(D, S)), nc(c, f, U));
              } catch (ot) {
                Zs(c, f, ot);
              }
          }
          function nc(c, f, x) {
            x !== null && typeof x == "object" && typeof x.then == "function"
              ? x.then(
                  function (S) {
                    Es(c, f, S);
                  },
                  function (S) {
                    return Zs(c, f, S);
                  },
                )
              : Es(c, f, x);
          }
          function Es(c, f, x) {
            ((f.status = "fulfilled"),
              (f.value = x),
              ic(f),
              (c.state = x),
              (f = c.pending),
              f !== null &&
                ((x = f.next),
                x === f
                  ? (c.pending = null)
                  : ((x = x.next), (f.next = x), ka(c, x))));
          }
          function Zs(c, f, x) {
            var S = c.pending;
            if (((c.pending = null), S !== null)) {
              S = S.next;
              do ((f.status = "rejected"), (f.reason = x), ic(f), (f = f.next));
              while (f !== S);
            }
            c.action = null;
          }
          function ic(c) {
            c = c.listeners;
            for (var f = 0; f < c.length; f++) (0, c[f])();
          }
          function rc(c, f) {
            return f;
          }
          function tl(c, f) {
            if (yn) {
              var x = ln.formState;
              if (x !== null) {
                e: {
                  var S = $t;
                  if (yn) {
                    if (li) {
                      var D = wv(li, Gr);
                      if (D) {
                        ((li = Av(D)), (S = Pm(D)));
                        break e;
                      }
                    }
                    ze(S);
                  }
                  S = !1;
                }
                S && (f = x[0]);
              }
            }
            ((x = mn()),
              (x.memoizedState = x.baseState = f),
              (S = {
                pending: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: rc,
                lastRenderedState: f,
              }),
              (x.queue = S),
              (x = Ta.bind(null, $t, S)),
              (S.dispatch = x),
              (S = el(!1)));
            var U = kh.bind(null, $t, !1, S.queue);
            return (
              (S = mn()),
              (D = { state: f, dispatch: null, action: c, pending: null }),
              (S.queue = D),
              (x = wr.bind(null, $t, D, U, x)),
              (D.dispatch = x),
              (S.memoizedState = c),
              [f, x, !1]
            );
          }
          function Va(c) {
            var f = vt();
            return ws(f, Ot, c);
          }
          function ws(c, f, x) {
            if (
              ((f = gn(c, f, rc)[0]),
              (c = Ki(ei)[0]),
              typeof f == "object" && f !== null && typeof f.then == "function")
            )
              try {
                var S = Pt(f);
              } catch (Y) {
                throw Y === tr ? fa : Y;
              }
            else S = f;
            f = vt();
            var D = f.queue,
              U = D.dispatch;
            return (
              x !== f.memoizedState &&
                (($t.flags |= 2048),
                Ar(9, { destroy: void 0 }, Fr.bind(null, D, x), null)),
              [S, U, c]
            );
          }
          function Fr(c, f) {
            c.action = f;
          }
          function Ga(c) {
            var f = vt(),
              x = Ot;
            if (x !== null) return ws(f, x, c);
            (vt(), (f = f.memoizedState), (x = vt()));
            var S = x.queue.dispatch;
            return ((x.memoizedState = c), [f, S, !1]);
          }
          function Ar(c, f, x, S) {
            return (
              (c = { tag: c, create: x, deps: S, inst: f, next: null }),
              (f = $t.updateQueue),
              f === null && ((f = bi()), ($t.updateQueue = f)),
              (x = f.lastEffect),
              x === null
                ? (f.lastEffect = c.next = c)
                : ((S = x.next),
                  (x.next = c),
                  (c.next = S),
                  (f.lastEffect = c)),
              c
            );
          }
          function sc() {
            return vt().memoizedState;
          }
          function Sa(c, f, x, S) {
            var D = mn();
            (($t.flags |= c),
              (D.memoizedState = Ar(
                1 | f,
                { destroy: void 0 },
                x,
                S === void 0 ? null : S,
              )));
          }
          function nl(c, f, x, S) {
            var D = vt();
            S = S === void 0 ? null : S;
            var U = D.memoizedState.inst;
            Ot !== null && S !== null && Lt(S, Ot.memoizedState.deps)
              ? (D.memoizedState = Ar(f, U, x, S))
              : (($t.flags |= c), (D.memoizedState = Ar(1 | f, U, x, S)));
          }
          function il(c, f) {
            Sa(8390656, 8, c, f);
          }
          function Ks(c, f) {
            nl(2048, 8, c, f);
          }
          function rl(c) {
            $t.flags |= 4;
            var f = $t.updateQueue;
            if (f === null)
              ((f = bi()), ($t.updateQueue = f), (f.events = [c]));
            else {
              var x = f.events;
              x === null ? (f.events = [c]) : x.push(c);
            }
          }
          function si(c) {
            var f = vt().memoizedState;
            return (
              rl({ ref: f, nextImpl: c }),
              function () {
                if ((dn & 2) !== 0) throw Error(r(440));
                return f.impl.apply(void 0, arguments);
              }
            );
          }
          function Ma(c, f) {
            return nl(4, 2, c, f);
          }
          function So(c, f) {
            return nl(4, 4, c, f);
          }
          function Ha(c, f) {
            if (typeof f == "function") {
              c = c();
              var x = f(c);
              return function () {
                typeof x == "function" ? x() : f(null);
              };
            }
            if (f != null)
              return (
                (c = c()),
                (f.current = c),
                function () {
                  f.current = null;
                }
              );
          }
          function sl(c, f, x) {
            ((x = x != null ? x.concat([c]) : null),
              nl(4, 4, Ha.bind(null, f, c), x));
          }
          function al() {}
          function ja(c, f) {
            var x = vt();
            f = f === void 0 ? null : f;
            var S = x.memoizedState;
            return f !== null && Lt(f, S[1])
              ? S[0]
              : ((x.memoizedState = [c, f]), c);
          }
          function Wa(c, f) {
            var x = vt();
            f = f === void 0 ? null : f;
            var S = x.memoizedState;
            if (f !== null && Lt(f, S[1])) return S[0];
            if (((S = c()), Mn)) {
              J(!0);
              try {
                c();
              } finally {
                J(!1);
              }
            }
            return ((x.memoizedState = [S, f]), S);
          }
          function Gi(c, f, x) {
            return x === void 0 ||
              ((Oo & 1073741824) !== 0 && (xn & 261930) === 0)
              ? (c.memoizedState = f)
              : ((c.memoizedState = x),
                (c = Eo()),
                ($t.lanes |= c),
                (Fo |= c),
                x);
          }
          function vf(c, f, x, S) {
            return Di(x, f)
              ? x
              : Rc.current !== null
                ? ((c = Gi(c, x, S)), Di(c, f) || (ti = !0), c)
                : (Oo & 42) === 0 ||
                    ((Oo & 1073741824) !== 0 && (xn & 261930) === 0)
                  ? ((ti = !0), (c.memoizedState = x))
                  : ((c = Eo()), ($t.lanes |= c), (Fo |= c), f);
          }
          function ac(c, f, x, S, D) {
            var U = ra();
            vn(U !== 0 && 8 > U ? U : 8);
            var Y = Bt.T,
              me = {};
            ((Bt.T = me), kh(c, !1, f, x));
            try {
              var We = D(),
                ot = Bt.S;
              if (
                (ot !== null && ot(me, We),
                We !== null &&
                  typeof We == "object" &&
                  typeof We.then == "function")
              ) {
                var xt = Oe(We, S);
                ol(c, f, xt, ai(c));
              } else ol(c, f, S, ai(c));
            } catch (ut) {
              ol(
                c,
                f,
                { then: function () {}, status: "rejected", reason: ut },
                ai(),
              );
            } finally {
              (vn(U),
                Y !== null && me.types !== null && (Y.types = me.types),
                (Bt.T = Y));
            }
          }
          function oc(c) {
            var f = c.memoizedState;
            if (f !== null) return f;
            f = {
              memoizedState: _c,
              baseState: _c,
              baseQueue: null,
              queue: {
                pending: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: ei,
                lastRenderedState: _c,
              },
              next: null,
            };
            var x = {};
            return (
              (f.next = {
                memoizedState: x,
                baseState: x,
                baseQueue: null,
                queue: {
                  pending: null,
                  lanes: 0,
                  dispatch: null,
                  lastRenderedReducer: ei,
                  lastRenderedState: x,
                },
                next: null,
              }),
              (c.memoizedState = f),
              (c = c.alternate),
              c !== null && (c.memoizedState = f),
              f
            );
          }
          function nu() {
            return H(Sc);
          }
          function iu() {
            return vt().memoizedState;
          }
          function vr() {
            return vt().memoizedState;
          }
          function As(c) {
            for (var f = c.return; f !== null; ) {
              switch (f.tag) {
                case 24:
                case 3:
                  var x = ai();
                  c = gr(x);
                  var S = es(f, c, x);
                  (S !== null && (hi(S, f, x), _s(S, f, x)),
                    (f = { cache: Ae() }),
                    (c.payload = f));
                  return;
              }
              f = f.return;
            }
          }
          function Cr(c, f, x) {
            var S = ai();
            ((x = {
              lane: S,
              revertLane: 0,
              gesture: null,
              action: x,
              hasEagerState: !1,
              eagerState: null,
              next: null,
            }),
              Vh(c)
                ? B0(f, x)
                : ((x = zi(c, f, x, S)),
                  x !== null && (hi(x, c, S), k0(x, f, S))));
          }
          function Ta(c, f, x) {
            var S = ai();
            ol(c, f, x, S);
          }
          function ol(c, f, x, S) {
            var D = {
              lane: S,
              revertLane: 0,
              gesture: null,
              action: x,
              hasEagerState: !1,
              eagerState: null,
              next: null,
            };
            if (Vh(c)) B0(f, D);
            else {
              var U = c.alternate;
              if (
                c.lanes === 0 &&
                (U === null || U.lanes === 0) &&
                ((U = f.lastRenderedReducer), U !== null)
              )
                try {
                  var Y = f.lastRenderedState,
                    me = U(Y, x);
                  if (((D.hasEagerState = !0), (D.eagerState = me), Di(me, Y)))
                    return (ar(c, f, D, 0), ln === null && Zi(), !1);
                } catch {
                } finally {
                }
              if (((x = zi(c, f, D, S)), x !== null))
                return (hi(x, c, S), k0(x, f, S), !0);
            }
            return !1;
          }
          function kh(c, f, x, S) {
            if (
              ((S = {
                lane: 2,
                revertLane: Se(),
                gesture: null,
                action: S,
                hasEagerState: !1,
                eagerState: null,
                next: null,
              }),
              Vh(c))
            ) {
              if (f) throw Error(r(479));
            } else ((f = zi(c, x, S, 2)), f !== null && hi(f, c, 2));
          }
          function Vh(c) {
            var f = c.alternate;
            return c === $t || (f !== null && f === $t);
          }
          function B0(c, f) {
            sn = on = !0;
            var x = c.pending;
            (x === null ? (f.next = f) : ((f.next = x.next), (x.next = f)),
              (c.pending = f));
          }
          function k0(c, f, x) {
            if ((x & 4194048) !== 0) {
              var S = f.lanes;
              ((S &= c.pendingLanes), (x |= S), (f.lanes = x), F(c, x));
            }
          }
          function Xp(c, f, x, S) {
            ((f = c.memoizedState),
              (x = x(S, f)),
              (x = x == null ? f : od({}, f, x)),
              (c.memoizedState = x),
              c.lanes === 0 && (c.updateQueue.baseState = x));
          }
          function Gh(c, f, x, S, D, U, Y) {
            return (
              (c = c.stateNode),
              typeof c.shouldComponentUpdate == "function"
                ? c.shouldComponentUpdate(S, U, Y)
                : f.prototype && f.prototype.isPureReactComponent
                  ? !Ee(x, S) || !Ee(D, U)
                  : !0
            );
          }
          function V0(c, f, x, S) {
            ((c = f.state),
              typeof f.componentWillReceiveProps == "function" &&
                f.componentWillReceiveProps(x, S),
              typeof f.UNSAFE_componentWillReceiveProps == "function" &&
                f.UNSAFE_componentWillReceiveProps(x, S),
              f.state !== c && Wf.enqueueReplaceState(f, f.state, null));
          }
          function lc(c, f) {
            var x = f;
            if ("ref" in f) {
              x = {};
              for (var S in f) S !== "ref" && (x[S] = f[S]);
            }
            if ((c = c.defaultProps)) {
              x === f && (x = od({}, x));
              for (var D in c) x[D] === void 0 && (x[D] = c[D]);
            }
            return x;
          }
          function Hh(c, f) {
            try {
              var x = c.onUncaughtError;
              x(f.value, { componentStack: f.stack });
            } catch (S) {
              setTimeout(function () {
                throw S;
              });
            }
          }
          function qp(c, f, x) {
            try {
              var S = c.onCaughtError;
              S(x.value, {
                componentStack: x.stack,
                errorBoundary: f.tag === 1 ? f.stateNode : null,
              });
            } catch (D) {
              setTimeout(function () {
                throw D;
              });
            }
          }
          function Yp(c, f, x) {
            return (
              (x = gr(x)),
              (x.tag = 3),
              (x.payload = { element: null }),
              (x.callback = function () {
                Hh(c, f);
              }),
              x
            );
          }
          function G0(c) {
            return ((c = gr(c)), (c.tag = 3), c);
          }
          function H0(c, f, x, S) {
            var D = x.type.getDerivedStateFromError;
            if (typeof D == "function") {
              var U = S.value;
              ((c.payload = function () {
                return D(U);
              }),
                (c.callback = function () {
                  qp(f, x, S);
                }));
            }
            var Y = x.stateNode;
            Y !== null &&
              typeof Y.componentDidCatch == "function" &&
              (c.callback = function () {
                (qp(f, x, S),
                  typeof D != "function" &&
                    (zo === null ? (zo = new Set([this])) : zo.add(this)));
                var me = S.stack;
                this.componentDidCatch(S.value, {
                  componentStack: me !== null ? me : "",
                });
              });
          }
          function Ob(c, f, x, S, D) {
            if (
              ((x.flags |= 32768),
              S !== null && typeof S == "object" && typeof S.then == "function")
            ) {
              if (
                ((f = x.alternate),
                f !== null && je(f, x, D, !0),
                (x = us.current),
                x !== null)
              ) {
                switch (x.tag) {
                  case 31:
                  case 13:
                    return (
                      fs === null
                        ? pu()
                        : x.alternate === null && gi === 0 && (gi = 3),
                      (x.flags &= -257),
                      (x.flags |= 65536),
                      (x.lanes = D),
                      S === lo
                        ? (x.flags |= 16384)
                        : ((f = x.updateQueue),
                          f === null
                            ? (x.updateQueue = new Set([S]))
                            : f.add(S),
                          vu(c, S, D)),
                      !1
                    );
                  case 22:
                    return (
                      (x.flags |= 65536),
                      S === lo
                        ? (x.flags |= 16384)
                        : ((f = x.updateQueue),
                          f === null
                            ? ((f = {
                                transitions: null,
                                markerInstances: null,
                                retryQueue: new Set([S]),
                              }),
                              (x.updateQueue = f))
                            : ((x = f.retryQueue),
                              x === null
                                ? (f.retryQueue = new Set([S]))
                                : x.add(S)),
                          vu(c, S, D)),
                      !1
                    );
                }
                throw Error(r(435, x.tag));
              }
              return (vu(c, S, D), pu(), !1);
            }
            if (yn)
              return (
                (f = us.current),
                f !== null
                  ? ((f.flags & 65536) === 0 && (f.flags |= 256),
                    (f.flags |= 65536),
                    (f.lanes = D),
                    S !== Dd &&
                      ((c = Error(r(422), { cause: S })), Ie(le(c, x))))
                  : (S !== Dd &&
                      ((f = Error(r(423), { cause: S })), Ie(le(f, x))),
                    (c = c.current.alternate),
                    (c.flags |= 65536),
                    (D &= -D),
                    (c.lanes |= D),
                    (S = le(S, x)),
                    (D = Yp(c.stateNode, S, D)),
                    Ba(c, D),
                    gi !== 4 && (gi = 2)),
                !1
              );
            var U = Error(r(520), { cause: S });
            if (
              ((U = le(U, x)),
              qf === null ? (qf = [U]) : qf.push(U),
              gi !== 4 && (gi = 2),
              f === null)
            )
              return !0;
            ((S = le(S, x)), (x = f));
            do {
              switch (x.tag) {
                case 3:
                  return (
                    (x.flags |= 65536),
                    (c = D & -D),
                    (x.lanes |= c),
                    (c = Yp(x.stateNode, S, c)),
                    Ba(x, c),
                    !1
                  );
                case 1:
                  if (
                    ((f = x.type),
                    (U = x.stateNode),
                    (x.flags & 128) === 0 &&
                      (typeof f.getDerivedStateFromError == "function" ||
                        (U !== null &&
                          typeof U.componentDidCatch == "function" &&
                          (zo === null || !zo.has(U)))))
                  )
                    return (
                      (x.flags |= 65536),
                      (D &= -D),
                      (x.lanes |= D),
                      (D = G0(D)),
                      H0(D, c, x, S),
                      Ba(x, D),
                      !1
                    );
              }
              x = x.return;
            } while (x !== null);
            return !1;
          }
          function yr(c, f, x, S) {
            f.child = c === null ? Jm(f, null, x, S) : _r(f, c.child, x, S);
          }
          function j0(c, f, x, S, D) {
            x = x.render;
            var U = f.ref;
            if ("ref" in S) {
              var Y = {};
              for (var me in S) me !== "ref" && (Y[me] = S[me]);
            } else Y = S;
            return (
              ke(f),
              (S = zt(c, f, x, Y, U, D)),
              (me = Ln()),
              c !== null && !ti
                ? (On(c, f, D), Xa(c, f, D))
                : (yn && me && Z(f), (f.flags |= 1), yr(c, f, S, D), f.child)
            );
          }
          function W0(c, f, x, S, D) {
            if (c === null) {
              var U = x.type;
              return typeof U == "function" &&
                !dc(U) &&
                U.defaultProps === void 0 &&
                x.compare === null
                ? ((f.tag = 15), (f.type = U), X0(c, f, U, S, D))
                : ((c = Co(x.type, null, S, f, f.mode, D)),
                  (c.ref = f.ref),
                  (c.return = f),
                  (f.child = c));
            }
            if (((U = c.child), !xf(c, D))) {
              var Y = U.memoizedProps;
              if (
                ((x = x.compare),
                (x = x !== null ? x : Ee),
                x(Y, S) && c.ref === f.ref)
              )
                return Xa(c, f, D);
            }
            return (
              (f.flags |= 1),
              (c = Ds(U, S)),
              (c.ref = f.ref),
              (c.return = f),
              (f.child = c)
            );
          }
          function X0(c, f, x, S, D) {
            if (c !== null) {
              var U = c.memoizedProps;
              if (Ee(U, S) && c.ref === f.ref)
                if (((ti = !1), (f.pendingProps = S = U), xf(c, D)))
                  (c.flags & 131072) !== 0 && (ti = !0);
                else return ((f.lanes = c.lanes), Xa(c, f, D));
            }
            return Wh(c, f, x, S, D);
          }
          function q0(c, f, x, S) {
            var D = S.children,
              U = c !== null ? c.memoizedState : null;
            if (
              (c === null &&
                f.stateNode === null &&
                (f.stateNode = {
                  _visibility: 1,
                  _pendingMarkers: null,
                  _retryCache: null,
                  _transitions: null,
                }),
              S.mode === "hidden")
            ) {
              if ((f.flags & 128) !== 0) {
                if (((U = U !== null ? U.baseLanes | x : x), c !== null)) {
                  for (S = f.child = c.child, D = 0; S !== null; )
                    ((D = D | S.lanes | S.childLanes), (S = S.sibling));
                  S = D & ~U;
                } else ((S = 0), (f.child = null));
                return ru(c, f, U, x, S);
              }
              if ((x & 536870912) !== 0)
                ((f.memoizedState = { baseLanes: 0, cachePool: null }),
                  c !== null && dt(f, U !== null ? U.cachePool : null),
                  U !== null ? qs(f, U) : G(),
                  Ce(f));
              else
                return (
                  (S = f.lanes = 536870912),
                  ru(c, f, U !== null ? U.baseLanes | x : x, x, S)
                );
            } else
              U !== null
                ? (dt(f, U.cachePool), qs(f, U), pt(), (f.memoizedState = null))
                : (c !== null && dt(f, null), G(), pt());
            return (yr(c, f, D, x), f.child);
          }
          function cc(c, f) {
            return (
              (c !== null && c.tag === 22) ||
                f.stateNode !== null ||
                (f.stateNode = {
                  _visibility: 1,
                  _pendingMarkers: null,
                  _retryCache: null,
                  _transitions: null,
                }),
              f.sibling
            );
          }
          function ru(c, f, x, S, D) {
            var U = Ke();
            return (
              (U =
                U === null
                  ? null
                  : {
                      parent: Ci ? ci._currentValue : ci._currentValue2,
                      pool: U,
                    }),
              (f.memoizedState = { baseLanes: x, cachePool: U }),
              c !== null && dt(f, null),
              G(),
              Ce(f),
              c !== null && je(c, f, S, !0),
              (f.childLanes = D),
              null
            );
          }
          function jh(c, f) {
            return (
              (f = ll({ mode: f.mode, children: f.children }, c.mode)),
              (f.ref = c.ref),
              (c.child = f),
              (f.return = c),
              f
            );
          }
          function Zp(c, f, x) {
            return (
              _r(f, c.child, null, x),
              (c = jh(f, f.pendingProps)),
              (c.flags |= 2),
              bt(f),
              (f.memoizedState = null),
              c
            );
          }
          function Y0(c, f, x) {
            var S = f.pendingProps,
              D = (f.flags & 128) !== 0;
            if (((f.flags &= -129), c === null)) {
              if (yn) {
                if (S.mode === "hidden")
                  return ((c = jh(f, S)), (f.lanes = 536870912), cc(null, c));
                if (
                  (Le(f),
                  (c = li)
                    ? ((c = Om(c, Gr)),
                      c !== null &&
                        ((f.memoizedState = {
                          dehydrated: c,
                          treeContext:
                            oa !== null ? { id: xr, overflow: wa } : null,
                          retryLane: 536870912,
                          hydrationErrors: null,
                        }),
                        (x = hm(c)),
                        (x.return = f),
                        (f.child = x),
                        ($i = f),
                        (li = null)))
                    : (c = null),
                  c === null)
                )
                  throw ze(f);
                return ((f.lanes = 536870912), null);
              }
              return jh(f, S);
            }
            var U = c.memoizedState;
            if (U !== null) {
              var Y = U.dehydrated;
              if ((Le(f), D))
                if (f.flags & 256) ((f.flags &= -257), (f = Zp(c, f, x)));
                else if (f.memoizedState !== null)
                  ((f.child = c.child), (f.flags |= 128), (f = null));
                else throw Error(r(558));
              else if (
                (ti || je(c, f, x, !1), (D = (x & c.childLanes) !== 0), ti || D)
              ) {
                if (
                  ((S = ln),
                  S !== null && ((Y = j(S, x)), Y !== 0 && Y !== U.retryLane))
                )
                  throw ((U.retryLane = Y), xi(c, Y), hi(S, c, Y), jr);
                (pu(), (f = Zp(c, f, x)));
              } else
                ((c = U.treeContext),
                  oi &&
                    ((li = Lv(Y)),
                    ($i = f),
                    (yn = !0),
                    (oo = null),
                    (Gr = !1),
                    c !== null && ue(f, c)),
                  (f = jh(f, S)),
                  (f.flags |= 4096));
              return f;
            }
            return (
              (c = Ds(c.child, { mode: S.mode, children: S.children })),
              (c.ref = f.ref),
              (f.child = c),
              (c.return = f),
              c
            );
          }
          function yf(c, f) {
            var x = f.ref;
            if (x === null)
              c !== null && c.ref !== null && (f.flags |= 4194816);
            else {
              if (typeof x != "function" && typeof x != "object")
                throw Error(r(284));
              (c === null || c.ref !== x) && (f.flags |= 4194816);
            }
          }
          function Wh(c, f, x, S, D) {
            return (
              ke(f),
              (x = zt(c, f, x, S, void 0, D)),
              (S = Ln()),
              c !== null && !ti
                ? (On(c, f, D), Xa(c, f, D))
                : (yn && S && Z(f), (f.flags |= 1), yr(c, f, x, D), f.child)
            );
          }
          function Kp(c, f, x, S, D, U) {
            return (
              ke(f),
              (f.updateQueue = null),
              (x = At(f, S, x, D)),
              Wt(c),
              (S = Ln()),
              c !== null && !ti
                ? (On(c, f, U), Xa(c, f, U))
                : (yn && S && Z(f), (f.flags |= 1), yr(c, f, x, U), f.child)
            );
          }
          function uc(c, f, x, S, D) {
            if ((ke(f), f.stateNode === null)) {
              var U = ro,
                Y = x.contextType;
              (typeof Y == "object" && Y !== null && (U = H(Y)),
                (U = new x(S, U)),
                (f.memoizedState =
                  U.state !== null && U.state !== void 0 ? U.state : null),
                (U.updater = Wf),
                (f.stateNode = U),
                (U._reactInternals = f),
                (U = f.stateNode),
                (U.props = S),
                (U.state = f.memoizedState),
                (U.refs = {}),
                ii(f),
                (Y = x.contextType),
                (U.context = typeof Y == "object" && Y !== null ? H(Y) : ro),
                (U.state = f.memoizedState),
                (Y = x.getDerivedStateFromProps),
                typeof Y == "function" &&
                  (Xp(f, x, Y, S), (U.state = f.memoizedState)),
                typeof x.getDerivedStateFromProps == "function" ||
                  typeof U.getSnapshotBeforeUpdate == "function" ||
                  (typeof U.UNSAFE_componentWillMount != "function" &&
                    typeof U.componentWillMount != "function") ||
                  ((Y = U.state),
                  typeof U.componentWillMount == "function" &&
                    U.componentWillMount(),
                  typeof U.UNSAFE_componentWillMount == "function" &&
                    U.UNSAFE_componentWillMount(),
                  Y !== U.state && Wf.enqueueReplaceState(U, U.state, null),
                  Xs(f, S, U, D),
                  Ss(),
                  (U.state = f.memoizedState)),
                typeof U.componentDidMount == "function" &&
                  (f.flags |= 4194308),
                (S = !0));
            } else if (c === null) {
              U = f.stateNode;
              var me = f.memoizedProps,
                We = lc(x, me);
              U.props = We;
              var ot = U.context,
                xt = x.contextType;
              ((Y = ro), typeof xt == "object" && xt !== null && (Y = H(xt)));
              var ut = x.getDerivedStateFromProps;
              ((xt =
                typeof ut == "function" ||
                typeof U.getSnapshotBeforeUpdate == "function"),
                (me = f.pendingProps !== me),
                xt ||
                  (typeof U.UNSAFE_componentWillReceiveProps != "function" &&
                    typeof U.componentWillReceiveProps != "function") ||
                  ((me || ot !== Y) && V0(f, U, S, Y)),
                (Us = !1));
              var Ct = f.memoizedState;
              ((U.state = Ct),
                Xs(f, S, U, D),
                Ss(),
                (ot = f.memoizedState),
                me || Ct !== ot || Us
                  ? (typeof ut == "function" &&
                      (Xp(f, x, ut, S), (ot = f.memoizedState)),
                    (We = Us || Gh(f, x, We, S, Ct, ot, Y))
                      ? (xt ||
                          (typeof U.UNSAFE_componentWillMount != "function" &&
                            typeof U.componentWillMount != "function") ||
                          (typeof U.componentWillMount == "function" &&
                            U.componentWillMount(),
                          typeof U.UNSAFE_componentWillMount == "function" &&
                            U.UNSAFE_componentWillMount()),
                        typeof U.componentDidMount == "function" &&
                          (f.flags |= 4194308))
                      : (typeof U.componentDidMount == "function" &&
                          (f.flags |= 4194308),
                        (f.memoizedProps = S),
                        (f.memoizedState = ot)),
                    (U.props = S),
                    (U.state = ot),
                    (U.context = Y),
                    (S = We))
                  : (typeof U.componentDidMount == "function" &&
                      (f.flags |= 4194308),
                    (S = !1)));
            } else {
              ((U = f.stateNode),
                Ir(c, f),
                (Y = f.memoizedProps),
                (xt = lc(x, Y)),
                (U.props = xt),
                (ut = f.pendingProps),
                (Ct = U.context),
                (ot = x.contextType),
                (We = ro),
                typeof ot == "object" && ot !== null && (We = H(ot)),
                (me = x.getDerivedStateFromProps),
                (ot =
                  typeof me == "function" ||
                  typeof U.getSnapshotBeforeUpdate == "function") ||
                  (typeof U.UNSAFE_componentWillReceiveProps != "function" &&
                    typeof U.componentWillReceiveProps != "function") ||
                  ((Y !== ut || Ct !== We) && V0(f, U, S, We)),
                (Us = !1),
                (Ct = f.memoizedState),
                (U.state = Ct),
                Xs(f, S, U, D),
                Ss());
              var Qt = f.memoizedState;
              Y !== ut ||
              Ct !== Qt ||
              Us ||
              (c !== null && c.dependencies !== null && Te(c.dependencies))
                ? (typeof me == "function" &&
                    (Xp(f, x, me, S), (Qt = f.memoizedState)),
                  (xt =
                    Us ||
                    Gh(f, x, xt, S, Ct, Qt, We) ||
                    (c !== null &&
                      c.dependencies !== null &&
                      Te(c.dependencies)))
                    ? (ot ||
                        (typeof U.UNSAFE_componentWillUpdate != "function" &&
                          typeof U.componentWillUpdate != "function") ||
                        (typeof U.componentWillUpdate == "function" &&
                          U.componentWillUpdate(S, Qt, We),
                        typeof U.UNSAFE_componentWillUpdate == "function" &&
                          U.UNSAFE_componentWillUpdate(S, Qt, We)),
                      typeof U.componentDidUpdate == "function" &&
                        (f.flags |= 4),
                      typeof U.getSnapshotBeforeUpdate == "function" &&
                        (f.flags |= 1024))
                    : (typeof U.componentDidUpdate != "function" ||
                        (Y === c.memoizedProps && Ct === c.memoizedState) ||
                        (f.flags |= 4),
                      typeof U.getSnapshotBeforeUpdate != "function" ||
                        (Y === c.memoizedProps && Ct === c.memoizedState) ||
                        (f.flags |= 1024),
                      (f.memoizedProps = S),
                      (f.memoizedState = Qt)),
                  (U.props = S),
                  (U.state = Qt),
                  (U.context = We),
                  (S = xt))
                : (typeof U.componentDidUpdate != "function" ||
                    (Y === c.memoizedProps && Ct === c.memoizedState) ||
                    (f.flags |= 4),
                  typeof U.getSnapshotBeforeUpdate != "function" ||
                    (Y === c.memoizedProps && Ct === c.memoizedState) ||
                    (f.flags |= 1024),
                  (S = !1));
            }
            return (
              (U = S),
              yf(c, f),
              (S = (f.flags & 128) !== 0),
              U || S
                ? ((U = f.stateNode),
                  (x =
                    S && typeof x.getDerivedStateFromError != "function"
                      ? null
                      : U.render()),
                  (f.flags |= 1),
                  c !== null && S
                    ? ((f.child = _r(f, c.child, null, D)),
                      (f.child = _r(f, null, x, D)))
                    : yr(c, f, x, D),
                  (f.memoizedState = U.state),
                  (c = f.child))
                : (c = Xa(c, f, D)),
              c
            );
          }
          function Z0(c, f, x, S) {
            return (ft(), (f.flags |= 256), yr(c, f, x, S), f.child);
          }
          function Qp(c) {
            return { baseLanes: c, cachePool: Je() };
          }
          function Jp(c, f, x) {
            return (
              (c = c !== null ? c.childLanes & ~x : 0),
              f && (c |= Wr),
              c
            );
          }
          function $p(c, f, x) {
            var S = f.pendingProps,
              D = !1,
              U = (f.flags & 128) !== 0,
              Y;
            if (
              ((Y = U) ||
                (Y =
                  c !== null && c.memoizedState === null
                    ? !1
                    : (Si.current & 2) !== 0),
              Y && ((D = !0), (f.flags &= -129)),
              (Y = (f.flags & 32) !== 0),
              (f.flags &= -33),
              c === null)
            ) {
              if (yn) {
                if (
                  (D ? Fe(f) : pt(),
                  (c = li)
                    ? ((c = Iv(c, Gr)),
                      c !== null &&
                        ((f.memoizedState = {
                          dehydrated: c,
                          treeContext:
                            oa !== null ? { id: xr, overflow: wa } : null,
                          retryLane: 536870912,
                          hydrationErrors: null,
                        }),
                        (x = hm(c)),
                        (x.return = f),
                        (f.child = x),
                        ($i = f),
                        (li = null)))
                    : (c = null),
                  c === null)
                )
                  throw ze(f);
                return (md(c) ? (f.lanes = 32) : (f.lanes = 536870912), null);
              }
              var me = S.children;
              return (
                (S = S.fallback),
                D
                  ? (pt(),
                    (D = f.mode),
                    (me = ll({ mode: "hidden", children: me }, D)),
                    (S = na(S, D, x, null)),
                    (me.return = f),
                    (S.return = f),
                    (me.sibling = S),
                    (f.child = me),
                    (S = f.child),
                    (S.memoizedState = Qp(x)),
                    (S.childLanes = Jp(c, Y, x)),
                    (f.memoizedState = Dc),
                    cc(null, S))
                  : (Fe(f), Xh(f, me))
              );
            }
            var We = c.memoizedState;
            if (We !== null && ((me = We.dehydrated), me !== null)) {
              if (U)
                f.flags & 256
                  ? (Fe(f), (f.flags &= -257), (f = fc(c, f, x)))
                  : f.memoizedState !== null
                    ? (pt(), (f.child = c.child), (f.flags |= 128), (f = null))
                    : (pt(),
                      (me = S.fallback),
                      (D = f.mode),
                      (S = ll({ mode: "visible", children: S.children }, D)),
                      (me = na(me, D, x, null)),
                      (me.flags |= 2),
                      (S.return = f),
                      (me.return = f),
                      (S.sibling = me),
                      (f.child = S),
                      _r(f, c.child, null, x),
                      (S = f.child),
                      (S.memoizedState = Qp(x)),
                      (S.childLanes = Jp(c, Y, x)),
                      (f.memoizedState = Dc),
                      (f = cc(null, S)));
              else if ((Fe(f), md(me)))
                ((Y = gd(me).digest),
                  (S = Error(r(419))),
                  (S.stack = ""),
                  (S.digest = Y),
                  Ie({ value: S, source: null, stack: null }),
                  (f = fc(c, f, x)));
              else if (
                (ti || je(c, f, x, !1), (Y = (x & c.childLanes) !== 0), ti || Y)
              ) {
                if (
                  ((Y = ln),
                  Y !== null && ((S = j(Y, x)), S !== 0 && S !== We.retryLane))
                )
                  throw ((We.retryLane = S), xi(c, S), hi(Y, c, S), jr);
                (_l(me) || pu(), (f = fc(c, f, x)));
              } else
                _l(me)
                  ? ((f.flags |= 192), (f.child = c.child), (f = null))
                  : ((c = We.treeContext),
                    oi &&
                      ((li = Nv(me)),
                      ($i = f),
                      (yn = !0),
                      (oo = null),
                      (Gr = !1),
                      c !== null && ue(f, c)),
                    (f = Xh(f, S.children)),
                    (f.flags |= 4096));
              return f;
            }
            return D
              ? (pt(),
                (me = S.fallback),
                (D = f.mode),
                (We = c.child),
                (U = We.sibling),
                (S = Ds(We, { mode: "hidden", children: S.children })),
                (S.subtreeFlags = We.subtreeFlags & 65011712),
                U !== null
                  ? (me = Ds(U, me))
                  : ((me = na(me, D, x, null)), (me.flags |= 2)),
                (me.return = f),
                (S.return = f),
                (S.sibling = me),
                (f.child = S),
                cc(null, S),
                (S = f.child),
                (me = c.child.memoizedState),
                me === null
                  ? (me = Qp(x))
                  : ((D = me.cachePool),
                    D !== null
                      ? ((We = Ci ? ci._currentValue : ci._currentValue2),
                        (D = D.parent !== We ? { parent: We, pool: We } : D))
                      : (D = Je()),
                    (me = { baseLanes: me.baseLanes | x, cachePool: D })),
                (S.memoizedState = me),
                (S.childLanes = Jp(c, Y, x)),
                (f.memoizedState = Dc),
                cc(c.child, S))
              : (Fe(f),
                (x = c.child),
                (c = x.sibling),
                (x = Ds(x, { mode: "visible", children: S.children })),
                (x.return = f),
                (x.sibling = null),
                c !== null &&
                  ((Y = f.deletions),
                  Y === null
                    ? ((f.deletions = [c]), (f.flags |= 16))
                    : Y.push(c)),
                (f.child = x),
                (f.memoizedState = null),
                x);
          }
          function Xh(c, f) {
            return (
              (f = ll({ mode: "visible", children: f }, c.mode)),
              (f.return = c),
              (c.child = f)
            );
          }
          function ll(c, f) {
            return ((c = t(22, c, null, f)), (c.lanes = 0), c);
          }
          function fc(c, f, x) {
            return (
              _r(f, c.child, null, x),
              (c = Xh(f, f.pendingProps.children)),
              (c.flags |= 2),
              (f.memoizedState = null),
              c
            );
          }
          function K0(c, f, x) {
            c.lanes |= f;
            var S = c.alternate;
            (S !== null && (S.lanes |= f), K(c.return, f, x));
          }
          function su(c, f, x, S, D, U) {
            var Y = c.memoizedState;
            Y === null
              ? (c.memoizedState = {
                  isBackwards: f,
                  rendering: null,
                  renderingStartTime: 0,
                  last: S,
                  tail: x,
                  tailMode: D,
                  treeForkCount: U,
                })
              : ((Y.isBackwards = f),
                (Y.rendering = null),
                (Y.renderingStartTime = 0),
                (Y.last = S),
                (Y.tail = x),
                (Y.tailMode = D),
                (Y.treeForkCount = U));
          }
          function em(c, f, x) {
            var S = f.pendingProps,
              D = S.revealOrder,
              U = S.tail;
            S = S.children;
            var Y = Si.current,
              me = (Y & 2) !== 0;
            if (
              (me ? ((Y = (Y & 1) | 2), (f.flags |= 128)) : (Y &= 1),
              _(Si, Y),
              yr(c, f, S, x),
              (S = yn ? Gf : 0),
              !me && c !== null && (c.flags & 128) !== 0)
            )
              e: for (c = f.child; c !== null; ) {
                if (c.tag === 13) c.memoizedState !== null && K0(c, x, f);
                else if (c.tag === 19) K0(c, x, f);
                else if (c.child !== null) {
                  ((c.child.return = c), (c = c.child));
                  continue;
                }
                if (c === f) break e;
                for (; c.sibling === null; ) {
                  if (c.return === null || c.return === f) break e;
                  c = c.return;
                }
                ((c.sibling.return = c.return), (c = c.sibling));
              }
            switch (D) {
              case "forwards":
                for (x = f.child, D = null; x !== null; )
                  ((c = x.alternate),
                    c !== null && _t(c) === null && (D = x),
                    (x = x.sibling));
                ((x = D),
                  x === null
                    ? ((D = f.child), (f.child = null))
                    : ((D = x.sibling), (x.sibling = null)),
                  su(f, !1, D, x, U, S));
                break;
              case "backwards":
              case "unstable_legacy-backwards":
                for (x = null, D = f.child, f.child = null; D !== null; ) {
                  if (((c = D.alternate), c !== null && _t(c) === null)) {
                    f.child = D;
                    break;
                  }
                  ((c = D.sibling), (D.sibling = x), (x = D), (D = c));
                }
                su(f, !0, x, null, U, S);
                break;
              case "together":
                su(f, !1, null, null, void 0, S);
                break;
              default:
                f.memoizedState = null;
            }
            return f.child;
          }
          function Xa(c, f, x) {
            if (
              (c !== null && (f.dependencies = c.dependencies),
              (Fo |= f.lanes),
              (x & f.childLanes) === 0)
            )
              if (c !== null) {
                if ((je(c, f, x, !1), (x & f.childLanes) === 0)) return null;
              } else return null;
            if (c !== null && f.child !== c.child) throw Error(r(153));
            if (f.child !== null) {
              for (
                c = f.child,
                  x = Ds(c, c.pendingProps),
                  f.child = x,
                  x.return = f;
                c.sibling !== null;
              )
                ((c = c.sibling),
                  (x = x.sibling = Ds(c, c.pendingProps)),
                  (x.return = f));
              x.sibling = null;
            }
            return f.child;
          }
          function xf(c, f) {
            return (c.lanes & f) !== 0
              ? !0
              : ((c = c.dependencies), !!(c !== null && Te(c)));
          }
          function tm(c, f, x) {
            switch (f.tag) {
              case 3:
                (ge(f, f.stateNode.containerInfo),
                  De(f, ci, c.memoizedState.cache),
                  ft());
                break;
              case 27:
              case 5:
                he(f);
                break;
              case 4:
                ge(f, f.stateNode.containerInfo);
                break;
              case 10:
                De(f, f.type, f.memoizedProps.value);
                break;
              case 31:
                if (f.memoizedState !== null)
                  return ((f.flags |= 128), Le(f), null);
                break;
              case 13:
                var S = f.memoizedState;
                if (S !== null)
                  return S.dehydrated !== null
                    ? (Fe(f), (f.flags |= 128), null)
                    : (x & f.child.childLanes) !== 0
                      ? $p(c, f, x)
                      : (Fe(f),
                        (c = Xa(c, f, x)),
                        c !== null ? c.sibling : null);
                Fe(f);
                break;
              case 19:
                var D = (c.flags & 128) !== 0;
                if (
                  ((S = (x & f.childLanes) !== 0),
                  S || (je(c, f, x, !1), (S = (x & f.childLanes) !== 0)),
                  D)
                ) {
                  if (S) return em(c, f, x);
                  f.flags |= 128;
                }
                if (
                  ((D = f.memoizedState),
                  D !== null &&
                    ((D.rendering = null),
                    (D.tail = null),
                    (D.lastEffect = null)),
                  _(Si, Si.current),
                  S)
                )
                  break;
                return null;
              case 22:
                return ((f.lanes = 0), q0(c, f, x, f.pendingProps));
              case 24:
                De(f, ci, c.memoizedState.cache);
            }
            return Xa(c, f, x);
          }
          function nm(c, f, x) {
            if (c !== null)
              if (c.memoizedProps !== f.pendingProps) ti = !0;
              else {
                if (!xf(c, x) && (f.flags & 128) === 0)
                  return ((ti = !1), tm(c, f, x));
                ti = (c.flags & 131072) !== 0;
              }
            else
              ((ti = !1), yn && (f.flags & 1048576) !== 0 && V(f, Gf, f.index));
            switch (((f.lanes = 0), f.tag)) {
              case 16:
                e: {
                  var S = f.pendingProps;
                  if (
                    ((c = St(f.elementType)),
                    (f.type = c),
                    typeof c == "function")
                  )
                    dc(c)
                      ? ((S = lc(c, S)),
                        (f.tag = 1),
                        (f = uc(null, f, c, S, x)))
                      : ((f.tag = 0), (f = Wh(null, f, c, S, x)));
                  else {
                    if (c != null) {
                      var D = c.$$typeof;
                      if (D === yu) {
                        ((f.tag = 11), (f = j0(null, f, c, S, x)));
                        break e;
                      } else if (D === cd) {
                        ((f.tag = 14), (f = W0(null, f, c, S, x)));
                        break e;
                      }
                    }
                    throw ((f = v(c) || c), Error(r(306, f, "")));
                  }
                }
                return f;
              case 0:
                return Wh(c, f, f.type, f.pendingProps, x);
              case 1:
                return (
                  (S = f.type),
                  (D = lc(S, f.pendingProps)),
                  uc(c, f, S, D, x)
                );
              case 3:
                e: {
                  if ((ge(f, f.stateNode.containerInfo), c === null))
                    throw Error(r(387));
                  var U = f.pendingProps;
                  ((D = f.memoizedState),
                    (S = D.element),
                    Ir(c, f),
                    Xs(f, U, null, x));
                  var Y = f.memoizedState;
                  if (
                    ((U = Y.cache),
                    De(f, ci, U),
                    U !== D.cache && rt(f, [ci], x, !0),
                    Ss(),
                    (U = Y.element),
                    oi && D.isDehydrated)
                  )
                    if (
                      ((D = { element: U, isDehydrated: !1, cache: Y.cache }),
                      (f.updateQueue.baseState = D),
                      (f.memoizedState = D),
                      f.flags & 256)
                    ) {
                      f = Z0(c, f, U, x);
                      break e;
                    } else if (U !== S) {
                      ((S = le(Error(r(424)), f)), Ie(S), (f = Z0(c, f, U, x)));
                      break e;
                    } else
                      for (
                        oi &&
                          ((li = Dv(f.stateNode.containerInfo)),
                          ($i = f),
                          (yn = !0),
                          (oo = null),
                          (Gr = !0)),
                          x = Jm(f, null, U, x),
                          f.child = x;
                        x;
                      )
                        ((x.flags = (x.flags & -3) | 4096), (x = x.sibling));
                  else {
                    if ((ft(), U === S)) {
                      f = Xa(c, f, x);
                      break e;
                    }
                    yr(c, f, U, x);
                  }
                  f = f.child;
                }
                return f;
              case 26:
                if (sa)
                  return (
                    yf(c, f),
                    c === null
                      ? (x = Vm(f.type, null, f.pendingProps, null))
                        ? (f.memoizedState = x)
                        : yn ||
                          (f.stateNode = bd(
                            f.type,
                            f.pendingProps,
                            br.current,
                            f,
                          ))
                      : (f.memoizedState = Vm(
                          f.type,
                          c.memoizedProps,
                          f.pendingProps,
                          c.memoizedState,
                        )),
                    null
                  );
              case 27:
                if (Ji)
                  return (
                    he(f),
                    c === null &&
                      Ji &&
                      yn &&
                      ((S = f.stateNode =
                        _d(f.type, f.pendingProps, br.current, ur.current, !1)),
                      ($i = f),
                      (Gr = !0),
                      (li = Im(f.type, S, li))),
                    yr(c, f, f.pendingProps.children, x),
                    yf(c, f),
                    c === null && (f.flags |= 4194304),
                    f.child
                  );
              case 5:
                return (
                  c === null &&
                    yn &&
                    (jv(f.type, f.pendingProps, ur.current),
                    (D = S = li) &&
                      ((S = Uv(S, f.type, f.pendingProps, Gr)),
                      S !== null
                        ? ((f.stateNode = S),
                          ($i = f),
                          (li = Rv(S)),
                          (Gr = !1),
                          (D = !0))
                        : (D = !1)),
                    D || ze(f)),
                  he(f),
                  (D = f.type),
                  (U = f.pendingProps),
                  (Y = c !== null ? c.memoizedProps : null),
                  (S = U.children),
                  Vr(D, U)
                    ? (S = null)
                    : Y !== null && Vr(D, Y) && (f.flags |= 32),
                  f.memoizedState !== null &&
                    ((D = zt(c, f, Kt, null, null, x)),
                    Ci ? (Sc._currentValue = D) : (Sc._currentValue2 = D)),
                  yf(c, f),
                  yr(c, f, S, x),
                  f.child
                );
              case 6:
                return (
                  c === null &&
                    yn &&
                    (km(f.pendingProps, ur.current),
                    (c = x = li) &&
                      ((x = Pv(x, f.pendingProps, Gr)),
                      x !== null
                        ? ((f.stateNode = x), ($i = f), (li = null), (c = !0))
                        : (c = !1)),
                    c || ze(f)),
                  null
                );
              case 13:
                return $p(c, f, x);
              case 4:
                return (
                  ge(f, f.stateNode.containerInfo),
                  (S = f.pendingProps),
                  c === null ? (f.child = _r(f, null, S, x)) : yr(c, f, S, x),
                  f.child
                );
              case 11:
                return j0(c, f, f.type, f.pendingProps, x);
              case 7:
                return (yr(c, f, f.pendingProps, x), f.child);
              case 8:
                return (yr(c, f, f.pendingProps.children, x), f.child);
              case 12:
                return (yr(c, f, f.pendingProps.children, x), f.child);
              case 10:
                return (
                  (S = f.pendingProps),
                  De(f, f.type, S.value),
                  yr(c, f, S.children, x),
                  f.child
                );
              case 9:
                return (
                  (D = f.type._context),
                  (S = f.pendingProps.children),
                  ke(f),
                  (D = H(D)),
                  (S = S(D)),
                  (f.flags |= 1),
                  yr(c, f, S, x),
                  f.child
                );
              case 14:
                return W0(c, f, f.type, f.pendingProps, x);
              case 15:
                return X0(c, f, f.type, f.pendingProps, x);
              case 19:
                return em(c, f, x);
              case 31:
                return Y0(c, f, x);
              case 22:
                return q0(c, f, x, f.pendingProps);
              case 24:
                return (
                  ke(f),
                  (S = H(ci)),
                  c === null
                    ? ((D = Ke()),
                      D === null &&
                        ((D = ln),
                        (U = Ae()),
                        (D.pooledCache = U),
                        U.refCount++,
                        U !== null && (D.pooledCacheLanes |= x),
                        (D = U)),
                      (f.memoizedState = { parent: S, cache: D }),
                      ii(f),
                      De(f, ci, D))
                    : ((c.lanes & x) !== 0 &&
                        (Ir(c, f), Xs(f, null, null, x), Ss()),
                      (D = c.memoizedState),
                      (U = f.memoizedState),
                      D.parent !== S
                        ? ((D = { parent: S, cache: S }),
                          (f.memoizedState = D),
                          f.lanes === 0 &&
                            (f.memoizedState = f.updateQueue.baseState = D),
                          De(f, ci, S))
                        : ((S = U.cache),
                          De(f, ci, S),
                          S !== D.cache && rt(f, [ci], x, !0))),
                  yr(c, f, f.pendingProps.children, x),
                  f.child
                );
              case 29:
                throw f.pendingProps;
            }
            throw Error(r(156, f.tag));
          }
          function Qs(c) {
            c.flags |= 4;
          }
          function bf(c) {
            Ls && (c.flags |= 8);
          }
          function Q0(c, f) {
            if (c !== null && c.child === f.child) return !1;
            if ((f.flags & 16) !== 0) return !0;
            for (c = f.child; c !== null; ) {
              if ((c.flags & 8218) !== 0 || (c.subtreeFlags & 8218) !== 0)
                return !0;
              c = c.sibling;
            }
            return !1;
          }
          function im(c, f, x, S) {
            if (Sn)
              for (x = f.child; x !== null; ) {
                if (x.tag === 5 || x.tag === 6) Pf(c, x.stateNode);
                else if (
                  !(x.tag === 4 || (Ji && x.tag === 27)) &&
                  x.child !== null
                ) {
                  ((x.child.return = x), (x = x.child));
                  continue;
                }
                if (x === f) break;
                for (; x.sibling === null; ) {
                  if (x.return === null || x.return === f) return;
                  x = x.return;
                }
                ((x.sibling.return = x.return), (x = x.sibling));
              }
            else if (Ls)
              for (var D = f.child; D !== null; ) {
                if (D.tag === 5) {
                  var U = D.stateNode;
                  (x && S && (U = Ev(U, D.type, D.memoizedProps)), Pf(c, U));
                } else if (D.tag === 6)
                  ((U = D.stateNode),
                    x && S && (U = Um(U, D.memoizedProps)),
                    Pf(c, U));
                else if (D.tag !== 4) {
                  if (D.tag === 22 && D.memoizedState !== null)
                    ((U = D.child),
                      U !== null && (U.return = D),
                      im(c, D, !0, !0));
                  else if (D.child !== null) {
                    ((D.child.return = D), (D = D.child));
                    continue;
                  }
                }
                if (D === f) break;
                for (; D.sibling === null; ) {
                  if (D.return === null || D.return === f) return;
                  D = D.return;
                }
                ((D.sibling.return = D.return), (D = D.sibling));
              }
          }
          function J0(c, f, x, S) {
            var D = !1;
            if (Ls)
              for (var U = f.child; U !== null; ) {
                if (U.tag === 5) {
                  var Y = U.stateNode;
                  (x && S && (Y = Ev(Y, U.type, U.memoizedProps)), Lm(c, Y));
                } else if (U.tag === 6)
                  ((Y = U.stateNode),
                    x && S && (Y = Um(Y, U.memoizedProps)),
                    Lm(c, Y));
                else if (U.tag !== 4) {
                  if (U.tag === 22 && U.memoizedState !== null)
                    ((D = U.child),
                      D !== null && (D.return = U),
                      J0(c, U, !0, !0),
                      (D = !0));
                  else if (U.child !== null) {
                    ((U.child.return = U), (U = U.child));
                    continue;
                  }
                }
                if (U === f) break;
                for (; U.sibling === null; ) {
                  if (U.return === null || U.return === f) return D;
                  U = U.return;
                }
                ((U.sibling.return = U.return), (U = U.sibling));
              }
            return D;
          }
          function $0(c, f) {
            if (Ls && Q0(c, f)) {
              c = f.stateNode;
              var x = c.containerInfo,
                S = Dm();
              (J0(S, f, !1, !1), (c.pendingChildren = S), Qs(f), Tv(x, S));
            }
          }
          function rm(c, f, x, S) {
            if (Sn) c.memoizedProps !== S && Qs(f);
            else if (Ls) {
              var D = c.stateNode,
                U = c.memoizedProps;
              if ((c = Q0(c, f)) || U !== S) {
                var Y = ur.current;
                ((U = Mv(D, x, U, S, !c, null)),
                  U === D
                    ? (f.stateNode = D)
                    : (bf(f),
                      as(U, x, S, Y) && Qs(f),
                      (f.stateNode = U),
                      c && im(U, f, !1, !1)));
              } else f.stateNode = D;
            }
          }
          function zr(c, f, x, S, D) {
            if ((c.mode & 32) !== 0 && (x === null ? If(f, S) : Mu(f, x, S))) {
              if (((c.flags |= 16777216), (D & 335544128) === D || xm(f, S)))
                if (di(c.stateNode, f, S)) c.flags |= 8192;
                else if (_n()) c.flags |= 8192;
                else throw ((Hr = lo), Nd);
            } else c.flags &= -16777217;
          }
          function au(c, f) {
            if (Wm(f)) {
              if (((c.flags |= 16777216), !Xm(f)))
                if (_n()) c.flags |= 8192;
                else throw ((Hr = lo), Nd);
            } else c.flags &= -16777217;
          }
          function _f(c, f) {
            (f !== null && (c.flags |= 4),
              c.flags & 16384 &&
                ((f = c.tag !== 22 ? L() : 536870912),
                (c.lanes |= f),
                (Nu |= f)));
          }
          function ou(c, f) {
            if (!yn)
              switch (c.tailMode) {
                case "hidden":
                  f = c.tail;
                  for (var x = null; f !== null; )
                    (f.alternate !== null && (x = f), (f = f.sibling));
                  x === null ? (c.tail = null) : (x.sibling = null);
                  break;
                case "collapsed":
                  x = c.tail;
                  for (var S = null; x !== null; )
                    (x.alternate !== null && (S = x), (x = x.sibling));
                  S === null
                    ? f || c.tail === null
                      ? (c.tail = null)
                      : (c.tail.sibling = null)
                    : (S.sibling = null);
              }
          }
          function Yn(c) {
            var f = c.alternate !== null && c.alternate.child === c.child,
              x = 0,
              S = 0;
            if (f)
              for (var D = c.child; D !== null; )
                ((x |= D.lanes | D.childLanes),
                  (S |= D.subtreeFlags & 65011712),
                  (S |= D.flags & 65011712),
                  (D.return = c),
                  (D = D.sibling));
            else
              for (D = c.child; D !== null; )
                ((x |= D.lanes | D.childLanes),
                  (S |= D.subtreeFlags),
                  (S |= D.flags),
                  (D.return = c),
                  (D = D.sibling));
            return ((c.subtreeFlags |= S), (c.childLanes = x), f);
          }
          function ev(c, f, x) {
            var S = f.pendingProps;
            switch ((se(f), f.tag)) {
              case 16:
              case 15:
              case 0:
              case 11:
              case 7:
              case 8:
              case 12:
              case 9:
              case 14:
                return (Yn(f), null);
              case 1:
                return (Yn(f), null);
              case 3:
                return (
                  (x = f.stateNode),
                  (S = null),
                  c !== null && (S = c.memoizedState.cache),
                  f.memoizedState.cache !== S && (f.flags |= 2048),
                  Qe(ci),
                  ae(),
                  x.pendingContext &&
                    ((x.context = x.pendingContext), (x.pendingContext = null)),
                  (c === null || c.child === null) &&
                    (Ye(f)
                      ? Qs(f)
                      : c === null ||
                        (c.memoizedState.isDehydrated &&
                          (f.flags & 256) === 0) ||
                        ((f.flags |= 1024), Re())),
                  $0(c, f),
                  Yn(f),
                  null
                );
              case 26:
                if (sa) {
                  var D = f.type,
                    U = f.memoizedState;
                  return (
                    c === null
                      ? (Qs(f),
                        U !== null
                          ? (Yn(f), au(f, U))
                          : (Yn(f), zr(f, D, null, S, x)))
                      : U
                        ? U !== c.memoizedState
                          ? (Qs(f), Yn(f), au(f, U))
                          : (Yn(f), (f.flags &= -16777217))
                        : ((U = c.memoizedProps),
                          Sn ? U !== S && Qs(f) : rm(c, f, D, S),
                          Yn(f),
                          zr(f, D, U, S, x)),
                    null
                  );
                }
              case 27:
                if (Ji) {
                  if (
                    (ye(f),
                    (x = br.current),
                    (D = f.type),
                    c !== null && f.stateNode != null)
                  )
                    Sn ? c.memoizedProps !== S && Qs(f) : rm(c, f, D, S);
                  else {
                    if (!S) {
                      if (f.stateNode === null) throw Error(r(166));
                      return (Yn(f), null);
                    }
                    ((c = ur.current),
                      Ye(f)
                        ? it(f, c)
                        : ((c = _d(D, S, x, c, !0)), (f.stateNode = c), Qs(f)));
                  }
                  return (Yn(f), null);
                }
              case 5:
                if ((ye(f), (D = f.type), c !== null && f.stateNode != null))
                  rm(c, f, D, S);
                else {
                  if (!S) {
                    if (f.stateNode === null) throw Error(r(166));
                    return (Yn(f), null);
                  }
                  if (((U = ur.current), Ye(f)))
                    (it(f, U), Vv(f.stateNode, D, S, U) && (f.flags |= 64));
                  else {
                    var Y = vm(D, S, br.current, U, f);
                    (bf(f),
                      im(Y, f, !1, !1),
                      (f.stateNode = Y),
                      as(Y, D, S, U) && Qs(f));
                  }
                }
                return (
                  Yn(f),
                  zr(
                    f,
                    f.type,
                    c === null ? null : c.memoizedProps,
                    f.pendingProps,
                    x,
                  ),
                  null
                );
              case 6:
                if (c && f.stateNode != null)
                  ((x = c.memoizedProps),
                    Sn
                      ? x !== S && Qs(f)
                      : Ls &&
                        (x !== S
                          ? ((c = br.current),
                            (x = ur.current),
                            bf(f),
                            (f.stateNode = Lo(S, c, x, f)))
                          : (f.stateNode = c.stateNode)));
                else {
                  if (typeof S != "string" && f.stateNode === null)
                    throw Error(r(166));
                  if (((c = br.current), (x = ur.current), Ye(f))) {
                    if (!oi) throw Error(r(176));
                    if (
                      ((c = f.stateNode),
                      (x = f.memoizedProps),
                      (S = null),
                      (D = $i),
                      D !== null)
                    )
                      switch (D.tag) {
                        case 27:
                        case 5:
                          S = D.memoizedProps;
                      }
                    Vb(c, x, f, S) || ze(f, !0);
                  } else (bf(f), (f.stateNode = Lo(S, c, x, f)));
                }
                return (Yn(f), null);
              case 31:
                if (
                  ((x = f.memoizedState),
                  c === null || c.memoizedState !== null)
                ) {
                  if (((S = Ye(f)), x !== null)) {
                    if (c === null) {
                      if (!S) throw Error(r(318));
                      if (!oi) throw Error(r(556));
                      if (
                        ((c = f.memoizedState),
                        (c = c !== null ? c.dehydrated : null),
                        !c)
                      )
                        throw Error(r(557));
                      Fm(c, f);
                    } else
                      (ft(),
                        (f.flags & 128) === 0 && (f.memoizedState = null),
                        (f.flags |= 4));
                    (Yn(f), (c = !1));
                  } else
                    ((x = Re()),
                      c !== null &&
                        c.memoizedState !== null &&
                        (c.memoizedState.hydrationErrors = x),
                      (c = !0));
                  if (!c) return f.flags & 256 ? (bt(f), f) : (bt(f), null);
                  if ((f.flags & 128) !== 0) throw Error(r(558));
                }
                return (Yn(f), null);
              case 13:
                if (
                  ((S = f.memoizedState),
                  c === null ||
                    (c.memoizedState !== null &&
                      c.memoizedState.dehydrated !== null))
                ) {
                  if (((D = Ye(f)), S !== null && S.dehydrated !== null)) {
                    if (c === null) {
                      if (!D) throw Error(r(318));
                      if (!oi) throw Error(r(344));
                      if (
                        ((D = f.memoizedState),
                        (D = D !== null ? D.dehydrated : null),
                        !D)
                      )
                        throw Error(r(317));
                      Fv(D, f);
                    } else
                      (ft(),
                        (f.flags & 128) === 0 && (f.memoizedState = null),
                        (f.flags |= 4));
                    (Yn(f), (D = !1));
                  } else
                    ((D = Re()),
                      c !== null &&
                        c.memoizedState !== null &&
                        (c.memoizedState.hydrationErrors = D),
                      (D = !0));
                  if (!D) return f.flags & 256 ? (bt(f), f) : (bt(f), null);
                }
                return (
                  bt(f),
                  (f.flags & 128) !== 0
                    ? ((f.lanes = x), f)
                    : ((x = S !== null),
                      (c = c !== null && c.memoizedState !== null),
                      x &&
                        ((S = f.child),
                        (D = null),
                        S.alternate !== null &&
                          S.alternate.memoizedState !== null &&
                          S.alternate.memoizedState.cachePool !== null &&
                          (D = S.alternate.memoizedState.cachePool.pool),
                        (U = null),
                        S.memoizedState !== null &&
                          S.memoizedState.cachePool !== null &&
                          (U = S.memoizedState.cachePool.pool),
                        U !== D && (S.flags |= 2048)),
                      x !== c && x && (f.child.flags |= 8192),
                      _f(f, f.updateQueue),
                      Yn(f),
                      null)
                );
              case 4:
                return (
                  ae(),
                  $0(c, f),
                  c === null && jn(f.stateNode.containerInfo),
                  Yn(f),
                  null
                );
              case 10:
                return (Qe(f.type), Yn(f), null);
              case 19:
                if ((b(Si), (S = f.memoizedState), S === null))
                  return (Yn(f), null);
                if (
                  ((D = (f.flags & 128) !== 0), (U = S.rendering), U === null)
                )
                  if (D) ou(S, !1);
                  else {
                    if (gi !== 0 || (c !== null && (c.flags & 128) !== 0))
                      for (c = f.child; c !== null; ) {
                        if (((U = _t(c)), U !== null)) {
                          for (
                            f.flags |= 128,
                              ou(S, !1),
                              c = U.updateQueue,
                              f.updateQueue = c,
                              _f(f, c),
                              f.subtreeFlags = 0,
                              c = x,
                              x = f.child;
                            x !== null;
                          )
                            (rd(x, c), (x = x.sibling));
                          return (
                            _(Si, (Si.current & 1) | 2),
                            yn && fe(f, S.treeForkCount),
                            f.child
                          );
                        }
                        c = c.sibling;
                      }
                    S.tail !== null &&
                      Dr() > Nl &&
                      ((f.flags |= 128),
                      (D = !0),
                      ou(S, !1),
                      (f.lanes = 4194304));
                  }
                else {
                  if (!D)
                    if (((c = _t(U)), c !== null)) {
                      if (
                        ((f.flags |= 128),
                        (D = !0),
                        (c = c.updateQueue),
                        (f.updateQueue = c),
                        _f(f, c),
                        ou(S, !0),
                        S.tail === null &&
                          S.tailMode === "hidden" &&
                          !U.alternate &&
                          !yn)
                      )
                        return (Yn(f), null);
                    } else
                      2 * Dr() - S.renderingStartTime > Nl &&
                        x !== 536870912 &&
                        ((f.flags |= 128),
                        (D = !0),
                        ou(S, !1),
                        (f.lanes = 4194304));
                  S.isBackwards
                    ? ((U.sibling = f.child), (f.child = U))
                    : ((c = S.last),
                      c !== null ? (c.sibling = U) : (f.child = U),
                      (S.last = U));
                }
                return S.tail !== null
                  ? ((c = S.tail),
                    (S.rendering = c),
                    (S.tail = c.sibling),
                    (S.renderingStartTime = Dr()),
                    (c.sibling = null),
                    (x = Si.current),
                    _(Si, D ? (x & 1) | 2 : x & 1),
                    yn && fe(f, S.treeForkCount),
                    c)
                  : (Yn(f), null);
              case 22:
              case 23:
                return (
                  bt(f),
                  ve(),
                  (S = f.memoizedState !== null),
                  c !== null
                    ? (c.memoizedState !== null) !== S && (f.flags |= 8192)
                    : S && (f.flags |= 8192),
                  S
                    ? (x & 536870912) !== 0 &&
                      (f.flags & 128) === 0 &&
                      (Yn(f), f.subtreeFlags & 6 && (f.flags |= 8192))
                    : Yn(f),
                  (x = f.updateQueue),
                  x !== null && _f(f, x.retryQueue),
                  (x = null),
                  c !== null &&
                    c.memoizedState !== null &&
                    c.memoizedState.cachePool !== null &&
                    (x = c.memoizedState.cachePool.pool),
                  (S = null),
                  f.memoizedState !== null &&
                    f.memoizedState.cachePool !== null &&
                    (S = f.memoizedState.cachePool.pool),
                  S !== x && (f.flags |= 2048),
                  c !== null && b(Tl),
                  null
                );
              case 24:
                return (
                  (x = null),
                  c !== null && (x = c.memoizedState.cache),
                  f.memoizedState.cache !== x && (f.flags |= 2048),
                  Qe(ci),
                  Yn(f),
                  null
                );
              case 25:
                return null;
              case 30:
                return null;
            }
            throw Error(r(156, f.tag));
          }
          function sm(c, f) {
            switch ((se(f), f.tag)) {
              case 1:
                return (
                  (c = f.flags),
                  c & 65536 ? ((f.flags = (c & -65537) | 128), f) : null
                );
              case 3:
                return (
                  Qe(ci),
                  ae(),
                  (c = f.flags),
                  (c & 65536) !== 0 && (c & 128) === 0
                    ? ((f.flags = (c & -65537) | 128), f)
                    : null
                );
              case 26:
              case 27:
              case 5:
                return (ye(f), null);
              case 31:
                if (f.memoizedState !== null) {
                  if ((bt(f), f.alternate === null)) throw Error(r(340));
                  ft();
                }
                return (
                  (c = f.flags),
                  c & 65536 ? ((f.flags = (c & -65537) | 128), f) : null
                );
              case 13:
                if (
                  (bt(f),
                  (c = f.memoizedState),
                  c !== null && c.dehydrated !== null)
                ) {
                  if (f.alternate === null) throw Error(r(340));
                  ft();
                }
                return (
                  (c = f.flags),
                  c & 65536 ? ((f.flags = (c & -65537) | 128), f) : null
                );
              case 19:
                return (b(Si), null);
              case 4:
                return (ae(), null);
              case 10:
                return (Qe(f.type), null);
              case 22:
              case 23:
                return (
                  bt(f),
                  ve(),
                  c !== null && b(Tl),
                  (c = f.flags),
                  c & 65536 ? ((f.flags = (c & -65537) | 128), f) : null
                );
              case 24:
                return (Qe(ci), null);
              case 25:
                return null;
              default:
                return null;
            }
          }
          function tv(c, f) {
            switch ((se(f), f.tag)) {
              case 3:
                (Qe(ci), ae());
                break;
              case 26:
              case 27:
              case 5:
                ye(f);
                break;
              case 4:
                ae();
                break;
              case 31:
                f.memoizedState !== null && bt(f);
                break;
              case 13:
                bt(f);
                break;
              case 19:
                b(Si);
                break;
              case 10:
                Qe(f.type);
                break;
              case 22:
              case 23:
                (bt(f), ve(), c !== null && b(Tl));
                break;
              case 24:
                Qe(ci);
            }
          }
          function qa(c, f) {
            try {
              var x = f.updateQueue,
                S = x !== null ? x.lastEffect : null;
              if (S !== null) {
                var D = S.next;
                x = D;
                do {
                  if ((x.tag & c) === c) {
                    S = void 0;
                    var U = x.create,
                      Y = x.inst;
                    ((S = U()), (Y.destroy = S));
                  }
                  x = x.next;
                } while (x !== D);
              }
            } catch (me) {
              Xt(f, f.return, me);
            }
          }
          function Ya(c, f, x) {
            try {
              var S = f.updateQueue,
                D = S !== null ? S.lastEffect : null;
              if (D !== null) {
                var U = D.next;
                S = U;
                do {
                  if ((S.tag & c) === c) {
                    var Y = S.inst,
                      me = Y.destroy;
                    if (me !== void 0) {
                      ((Y.destroy = void 0), (D = f));
                      var We = x,
                        ot = me;
                      try {
                        ot();
                      } catch (xt) {
                        Xt(D, We, xt);
                      }
                    }
                  }
                  S = S.next;
                } while (S !== U);
              }
            } catch (xt) {
              Xt(f, f.return, xt);
            }
          }
          function lu(c) {
            var f = c.updateQueue;
            if (f !== null) {
              var x = c.stateNode;
              try {
                Ms(f, x);
              } catch (S) {
                Xt(c, c.return, S);
              }
            }
          }
          function qh(c, f, x) {
            ((x.props = lc(c.type, c.memoizedProps)),
              (x.state = c.memoizedState));
            try {
              x.componentWillUnmount();
            } catch (S) {
              Xt(c, f, S);
            }
          }
          function cu(c, f) {
            try {
              var x = c.ref;
              if (x !== null) {
                switch (c.tag) {
                  case 26:
                  case 27:
                  case 5:
                    var S = bu(c.stateNode);
                    break;
                  case 30:
                    S = c.stateNode;
                    break;
                  default:
                    S = c.stateNode;
                }
                typeof x == "function"
                  ? (c.refCleanup = x(S))
                  : (x.current = S);
              }
            } catch (D) {
              Xt(c, f, D);
            }
          }
          function Rr(c, f) {
            var x = c.ref,
              S = c.refCleanup;
            if (x !== null)
              if (typeof S == "function")
                try {
                  S();
                } catch (D) {
                  Xt(c, f, D);
                } finally {
                  ((c.refCleanup = null),
                    (c = c.alternate),
                    c != null && (c.refCleanup = null));
                }
              else if (typeof x == "function")
                try {
                  x(null);
                } catch (D) {
                  Xt(c, f, D);
                }
              else x.current = null;
          }
          function hc(c) {
            var f = c.type,
              x = c.memoizedProps,
              S = c.stateNode;
            try {
              mv(S, f, x, c);
            } catch (D) {
              Xt(c, c.return, D);
            }
          }
          function Sf(c, f, x) {
            try {
              gv(c.stateNode, c.type, x, f, c);
            } catch (S) {
              Xt(c, c.return, S);
            }
          }
          function am(c) {
            return (
              c.tag === 5 ||
              c.tag === 3 ||
              (sa ? c.tag === 26 : !1) ||
              (Ji ? c.tag === 27 && Mc(c.type) : !1) ||
              c.tag === 4
            );
          }
          function Mo(c) {
            e: for (;;) {
              for (; c.sibling === null; ) {
                if (c.return === null || am(c.return)) return null;
                c = c.return;
              }
              for (
                c.sibling.return = c.return, c = c.sibling;
                c.tag !== 5 && c.tag !== 6 && c.tag !== 18;
              ) {
                if (
                  (Ji && c.tag === 27 && Mc(c.type)) ||
                  c.flags & 2 ||
                  c.child === null ||
                  c.tag === 4
                )
                  continue e;
                ((c.child.return = c), (c = c.child));
              }
              if (!(c.flags & 2)) return c.stateNode;
            }
          }
          function Yh(c, f, x) {
            var S = c.tag;
            if (S === 5 || S === 6)
              ((c = c.stateNode), f ? yv(x, c, f) : wm(x, c));
            else if (
              S !== 4 &&
              (Ji && S === 27 && Mc(c.type) && ((x = c.stateNode), (f = null)),
              (c = c.child),
              c !== null)
            )
              for (Yh(c, f, x), c = c.sibling; c !== null; )
                (Yh(c, f, x), (c = c.sibling));
          }
          function Mf(c, f, x) {
            var S = c.tag;
            if (S === 5 || S === 6)
              ((c = c.stateNode), f ? vv(x, c, f) : Em(x, c));
            else if (
              S !== 4 &&
              (Ji && S === 27 && Mc(c.type) && (x = c.stateNode),
              (c = c.child),
              c !== null)
            )
              for (Mf(c, f, x), c = c.sibling; c !== null; )
                (Mf(c, f, x), (c = c.sibling));
          }
          function om(c, f, x) {
            c = c.containerInfo;
            try {
              Nm(c, x);
            } catch (S) {
              Xt(f, f.return, S);
            }
          }
          function nv(c) {
            var f = c.stateNode,
              x = c.memoizedProps;
            try {
              ji(c.type, x, f, c);
            } catch (S) {
              Xt(c, c.return, S);
            }
          }
          function Fb(c, f) {
            for (ud(c.containerInfo), Li = f; Li !== null; )
              if (
                ((c = Li),
                (f = c.child),
                (c.subtreeFlags & 1028) !== 0 && f !== null)
              )
                ((f.return = c), (Li = f));
              else
                for (; Li !== null; ) {
                  c = Li;
                  var x = c.alternate;
                  switch (((f = c.flags), c.tag)) {
                    case 0:
                      if (
                        (f & 4) !== 0 &&
                        ((f = c.updateQueue),
                        (f = f !== null ? f.events : null),
                        f !== null)
                      )
                        for (var S = 0; S < f.length; S++) {
                          var D = f[S];
                          D.ref.impl = D.nextImpl;
                        }
                      break;
                    case 11:
                    case 15:
                      break;
                    case 1:
                      if ((f & 1024) !== 0 && x !== null) {
                        ((f = void 0),
                          (S = c),
                          (D = x.memoizedProps),
                          (x = x.memoizedState));
                        var U = S.stateNode;
                        try {
                          var Y = lc(S.type, D);
                          ((f = U.getSnapshotBeforeUpdate(Y, x)),
                            (U.__reactInternalSnapshotBeforeUpdate = f));
                        } catch (me) {
                          Xt(S, S.return, me);
                        }
                      }
                      break;
                    case 3:
                      (f & 1024) !== 0 && Sn && Rm(c.stateNode.containerInfo);
                      break;
                    case 5:
                    case 26:
                    case 27:
                    case 6:
                    case 4:
                    case 17:
                      break;
                    default:
                      if ((f & 1024) !== 0) throw Error(r(163));
                  }
                  if (((f = c.sibling), f !== null)) {
                    ((f.return = c.return), (Li = f));
                    break;
                  }
                  Li = c.return;
                }
          }
          function iv(c, f, x) {
            var S = x.flags;
            switch (x.tag) {
              case 0:
              case 11:
              case 15:
                (Br(c, x), S & 4 && qa(5, x));
                break;
              case 1:
                if ((Br(c, x), S & 4))
                  if (((c = x.stateNode), f === null))
                    try {
                      c.componentDidMount();
                    } catch (Y) {
                      Xt(x, x.return, Y);
                    }
                  else {
                    var D = lc(x.type, f.memoizedProps);
                    f = f.memoizedState;
                    try {
                      c.componentDidUpdate(
                        D,
                        f,
                        c.__reactInternalSnapshotBeforeUpdate,
                      );
                    } catch (Y) {
                      Xt(x, x.return, Y);
                    }
                  }
                (S & 64 && lu(x), S & 512 && cu(x, x.return));
                break;
              case 3:
                if ((Br(c, x), S & 64 && ((S = x.updateQueue), S !== null))) {
                  if (((c = null), x.child !== null))
                    switch (x.child.tag) {
                      case 27:
                      case 5:
                        c = bu(x.child.stateNode);
                        break;
                      case 1:
                        c = x.child.stateNode;
                    }
                  try {
                    Ms(S, c);
                  } catch (Y) {
                    Xt(x, x.return, Y);
                  }
                }
                break;
              case 27:
                Ji && f === null && S & 4 && nv(x);
              case 26:
              case 5:
                if ((Br(c, x), f === null)) {
                  if (S & 4) hc(x);
                  else if (S & 64) {
                    ((c = x.type), (f = x.memoizedProps), (D = x.stateNode));
                    try {
                      Bv(D, c, f, x);
                    } catch (Y) {
                      Xt(x, x.return, Y);
                    }
                  }
                }
                S & 512 && cu(x, x.return);
                break;
              case 12:
                Br(c, x);
                break;
              case 31:
                (Br(c, x), S & 4 && $s(c, x));
                break;
              case 13:
                (Br(c, x),
                  S & 4 && Ef(c, x),
                  S & 64 &&
                    ((S = x.memoizedState),
                    S !== null &&
                      ((S = S.dehydrated),
                      S !== null && ((x = zb.bind(null, x)), vd(S, x)))));
                break;
              case 22:
                if (((S = x.memoizedState !== null || Mi), !S)) {
                  ((f = (f !== null && f.memoizedState !== null) || Ti),
                    (D = Mi));
                  var U = Ti;
                  ((Mi = S),
                    (Ti = f) && !U
                      ? ta(c, x, (x.subtreeFlags & 8772) !== 0)
                      : Br(c, x),
                    (Mi = D),
                    (Ti = U));
                }
                break;
              case 30:
                break;
              default:
                Br(c, x);
            }
          }
          function lm(c) {
            var f = c.alternate;
            (f !== null && ((c.alternate = null), lm(f)),
              (c.child = null),
              (c.deletions = null),
              (c.sibling = null),
              c.tag === 5 && ((f = c.stateNode), f !== null && fd(f)),
              (c.stateNode = null),
              (c.return = null),
              (c.dependencies = null),
              (c.memoizedProps = null),
              (c.memoizedState = null),
              (c.pendingProps = null),
              (c.stateNode = null),
              (c.updateQueue = null));
          }
          function Js(c, f, x) {
            for (x = x.child; x !== null; ) (Tf(c, f, x), (x = x.sibling));
          }
          function Tf(c, f, x) {
            if (cs && typeof cs.onCommitFiberUnmount == "function")
              try {
                cs.onCommitFiberUnmount(wc, x);
              } catch {}
            switch (x.tag) {
              case 26:
                if (sa) {
                  (Ti || Rr(x, f),
                    Js(c, f, x),
                    x.memoizedState
                      ? Sl(x.memoizedState)
                      : x.stateNode && jm(x.stateNode));
                  break;
                }
              case 27:
                if (Ji) {
                  Ti || Rr(x, f);
                  var S = mi,
                    D = Ni;
                  (Mc(x.type) && ((mi = x.stateNode), (Ni = !1)),
                    Js(c, f, x),
                    cr(x.stateNode),
                    (mi = S),
                    (Ni = D));
                  break;
                }
              case 5:
                Ti || Rr(x, f);
              case 6:
                if (Sn) {
                  if (
                    ((S = mi),
                    (D = Ni),
                    (mi = null),
                    Js(c, f, x),
                    (mi = S),
                    (Ni = D),
                    mi !== null)
                  )
                    if (Ni)
                      try {
                        Am(mi, x.stateNode);
                      } catch (U) {
                        Xt(x, f, U);
                      }
                    else
                      try {
                        xv(mi, x.stateNode);
                      } catch (U) {
                        Xt(x, f, U);
                      }
                } else Js(c, f, x);
                break;
              case 18:
                Sn &&
                  mi !== null &&
                  (Ni ? yd(mi, x.stateNode) : Bm(mi, x.stateNode));
                break;
              case 4:
                Sn
                  ? ((S = mi),
                    (D = Ni),
                    (mi = x.stateNode.containerInfo),
                    (Ni = !0),
                    Js(c, f, x),
                    (mi = S),
                    (Ni = D))
                  : (Ls && om(x.stateNode, x, Dm()), Js(c, f, x));
                break;
              case 0:
              case 11:
              case 14:
              case 15:
                (Ya(2, x, f), Ti || Ya(4, x, f), Js(c, f, x));
                break;
              case 1:
                (Ti ||
                  (Rr(x, f),
                  (S = x.stateNode),
                  typeof S.componentWillUnmount == "function" && qh(x, f, S)),
                  Js(c, f, x));
                break;
              case 21:
                Js(c, f, x);
                break;
              case 22:
                ((Ti = (S = Ti) || x.memoizedState !== null),
                  Js(c, f, x),
                  (Ti = S));
                break;
              default:
                Js(c, f, x);
            }
          }
          function $s(c, f) {
            if (
              oi &&
              f.memoizedState === null &&
              ((c = f.alternate),
              c !== null && ((c = c.memoizedState), c !== null))
            ) {
              c = c.dehydrated;
              try {
                Gb(c);
              } catch (x) {
                Xt(f, f.return, x);
              }
            }
          }
          function Ef(c, f) {
            if (
              oi &&
              f.memoizedState === null &&
              ((c = f.alternate),
              c !== null &&
                ((c = c.memoizedState),
                c !== null && ((c = c.dehydrated), c !== null)))
            )
              try {
                Hb(c);
              } catch (x) {
                Xt(f, f.return, x);
              }
          }
          function ea(c) {
            switch (c.tag) {
              case 31:
              case 13:
              case 19:
                var f = c.stateNode;
                return (f === null && (f = c.stateNode = new eg()), f);
              case 22:
                return (
                  (c = c.stateNode),
                  (f = c._retryCache),
                  f === null && (f = c._retryCache = new eg()),
                  f
                );
              default:
                throw Error(r(435, c.tag));
            }
          }
          function To(c, f) {
            var x = ea(c);
            f.forEach(function (S) {
              if (!x.has(S)) {
                x.add(S);
                var D = Bb.bind(null, c, S);
                S.then(D, D);
              }
            });
          }
          function or(c, f) {
            var x = f.deletions;
            if (x !== null)
              for (var S = 0; S < x.length; S++) {
                var D = x[S],
                  U = c,
                  Y = f;
                if (Sn) {
                  var me = Y;
                  e: for (; me !== null; ) {
                    switch (me.tag) {
                      case 27:
                        if (Ji) {
                          if (Mc(me.type)) {
                            ((mi = me.stateNode), (Ni = !1));
                            break e;
                          }
                          break;
                        }
                      case 5:
                        ((mi = me.stateNode), (Ni = !1));
                        break e;
                      case 3:
                      case 4:
                        ((mi = me.stateNode.containerInfo), (Ni = !0));
                        break e;
                    }
                    me = me.return;
                  }
                  if (mi === null) throw Error(r(160));
                  (Tf(U, Y, D), (mi = null), (Ni = !1));
                } else Tf(U, Y, D);
                ((U = D.alternate),
                  U !== null && (U.return = null),
                  (D.return = null));
              }
            if (f.subtreeFlags & 13886)
              for (f = f.child; f !== null; ) (wf(f, c), (f = f.sibling));
          }
          function wf(c, f) {
            var x = c.alternate,
              S = c.flags;
            switch (c.tag) {
              case 0:
              case 11:
              case 14:
              case 15:
                (or(f, c),
                  lr(c),
                  S & 4 && (Ya(3, c, c.return), qa(3, c), Ya(5, c, c.return)));
                break;
              case 1:
                (or(f, c),
                  lr(c),
                  S & 512 && (Ti || x === null || Rr(x, x.return)),
                  S & 64 &&
                    Mi &&
                    ((c = c.updateQueue),
                    c !== null &&
                      ((S = c.callbacks),
                      S !== null &&
                        ((x = c.shared.hiddenCallbacks),
                        (c.shared.hiddenCallbacks =
                          x === null ? S : x.concat(S))))));
                break;
              case 26:
                if (sa) {
                  var D = Vn;
                  if (
                    (or(f, c),
                    lr(c),
                    S & 512 && (Ti || x === null || Rr(x, x.return)),
                    S & 4)
                  ) {
                    S = x !== null ? x.memoizedState : null;
                    var U = c.memoizedState;
                    x === null
                      ? U === null
                        ? c.stateNode === null
                          ? (c.stateNode = Wv(D, c.type, c.memoizedProps, c))
                          : Hm(D, c.type, c.stateNode)
                        : (c.stateNode = Gm(D, U, c.memoizedProps))
                      : S !== U
                        ? (S === null
                            ? x.stateNode !== null && jm(x.stateNode)
                            : Sl(S),
                          U === null
                            ? Hm(D, c.type, c.stateNode)
                            : Gm(D, U, c.memoizedProps))
                        : U === null &&
                          c.stateNode !== null &&
                          Sf(c, c.memoizedProps, x.memoizedProps);
                  }
                  break;
                }
              case 27:
                if (Ji) {
                  (or(f, c),
                    lr(c),
                    S & 512 && (Ti || x === null || Rr(x, x.return)),
                    x !== null &&
                      S & 4 &&
                      Sf(c, c.memoizedProps, x.memoizedProps));
                  break;
                }
              case 5:
                if (
                  (or(f, c),
                  lr(c),
                  S & 512 && (Ti || x === null || Rr(x, x.return)),
                  Sn)
                ) {
                  if (c.flags & 32) {
                    D = c.stateNode;
                    try {
                      Cm(D);
                    } catch (ut) {
                      Xt(c, c.return, ut);
                    }
                  }
                  (S & 4 &&
                    c.stateNode != null &&
                    ((D = c.memoizedProps),
                    Sf(c, D, x !== null ? x.memoizedProps : D)),
                    S & 1024 && (Au = !0));
                } else
                  Ls &&
                    c.alternate !== null &&
                    (c.alternate.stateNode = c.stateNode);
                break;
              case 6:
                if ((or(f, c), lr(c), S & 4 && Sn)) {
                  if (c.stateNode === null) throw Error(r(162));
                  ((S = c.memoizedProps),
                    (x = x !== null ? x.memoizedProps : S),
                    (D = c.stateNode));
                  try {
                    pv(D, x, S);
                  } catch (ut) {
                    Xt(c, c.return, ut);
                  }
                }
                break;
              case 3:
                if (
                  (sa
                    ? (Xv(),
                      (D = Vn),
                      (Vn = zf(f.containerInfo)),
                      or(f, c),
                      (Vn = D))
                    : or(f, c),
                  lr(c),
                  S & 4)
                ) {
                  if (Sn && oi && x !== null && x.memoizedState.isDehydrated)
                    try {
                      kv(f.containerInfo);
                    } catch (ut) {
                      Xt(c, c.return, ut);
                    }
                  if (Ls) {
                    ((S = f.containerInfo), (x = f.pendingChildren));
                    try {
                      Nm(S, x);
                    } catch (ut) {
                      Xt(c, c.return, ut);
                    }
                  }
                }
                Au && ((Au = !1), Zh(c));
                break;
              case 4:
                (sa
                  ? ((x = Vn),
                    (Vn = zf(c.stateNode.containerInfo)),
                    or(f, c),
                    lr(c),
                    (Vn = x))
                  : (or(f, c), lr(c)),
                  S & 4 &&
                    Ls &&
                    om(c.stateNode, c, c.stateNode.pendingChildren));
                break;
              case 12:
                (or(f, c), lr(c));
                break;
              case 31:
                (or(f, c),
                  lr(c),
                  S & 4 &&
                    ((S = c.updateQueue),
                    S !== null && ((c.updateQueue = null), To(c, S))));
                break;
              case 13:
                (or(f, c),
                  lr(c),
                  c.child.flags & 8192 &&
                    (c.memoizedState !== null) !=
                      (x !== null && x.memoizedState !== null) &&
                    (Yf = Dr()),
                  S & 4 &&
                    ((S = c.updateQueue),
                    S !== null && ((c.updateQueue = null), To(c, S))));
                break;
              case 22:
                D = c.memoizedState !== null;
                var Y = x !== null && x.memoizedState !== null,
                  me = Mi,
                  We = Ti;
                if (
                  ((Mi = me || D),
                  (Ti = We || Y),
                  or(f, c),
                  (Ti = We),
                  (Mi = me),
                  lr(c),
                  S & 8192 &&
                    ((f = c.stateNode),
                    (f._visibility = D
                      ? f._visibility & -2
                      : f._visibility | 1),
                    D && (x === null || Y || Mi || Ti || cl(c)),
                    Sn))
                ) {
                  e: if (((x = null), Sn))
                    for (f = c; ; ) {
                      if (f.tag === 5 || (sa && f.tag === 26)) {
                        if (x === null) {
                          Y = x = f;
                          try {
                            ((U = Y.stateNode),
                              D ? kb(U) : _v(Y.stateNode, Y.memoizedProps));
                          } catch (ut) {
                            Xt(Y, Y.return, ut);
                          }
                        }
                      } else if (f.tag === 6) {
                        if (x === null) {
                          Y = f;
                          try {
                            var ot = Y.stateNode;
                            D ? bv(ot) : Sv(ot, Y.memoizedProps);
                          } catch (ut) {
                            Xt(Y, Y.return, ut);
                          }
                        }
                      } else if (f.tag === 18) {
                        if (x === null) {
                          Y = f;
                          try {
                            var xt = Y.stateNode;
                            D ? Gv(xt) : Hv(Y.stateNode);
                          } catch (ut) {
                            Xt(Y, Y.return, ut);
                          }
                        }
                      } else if (
                        ((f.tag !== 22 && f.tag !== 23) ||
                          f.memoizedState === null ||
                          f === c) &&
                        f.child !== null
                      ) {
                        ((f.child.return = f), (f = f.child));
                        continue;
                      }
                      if (f === c) break e;
                      for (; f.sibling === null; ) {
                        if (f.return === null || f.return === c) break e;
                        (x === f && (x = null), (f = f.return));
                      }
                      (x === f && (x = null),
                        (f.sibling.return = f.return),
                        (f = f.sibling));
                    }
                }
                S & 4 &&
                  ((S = c.updateQueue),
                  S !== null &&
                    ((x = S.retryQueue),
                    x !== null && ((S.retryQueue = null), To(c, x))));
                break;
              case 19:
                (or(f, c),
                  lr(c),
                  S & 4 &&
                    ((S = c.updateQueue),
                    S !== null && ((c.updateQueue = null), To(c, S))));
                break;
              case 30:
                break;
              case 21:
                break;
              default:
                (or(f, c), lr(c));
            }
          }
          function lr(c) {
            var f = c.flags;
            if (f & 2) {
              try {
                for (var x, S = c.return; S !== null; ) {
                  if (am(S)) {
                    x = S;
                    break;
                  }
                  S = S.return;
                }
                if (Sn) {
                  if (x == null) throw Error(r(160));
                  switch (x.tag) {
                    case 27:
                      if (Ji) {
                        var D = x.stateNode,
                          U = Mo(c);
                        Mf(c, U, D);
                        break;
                      }
                    case 5:
                      var Y = x.stateNode;
                      x.flags & 32 && (Cm(Y), (x.flags &= -33));
                      var me = Mo(c);
                      Mf(c, me, Y);
                      break;
                    case 3:
                    case 4:
                      var We = x.stateNode.containerInfo,
                        ot = Mo(c);
                      Yh(c, ot, We);
                      break;
                    default:
                      throw Error(r(161));
                  }
                }
              } catch (xt) {
                Xt(c, c.return, xt);
              }
              c.flags &= -3;
            }
            f & 4096 && (c.flags &= -4097);
          }
          function Zh(c) {
            if (c.subtreeFlags & 1024)
              for (c = c.child; c !== null; ) {
                var f = c;
                (Zh(f),
                  f.tag === 5 && f.flags & 1024 && _m(f.stateNode),
                  (c = c.sibling));
              }
          }
          function Br(c, f) {
            if (f.subtreeFlags & 8772)
              for (f = f.child; f !== null; )
                (iv(c, f.alternate, f), (f = f.sibling));
          }
          function cl(c) {
            for (c = c.child; c !== null; ) {
              var f = c;
              switch (f.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  (Ya(4, f, f.return), cl(f));
                  break;
                case 1:
                  Rr(f, f.return);
                  var x = f.stateNode;
                  (typeof x.componentWillUnmount == "function" &&
                    qh(f, f.return, x),
                    cl(f));
                  break;
                case 27:
                  Ji && cr(f.stateNode);
                case 26:
                case 5:
                  (Rr(f, f.return), cl(f));
                  break;
                case 22:
                  f.memoizedState === null && cl(f);
                  break;
                case 30:
                  cl(f);
                  break;
                default:
                  cl(f);
              }
              c = c.sibling;
            }
          }
          function ta(c, f, x) {
            for (
              x = x && (f.subtreeFlags & 8772) !== 0, f = f.child;
              f !== null;
            ) {
              var S = f.alternate,
                D = c,
                U = f,
                Y = U.flags;
              switch (U.tag) {
                case 0:
                case 11:
                case 15:
                  (ta(D, U, x), qa(4, U));
                  break;
                case 1:
                  if (
                    (ta(D, U, x),
                    (S = U),
                    (D = S.stateNode),
                    typeof D.componentDidMount == "function")
                  )
                    try {
                      D.componentDidMount();
                    } catch (ot) {
                      Xt(S, S.return, ot);
                    }
                  if (((S = U), (D = S.updateQueue), D !== null)) {
                    var me = S.stateNode;
                    try {
                      var We = D.shared.hiddenCallbacks;
                      if (We !== null)
                        for (
                          D.shared.hiddenCallbacks = null, D = 0;
                          D < We.length;
                          D++
                        )
                          ts(We[D], me);
                    } catch (ot) {
                      Xt(S, S.return, ot);
                    }
                  }
                  (x && Y & 64 && lu(U), cu(U, U.return));
                  break;
                case 27:
                  Ji && nv(U);
                case 26:
                case 5:
                  (ta(D, U, x),
                    x && S === null && Y & 4 && hc(U),
                    cu(U, U.return));
                  break;
                case 12:
                  ta(D, U, x);
                  break;
                case 31:
                  (ta(D, U, x), x && Y & 4 && $s(D, U));
                  break;
                case 13:
                  (ta(D, U, x), x && Y & 4 && Ef(D, U));
                  break;
                case 22:
                  (U.memoizedState === null && ta(D, U, x), cu(U, U.return));
                  break;
                case 30:
                  break;
                default:
                  ta(D, U, x);
              }
              f = f.sibling;
            }
          }
          function ul(c, f) {
            var x = null;
            (c !== null &&
              c.memoizedState !== null &&
              c.memoizedState.cachePool !== null &&
              (x = c.memoizedState.cachePool.pool),
              (c = null),
              f.memoizedState !== null &&
                f.memoizedState.cachePool !== null &&
                (c = f.memoizedState.cachePool.pool),
              c !== x && (c != null && c.refCount++, x != null && _e(x)));
          }
          function cm(c, f) {
            ((c = null),
              f.alternate !== null && (c = f.alternate.memoizedState.cache),
              (f = f.memoizedState.cache),
              f !== c && (f.refCount++, c != null && _e(c)));
          }
          function fi(c, f, x, S) {
            if (f.subtreeFlags & 10256)
              for (f = f.child; f !== null; ) (Kh(c, f, x, S), (f = f.sibling));
          }
          function Kh(c, f, x, S) {
            var D = f.flags;
            switch (f.tag) {
              case 0:
              case 11:
              case 15:
                (fi(c, f, x, S), D & 2048 && qa(9, f));
                break;
              case 1:
                fi(c, f, x, S);
                break;
              case 3:
                (fi(c, f, x, S),
                  D & 2048 &&
                    ((c = null),
                    f.alternate !== null &&
                      (c = f.alternate.memoizedState.cache),
                    (f = f.memoizedState.cache),
                    f !== c && (f.refCount++, c != null && _e(c))));
                break;
              case 12:
                if (D & 2048) {
                  (fi(c, f, x, S), (c = f.stateNode));
                  try {
                    var U = f.memoizedProps,
                      Y = U.id,
                      me = U.onPostCommit;
                    typeof me == "function" &&
                      me(
                        Y,
                        f.alternate === null ? "mount" : "update",
                        c.passiveEffectDuration,
                        -0,
                      );
                  } catch (We) {
                    Xt(f, f.return, We);
                  }
                } else fi(c, f, x, S);
                break;
              case 31:
                fi(c, f, x, S);
                break;
              case 13:
                fi(c, f, x, S);
                break;
              case 23:
                break;
              case 22:
                ((U = f.stateNode),
                  (Y = f.alternate),
                  f.memoizedState !== null
                    ? U._visibility & 2
                      ? fi(c, f, x, S)
                      : uu(c, f)
                    : U._visibility & 2
                      ? fi(c, f, x, S)
                      : ((U._visibility |= 2),
                        is(c, f, x, S, (f.subtreeFlags & 10256) !== 0 || !1)),
                  D & 2048 && ul(Y, f));
                break;
              case 24:
                (fi(c, f, x, S), D & 2048 && cm(f.alternate, f));
                break;
              default:
                fi(c, f, x, S);
            }
          }
          function is(c, f, x, S, D) {
            for (
              D = D && ((f.subtreeFlags & 10256) !== 0 || !1), f = f.child;
              f !== null;
            ) {
              var U = c,
                Y = f,
                me = x,
                We = S,
                ot = Y.flags;
              switch (Y.tag) {
                case 0:
                case 11:
                case 15:
                  (is(U, Y, me, We, D), qa(8, Y));
                  break;
                case 23:
                  break;
                case 22:
                  var xt = Y.stateNode;
                  (Y.memoizedState !== null
                    ? xt._visibility & 2
                      ? is(U, Y, me, We, D)
                      : uu(U, Y)
                    : ((xt._visibility |= 2), is(U, Y, me, We, D)),
                    D && ot & 2048 && ul(Y.alternate, Y));
                  break;
                case 24:
                  (is(U, Y, me, We, D), D && ot & 2048 && cm(Y.alternate, Y));
                  break;
                default:
                  is(U, Y, me, We, D);
              }
              f = f.sibling;
            }
          }
          function uu(c, f) {
            if (f.subtreeFlags & 10256)
              for (f = f.child; f !== null; ) {
                var x = c,
                  S = f,
                  D = S.flags;
                switch (S.tag) {
                  case 22:
                    (uu(x, S), D & 2048 && ul(S.alternate, S));
                    break;
                  case 24:
                    (uu(x, S), D & 2048 && cm(S.alternate, S));
                    break;
                  default:
                    uu(x, S);
                }
                f = f.sibling;
              }
          }
          function Za(c, f, x) {
            if (c.subtreeFlags & Is)
              for (c = c.child; c !== null; ) (fl(c, f, x), (c = c.sibling));
          }
          function fl(c, f, x) {
            switch (c.tag) {
              case 26:
                if ((Za(c, f, x), c.flags & Is))
                  if (c.memoizedState !== null)
                    qv(x, Vn, c.memoizedState, c.memoizedProps);
                  else {
                    var S = c.stateNode,
                      D = c.type;
                    ((c = c.memoizedProps),
                      ((f & 335544128) === f || xm(D, c)) && hd(x, S, D, c));
                  }
                break;
              case 5:
                (Za(c, f, x),
                  c.flags & Is &&
                    ((S = c.stateNode),
                    (D = c.type),
                    (c = c.memoizedProps),
                    ((f & 335544128) === f || xm(D, c)) && hd(x, S, D, c)));
                break;
              case 3:
              case 4:
                sa
                  ? ((S = Vn),
                    (Vn = zf(c.stateNode.containerInfo)),
                    Za(c, f, x),
                    (Vn = S))
                  : Za(c, f, x);
                break;
              case 22:
                c.memoizedState === null &&
                  ((S = c.alternate),
                  S !== null && S.memoizedState !== null
                    ? ((S = Is), (Is = 16777216), Za(c, f, x), (Is = S))
                    : Za(c, f, x));
                break;
              default:
                Za(c, f, x);
            }
          }
          function Qh(c) {
            var f = c.alternate;
            if (f !== null && ((c = f.child), c !== null)) {
              f.child = null;
              do ((f = c.sibling), (c.sibling = null), (c = f));
              while (c !== null);
            }
          }
          function fu(c) {
            var f = c.deletions;
            if ((c.flags & 16) !== 0) {
              if (f !== null)
                for (var x = 0; x < f.length; x++) {
                  var S = f[x];
                  ((Li = S), Cs(S, c));
                }
              Qh(c);
            }
            if (c.subtreeFlags & 10256)
              for (c = c.child; c !== null; ) (Jh(c), (c = c.sibling));
          }
          function Jh(c) {
            switch (c.tag) {
              case 0:
              case 11:
              case 15:
                (fu(c), c.flags & 2048 && Ya(9, c, c.return));
                break;
              case 3:
                fu(c);
                break;
              case 12:
                fu(c);
                break;
              case 22:
                var f = c.stateNode;
                c.memoizedState !== null &&
                f._visibility & 2 &&
                (c.return === null || c.return.tag !== 13)
                  ? ((f._visibility &= -3), Af(c))
                  : fu(c);
                break;
              default:
                fu(c);
            }
          }
          function Af(c) {
            var f = c.deletions;
            if ((c.flags & 16) !== 0) {
              if (f !== null)
                for (var x = 0; x < f.length; x++) {
                  var S = f[x];
                  ((Li = S), Cs(S, c));
                }
              Qh(c);
            }
            for (c = c.child; c !== null; ) {
              switch (((f = c), f.tag)) {
                case 0:
                case 11:
                case 15:
                  (Ya(8, f, f.return), Af(f));
                  break;
                case 22:
                  ((x = f.stateNode),
                    x._visibility & 2 && ((x._visibility &= -3), Af(f)));
                  break;
                default:
                  Af(f);
              }
              c = c.sibling;
            }
          }
          function Cs(c, f) {
            for (; Li !== null; ) {
              var x = Li;
              switch (x.tag) {
                case 0:
                case 11:
                case 15:
                  Ya(8, x, f);
                  break;
                case 23:
                case 22:
                  if (
                    x.memoizedState !== null &&
                    x.memoizedState.cachePool !== null
                  ) {
                    var S = x.memoizedState.cachePool.pool;
                    S != null && S.refCount++;
                  }
                  break;
                case 24:
                  _e(x.memoizedState.cache);
              }
              if (((S = x.child), S !== null)) ((S.return = x), (Li = S));
              else
                e: for (x = c; Li !== null; ) {
                  S = Li;
                  var D = S.sibling,
                    U = S.return;
                  if ((lm(S), S === x)) {
                    Li = null;
                    break e;
                  }
                  if (D !== null) {
                    ((D.return = U), (Li = D));
                    break e;
                  }
                  Li = U;
                }
            }
          }
          function hl(c) {
            var f = Jt(c);
            if (f != null) {
              if (typeof f.memoizedProps["data-testname"] != "string")
                throw Error(r(364));
              return f;
            }
            if (((c = Ri(c)), c === null)) throw Error(r(362));
            return c.stateNode.current;
          }
          function dl(c, f) {
            var x = c.tag;
            switch (f.$$typeof) {
              case da:
                if (c.type === f.value) return !0;
                break;
              case Ru:
                e: {
                  for (f = f.value, c = [c, 0], x = 0; x < c.length; ) {
                    var S = c[x++],
                      D = S.tag,
                      U = c[x++],
                      Y = f[U];
                    if ((D !== 5 && D !== 26 && D !== 27) || !bl(S)) {
                      for (; Y != null && dl(S, Y); ) (U++, (Y = f[U]));
                      if (U === f.length) {
                        f = !0;
                        break e;
                      } else
                        for (S = S.child; S !== null; )
                          (c.push(S, U), (S = S.sibling));
                    }
                  }
                  f = !1;
                }
                return f;
              case Du:
                if (
                  (x === 5 || x === 26 || x === 27) &&
                  Tm(c.stateNode, f.value)
                )
                  return !0;
                break;
              case Cl:
                if (
                  (x === 5 || x === 6 || x === 26 || x === 27) &&
                  ((c = Of(c)), c !== null && 0 <= c.indexOf(f.value))
                )
                  return !0;
                break;
              case Xf:
                if (
                  (x === 5 || x === 26 || x === 27) &&
                  ((c = c.memoizedProps["data-testname"]),
                  typeof c == "string" &&
                    c.toLowerCase() === f.value.toLowerCase())
                )
                  return !0;
                break;
              default:
                throw Error(r(365));
            }
            return !1;
          }
          function hu(c) {
            switch (c.$$typeof) {
              case da:
                return "<" + (v(c.value) || "Unknown") + ">";
              case Ru:
                return ":has(" + (hu(c) || "") + ")";
              case Du:
                return '[role="' + c.value + '"]';
              case Cl:
                return '"' + c.value + '"';
              case Xf:
                return '[data-testname="' + c.value + '"]';
              default:
                throw Error(r(365));
            }
          }
          function du(c, f) {
            var x = [];
            c = [c, 0];
            for (var S = 0; S < c.length; ) {
              var D = c[S++],
                U = D.tag,
                Y = c[S++],
                me = f[Y];
              if ((U !== 5 && U !== 26 && U !== 27) || !bl(D)) {
                for (; me != null && dl(D, me); ) (Y++, (me = f[Y]));
                if (Y === f.length) x.push(D);
                else
                  for (D = D.child; D !== null; )
                    (c.push(D, Y), (D = D.sibling));
              }
            }
            return x;
          }
          function rs(c, f) {
            if (!Qi) throw Error(r(363));
            ((c = hl(c)), (c = du(c, f)), (f = []), (c = Array.from(c)));
            for (var x = 0; x < c.length; ) {
              var S = c[x++],
                D = S.tag;
              if (D === 5 || D === 26 || D === 27) bl(S) || f.push(S.stateNode);
              else for (S = S.child; S !== null; ) (c.push(S), (S = S.sibling));
            }
            return f;
          }
          function ai() {
            return (dn & 2) !== 0 && xn !== 0
              ? xn & -xn
              : Bt.T !== null
                ? Se()
                : Su();
          }
          function Eo() {
            if (Wr === 0)
              if ((xn & 536870912) === 0 || yn) {
                var c = Ec;
                ((Ec <<= 1), (Ec & 3932160) === 0 && (Ec = 262144), (Wr = c));
              } else Wr = 536870912;
            return ((c = us.current), c !== null && (c.flags |= 32), Wr);
          }
          function hi(c, f, x) {
            (((c === ln && (Gn === 2 || Gn === 9)) ||
              c.cancelPendingCommit !== null) &&
              (_i(c, 0), Qa(c, xn, Wr, !1)),
              O(c, x),
              ((dn & 2) === 0 || c !== ln) &&
                (c === ln &&
                  ((dn & 2) === 0 && (Ll |= x), gi === 4 && Qa(c, xn, Wr, !1)),
                et(c)));
          }
          function Ea(c, f, x) {
            if ((dn & 6) !== 0) throw Error(r(327));
            var S =
                (!x && (f & 127) === 0 && (f & c.expiredLanes) === 0) ||
                C(c, f),
              D = S ? av(c, f) : Ja(c, f, !0),
              U = S;
            do {
              if (D === 0) {
                Rl && !S && Qa(c, f, 0, !1);
                break;
              } else {
                if (((x = c.current.alternate), U && !rv(x))) {
                  ((D = Ja(c, f, !1)), (U = !1));
                  continue;
                }
                if (D === 2) {
                  if (((U = f), c.errorRecoveryDisabledLanes & U)) var Y = 0;
                  else
                    ((Y = c.pendingLanes & -536870913),
                      (Y = Y !== 0 ? Y : Y & 536870912 ? 536870912 : 0));
                  if (Y !== 0) {
                    f = Y;
                    e: {
                      var me = c;
                      D = qf;
                      var We = oi && me.current.memoizedState.isDehydrated;
                      if (
                        (We && (_i(me, Y).flags |= 256),
                        (Y = Ja(me, Y, !1)),
                        Y !== 2)
                      ) {
                        if (Dl && !We) {
                          ((me.errorRecoveryDisabledLanes |= U),
                            (Ll |= U),
                            (D = 4));
                          break e;
                        }
                        ((U = hs),
                          (hs = D),
                          U !== null &&
                            (hs === null ? (hs = U) : hs.push.apply(hs, U)));
                      }
                      D = Y;
                    }
                    if (((U = !1), D !== 2)) continue;
                  }
                }
                if (D === 1) {
                  (_i(c, 0), Qa(c, f, 0, !0));
                  break;
                }
                e: {
                  switch (((S = c), (U = D), U)) {
                    case 0:
                    case 1:
                      throw Error(r(345));
                    case 4:
                      if ((f & 4194048) !== f) break;
                    case 6:
                      Qa(S, f, Wr, !Ra);
                      break e;
                    case 2:
                      hs = null;
                      break;
                    case 3:
                    case 5:
                      break;
                    default:
                      throw Error(r(329));
                  }
                  if ((f & 62914560) === f && ((D = Yf + 300 - Dr()), 10 < D)) {
                    if ((Qa(S, f, Wr, !Ra), T(S, 0, !0) !== 0)) break e;
                    ((ho = f),
                      (S.timeoutHandle = ym(
                        Ka.bind(
                          null,
                          S,
                          x,
                          hs,
                          Zf,
                          Pd,
                          f,
                          Wr,
                          Ll,
                          Nu,
                          Ra,
                          U,
                          "Throttled",
                          -0,
                          0,
                        ),
                        D,
                      )));
                    break e;
                  }
                  Ka(S, x, hs, Zf, Pd, f, Wr, Ll, Nu, Ra, U, null, -0, 0);
                }
              }
              break;
            } while (!0);
            et(c);
          }
          function Ka(c, f, x, S, D, U, Y, me, We, ot, xt, ut, Ct, Qt) {
            if (
              ((c.timeoutHandle = os),
              (ut = f.subtreeFlags),
              ut & 8192 || (ut & 16785408) === 16785408)
            ) {
              ((ut = bm()), fl(f, U, ut));
              var Ui =
                (U & 62914560) === U
                  ? Yf - Dr()
                  : (U & 4194048) === U
                    ? Nc - Dr()
                    : 0;
              if (((Ui = dv(ut, Ui)), Ui !== null)) {
                ((ho = U),
                  (c.cancelPendingCommit = Ui(
                    eo.bind(
                      null,
                      c,
                      f,
                      U,
                      x,
                      S,
                      D,
                      Y,
                      me,
                      We,
                      xt,
                      ut,
                      null,
                      Ct,
                      Qt,
                    ),
                  )),
                  Qa(c, U, Y, !ot));
                return;
              }
            }
            eo(c, f, U, x, S, D, Y, me, We);
          }
          function rv(c) {
            for (var f = c; ; ) {
              var x = f.tag;
              if (
                (x === 0 || x === 11 || x === 15) &&
                f.flags & 16384 &&
                ((x = f.updateQueue),
                x !== null && ((x = x.stores), x !== null))
              )
                for (var S = 0; S < x.length; S++) {
                  var D = x[S],
                    U = D.getSnapshot;
                  D = D.value;
                  try {
                    if (!Di(U(), D)) return !1;
                  } catch {
                    return !1;
                  }
                }
              if (((x = f.child), f.subtreeFlags & 16384 && x !== null))
                ((x.return = f), (f = x));
              else {
                if (f === c) break;
                for (; f.sibling === null; ) {
                  if (f.return === null || f.return === c) return !0;
                  f = f.return;
                }
                ((f.sibling.return = f.return), (f = f.sibling));
              }
            }
            return !0;
          }
          function Qa(c, f, x, S) {
            ((f &= ~Lu),
              (f &= ~Ll),
              (c.suspendedLanes |= f),
              (c.pingedLanes &= ~f),
              S && (c.warmLanes |= f),
              (S = c.expirationTimes));
            for (var D = f; 0 < D; ) {
              var U = 31 - ls(D),
                Y = 1 << U;
              ((S[U] = -1), (D &= ~Y));
            }
            x !== 0 && N(c, x, f);
          }
          function $h() {
            return (dn & 6) === 0 ? ($e(0), !1) : !0;
          }
          function ed() {
            if (pn !== null) {
              if (Gn === 0) var c = pn.return;
              else
                ((c = pn),
                  (Aa = Kn = null),
                  rn(c),
                  (El = null),
                  (Ac = 0),
                  (c = pn));
              for (; c !== null; ) (tv(c.alternate, c), (c = c.return));
              pn = null;
            }
          }
          function _i(c, f) {
            var x = c.timeoutHandle;
            (x !== os && ((c.timeoutHandle = os), hv(x)),
              (x = c.cancelPendingCommit),
              x !== null && ((c.cancelPendingCommit = null), x()),
              (ho = 0),
              ed(),
              (ln = c),
              (pn = x = Ds(c.current, null)),
              (xn = f),
              (Gn = 0),
              (Wi = null),
              (Ra = !1),
              (Rl = C(c, f)),
              (Dl = !1),
              (Nu = Wr = Lu = Ll = Fo = gi = 0),
              (hs = qf = null),
              (Pd = !1),
              (f & 8) !== 0 && (f |= f & 32));
            var S = c.entangledLanes;
            if (S !== 0)
              for (c = c.entanglements, S &= f; 0 < S; ) {
                var D = 31 - ls(S),
                  U = 1 << D;
                ((f |= c[D]), (S &= ~U));
              }
            return ((fo = f), Zi(), x);
          }
          function Zn(c, f) {
            (($t = null),
              (Bt.H = Ps),
              f === tr || f === fa
                ? ((f = Dt()), (Gn = 3))
                : f === Nd
                  ? ((f = Dt()), (Gn = 4))
                  : (Gn =
                      f === jr
                        ? 8
                        : f !== null &&
                            typeof f == "object" &&
                            typeof f.then == "function"
                          ? 6
                          : 1),
              (Wi = f),
              pn === null && ((gi = 1), Hh(c, le(f, c.current))));
          }
          function _n() {
            var c = us.current;
            return c === null
              ? !0
              : (xn & 4194048) === xn
                ? fs === null
                : (xn & 62914560) === xn || (xn & 536870912) !== 0
                  ? c === fs
                  : !1;
          }
          function wo() {
            var c = Bt.H;
            return ((Bt.H = Ps), c === null ? Ps : c);
          }
          function Rs() {
            var c = Bt.A;
            return ((Bt.A = Cu), c);
          }
          function pu() {
            ((gi = 4),
              Ra || ((xn & 4194048) !== xn && us.current !== null) || (Rl = !0),
              ((Fo & 134217727) === 0 && (Ll & 134217727) === 0) ||
                ln === null ||
                Qa(ln, xn, Wr, !1));
          }
          function Ja(c, f, x) {
            var S = dn;
            dn |= 2;
            var D = wo(),
              U = Rs();
            ((ln !== c || xn !== f) && ((Zf = null), _i(c, f)), (f = !1));
            var Y = gi;
            e: do
              try {
                if (Gn !== 0 && pn !== null) {
                  var me = pn,
                    We = Wi;
                  switch (Gn) {
                    case 8:
                      (ed(), (Y = 6));
                      break e;
                    case 3:
                    case 2:
                    case 9:
                    case 6:
                      us.current === null && (f = !0);
                      var ot = Gn;
                      if (((Gn = 0), (Wi = null), $a(c, me, We, ot), x && Rl)) {
                        Y = 0;
                        break e;
                      }
                      break;
                    default:
                      ((ot = Gn), (Gn = 0), (Wi = null), $a(c, me, We, ot));
                  }
                }
                (sv(), (Y = gi));
                break;
              } catch (xt) {
                Zn(c, xt);
              }
            while (!0);
            return (
              f && c.shellSuspendCounter++,
              (Aa = Kn = null),
              (dn = S),
              (Bt.H = D),
              (Bt.A = U),
              pn === null && ((ln = null), (xn = 0), Zi()),
              Y
            );
          }
          function sv() {
            for (; pn !== null; ) pl(pn);
          }
          function av(c, f) {
            var x = dn;
            dn |= 2;
            var S = wo(),
              D = Rs();
            ln !== c || xn !== f
              ? ((Zf = null), (Nl = Dr() + 500), _i(c, f))
              : (Rl = C(c, f));
            e: do
              try {
                if (Gn !== 0 && pn !== null) {
                  f = pn;
                  var U = Wi;
                  t: switch (Gn) {
                    case 1:
                      ((Gn = 0), (Wi = null), $a(c, f, U, 1));
                      break;
                    case 2:
                    case 9:
                      if (ct(U)) {
                        ((Gn = 0), (Wi = null), td(f));
                        break;
                      }
                      ((f = function () {
                        ((Gn !== 2 && Gn !== 9) || ln !== c || (Gn = 7), et(c));
                      }),
                        U.then(f, f));
                      break e;
                    case 3:
                      Gn = 7;
                      break e;
                    case 4:
                      Gn = 5;
                      break e;
                    case 7:
                      ct(U)
                        ? ((Gn = 0), (Wi = null), td(f))
                        : ((Gn = 0), (Wi = null), $a(c, f, U, 7));
                      break;
                    case 5:
                      var Y = null;
                      switch (pn.tag) {
                        case 26:
                          Y = pn.memoizedState;
                        case 5:
                        case 27:
                          var me = pn,
                            We = me.type,
                            ot = me.pendingProps;
                          if (Y ? Xm(Y) : di(me.stateNode, We, ot)) {
                            ((Gn = 0), (Wi = null));
                            var xt = me.sibling;
                            if (xt !== null) pn = xt;
                            else {
                              var ut = me.return;
                              ut !== null ? ((pn = ut), gu(ut)) : (pn = null);
                            }
                            break t;
                          }
                      }
                      ((Gn = 0), (Wi = null), $a(c, f, U, 5));
                      break;
                    case 6:
                      ((Gn = 0), (Wi = null), $a(c, f, U, 6));
                      break;
                    case 8:
                      (ed(), (gi = 6));
                      break e;
                    default:
                      throw Error(r(462));
                  }
                }
                mu();
                break;
              } catch (Ct) {
                Zn(c, Ct);
              }
            while (!0);
            return (
              (Aa = Kn = null),
              (Bt.H = S),
              (Bt.A = D),
              (dn = x),
              pn !== null ? 0 : ((ln = null), (xn = 0), Zi(), gi)
            );
          }
          function mu() {
            for (; pn !== null && !Zv(); ) pl(pn);
          }
          function pl(c) {
            var f = nm(c.alternate, c, fo);
            ((c.memoizedProps = c.pendingProps), f === null ? gu(c) : (pn = f));
          }
          function td(c) {
            var f = c,
              x = f.alternate;
            switch (f.tag) {
              case 15:
              case 0:
                f = Kp(x, f, f.pendingProps, f.type, void 0, xn);
                break;
              case 11:
                f = Kp(x, f, f.pendingProps, f.type.render, f.ref, xn);
                break;
              case 5:
                rn(f);
              default:
                (tv(x, f), (f = pn = rd(f, fo)), (f = nm(x, f, fo)));
            }
            ((c.memoizedProps = c.pendingProps), f === null ? gu(c) : (pn = f));
          }
          function $a(c, f, x, S) {
            ((Aa = Kn = null), rn(f), (El = null), (Ac = 0));
            var D = f.return;
            try {
              if (Ob(c, D, f, x, xn)) {
                ((gi = 1), Hh(c, le(x, c.current)), (pn = null));
                return;
              }
            } catch (U) {
              if (D !== null) throw ((pn = D), U);
              ((gi = 1), Hh(c, le(x, c.current)), (pn = null));
              return;
            }
            f.flags & 32768
              ? (yn || S === 1
                  ? (c = !0)
                  : Rl || (xn & 536870912) !== 0
                    ? (c = !1)
                    : ((Ra = c = !0),
                      (S === 2 || S === 9 || S === 3 || S === 6) &&
                        ((S = us.current),
                        S !== null && S.tag === 13 && (S.flags |= 16384))),
                ml(f, c))
              : gu(f);
          }
          function gu(c) {
            var f = c;
            do {
              if ((f.flags & 32768) !== 0) {
                ml(f, Ra);
                return;
              }
              c = f.return;
              var x = ev(f.alternate, f, fo);
              if (x !== null) {
                pn = x;
                return;
              }
              if (((f = f.sibling), f !== null)) {
                pn = f;
                return;
              }
              pn = f = c;
            } while (f !== null);
            gi === 0 && (gi = 5);
          }
          function ml(c, f) {
            do {
              var x = sm(c.alternate, c);
              if (x !== null) {
                ((x.flags &= 32767), (pn = x));
                return;
              }
              if (
                ((x = c.return),
                x !== null &&
                  ((x.flags |= 32768),
                  (x.subtreeFlags = 0),
                  (x.deletions = null)),
                !f && ((c = c.sibling), c !== null))
              ) {
                pn = c;
                return;
              }
              pn = c = x;
            } while (c !== null);
            ((gi = 6), (pn = null));
          }
          function eo(c, f, x, S, D, U, Y, me, We) {
            c.cancelPendingCommit = null;
            do no();
            while (Xi !== 0);
            if ((dn & 6) !== 0) throw Error(r(327));
            if (f !== null) {
              if (f === c.current) throw Error(r(177));
              if (
                ((U = f.lanes | f.childLanes),
                (U |= Cc),
                B(c, x, U, Y, me, We),
                c === ln && ((pn = ln = null), (xn = 0)),
                (Uc = f),
                (Bo = c),
                (ho = x),
                (Uu = U),
                (Id = D),
                (tg = S),
                (f.subtreeFlags & 10256) !== 0 || (f.flags & 10256) !== 0
                  ? ((c.callbackNode = null),
                    (c.callbackPriority = 0),
                    Hi(kf, function () {
                      return (Cf(), null);
                    }))
                  : ((c.callbackNode = null), (c.callbackPriority = 0)),
                (S = (f.flags & 13878) !== 0),
                (f.subtreeFlags & 13878) !== 0 || S)
              ) {
                ((S = Bt.T),
                  (Bt.T = null),
                  (D = ra()),
                  vn(2),
                  (Y = dn),
                  (dn |= 4));
                try {
                  Fb(c, f, x);
                } finally {
                  ((dn = Y), vn(D), (Bt.T = S));
                }
              }
              ((Xi = 1), Ao(), to(), nd());
            }
          }
          function Ao() {
            if (Xi === 1) {
              Xi = 0;
              var c = Bo,
                f = Uc,
                x = (f.flags & 13878) !== 0;
              if ((f.subtreeFlags & 13878) !== 0 || x) {
                ((x = Bt.T), (Bt.T = null));
                var S = ra();
                vn(2);
                var D = dn;
                dn |= 4;
                try {
                  (wf(f, c), fv(c.containerInfo));
                } finally {
                  ((dn = D), vn(S), (Bt.T = x));
                }
              }
              ((c.current = f), (Xi = 2));
            }
          }
          function to() {
            if (Xi === 2) {
              Xi = 0;
              var c = Bo,
                f = Uc,
                x = (f.flags & 8772) !== 0;
              if ((f.subtreeFlags & 8772) !== 0 || x) {
                ((x = Bt.T), (Bt.T = null));
                var S = ra();
                vn(2);
                var D = dn;
                dn |= 4;
                try {
                  iv(c, f.alternate, f);
                } finally {
                  ((dn = D), vn(S), (Bt.T = x));
                }
              }
              Xi = 3;
            }
          }
          function nd() {
            if (Xi === 4 || Xi === 3) {
              ((Xi = 0), Ym());
              var c = Bo,
                f = Uc,
                x = ho,
                S = tg;
              (f.subtreeFlags & 10256) !== 0 || (f.flags & 10256) !== 0
                ? (Xi = 5)
                : ((Xi = 0), (Uc = Bo = null), id(c, c.pendingLanes));
              var D = c.pendingLanes;
              if (
                (D === 0 && (zo = null),
                X(x),
                (f = f.stateNode),
                cs && typeof cs.onCommitFiberRoot == "function")
              )
                try {
                  cs.onCommitFiberRoot(
                    wc,
                    f,
                    void 0,
                    (f.current.flags & 128) === 128,
                  );
                } catch {}
              if (S !== null) {
                ((f = Bt.T), (D = ra()), vn(2), (Bt.T = null));
                try {
                  for (var U = c.onRecoverableError, Y = 0; Y < S.length; Y++) {
                    var me = S[Y];
                    U(me.value, { componentStack: me.stack });
                  }
                } finally {
                  ((Bt.T = f), vn(D));
                }
              }
              ((ho & 3) !== 0 && no(),
                et(c),
                (D = c.pendingLanes),
                (x & 261930) !== 0 && (D & 42) !== 0
                  ? c === Kf
                    ? Rn++
                    : ((Rn = 0), (Kf = c))
                  : (Rn = 0),
                oi && Ff(),
                $e(0));
            }
          }
          function id(c, f) {
            (c.pooledCacheLanes &= f) === 0 &&
              ((f = c.pooledCache),
              f != null && ((c.pooledCache = null), _e(f)));
          }
          function no() {
            return (Ao(), to(), nd(), Cf());
          }
          function Cf() {
            if (Xi !== 5) return !1;
            var c = Bo,
              f = Uu;
            Uu = 0;
            var x = X(ho),
              S = 32 > x ? 32 : x;
            x = Bt.T;
            var D = ra();
            try {
              (vn(S), (Bt.T = null), (S = Id), (Id = null));
              var U = Bo,
                Y = ho;
              if (((Xi = 0), (Uc = Bo = null), (ho = 0), (dn & 6) !== 0))
                throw Error(r(331));
              var me = dn;
              if (
                ((dn |= 4),
                Jh(U.current),
                Kh(U, U.current, Y, S),
                (dn = me),
                $e(0, !1),
                cs && typeof cs.onPostCommitFiberRoot == "function")
              )
                try {
                  cs.onPostCommitFiberRoot(wc, U);
                } catch {}
              return !0;
            } finally {
              (vn(D), (Bt.T = x), id(c, f));
            }
          }
          function gl(c, f, x) {
            ((f = le(x, f)),
              (f = Yp(c.stateNode, f, 2)),
              (c = es(c, f, 2)),
              c !== null && (O(c, 2), et(c)));
          }
          function Xt(c, f, x) {
            if (c.tag === 3) gl(c, c, x);
            else
              for (; f !== null; ) {
                if (f.tag === 3) {
                  gl(f, c, x);
                  break;
                } else if (f.tag === 1) {
                  var S = f.stateNode;
                  if (
                    typeof f.type.getDerivedStateFromError == "function" ||
                    (typeof S.componentDidCatch == "function" &&
                      (zo === null || !zo.has(S)))
                  ) {
                    ((c = le(x, c)),
                      (x = G0(2)),
                      (S = es(f, x, 2)),
                      S !== null && (H0(x, S, f, c), O(S, 2), et(S)));
                    break;
                  }
                }
                f = f.return;
              }
          }
          function vu(c, f, x) {
            var S = c.pingCache;
            if (S === null) {
              S = c.pingCache = new Os();
              var D = new Set();
              S.set(f, D);
            } else
              ((D = S.get(f)), D === void 0 && ((D = new Set()), S.set(f, D)));
            D.has(x) ||
              ((Dl = !0), D.add(x), (c = ov.bind(null, c, f, x)), f.then(c, c));
          }
          function ov(c, f, x) {
            var S = c.pingCache;
            (S !== null && S.delete(f),
              (c.pingedLanes |= c.suspendedLanes & x),
              (c.warmLanes &= ~x),
              ln === c &&
                (xn & x) === x &&
                (gi === 4 ||
                (gi === 3 && (xn & 62914560) === xn && 300 > Dr() - Yf)
                  ? (dn & 2) === 0 && _i(c, 0)
                  : (Lu |= x),
                Nu === xn && (Nu = 0)),
              et(c));
          }
          function lv(c, f) {
            (f === 0 && (f = L()),
              (c = xi(c, f)),
              c !== null && (O(c, f), et(c)));
          }
          function zb(c) {
            var f = c.memoizedState,
              x = 0;
            (f !== null && (x = f.retryLane), lv(c, x));
          }
          function Bb(c, f) {
            var x = 0;
            switch (c.tag) {
              case 31:
              case 13:
                var S = c.stateNode,
                  D = c.memoizedState;
                D !== null && (x = D.retryLane);
                break;
              case 19:
                S = c.stateNode;
                break;
              case 22:
                S = c.stateNode._retryCache;
                break;
              default:
                throw Error(r(314));
            }
            (S !== null && S.delete(f), lv(c, x));
          }
          function Hi(c, f) {
            return Bf(c, f);
          }
          function um(c, f, x, S) {
            ((this.tag = c),
              (this.key = x),
              (this.sibling =
                this.child =
                this.return =
                this.stateNode =
                this.type =
                this.elementType =
                  null),
              (this.index = 0),
              (this.refCleanup = this.ref = null),
              (this.pendingProps = f),
              (this.dependencies =
                this.memoizedState =
                this.updateQueue =
                this.memoizedProps =
                  null),
              (this.mode = S),
              (this.subtreeFlags = this.flags = 0),
              (this.deletions = null),
              (this.childLanes = this.lanes = 0),
              (this.alternate = null));
          }
          function dc(c) {
            return ((c = c.prototype), !(!c || !c.isReactComponent));
          }
          function Ds(c, f) {
            var x = c.alternate;
            return (
              x === null
                ? ((x = t(c.tag, f, c.key, c.mode)),
                  (x.elementType = c.elementType),
                  (x.type = c.type),
                  (x.stateNode = c.stateNode),
                  (x.alternate = c),
                  (c.alternate = x))
                : ((x.pendingProps = f),
                  (x.type = c.type),
                  (x.flags = 0),
                  (x.subtreeFlags = 0),
                  (x.deletions = null)),
              (x.flags = c.flags & 65011712),
              (x.childLanes = c.childLanes),
              (x.lanes = c.lanes),
              (x.child = c.child),
              (x.memoizedProps = c.memoizedProps),
              (x.memoizedState = c.memoizedState),
              (x.updateQueue = c.updateQueue),
              (f = c.dependencies),
              (x.dependencies =
                f === null
                  ? null
                  : { lanes: f.lanes, firstContext: f.firstContext }),
              (x.sibling = c.sibling),
              (x.index = c.index),
              (x.ref = c.ref),
              (x.refCleanup = c.refCleanup),
              x
            );
          }
          function rd(c, f) {
            c.flags &= 65011714;
            var x = c.alternate;
            return (
              x === null
                ? ((c.childLanes = 0),
                  (c.lanes = f),
                  (c.child = null),
                  (c.subtreeFlags = 0),
                  (c.memoizedProps = null),
                  (c.memoizedState = null),
                  (c.updateQueue = null),
                  (c.dependencies = null),
                  (c.stateNode = null))
                : ((c.childLanes = x.childLanes),
                  (c.lanes = x.lanes),
                  (c.child = x.child),
                  (c.subtreeFlags = 0),
                  (c.deletions = null),
                  (c.memoizedProps = x.memoizedProps),
                  (c.memoizedState = x.memoizedState),
                  (c.updateQueue = x.updateQueue),
                  (c.type = x.type),
                  (f = x.dependencies),
                  (c.dependencies =
                    f === null
                      ? null
                      : { lanes: f.lanes, firstContext: f.firstContext })),
              c
            );
          }
          function Co(c, f, x, S, D, U) {
            var Y = 0;
            if (((S = c), typeof c == "function")) dc(c) && (Y = 1);
            else if (typeof c == "string")
              Y =
                sa && Ji
                  ? xd(c, x, ur.current)
                    ? 26
                    : qm(c)
                      ? 27
                      : 5
                  : sa
                    ? xd(c, x, ur.current)
                      ? 26
                      : 5
                    : Ji && qm(c)
                      ? 27
                      : 5;
            else
              e: switch (c) {
                case Nf:
                  return (
                    (c = t(31, x, f, D)),
                    (c.elementType = Nf),
                    (c.lanes = U),
                    c
                  );
                case vc:
                  return na(x.children, D, U, f);
                case yc:
                  ((Y = 8), (D |= 24));
                  break;
                case xc:
                  return (
                    (c = t(12, x, f, D | 2)),
                    (c.elementType = xc),
                    (c.lanes = U),
                    c
                  );
                case ld:
                  return (
                    (c = t(13, x, f, D)),
                    (c.elementType = ld),
                    (c.lanes = U),
                    c
                  );
                case Ro:
                  return (
                    (c = t(19, x, f, D)),
                    (c.elementType = Ro),
                    (c.lanes = U),
                    c
                  );
                default:
                  if (typeof c == "object" && c !== null)
                    switch (c.$$typeof) {
                      case ia:
                        Y = 10;
                        break e;
                      case Lf:
                        Y = 9;
                        break e;
                      case yu:
                        Y = 11;
                        break e;
                      case cd:
                        Y = 14;
                        break e;
                      case kr:
                        ((Y = 16), (S = null));
                        break e;
                    }
                  ((Y = 29),
                    (x = Error(r(130, c === null ? "null" : typeof c, ""))),
                    (S = null));
              }
            return (
              (f = t(Y, x, f, D)),
              (f.elementType = c),
              (f.type = S),
              (f.lanes = U),
              f
            );
          }
          function na(c, f, x, S) {
            return ((c = t(7, c, S, f)), (c.lanes = x), c);
          }
          function fm(c, f, x) {
            return ((c = t(6, c, null, f)), (c.lanes = x), c);
          }
          function hm(c) {
            var f = t(18, null, null, 0);
            return ((f.stateNode = c), f);
          }
          function dm(c, f, x) {
            return (
              (f = t(4, c.children !== null ? c.children : [], c.key, f)),
              (f.lanes = x),
              (f.stateNode = {
                containerInfo: c.containerInfo,
                pendingChildren: null,
                implementation: c.implementation,
              }),
              f
            );
          }
          function cv(c, f, x, S, D, U, Y, me, We) {
            ((this.tag = 1),
              (this.containerInfo = c),
              (this.pingCache = this.current = this.pendingChildren = null),
              (this.timeoutHandle = os),
              (this.callbackNode =
                this.next =
                this.pendingContext =
                this.context =
                this.cancelPendingCommit =
                  null),
              (this.callbackPriority = 0),
              (this.expirationTimes = I(-1)),
              (this.entangledLanes =
                this.shellSuspendCounter =
                this.errorRecoveryDisabledLanes =
                this.expiredLanes =
                this.warmLanes =
                this.pingedLanes =
                this.suspendedLanes =
                this.pendingLanes =
                  0),
              (this.entanglements = I(0)),
              (this.hiddenUpdates = I(null)),
              (this.identifierPrefix = S),
              (this.onUncaughtError = D),
              (this.onCaughtError = U),
              (this.onRecoverableError = Y),
              (this.pooledCache = null),
              (this.pooledCacheLanes = 0),
              (this.formState = We),
              (this.incompleteTransitions = new Map()));
          }
          function vl(c, f, x, S, D, U, Y, me, We, ot, xt, ut) {
            return (
              (c = new cv(c, f, x, Y, We, ot, xt, ut, me)),
              (f = 1),
              U === !0 && (f |= 24),
              (U = t(3, null, null, f)),
              (c.current = U),
              (U.stateNode = c),
              (f = Ae()),
              f.refCount++,
              (c.pooledCache = f),
              f.refCount++,
              (U.memoizedState = { element: S, isDehydrated: x, cache: f }),
              ii(U),
              c
            );
          }
          function sd(c) {
            return c ? ((c = ro), c) : ro;
          }
          function Rf(c) {
            var f = c._reactInternals;
            if (f === void 0)
              throw typeof c.render == "function"
                ? Error(r(188))
                : ((c = Object.keys(c).join(",")), Error(r(268, c)));
            return (
              (c = u(f)),
              (c = c !== null ? h(c) : null),
              c === null ? null : bu(c.stateNode)
            );
          }
          function pm(c, f, x, S, D, U) {
            ((D = sd(D)),
              S.context === null ? (S.context = D) : (S.pendingContext = D),
              (S = gr(f)),
              (S.payload = { element: x }),
              (U = U === void 0 ? null : U),
              U !== null && (S.callback = U),
              (x = es(c, S, f)),
              x !== null && (hi(x, c, f), _s(x, c, f)));
          }
          function pc(c, f) {
            if (((c = c.memoizedState), c !== null && c.dehydrated !== null)) {
              var x = c.retryLane;
              c.retryLane = x !== 0 && x < f ? x : f;
            }
          }
          function Df(c, f) {
            (pc(c, f), (c = c.alternate) && pc(c, f));
          }
          var an = {},
            ad = M0,
            ss = z9,
            od = Object.assign,
            mc = Symbol.for("react.element"),
            io = Symbol.for("react.transitional.element"),
            gc = Symbol.for("react.portal"),
            vc = Symbol.for("react.fragment"),
            yc = Symbol.for("react.strict_mode"),
            xc = Symbol.for("react.profiler"),
            Lf = Symbol.for("react.consumer"),
            ia = Symbol.for("react.context"),
            yu = Symbol.for("react.forward_ref"),
            ld = Symbol.for("react.suspense"),
            Ro = Symbol.for("react.suspense_list"),
            cd = Symbol.for("react.memo"),
            kr = Symbol.for("react.lazy"),
            Nf = Symbol.for("react.activity"),
            mm = Symbol.for("react.memo_cache_sentinel"),
            Do = Symbol.iterator,
            yl = Symbol.for("react.client.reference"),
            xl = Array.isArray,
            Bt =
              ad.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
            gm = e.rendererVersion,
            Uf = e.rendererPackageName,
            xu = e.extraDevToolsConfig,
            bu = e.getPublicInstance,
            uv = e.getRootHostContext,
            _u = e.getChildHostContext,
            ud = e.prepareForCommit,
            fv = e.resetAfterCommit,
            vm = e.createInstance;
          e.cloneMutableInstance;
          var Pf = e.appendInitialChild,
            as = e.finalizeInitialChildren,
            Vr = e.shouldSetTextContent,
            Lo = e.createTextInstance;
          e.cloneMutableTextInstance;
          var ym = e.scheduleTimeout,
            hv = e.cancelTimeout,
            os = e.noTimeout,
            Ci = e.isPrimaryRenderer;
          e.warnsIfNotActing;
          var Sn = e.supportsMutation,
            Ls = e.supportsPersistence,
            oi = e.supportsHydration,
            Jt = e.getInstanceFromNode;
          e.beforeActiveInstanceBlur;
          var jn = e.preparePortalMount;
          (e.prepareScopeUpdate, e.getInstanceFromScope);
          var vn = e.setCurrentUpdatePriority,
            ra = e.getCurrentUpdatePriority,
            Su = e.resolveUpdatePriority;
          (e.trackSchedulerEvent, e.resolveEventType, e.resolveEventTimeStamp);
          var bc = e.shouldAttemptEagerTransition,
            fd = e.detachDeletedInstance;
          e.requestPostPaintCallback;
          var If = e.maySuspendCommit,
            Mu = e.maySuspendCommitOnUpdate,
            xm = e.maySuspendCommitInSyncRender,
            di = e.preloadInstance,
            bm = e.startSuspendingCommit,
            hd = e.suspendInstance;
          e.suspendOnActiveViewTransition;
          var dv = e.waitForCommitToBeReady;
          e.getSuspendedCommitReason;
          var _c = e.NotPendingTransition,
            Sc = e.HostTransitionContext,
            _m = e.resetFormInstance;
          e.bindToConsole;
          var Sm = e.supportsMicrotasks,
            Mm = e.scheduleMicrotask,
            Qi = e.supportsTestSelectors,
            Ri = e.findFiberRoot,
            dd = e.getBoundingRect,
            Of = e.getTextContent,
            bl = e.isHiddenSubtree,
            Tm = e.matchAccessibilityRole,
            No = e.setFocusIfFocusable,
            pd = e.setupIntersectionObserver,
            Em = e.appendChild,
            wm = e.appendChildToContainer,
            pv = e.commitTextUpdate,
            mv = e.commitMount,
            gv = e.commitUpdate,
            vv = e.insertBefore,
            yv = e.insertInContainerBefore,
            xv = e.removeChild,
            Am = e.removeChildFromContainer,
            Cm = e.resetTextContent,
            kb = e.hideInstance,
            bv = e.hideTextInstance,
            _v = e.unhideInstance,
            Sv = e.unhideTextInstance;
          (e.cancelViewTransitionName,
            e.cancelRootViewTransitionName,
            e.restoreRootViewTransitionName,
            e.cloneRootViewTransitionContainer,
            e.removeRootViewTransitionClone,
            e.measureClonedInstance,
            e.hasInstanceChanged,
            e.hasInstanceAffectedParent,
            e.startViewTransition,
            e.startGestureTransition,
            e.stopViewTransition,
            e.getCurrentGestureOffset,
            e.createViewTransitionInstance);
          var Rm = e.clearContainer;
          (e.createFragmentInstance,
            e.updateFragmentInstanceFiber,
            e.commitNewChildToFragmentInstance,
            e.deleteChildFromFragmentInstance);
          var Mv = e.cloneInstance,
            Dm = e.createContainerChildSet,
            Lm = e.appendChildToContainerChildSet,
            Tv = e.finalizeContainerChildren,
            Nm = e.replaceContainerChildren,
            Ev = e.cloneHiddenInstance,
            Um = e.cloneHiddenTextInstance,
            _l = e.isSuspenseInstancePending,
            md = e.isSuspenseInstanceFallback,
            gd = e.getSuspenseInstanceFallbackErrorDetails,
            vd = e.registerSuspenseInstanceRetry,
            wv = e.canHydrateFormStateMarker,
            Pm = e.isFormStateMarkerMatching,
            Av = e.getNextHydratableSibling,
            Cv = e.getNextHydratableSiblingAfterSingleton,
            Rv = e.getFirstHydratableChild,
            Dv = e.getFirstHydratableChildWithinContainer,
            Lv = e.getFirstHydratableChildWithinActivityInstance,
            Nv = e.getFirstHydratableChildWithinSuspenseInstance,
            Im = e.getFirstHydratableChildWithinSingleton,
            Uv = e.canHydrateInstance,
            Pv = e.canHydrateTextInstance,
            Om = e.canHydrateActivityInstance,
            Iv = e.canHydrateSuspenseInstance,
            Ov = e.hydrateInstance,
            Vb = e.hydrateTextInstance,
            Fm = e.hydrateActivityInstance,
            Fv = e.hydrateSuspenseInstance,
            zv = e.getNextHydratableInstanceAfterActivityInstance,
            zm = e.getNextHydratableInstanceAfterSuspenseInstance,
            Bv = e.commitHydratedInstance,
            kv = e.commitHydratedContainer,
            Gb = e.commitHydratedActivityInstance,
            Hb = e.commitHydratedSuspenseInstance,
            Vv = e.finalizeHydratedChildren,
            Ff = e.flushHydrationEvents;
          e.clearActivityBoundary;
          var Bm = e.clearSuspenseBoundary;
          e.clearActivityBoundaryFromContainer;
          var yd = e.clearSuspenseBoundaryFromContainer,
            Gv = e.hideDehydratedBoundary,
            Hv = e.unhideDehydratedBoundary,
            Tu = e.shouldDeleteUnhydratedTailInstances;
          (e.diffHydratedPropsForDevWarnings,
            e.diffHydratedTextForDevWarnings,
            e.describeHydratableInstanceForDevWarnings);
          var jv = e.validateHydratableInstance,
            km = e.validateHydratableTextInstance,
            sa = e.supportsResources,
            xd = e.isHostHoistableType,
            zf = e.getHoistableRoot,
            Vm = e.getResource,
            Gm = e.acquireResource,
            Sl = e.releaseResource,
            Wv = e.hydrateHoistable,
            Hm = e.mountHoistable,
            jm = e.unmountHoistable,
            bd = e.createHoistableInstance,
            Xv = e.prepareToCommitHoistables,
            Wm = e.mayResourceSuspendCommit,
            Xm = e.preloadResource,
            qv = e.suspendResource,
            Ji = e.supportsSingletons,
            _d = e.resolveSingletonInstance,
            ji = e.acquireSingletonInstance,
            cr = e.releaseSingletonInstance,
            qm = e.isHostSingletonType,
            Mc = e.isSingletonScope,
            Sd = [],
            Tc = -1,
            ro = {},
            ls = Math.clz32 ? Math.clz32 : w,
            Md = Math.log,
            Yv = Math.LN2,
            Td = 256,
            Ec = 262144,
            Eu = 4194304,
            Bf = ss.unstable_scheduleCallback,
            Ed = ss.unstable_cancelCallback,
            Zv = ss.unstable_shouldYield,
            Ym = ss.unstable_requestPaint,
            Dr = ss.unstable_now,
            wd = ss.unstable_ImmediatePriority,
            Kv = ss.unstable_UserBlockingPriority,
            kf = ss.unstable_NormalPriority,
            Ad = ss.unstable_IdlePriority,
            Zm = ss.log,
            Qv = ss.unstable_setDisableYieldValue,
            wc = null,
            cs = null,
            Di = typeof Object.is == "function" ? Object.is : ee,
            Cd =
              typeof reportError == "function"
                ? reportError
                : function (c) {
                    if (
                      typeof window == "object" &&
                      typeof window.ErrorEvent == "function"
                    ) {
                      var f = new window.ErrorEvent("error", {
                        bubbles: !0,
                        cancelable: !0,
                        message:
                          typeof c == "object" &&
                          c !== null &&
                          typeof c.message == "string"
                            ? String(c.message)
                            : String(c),
                        error: c,
                      });
                      if (!window.dispatchEvent(f)) return;
                    } else if (
                      typeof process == "object" &&
                      typeof process.emit == "function"
                    ) {
                      process.emit("uncaughtException", c);
                      return;
                    }
                    console.error(c);
                  },
            jb = Object.prototype.hasOwnProperty,
            Rd,
            so,
            Vf = !1,
            Km = new WeakMap(),
            Uo = [],
            ao = 0,
            Wn = null,
            Gf = 0,
            aa = [],
            Ns = 0,
            oa = null,
            xr = 1,
            wa = "",
            ur = y(null),
            Po = y(null),
            br = y(null),
            Hf = y(null),
            $i = null,
            li = null,
            yn = !1,
            oo = null,
            Gr = !1,
            Dd = Error(r(519)),
            la = y(null),
            Kn = null,
            Aa = null,
            Jv =
              typeof AbortController < "u"
                ? AbortController
                : function () {
                    var c = [],
                      f = (this.signal = {
                        aborted: !1,
                        addEventListener: function (x, S) {
                          c.push(S);
                        },
                      });
                    this.abort = function () {
                      ((f.aborted = !0),
                        c.forEach(function (x) {
                          return x();
                        }));
                    };
                  },
            fr = ss.unstable_scheduleCallback,
            Wb = ss.unstable_NormalPriority,
            ci = {
              $$typeof: ia,
              Consumer: null,
              Provider: null,
              _currentValue: null,
              _currentValue2: null,
              _threadCount: 0,
            },
            jf = null,
            kn = null,
            Lr = !1,
            ca = !1,
            Ld = !1,
            Ml = 0,
            wu = null,
            Qm = 0,
            Io = 0,
            er = null,
            ua = Bt.S;
          Bt.S = function (c, f) {
            ((Nc = Dr()),
              typeof f == "object" &&
                f !== null &&
                typeof f.then == "function" &&
                lt(c, f),
              ua !== null && ua(c, f));
          };
          var Tl = y(null),
            tr = Error(r(460)),
            Nd = Error(r(474)),
            fa = Error(r(542)),
            lo = { then: function () {} },
            Hr = null,
            El = null,
            Ac = 0,
            _r = $r(!0),
            Jm = $r(!1),
            Sr = [],
            co = 0,
            Cc = 0,
            Us = !1,
            Ud = !1,
            Rc = y(null),
            wl = y(0),
            us = y(null),
            fs = null,
            Si = y(0),
            Oo = 0,
            $t = null,
            Ot = null,
            Zt = null,
            on = !1,
            sn = !1,
            Mn = !1,
            Nr = 0,
            ha = 0,
            Ca = null,
            $m = 0,
            Ps = {
              readContext: H,
              use: Bi,
              useCallback: gt,
              useContext: gt,
              useEffect: gt,
              useImperativeHandle: gt,
              useLayoutEffect: gt,
              useInsertionEffect: gt,
              useMemo: gt,
              useReducer: gt,
              useRef: gt,
              useState: gt,
              useDebugValue: gt,
              useDeferredValue: gt,
              useTransition: gt,
              useSyncExternalStore: gt,
              useId: gt,
              useHostTransitionStatus: gt,
              useFormState: gt,
              useActionState: gt,
              useOptimistic: gt,
              useMemoCache: gt,
              useCacheRefresh: gt,
            };
          Ps.useEffectEvent = gt;
          var pi = {
              readContext: H,
              use: Bi,
              useCallback: function (c, f) {
                return ((mn().memoizedState = [c, f === void 0 ? null : f]), c);
              },
              useContext: H,
              useEffect: il,
              useImperativeHandle: function (c, f, x) {
                ((x = x != null ? x.concat([c]) : null),
                  Sa(4194308, 4, Ha.bind(null, f, c), x));
              },
              useLayoutEffect: function (c, f) {
                return Sa(4194308, 4, c, f);
              },
              useInsertionEffect: function (c, f) {
                Sa(4, 2, c, f);
              },
              useMemo: function (c, f) {
                var x = mn();
                f = f === void 0 ? null : f;
                var S = c();
                if (Mn) {
                  J(!0);
                  try {
                    c();
                  } finally {
                    J(!1);
                  }
                }
                return ((x.memoizedState = [S, f]), S);
              },
              useReducer: function (c, f, x) {
                var S = mn();
                if (x !== void 0) {
                  var D = x(f);
                  if (Mn) {
                    J(!0);
                    try {
                      x(f);
                    } finally {
                      J(!1);
                    }
                  }
                } else D = f;
                return (
                  (S.memoizedState = S.baseState = D),
                  (c = {
                    pending: null,
                    lanes: 0,
                    dispatch: null,
                    lastRenderedReducer: c,
                    lastRenderedState: D,
                  }),
                  (S.queue = c),
                  (c = c.dispatch = Cr.bind(null, $t, c)),
                  [S.memoizedState, c]
                );
              },
              useRef: function (c) {
                var f = mn();
                return ((c = { current: c }), (f.memoizedState = c));
              },
              useState: function (c) {
                c = el(c);
                var f = c.queue,
                  x = Ta.bind(null, $t, f);
                return ((f.dispatch = x), [c.memoizedState, x]);
              },
              useDebugValue: al,
              useDeferredValue: function (c, f) {
                var x = mn();
                return Gi(x, c, f);
              },
              useTransition: function () {
                var c = el(!1);
                return (
                  (c = ac.bind(null, $t, c.queue, !0, !1)),
                  (mn().memoizedState = c),
                  [!1, c]
                );
              },
              useSyncExternalStore: function (c, f, x) {
                var S = $t,
                  D = mn();
                if (yn) {
                  if (x === void 0) throw Error(r(407));
                  x = x();
                } else {
                  if (((x = f()), ln === null)) throw Error(r(349));
                  (xn & 127) !== 0 || ri(S, f, x);
                }
                D.memoizedState = x;
                var U = { value: x, getSnapshot: f };
                return (
                  (D.queue = U),
                  il(ns.bind(null, S, U, c), [c]),
                  (S.flags |= 2048),
                  Ar(9, { destroy: void 0 }, Or.bind(null, S, U, x, f), null),
                  x
                );
              },
              useId: function () {
                var c = mn(),
                  f = ln.identifierPrefix;
                if (yn) {
                  var x = wa,
                    S = xr;
                  ((x = (S & ~(1 << (32 - ls(S) - 1))).toString(32) + x),
                    (f = "_" + f + "R_" + x),
                    (x = Nr++),
                    0 < x && (f += "H" + x.toString(32)),
                    (f += "_"));
                } else
                  ((x = $m++), (f = "_" + f + "r_" + x.toString(32) + "_"));
                return (c.memoizedState = f);
              },
              useHostTransitionStatus: nu,
              useFormState: tl,
              useActionState: tl,
              useOptimistic: function (c) {
                var f = mn();
                f.memoizedState = f.baseState = c;
                var x = {
                  pending: null,
                  lanes: 0,
                  dispatch: null,
                  lastRenderedReducer: null,
                  lastRenderedState: null,
                };
                return (
                  (f.queue = x),
                  (f = kh.bind(null, $t, !0, x)),
                  (x.dispatch = f),
                  [c, f]
                );
              },
              useMemoCache: ki,
              useCacheRefresh: function () {
                return (mn().memoizedState = As.bind(null, $t));
              },
              useEffectEvent: function (c) {
                var f = mn(),
                  x = { impl: c };
                return (
                  (f.memoizedState = x),
                  function () {
                    if ((dn & 2) !== 0) throw Error(r(440));
                    return x.impl.apply(void 0, arguments);
                  }
                );
              },
            },
            uo = {
              readContext: H,
              use: Bi,
              useCallback: ja,
              useContext: H,
              useEffect: Ks,
              useImperativeHandle: sl,
              useInsertionEffect: Ma,
              useLayoutEffect: So,
              useMemo: Wa,
              useReducer: Ki,
              useRef: sc,
              useState: function () {
                return Ki(ei);
              },
              useDebugValue: al,
              useDeferredValue: function (c, f) {
                var x = vt();
                return vf(x, Ot.memoizedState, c, f);
              },
              useTransition: function () {
                var c = Ki(ei)[0],
                  f = vt().memoizedState;
                return [typeof c == "boolean" ? c : Pt(c), f];
              },
              useSyncExternalStore: Vi,
              useId: iu,
              useHostTransitionStatus: nu,
              useFormState: Va,
              useActionState: Va,
              useOptimistic: function (c, f) {
                var x = vt();
                return Ys(x, Ot, c, f);
              },
              useMemoCache: ki,
              useCacheRefresh: vr,
            };
          uo.useEffectEvent = si;
          var Al = {
            readContext: H,
            use: Bi,
            useCallback: ja,
            useContext: H,
            useEffect: Ks,
            useImperativeHandle: sl,
            useInsertionEffect: Ma,
            useLayoutEffect: So,
            useMemo: Wa,
            useReducer: qn,
            useRef: sc,
            useState: function () {
              return qn(ei);
            },
            useDebugValue: al,
            useDeferredValue: function (c, f) {
              var x = vt();
              return Ot === null ? Gi(x, c, f) : vf(x, Ot.memoizedState, c, f);
            },
            useTransition: function () {
              var c = qn(ei)[0],
                f = vt().memoizedState;
              return [typeof c == "boolean" ? c : Pt(c), f];
            },
            useSyncExternalStore: Vi,
            useId: iu,
            useHostTransitionStatus: nu,
            useFormState: Ga,
            useActionState: Ga,
            useOptimistic: function (c, f) {
              var x = vt();
              return Ot !== null
                ? Ys(x, Ot, c, f)
                : ((x.baseState = c), [c, x.queue.dispatch]);
            },
            useMemoCache: ki,
            useCacheRefresh: vr,
          };
          Al.useEffectEvent = si;
          var Wf = {
              enqueueSetState: function (c, f, x) {
                c = c._reactInternals;
                var S = ai(),
                  D = gr(S);
                ((D.payload = f),
                  x != null && (D.callback = x),
                  (f = es(c, D, S)),
                  f !== null && (hi(f, c, S), _s(f, c, S)));
              },
              enqueueReplaceState: function (c, f, x) {
                c = c._reactInternals;
                var S = ai(),
                  D = gr(S);
                ((D.tag = 1),
                  (D.payload = f),
                  x != null && (D.callback = x),
                  (f = es(c, D, S)),
                  f !== null && (hi(f, c, S), _s(f, c, S)));
              },
              enqueueForceUpdate: function (c, f) {
                c = c._reactInternals;
                var x = ai(),
                  S = gr(x);
                ((S.tag = 2),
                  f != null && (S.callback = f),
                  (f = es(c, S, x)),
                  f !== null && (hi(f, c, x), _s(f, c, x)));
              },
            },
            jr = Error(r(461)),
            ti = !1,
            Dc = {
              dehydrated: null,
              treeContext: null,
              retryLane: 0,
              hydrationErrors: null,
            },
            Mi = !1,
            Ti = !1,
            Au = !1,
            eg = typeof WeakSet == "function" ? WeakSet : Set,
            Li = null,
            mi = null,
            Ni = !1,
            Vn = null,
            Is = 8192,
            Cu = {
              getCacheForType: function (c) {
                var f = H(ci),
                  x = f.data.get(c);
                return (x === void 0 && ((x = c()), f.data.set(c, x)), x);
              },
              cacheSignal: function () {
                return H(ci).controller.signal;
              },
            },
            da = 0,
            Ru = 1,
            Du = 2,
            Xf = 3,
            Cl = 4;
          if (typeof Symbol == "function" && Symbol.for) {
            var Lc = Symbol.for;
            ((da = Lc("selector.component")),
              (Ru = Lc("selector.has_pseudo_class")),
              (Du = Lc("selector.role")),
              (Xf = Lc("selector.test_id")),
              (Cl = Lc("selector.text")));
          }
          var Os = typeof WeakMap == "function" ? WeakMap : Map,
            dn = 0,
            ln = null,
            pn = null,
            xn = 0,
            Gn = 0,
            Wi = null,
            Ra = !1,
            Rl = !1,
            Dl = !1,
            fo = 0,
            gi = 0,
            Fo = 0,
            Ll = 0,
            Lu = 0,
            Wr = 0,
            Nu = 0,
            qf = null,
            hs = null,
            Pd = !1,
            Yf = 0,
            Nc = 0,
            Nl = 1 / 0,
            Zf = null,
            zo = null,
            Xi = 0,
            Bo = null,
            Uc = null,
            ho = 0,
            Uu = 0,
            Id = null,
            tg = null,
            Rn = 0,
            Kf = null;
          return (
            (an.attemptContinuousHydration = function (c) {
              if (c.tag === 13 || c.tag === 31) {
                var f = xi(c, 67108864);
                (f !== null && hi(f, c, 67108864), Df(c, 67108864));
              }
            }),
            (an.attemptHydrationAtCurrentPriority = function (c) {
              if (c.tag === 13 || c.tag === 31) {
                var f = ai();
                f = q(f);
                var x = xi(c, f);
                (x !== null && hi(x, c, f), Df(c, f));
              }
            }),
            (an.attemptSynchronousHydration = function (c) {
              switch (c.tag) {
                case 3:
                  if (
                    ((c = c.stateNode), c.current.memoizedState.isDehydrated)
                  ) {
                    var f = E(c.pendingLanes);
                    if (f !== 0) {
                      for (c.pendingLanes |= 2, c.entangledLanes |= 2; f; ) {
                        var x = 1 << (31 - ls(f));
                        ((c.entanglements[1] |= x), (f &= ~x));
                      }
                      (et(c), (dn & 6) === 0 && ((Nl = Dr() + 500), $e(0)));
                    }
                  }
                  break;
                case 31:
                case 13:
                  ((f = xi(c, 2)), f !== null && hi(f, c, 2), $h(), Df(c, 2));
              }
            }),
            (an.batchedUpdates = function (c, f) {
              return c(f);
            }),
            (an.createComponentSelector = function (c) {
              return { $$typeof: da, value: c };
            }),
            (an.createContainer = function (c, f, x, S, D, U, Y, me, We, ot) {
              return vl(c, f, !1, null, x, S, U, null, Y, me, We, ot);
            }),
            (an.createHasPseudoClassSelector = function (c) {
              return { $$typeof: Ru, value: c };
            }),
            (an.createHydrationContainer = function (
              c,
              f,
              x,
              S,
              D,
              U,
              Y,
              me,
              We,
              ot,
              xt,
              ut,
              Ct,
              Qt,
            ) {
              var Ui;
              return (
                (c = vl(x, S, !0, c, D, U, me, Qt, We, ot, xt, ut)),
                (c.context = sd(null)),
                (x = c.current),
                (S = ai()),
                (S = q(S)),
                (D = gr(S)),
                (D.callback = (Ui = f) != null ? Ui : null),
                es(x, D, S),
                (f = S),
                (c.current.lanes = f),
                O(c, f),
                et(c),
                c
              );
            }),
            (an.createPortal = function (c, f, x) {
              var S =
                3 < arguments.length && arguments[3] !== void 0
                  ? arguments[3]
                  : null;
              return {
                $$typeof: gc,
                key: S == null ? null : "" + S,
                children: c,
                containerInfo: f,
                implementation: x,
              };
            }),
            (an.createRoleSelector = function (c) {
              return { $$typeof: Du, value: c };
            }),
            (an.createTestNameSelector = function (c) {
              return { $$typeof: Xf, value: c };
            }),
            (an.createTextSelector = function (c) {
              return { $$typeof: Cl, value: c };
            }),
            (an.defaultOnCaughtError = function (c) {
              console.error(c);
            }),
            (an.defaultOnRecoverableError = function (c) {
              Cd(c);
            }),
            (an.defaultOnUncaughtError = function (c) {
              Cd(c);
            }),
            (an.deferredUpdates = function (c) {
              var f = Bt.T,
                x = ra();
              try {
                return (vn(32), (Bt.T = null), c());
              } finally {
                (vn(x), (Bt.T = f));
              }
            }),
            (an.discreteUpdates = function (c, f, x, S, D) {
              var U = Bt.T,
                Y = ra();
              try {
                return (vn(2), (Bt.T = null), c(f, x, S, D));
              } finally {
                (vn(Y), (Bt.T = U), dn === 0 && (Nl = Dr() + 500));
              }
            }),
            (an.findAllNodes = rs),
            (an.findBoundingRects = function (c, f) {
              if (!Qi) throw Error(r(363));
              ((f = rs(c, f)), (c = []));
              for (var x = 0; x < f.length; x++) c.push(dd(f[x]));
              for (f = c.length - 1; 0 < f; f--) {
                x = c[f];
                for (
                  var S = x.x,
                    D = S + x.width,
                    U = x.y,
                    Y = U + x.height,
                    me = f - 1;
                  0 <= me;
                  me--
                )
                  if (f !== me) {
                    var We = c[me],
                      ot = We.x,
                      xt = ot + We.width,
                      ut = We.y,
                      Ct = ut + We.height;
                    if (S >= ot && U >= ut && D <= xt && Y <= Ct) {
                      c.splice(f, 1);
                      break;
                    } else if (
                      S !== ot ||
                      x.width !== We.width ||
                      Ct < U ||
                      ut > Y
                    ) {
                      if (
                        !(
                          U !== ut ||
                          x.height !== We.height ||
                          xt < S ||
                          ot > D
                        )
                      ) {
                        (ot > S && ((We.width += ot - S), (We.x = S)),
                          xt < D && (We.width = D - ot),
                          c.splice(f, 1));
                        break;
                      }
                    } else {
                      (ut > U && ((We.height += ut - U), (We.y = U)),
                        Ct < Y && (We.height = Y - ut),
                        c.splice(f, 1));
                      break;
                    }
                  }
              }
              return c;
            }),
            (an.findHostInstance = Rf),
            (an.findHostInstanceWithNoPortals = function (c) {
              return (
                (c = u(c)),
                (c = c !== null ? d(c) : null),
                c === null ? null : bu(c.stateNode)
              );
            }),
            (an.findHostInstanceWithWarning = function (c) {
              return Rf(c);
            }),
            (an.flushPassiveEffects = no),
            (an.flushSyncFromReconciler = function (c) {
              var f = dn;
              dn |= 1;
              var x = Bt.T,
                S = ra();
              try {
                if ((vn(2), (Bt.T = null), c)) return c();
              } finally {
                (vn(S), (Bt.T = x), (dn = f), (dn & 6) === 0 && $e(0));
              }
            }),
            (an.flushSyncWork = $h),
            (an.focusWithin = function (c, f) {
              if (!Qi) throw Error(r(363));
              for (
                c = hl(c), f = du(c, f), f = Array.from(f), c = 0;
                c < f.length;
              ) {
                var x = f[c++],
                  S = x.tag;
                if (!bl(x)) {
                  if ((S === 5 || S === 26 || S === 27) && No(x.stateNode))
                    return !0;
                  for (x = x.child; x !== null; ) (f.push(x), (x = x.sibling));
                }
              }
              return !1;
            }),
            (an.getFindAllNodesFailureDescription = function (c, f) {
              if (!Qi) throw Error(r(363));
              var x = 0,
                S = [];
              c = [hl(c), 0];
              for (var D = 0; D < c.length; ) {
                var U = c[D++],
                  Y = U.tag,
                  me = c[D++],
                  We = f[me];
                if (
                  ((Y !== 5 && Y !== 26 && Y !== 27) || !bl(U)) &&
                  (dl(U, We) && (S.push(hu(We)), me++, me > x && (x = me)),
                  me < f.length)
                )
                  for (U = U.child; U !== null; )
                    (c.push(U, me), (U = U.sibling));
              }
              if (x < f.length) {
                for (c = []; x < f.length; x++) c.push(hu(f[x]));
                return (
                  `findAllNodes was able to match part of the selector:
  ` +
                  (S.join(" > ") +
                    `

No matching component was found for:
  `) +
                  c.join(" > ")
                );
              }
              return null;
            }),
            (an.getPublicRootInstance = function (c) {
              if (((c = c.current), !c.child)) return null;
              switch (c.child.tag) {
                case 27:
                case 5:
                  return bu(c.child.stateNode);
                default:
                  return c.child.stateNode;
              }
            }),
            (an.injectIntoDevTools = function () {
              var c = {
                bundleType: 0,
                version: gm,
                rendererPackageName: Uf,
                currentDispatcherRef: Bt,
                reconcilerVersion: "19.2.0",
              };
              if (
                (xu !== null && (c.rendererConfig = xu),
                typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
              )
                c = !1;
              else {
                var f = __REACT_DEVTOOLS_GLOBAL_HOOK__;
                if (f.isDisabled || !f.supportsFiber) c = !0;
                else {
                  try {
                    ((wc = f.inject(c)), (cs = f));
                  } catch {}
                  c = !!f.checkDCE;
                }
              }
              return c;
            }),
            (an.isAlreadyRendering = function () {
              return (dn & 6) !== 0;
            }),
            (an.observeVisibleRects = function (c, f, x, S) {
              if (!Qi) throw Error(r(363));
              c = rs(c, f);
              var D = pd(c, x, S).disconnect;
              return {
                disconnect: function () {
                  D();
                },
              };
            }),
            (an.shouldError = function () {
              return null;
            }),
            (an.shouldSuspend = function () {
              return !1;
            }),
            (an.startHostTransition = function (c, f, x, S) {
              if (c.tag !== 5) throw Error(r(476));
              var D = oc(c).queue;
              ac(
                c,
                D,
                f,
                _c,
                x === null
                  ? n
                  : function () {
                      var U = oc(c);
                      return (
                        U.next === null && (U = c.alternate.memoizedState),
                        ol(c, U.next.queue, {}, ai()),
                        x(S)
                      );
                    },
              );
            }),
            (an.updateContainer = function (c, f, x, S) {
              var D = f.current,
                U = ai();
              return (pm(D, U, c, f, x, S), U);
            }),
            (an.updateContainerSync = function (c, f, x, S) {
              return (pm(f.current, 2, c, f, x, S), 2);
            }),
            an
          );
        }),
          (i.exports.default = i.exports),
          Object.defineProperty(i.exports, "__esModule", { value: !0 }));
      })(A3)),
    A3.exports
  );
}
var R3;
function f7() {
  return (R3 || ((R3 = 1), (w3.exports = u7())), w3.exports);
}
var h7 = f7();
const d7 = c7(h7);
function p7(i) {
  const e = d7(i);
  return (e.injectIntoDevTools(), e);
}
const vU = 0,
  Lp = {},
  m7 = /^three(?=[A-Z])/,
  Pb = (i) => `${i[0].toUpperCase()}${i.slice(1)}`;
let g7 = 0;
const v7 = (i) => typeof i == "function";
function y7(i) {
  if (v7(i)) {
    const e = `${g7++}`;
    return ((Lp[e] = i), e);
  } else Object.assign(Lp, i);
}
function yU(i, e) {
  const t = Pb(i),
    n = Lp[t];
  if (i !== "primitive" && !n)
    throw new Error(
      `R3F: ${t} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`,
    );
  if (i === "primitive" && !e.object)
    throw new Error("R3F: Primitives without 'object' are invalid!");
  if (e.args !== void 0 && !Array.isArray(e.args))
    throw new Error("R3F: The args prop must be an array!");
}
function x7(i, e, t) {
  var n;
  return (
    (i = Pb(i) in Lp ? i : i.replace(m7, "")),
    yU(i, e),
    i === "primitive" &&
      (n = e.object) != null &&
      n.__r3f &&
      delete e.object.__r3f,
    z1(e.object, t, i, e)
  );
}
function b7(i) {
  if (!i.isHidden) {
    var e;
    (i.props.attach && (e = i.parent) != null && e.object
      ? k1(i.parent, i)
      : va(i.object) && (i.object.visible = !1),
      (i.isHidden = !0),
      Hp(i));
  }
}
function xU(i) {
  if (i.isHidden) {
    var e;
    (i.props.attach && (e = i.parent) != null && e.object
      ? B1(i.parent, i)
      : va(i.object) && i.props.visible !== !1 && (i.object.visible = !0),
      (i.isHidden = !1),
      Hp(i));
  }
}
function ME(i, e, t) {
  const n = e.root.getState();
  if (!(!i.parent && i.object !== n.scene)) {
    if (!e.object) {
      var r, s;
      const o = Lp[Pb(e.type)];
      ((e.object =
        (r = e.props.object) != null
          ? r
          : new o(...((s = e.props.args) != null ? s : []))),
        (e.object.__r3f = e));
    }
    if ((Qu(e.object, e.props), e.props.attach)) B1(i, e);
    else if (va(e.object) && va(i.object)) {
      const o = i.object.children.indexOf(t == null ? void 0 : t.object);
      if (t && o !== -1) {
        const u = i.object.children.indexOf(e.object);
        if (u !== -1) {
          i.object.children.splice(u, 1);
          const h = u < o ? o - 1 : o;
          i.object.children.splice(h, 0, e.object);
        } else
          ((e.object.parent = i.object),
            i.object.children.splice(o, 0, e.object),
            e.object.dispatchEvent({ type: "added" }),
            i.object.dispatchEvent({ type: "childadded", child: e.object }));
      } else i.object.add(e.object);
    }
    for (const o of e.children) ME(e, o);
    Hp(e);
  }
}
function US(i, e) {
  e && ((e.parent = i), i.children.push(e), ME(i, e));
}
function D3(i, e, t) {
  if (!e || !t) return;
  e.parent = i;
  const n = i.children.indexOf(t);
  (n !== -1 ? i.children.splice(n, 0, e) : i.children.push(e), ME(i, e, t));
}
function bU(i) {
  if (typeof i.dispose == "function") {
    const e = () => {
      try {
        i.dispose();
      } catch {}
    };
    typeof IS_REACT_ACT_ENVIRONMENT < "u"
      ? e()
      : OM.unstable_scheduleCallback(OM.unstable_IdlePriority, e);
  }
}
function zM(i, e, t) {
  if (!e) return;
  e.parent = null;
  const n = i.children.indexOf(e);
  (n !== -1 && i.children.splice(n, 1),
    e.props.attach
      ? k1(i, e)
      : va(e.object) &&
        va(i.object) &&
        (i.object.remove(e.object), t7(cU(e), e.object)));
  const r = e.props.dispose !== null && t !== !1;
  for (let s = e.children.length - 1; s >= 0; s--) {
    const o = e.children[s];
    zM(e, o, r);
  }
  ((e.children.length = 0),
    delete e.object.__r3f,
    r && e.type !== "primitive" && e.object.type !== "Scene" && bU(e.object),
    t === void 0 && Hp(e));
}
function _7(i, e) {
  for (const t of [i, i.alternate])
    if (t !== null)
      if (typeof t.ref == "function") {
        t.refCleanup == null || t.refCleanup();
        const n = t.ref(e);
        typeof n == "function" && (t.refCleanup = n);
      } else t.ref && (t.ref.current = e);
}
const Lx = [];
function S7() {
  for (const [t] of Lx) {
    const n = t.parent;
    if (n) {
      t.props.attach
        ? k1(n, t)
        : va(t.object) && va(n.object) && n.object.remove(t.object);
      for (const r of t.children)
        r.props.attach
          ? k1(t, r)
          : va(r.object) && va(t.object) && t.object.remove(r.object);
    }
    (t.isHidden && xU(t),
      t.object.__r3f && delete t.object.__r3f,
      t.type !== "primitive" && bU(t.object));
  }
  for (const [t, n, r] of Lx) {
    t.props = n;
    const s = t.parent;
    if (s) {
      var i, e;
      const o = Lp[Pb(t.type)];
      ((t.object =
        (i = t.props.object) != null
          ? i
          : new o(...((e = t.props.args) != null ? e : []))),
        (t.object.__r3f = t),
        _7(r, t.object),
        Qu(t.object, t.props),
        t.props.attach
          ? B1(s, t)
          : va(t.object) && va(s.object) && s.object.add(t.object));
      for (const u of t.children)
        u.props.attach
          ? B1(t, u)
          : va(u.object) && va(t.object) && t.object.add(u.object);
      Hp(t);
    }
  }
  Lx.length = 0;
}
const PS = () => {},
  L3 = {};
let dx = vU;
const M7 = 0,
  T7 = 4,
  BM = p7({
    isPrimaryRenderer: !1,
    warnsIfNotActing: !1,
    supportsMutation: !0,
    supportsPersistence: !1,
    supportsHydration: !1,
    createInstance: x7,
    removeChild: zM,
    appendChild: US,
    appendInitialChild: US,
    insertBefore: D3,
    appendChildToContainer(i, e) {
      const t = i.getState().scene.__r3f;
      !e || !t || US(t, e);
    },
    removeChildFromContainer(i, e) {
      const t = i.getState().scene.__r3f;
      !e || !t || zM(t, e);
    },
    insertInContainerBefore(i, e, t) {
      const n = i.getState().scene.__r3f;
      !e || !t || !n || D3(n, e, t);
    },
    getRootHostContext: () => L3,
    getChildHostContext: () => L3,
    commitUpdate(i, e, t, n, r) {
      var s, o, u;
      yU(e, n);
      let h = !1;
      if (
        (((i.type === "primitive" && t.object !== n.object) ||
          ((s = n.args) == null ? void 0 : s.length) !==
            ((o = t.args) == null ? void 0 : o.length) ||
          ((u = n.args) != null &&
            u.some((m, v) => {
              var y;
              return m !== ((y = t.args) == null ? void 0 : y[v]);
            }))) &&
          (h = !0),
        h)
      )
        Lx.push([i, { ...n }, r]);
      else {
        const m = Q9(i, n);
        Object.keys(m).length && (Object.assign(i.props, m), Qu(i.object, m));
      }
      (r.sibling === null || (r.flags & T7) === M7) && S7();
    },
    finalizeInitialChildren: () => !1,
    commitMount() {},
    getPublicInstance: (i) => (i == null ? void 0 : i.object),
    prepareForCommit: () => null,
    preparePortalMount: (i) => z1(i.getState().scene, i, "", {}),
    resetAfterCommit: () => {},
    shouldSetTextContent: () => !1,
    clearContainer: () => !1,
    hideInstance: b7,
    unhideInstance: xU,
    createTextInstance: PS,
    hideTextInstance: PS,
    unhideTextInstance: PS,
    scheduleTimeout: typeof setTimeout == "function" ? setTimeout : void 0,
    cancelTimeout: typeof clearTimeout == "function" ? clearTimeout : void 0,
    noTimeout: -1,
    getInstanceFromNode: () => null,
    beforeActiveInstanceBlur() {},
    afterActiveInstanceBlur() {},
    detachDeletedInstance() {},
    prepareScopeUpdate() {},
    getInstanceFromScope: () => null,
    shouldAttemptEagerTransition: () => !1,
    trackSchedulerEvent: () => {},
    resolveEventType: () => null,
    resolveEventTimeStamp: () => -1.1,
    requestPostPaintCallback() {},
    maySuspendCommit: () => !1,
    preloadInstance: () => !0,
    suspendInstance() {},
    waitForCommitToBeReady: () => null,
    NotPendingTransition: null,
    HostTransitionContext: ie.createContext(null),
    setCurrentUpdatePriority(i) {
      dx = i;
    },
    getCurrentUpdatePriority() {
      return dx;
    },
    resolveUpdatePriority() {
      var i;
      if (dx !== vU) return dx;
      switch (
        typeof window < "u" &&
        ((i = window.event) == null ? void 0 : i.type)
      ) {
        case "click":
        case "contextmenu":
        case "dblclick":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
          return o7;
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "pointerenter":
        case "pointerleave":
        case "wheel":
          return s7;
        default:
          return a7;
      }
    },
    resetFormInstance() {},
    rendererPackageName: "@react-three/fiber",
    rendererVersion: l7.version,
    applyViewTransitionName(i, e, t) {},
    restoreViewTransitionName(i, e) {},
    cancelViewTransitionName(i, e, t) {},
    cancelRootViewTransitionName(i) {},
    restoreRootViewTransitionName(i) {},
    InstanceMeasurement: null,
    measureInstance: (i) => null,
    wasInstanceInViewport: (i) => !0,
    hasInstanceChanged: (i, e) => !1,
    hasInstanceAffectedParent: (i, e) => !1,
    suspendOnActiveViewTransition(i, e) {},
    startGestureTransition: () => null,
    startViewTransition: () => null,
    stopViewTransition(i) {},
    createViewTransitionInstance: (i) => null,
    getCurrentGestureOffset(i) {
      throw new Error(
        "startGestureTransition is not yet supported in react-three-fiber.",
      );
    },
    cloneMutableInstance(i, e) {
      return i;
    },
    cloneMutableTextInstance(i) {
      return i;
    },
    cloneRootViewTransitionContainer(i) {
      throw new Error("Not implemented.");
    },
    removeRootViewTransitionClone(i, e) {
      throw new Error("Not implemented.");
    },
    createFragmentInstance: (i) => null,
    updateFragmentInstanceFiber(i, e) {},
    commitNewChildToFragmentInstance(i, e) {},
    deleteChildFromFragmentInstance(i, e) {},
    measureClonedInstance: (i) => null,
    maySuspendCommitOnUpdate: (i, e, t) => !1,
    maySuspendCommitInSyncRender: (i, e) => !1,
    startSuspendingCommit: () => null,
    getSuspendedCommitReason: (i, e) => null,
  }),
  Ih = new Map(),
  lp = { objects: "shallow", strict: !1 };
function E7(i, e) {
  if (
    !e &&
    typeof HTMLCanvasElement < "u" &&
    i instanceof HTMLCanvasElement &&
    i.parentElement
  ) {
    const {
      width: t,
      height: n,
      top: r,
      left: s,
    } = i.parentElement.getBoundingClientRect();
    return { width: t, height: n, top: r, left: s };
  } else if (!e && typeof OffscreenCanvas < "u" && i instanceof OffscreenCanvas)
    return { width: i.width, height: i.height, top: 0, left: 0 };
  return { width: 0, height: 0, top: 0, left: 0, ...e };
}
function w7(i) {
  const e = Ih.get(i),
    t = e == null ? void 0 : e.fiber,
    n = e == null ? void 0 : e.store;
  e && console.warn("R3F.createRoot should only be called once!");
  const r = typeof reportError == "function" ? reportError : console.error,
    s = n || i7(GM, U3),
    o = t || BM.createContainer(s, r7, null, !1, null, "", r, r, r, null);
  e || Ih.set(i, { fiber: o, store: s });
  let u,
    h,
    d = !1,
    m = null;
  return {
    async configure(v = {}) {
      let y;
      m = new Promise((V) => (y = V));
      let {
          gl: b,
          size: _,
          scene: w,
          events: E,
          onCreated: T,
          shadows: C = !1,
          linear: R = !1,
          flat: L = !1,
          legacy: I = !1,
          orthographic: O = !1,
          frameloop: B = "always",
          dpr: N = [1, 2],
          performance: F,
          raycaster: j,
          camera: q,
          onPointerMissed: X,
        } = v,
        J = s.getState(),
        ee = J.gl;
      if (!J.gl) {
        const V = {
            canvas: i,
            powerPreference: "high-performance",
            antialias: !0,
            alpha: !0,
          },
          Z = typeof b == "function" ? await b(V) : b;
        (E3(Z) ? (ee = Z) : (ee = new sU({ ...V, ...b })), J.set({ gl: ee }));
      }
      let ne = J.raycaster;
      ne || J.set({ raycaster: (ne = new ZN()) });
      const { params: W, ...$ } = j || {};
      if (
        (Pi.equ($, ne, lp) || Qu(ne, { ...$ }),
        Pi.equ(W, ne.params, lp) || Qu(ne, { params: { ...ne.params, ...W } }),
        !J.camera || (J.camera === h && !Pi.equ(h, q, lp)))
      ) {
        h = q;
        const V = q == null ? void 0 : q.isCamera,
          Z = V
            ? q
            : O
              ? new Wc(0, 0, 0, 0, 0.1, 1e3)
              : new ir(75, 0, 0.1, 1e3);
        (V ||
          ((Z.position.z = 5),
          q &&
            (Qu(Z, q),
            Z.manual ||
              (("aspect" in q ||
                "left" in q ||
                "right" in q ||
                "bottom" in q ||
                "top" in q) &&
                ((Z.manual = !0), Z.updateProjectionMatrix()))),
          !J.camera && !(q != null && q.rotation) && Z.lookAt(0, 0, 0)),
          J.set({ camera: Z }),
          (ne.camera = Z));
      }
      if (!J.scene) {
        let V;
        (w != null && w.isScene
          ? ((V = w), z1(V, s, "", {}))
          : ((V = new XT()), z1(V, s, "", {}), w && Qu(V, w)),
          J.set({ scene: V }));
      }
      E && !J.events.handlers && J.set({ events: E(s) });
      const de = E7(i, _);
      if (
        (Pi.equ(de, J.size, lp) ||
          J.setSize(de.width, de.height, de.top, de.left),
        N && J.viewport.dpr !== hU(N) && J.setDpr(N),
        J.frameloop !== B && J.setFrameloop(B),
        J.onPointerMissed || J.set({ onPointerMissed: X }),
        F &&
          !Pi.equ(F, J.performance, lp) &&
          J.set((V) => ({ performance: { ...V.performance, ...F } })),
        !J.xr)
      ) {
        var le;
        const V = (ue, ge) => {
            const ae = s.getState();
            ae.frameloop !== "never" && U3(ue, !0, ae, ge);
          },
          Z = () => {
            const ue = s.getState();
            ((ue.gl.xr.enabled = ue.gl.xr.isPresenting),
              ue.gl.xr.setAnimationLoop(ue.gl.xr.isPresenting ? V : null),
              ue.gl.xr.isPresenting || GM(ue));
          },
          se = {
            connect() {
              const ue = s.getState().gl;
              (ue.xr.addEventListener("sessionstart", Z),
                ue.xr.addEventListener("sessionend", Z));
            },
            disconnect() {
              const ue = s.getState().gl;
              (ue.xr.removeEventListener("sessionstart", Z),
                ue.xr.removeEventListener("sessionend", Z));
            },
          };
        (typeof ((le = ee.xr) == null ? void 0 : le.addEventListener) ==
          "function" && se.connect(),
          J.set({ xr: se }));
      }
      if (ee.shadowMap) {
        const V = ee.shadowMap.enabled,
          Z = ee.shadowMap.type;
        if (((ee.shadowMap.enabled = !!C), Pi.boo(C))) ee.shadowMap.type = Fg;
        else if (Pi.str(C)) {
          var fe;
          const se = { basic: gL, percentage: _p, soft: Fg, variance: bh };
          ee.shadowMap.type = (fe = se[C]) != null ? fe : Fg;
        } else Pi.obj(C) && Object.assign(ee.shadowMap, C);
        (V !== ee.shadowMap.enabled || Z !== ee.shadowMap.type) &&
          (ee.shadowMap.needsUpdate = !0);
      }
      return (
        (Cn.enabled = !I),
        d ||
          ((ee.outputColorSpace = R ? af : vs), (ee.toneMapping = L ? xo : Z1)),
        J.legacy !== I && J.set(() => ({ legacy: I })),
        J.linear !== R && J.set(() => ({ linear: R })),
        J.flat !== L && J.set(() => ({ flat: L })),
        b && !Pi.fun(b) && !E3(b) && !Pi.equ(b, ee, lp) && Qu(ee, b),
        (u = T),
        (d = !0),
        y(),
        this
      );
    },
    render(v) {
      return (
        !d && !m && this.configure(),
        m.then(() => {
          BM.updateContainer(
            P.jsx(A7, { store: s, children: v, onCreated: u, rootElement: i }),
            o,
            null,
            () => {},
          );
        }),
        s
      );
    },
    unmount() {
      _U(i);
    },
  };
}
function A7({ store: i, children: e, onCreated: t, rootElement: n }) {
  return (
    z0(() => {
      const r = i.getState();
      (r.set((s) => ({ internal: { ...s.internal, active: !0 } })),
        t && t(r),
        i.getState().events.connected ||
          r.events.connect == null ||
          r.events.connect(n));
    }, []),
    P.jsx(mU.Provider, { value: i, children: e })
  );
}
function _U(i, e) {
  const t = Ih.get(i),
    n = t == null ? void 0 : t.fiber;
  if (n) {
    const r = t == null ? void 0 : t.store.getState();
    (r && (r.internal.active = !1),
      BM.updateContainer(null, n, null, () => {
        r &&
          setTimeout(() => {
            try {
              var s, o, u, h;
              (r.events.disconnect == null || r.events.disconnect(),
                (s = r.gl) == null ||
                  (o = s.renderLists) == null ||
                  o.dispose == null ||
                  o.dispose(),
                (u = r.gl) == null ||
                  u.forceContextLoss == null ||
                  u.forceContextLoss(),
                (h = r.gl) != null && h.xr && r.xr.disconnect(),
                Y9(r.scene),
                Ih.delete(i));
            } catch {}
          }, 500);
      }));
  }
}
const C7 = new Set(),
  R7 = new Set(),
  D7 = new Set();
function IS(i, e) {
  if (i.size) for (const { callback: t } of i.values()) t(e);
}
function Yg(i, e) {
  switch (i) {
    case "before":
      return IS(C7, e);
    case "after":
      return IS(R7, e);
    case "tail":
      return IS(D7, e);
  }
}
let OS, FS;
function kM(i, e, t) {
  let n = e.clock.getDelta();
  (e.frameloop === "never" &&
    typeof i == "number" &&
    ((n = i - e.clock.elapsedTime),
    (e.clock.oldTime = e.clock.elapsedTime),
    (e.clock.elapsedTime = i)),
    (OS = e.internal.subscribers));
  for (let r = 0; r < OS.length; r++)
    ((FS = OS[r]), FS.ref.current(FS.store.getState(), n, t));
  return (
    !e.internal.priority && e.gl.render && e.gl.render(e.scene, e.camera),
    (e.internal.frames = Math.max(0, e.internal.frames - 1)),
    e.frameloop === "always" ? 1 : e.internal.frames
  );
}
let V1 = !1,
  VM = !1,
  zS,
  N3,
  cp;
function SU(i) {
  ((N3 = requestAnimationFrame(SU)),
    (V1 = !0),
    (zS = 0),
    Yg("before", i),
    (VM = !0));
  for (const t of Ih.values()) {
    var e;
    ((cp = t.store.getState()),
      cp.internal.active &&
        (cp.frameloop === "always" || cp.internal.frames > 0) &&
        !((e = cp.gl.xr) != null && e.isPresenting) &&
        (zS += kM(i, cp)));
  }
  if (((VM = !1), Yg("after", i), zS === 0))
    return (Yg("tail", i), (V1 = !1), cancelAnimationFrame(N3));
}
function GM(i, e = 1) {
  var t;
  if (!i) return Ih.forEach((n) => GM(n.store.getState(), e));
  ((t = i.gl.xr) != null && t.isPresenting) ||
    !i.internal.active ||
    i.frameloop === "never" ||
    (e > 1
      ? (i.internal.frames = Math.min(60, i.internal.frames + e))
      : VM
        ? (i.internal.frames = 2)
        : (i.internal.frames = 1),
    V1 || ((V1 = !0), requestAnimationFrame(SU)));
}
function U3(i, e = !0, t, n) {
  if ((e && Yg("before", i), t)) kM(i, t, n);
  else for (const r of Ih.values()) kM(i, r.store.getState());
  e && Yg("after", i);
}
const BS = {
  onClick: ["click", !1],
  onContextMenu: ["contextmenu", !1],
  onDoubleClick: ["dblclick", !1],
  onWheel: ["wheel", !0],
  onPointerDown: ["pointerdown", !0],
  onPointerUp: ["pointerup", !0],
  onPointerLeave: ["pointerleave", !0],
  onPointerMove: ["pointermove", !0],
  onPointerCancel: ["pointercancel", !0],
  onLostPointerCapture: ["lostpointercapture", !0],
};
function L7(i) {
  const { handlePointer: e } = n7(i);
  return {
    priority: 1,
    enabled: !0,
    compute(t, n, r) {
      (n.pointer.set(
        (t.offsetX / n.size.width) * 2 - 1,
        -(t.offsetY / n.size.height) * 2 + 1,
      ),
        n.raycaster.setFromCamera(n.pointer, n.camera));
    },
    connected: void 0,
    handlers: Object.keys(BS).reduce((t, n) => ({ ...t, [n]: e(n) }), {}),
    update: () => {
      var t;
      const { events: n, internal: r } = i.getState();
      (t = r.lastEvent) != null &&
        t.current &&
        n.handlers &&
        n.handlers.onPointerMove(r.lastEvent.current);
    },
    connect: (t) => {
      const { set: n, events: r } = i.getState();
      if (
        (r.disconnect == null || r.disconnect(),
        n((s) => ({ events: { ...s.events, connected: t } })),
        r.handlers)
      )
        for (const s in r.handlers) {
          const o = r.handlers[s],
            [u, h] = BS[s];
          t.addEventListener(u, o, { passive: h });
        }
    },
    disconnect: () => {
      const { set: t, events: n } = i.getState();
      if (n.connected) {
        if (n.handlers)
          for (const r in n.handlers) {
            const s = n.handlers[r],
              [o] = BS[r];
            n.connected.removeEventListener(o, s);
          }
        t((r) => ({ events: { ...r.events, connected: void 0 } }));
      }
    },
  };
}
function P3(i, e) {
  let t;
  return (...n) => {
    (window.clearTimeout(t), (t = window.setTimeout(() => i(...n), e)));
  };
}
function N7(
  { debounce: i, scroll: e, polyfill: t, offsetSize: n } = {
    debounce: 0,
    scroll: !1,
    offsetSize: !1,
  },
) {
  const r = t || (typeof window > "u" ? class {} : window.ResizeObserver);
  if (!r)
    throw new Error(
      "This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills",
    );
  const [s, o] = ie.useState({
      left: 0,
      top: 0,
      width: 0,
      height: 0,
      bottom: 0,
      right: 0,
      x: 0,
      y: 0,
    }),
    u = ie.useRef({
      element: null,
      scrollContainers: null,
      resizeObserver: null,
      lastBounds: s,
      orientationHandler: null,
    }),
    h = i ? (typeof i == "number" ? i : i.scroll) : null,
    d = i ? (typeof i == "number" ? i : i.resize) : null,
    m = ie.useRef(!1);
  ie.useEffect(() => ((m.current = !0), () => void (m.current = !1)));
  const [v, y, b] = ie.useMemo(() => {
    const T = () => {
      if (!u.current.element) return;
      const {
          left: C,
          top: R,
          width: L,
          height: I,
          bottom: O,
          right: B,
          x: N,
          y: F,
        } = u.current.element.getBoundingClientRect(),
        j = {
          left: C,
          top: R,
          width: L,
          height: I,
          bottom: O,
          right: B,
          x: N,
          y: F,
        };
      (u.current.element instanceof HTMLElement &&
        n &&
        ((j.height = u.current.element.offsetHeight),
        (j.width = u.current.element.offsetWidth)),
        Object.freeze(j),
        m.current &&
          !O7(u.current.lastBounds, j) &&
          o((u.current.lastBounds = j)));
    };
    return [T, d ? P3(T, d) : T, h ? P3(T, h) : T];
  }, [o, n, h, d]);
  function _() {
    (u.current.scrollContainers &&
      (u.current.scrollContainers.forEach((T) =>
        T.removeEventListener("scroll", b, !0),
      ),
      (u.current.scrollContainers = null)),
      u.current.resizeObserver &&
        (u.current.resizeObserver.disconnect(),
        (u.current.resizeObserver = null)),
      u.current.orientationHandler &&
        ("orientation" in screen && "removeEventListener" in screen.orientation
          ? screen.orientation.removeEventListener(
              "change",
              u.current.orientationHandler,
            )
          : "onorientationchange" in window &&
            window.removeEventListener(
              "orientationchange",
              u.current.orientationHandler,
            )));
  }
  function w() {
    u.current.element &&
      ((u.current.resizeObserver = new r(b)),
      u.current.resizeObserver.observe(u.current.element),
      e &&
        u.current.scrollContainers &&
        u.current.scrollContainers.forEach((T) =>
          T.addEventListener("scroll", b, { capture: !0, passive: !0 }),
        ),
      (u.current.orientationHandler = () => {
        b();
      }),
      "orientation" in screen && "addEventListener" in screen.orientation
        ? screen.orientation.addEventListener(
            "change",
            u.current.orientationHandler,
          )
        : "onorientationchange" in window &&
          window.addEventListener(
            "orientationchange",
            u.current.orientationHandler,
          ));
  }
  const E = (T) => {
    !T ||
      T === u.current.element ||
      (_(), (u.current.element = T), (u.current.scrollContainers = MU(T)), w());
  };
  return (
    P7(b, !!e),
    U7(y),
    ie.useEffect(() => {
      (_(), w());
    }, [e, b, y]),
    ie.useEffect(() => _, []),
    [E, s, v]
  );
}
function U7(i) {
  ie.useEffect(() => {
    const e = i;
    return (
      window.addEventListener("resize", e),
      () => void window.removeEventListener("resize", e)
    );
  }, [i]);
}
function P7(i, e) {
  ie.useEffect(() => {
    if (e) {
      const t = i;
      return (
        window.addEventListener("scroll", t, { capture: !0, passive: !0 }),
        () => void window.removeEventListener("scroll", t, !0)
      );
    }
  }, [i, e]);
}
function MU(i) {
  const e = [];
  if (!i || i === document.body) return e;
  const {
    overflow: t,
    overflowX: n,
    overflowY: r,
  } = window.getComputedStyle(i);
  return (
    [t, n, r].some((s) => s === "auto" || s === "scroll") && e.push(i),
    [...e, ...MU(i.parentElement)]
  );
}
const I7 = ["x", "y", "top", "bottom", "left", "right", "width", "height"],
  O7 = (i, e) => I7.every((t) => i[t] === e[t]);
function F7({
  ref: i,
  children: e,
  fallback: t,
  resize: n,
  style: r,
  gl: s,
  events: o = L7,
  eventSource: u,
  eventPrefix: h,
  shadows: d,
  linear: m,
  flat: v,
  legacy: y,
  orthographic: b,
  frameloop: _,
  dpr: w,
  performance: E,
  raycaster: T,
  camera: C,
  scene: R,
  onPointerMissed: L,
  onCreated: I,
  ...O
}) {
  ie.useMemo(() => y7(S9), []);
  const B = W9(),
    [N, F] = N7({ scroll: !0, debounce: { scroll: 50, resize: 0 }, ...n }),
    j = ie.useRef(null),
    q = ie.useRef(null);
  ie.useImperativeHandle(i, () => j.current);
  const X = fU(L),
    [J, ee] = ie.useState(!1),
    [ne, W] = ie.useState(!1);
  if (J) throw J;
  if (ne) throw ne;
  const $ = ie.useRef(null);
  (z0(() => {
    const le = j.current;
    if (F.width > 0 && F.height > 0 && le) {
      $.current || ($.current = w7(le));
      async function fe() {
        (await $.current.configure({
          gl: s,
          scene: R,
          events: o,
          shadows: d,
          linear: m,
          flat: v,
          legacy: y,
          orthographic: b,
          frameloop: _,
          dpr: w,
          performance: E,
          raycaster: T,
          camera: C,
          size: F,
          onPointerMissed: (...V) =>
            X.current == null ? void 0 : X.current(...V),
          onCreated: (V) => {
            (V.events.connect == null ||
              V.events.connect(u ? (H9(u) ? u.current : u) : q.current),
              h &&
                V.setEvents({
                  compute: (Z, se) => {
                    const ue = Z[h + "X"],
                      ge = Z[h + "Y"];
                    (se.pointer.set(
                      (ue / se.size.width) * 2 - 1,
                      -(ge / se.size.height) * 2 + 1,
                    ),
                      se.raycaster.setFromCamera(se.pointer, se.camera));
                  },
                }),
              I == null || I(V));
          },
        }),
          $.current.render(
            P.jsx(B, {
              children: P.jsx(q9, {
                set: W,
                children: P.jsx(ie.Suspense, {
                  fallback: P.jsx(X9, { set: ee }),
                  children: e ?? null,
                }),
              }),
            }),
          ));
      }
      fe();
    }
  }),
    ie.useEffect(() => {
      const le = j.current;
      if (le) return () => _U(le);
    }, []));
  const de = u ? "none" : "auto";
  return P.jsx("div", {
    ref: q,
    style: {
      position: "relative",
      width: "100%",
      height: "100%",
      overflow: "hidden",
      pointerEvents: de,
      ...r,
    },
    ...O,
    children: P.jsx("div", {
      ref: N,
      style: { width: "100%", height: "100%" },
      children: P.jsx("canvas", {
        ref: j,
        style: { display: "block" },
        children: t,
      }),
    }),
  });
}
function eu(i) {
  return P.jsx(oU, { children: P.jsx(F7, { ...i }) });
}
function cf() {
  return (
    (cf = Object.assign
      ? Object.assign.bind()
      : function (i) {
          for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var n in t) ({}).hasOwnProperty.call(t, n) && (i[n] = t[n]);
          }
          return i;
        }),
    cf.apply(null, arguments)
  );
}
const TU = parseInt(zp.replace(/\D+/g, "")),
  EU = TU >= 125 ? "uv1" : "uv2";
var z7 = Object.defineProperty,
  B7 = (i, e, t) =>
    e in i
      ? z7(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (i[e] = t),
  k7 = (i, e, t) => (B7(i, e + "", t), t);
class V7 {
  constructor() {
    k7(this, "_listeners");
  }
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const n = this._listeners;
    (n[e] === void 0 && (n[e] = []), n[e].indexOf(t) === -1 && n[e].push(t));
  }
  hasEventListener(e, t) {
    if (this._listeners === void 0) return !1;
    const n = this._listeners;
    return n[e] !== void 0 && n[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    if (this._listeners === void 0) return;
    const r = this._listeners[e];
    if (r !== void 0) {
      const s = r.indexOf(t);
      s !== -1 && r.splice(s, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const n = this._listeners[e.type];
    if (n !== void 0) {
      e.target = this;
      const r = n.slice(0);
      for (let s = 0, o = r.length; s < o; s++) r[s].call(this, e);
      e.target = null;
    }
  }
}
var G7 = Object.defineProperty,
  H7 = (i, e, t) =>
    e in i
      ? G7(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (i[e] = t),
  Ht = (i, e, t) => (H7(i, typeof e != "symbol" ? e + "" : e, t), t);
const px = new Oh(),
  I3 = new Vc(),
  j7 = Math.cos(70 * (Math.PI / 180)),
  O3 = (i, e) => ((i % e) + e) % e;
let W7 = class extends V7 {
  constructor(e, t) {
    (super(),
      Ht(this, "object"),
      Ht(this, "domElement"),
      Ht(this, "enabled", !0),
      Ht(this, "target", new te()),
      Ht(this, "minDistance", 0),
      Ht(this, "maxDistance", 1 / 0),
      Ht(this, "minZoom", 0),
      Ht(this, "maxZoom", 1 / 0),
      Ht(this, "minPolarAngle", 0),
      Ht(this, "maxPolarAngle", Math.PI),
      Ht(this, "minAzimuthAngle", -1 / 0),
      Ht(this, "maxAzimuthAngle", 1 / 0),
      Ht(this, "enableDamping", !1),
      Ht(this, "dampingFactor", 0.05),
      Ht(this, "enableZoom", !0),
      Ht(this, "zoomSpeed", 1),
      Ht(this, "enableRotate", !0),
      Ht(this, "rotateSpeed", 1),
      Ht(this, "enablePan", !0),
      Ht(this, "panSpeed", 1),
      Ht(this, "screenSpacePanning", !0),
      Ht(this, "keyPanSpeed", 7),
      Ht(this, "zoomToCursor", !1),
      Ht(this, "autoRotate", !1),
      Ht(this, "autoRotateSpeed", 2),
      Ht(this, "reverseOrbit", !1),
      Ht(this, "reverseHorizontalOrbit", !1),
      Ht(this, "reverseVerticalOrbit", !1),
      Ht(this, "keys", {
        LEFT: "ArrowLeft",
        UP: "ArrowUp",
        RIGHT: "ArrowRight",
        BOTTOM: "ArrowDown",
      }),
      Ht(this, "mouseButtons", {
        LEFT: ph.ROTATE,
        MIDDLE: ph.DOLLY,
        RIGHT: ph.PAN,
      }),
      Ht(this, "touches", { ONE: mh.ROTATE, TWO: mh.DOLLY_PAN }),
      Ht(this, "target0"),
      Ht(this, "position0"),
      Ht(this, "zoom0"),
      Ht(this, "_domElementKeyEvents", null),
      Ht(this, "getPolarAngle"),
      Ht(this, "getAzimuthalAngle"),
      Ht(this, "setPolarAngle"),
      Ht(this, "setAzimuthalAngle"),
      Ht(this, "getDistance"),
      Ht(this, "getZoomScale"),
      Ht(this, "listenToKeyEvents"),
      Ht(this, "stopListenToKeyEvents"),
      Ht(this, "saveState"),
      Ht(this, "reset"),
      Ht(this, "update"),
      Ht(this, "connect"),
      Ht(this, "dispose"),
      Ht(this, "dollyIn"),
      Ht(this, "dollyOut"),
      Ht(this, "getScale"),
      Ht(this, "setScale"),
      (this.object = e),
      (this.domElement = t),
      (this.target0 = this.target.clone()),
      (this.position0 = this.object.position.clone()),
      (this.zoom0 = this.object.zoom),
      (this.getPolarAngle = () => m.phi),
      (this.getAzimuthalAngle = () => m.theta),
      (this.setPolarAngle = (re) => {
        let Se = O3(re, 2 * Math.PI),
          lt = m.phi;
        (lt < 0 && (lt += 2 * Math.PI), Se < 0 && (Se += 2 * Math.PI));
        let ce = Math.abs(Se - lt);
        (2 * Math.PI - ce < ce &&
          (Se < lt ? (Se += 2 * Math.PI) : (lt += 2 * Math.PI)),
          (v.phi = Se - lt),
          n.update());
      }),
      (this.setAzimuthalAngle = (re) => {
        let Se = O3(re, 2 * Math.PI),
          lt = m.theta;
        (lt < 0 && (lt += 2 * Math.PI), Se < 0 && (Se += 2 * Math.PI));
        let ce = Math.abs(Se - lt);
        (2 * Math.PI - ce < ce &&
          (Se < lt ? (Se += 2 * Math.PI) : (lt += 2 * Math.PI)),
          (v.theta = Se - lt),
          n.update());
      }),
      (this.getDistance = () => n.object.position.distanceTo(n.target)),
      (this.listenToKeyEvents = (re) => {
        (re.addEventListener("keydown", be), (this._domElementKeyEvents = re));
      }),
      (this.stopListenToKeyEvents = () => {
        (this._domElementKeyEvents.removeEventListener("keydown", be),
          (this._domElementKeyEvents = null));
      }),
      (this.saveState = () => {
        (n.target0.copy(n.target),
          n.position0.copy(n.object.position),
          (n.zoom0 = n.object.zoom));
      }),
      (this.reset = () => {
        (n.target.copy(n.target0),
          n.object.position.copy(n.position0),
          (n.object.zoom = n.zoom0),
          n.object.updateProjectionMatrix(),
          n.dispatchEvent(r),
          n.update(),
          (h = u.NONE));
      }),
      (this.update = (() => {
        const re = new te(),
          Se = new te(0, 1, 0),
          lt = new Jr().setFromUnitVectors(e.up, Se),
          ce = lt.clone().invert(),
          Oe = new te(),
          Ke = new Jr(),
          dt = 2 * Math.PI;
        return function () {
          const Ee = n.object.position;
          (lt.setFromUnitVectors(e.up, Se),
            ce.copy(lt).invert(),
            re.copy(Ee).sub(n.target),
            re.applyQuaternion(lt),
            m.setFromVector3(re),
            n.autoRotate && h === u.NONE && ee(X()),
            n.enableDamping
              ? ((m.theta += v.theta * n.dampingFactor),
                (m.phi += v.phi * n.dampingFactor))
              : ((m.theta += v.theta), (m.phi += v.phi)));
          let ct = n.minAzimuthAngle,
            Mt = n.maxAzimuthAngle;
          (isFinite(ct) &&
            isFinite(Mt) &&
            (ct < -Math.PI ? (ct += dt) : ct > Math.PI && (ct -= dt),
            Mt < -Math.PI ? (Mt += dt) : Mt > Math.PI && (Mt -= dt),
            ct <= Mt
              ? (m.theta = Math.max(ct, Math.min(Mt, m.theta)))
              : (m.theta =
                  m.theta > (ct + Mt) / 2
                    ? Math.max(ct, m.theta)
                    : Math.min(Mt, m.theta))),
            (m.phi = Math.max(
              n.minPolarAngle,
              Math.min(n.maxPolarAngle, m.phi),
            )),
            m.makeSafe(),
            n.enableDamping === !0
              ? n.target.addScaledVector(b, n.dampingFactor)
              : n.target.add(b),
            (n.zoomToCursor && F) || n.object.isOrthographicCamera
              ? (m.radius = se(m.radius))
              : (m.radius = se(m.radius * y)),
            re.setFromSpherical(m),
            re.applyQuaternion(ce),
            Ee.copy(n.target).add(re),
            n.object.matrixAutoUpdate || n.object.updateMatrix(),
            n.object.lookAt(n.target),
            n.enableDamping === !0
              ? ((v.theta *= 1 - n.dampingFactor),
                (v.phi *= 1 - n.dampingFactor),
                b.multiplyScalar(1 - n.dampingFactor))
              : (v.set(0, 0, 0), b.set(0, 0, 0)));
          let St = !1;
          if (n.zoomToCursor && F) {
            let Dt = null;
            if (n.object instanceof ir && n.object.isPerspectiveCamera) {
              const hn = re.length();
              Dt = se(hn * y);
              const bn = hn - Dt;
              (n.object.position.addScaledVector(B, bn),
                n.object.updateMatrixWorld());
            } else if (n.object.isOrthographicCamera) {
              const hn = new te(N.x, N.y, 0);
              (hn.unproject(n.object),
                (n.object.zoom = Math.max(
                  n.minZoom,
                  Math.min(n.maxZoom, n.object.zoom / y),
                )),
                n.object.updateProjectionMatrix(),
                (St = !0));
              const bn = new te(N.x, N.y, 0);
              (bn.unproject(n.object),
                n.object.position.sub(bn).add(hn),
                n.object.updateMatrixWorld(),
                (Dt = re.length()));
            } else
              (console.warn(
                "WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled.",
              ),
                (n.zoomToCursor = !1));
            Dt !== null &&
              (n.screenSpacePanning
                ? n.target
                    .set(0, 0, -1)
                    .transformDirection(n.object.matrix)
                    .multiplyScalar(Dt)
                    .add(n.object.position)
                : (px.origin.copy(n.object.position),
                  px.direction
                    .set(0, 0, -1)
                    .transformDirection(n.object.matrix),
                  Math.abs(n.object.up.dot(px.direction)) < j7
                    ? e.lookAt(n.target)
                    : (I3.setFromNormalAndCoplanarPoint(n.object.up, n.target),
                      px.intersectPlane(I3, n.target))));
          } else
            n.object instanceof Wc &&
              n.object.isOrthographicCamera &&
              ((St = y !== 1),
              St &&
                ((n.object.zoom = Math.max(
                  n.minZoom,
                  Math.min(n.maxZoom, n.object.zoom / y),
                )),
                n.object.updateProjectionMatrix()));
          return (
            (y = 1),
            (F = !1),
            St ||
            Oe.distanceToSquared(n.object.position) > d ||
            8 * (1 - Ke.dot(n.object.quaternion)) > d
              ? (n.dispatchEvent(r),
                Oe.copy(n.object.position),
                Ke.copy(n.object.quaternion),
                (St = !1),
                !0)
              : !1
          );
        };
      })()),
      (this.connect = (re) => {
        ((n.domElement = re),
          (n.domElement.style.touchAction = "none"),
          n.domElement.addEventListener("contextmenu", ht),
          n.domElement.addEventListener("pointerdown", ke),
          n.domElement.addEventListener("pointercancel", k),
          n.domElement.addEventListener("wheel", _e));
      }),
      (this.dispose = () => {
        var re, Se, lt, ce, Oe, Ke;
        (n.domElement && (n.domElement.style.touchAction = "auto"),
          (re = n.domElement) == null ||
            re.removeEventListener("contextmenu", ht),
          (Se = n.domElement) == null ||
            Se.removeEventListener("pointerdown", ke),
          (lt = n.domElement) == null ||
            lt.removeEventListener("pointercancel", k),
          (ce = n.domElement) == null || ce.removeEventListener("wheel", _e),
          (Oe = n.domElement) == null ||
            Oe.ownerDocument.removeEventListener("pointermove", H),
          (Ke = n.domElement) == null ||
            Ke.ownerDocument.removeEventListener("pointerup", k),
          n._domElementKeyEvents !== null &&
            n._domElementKeyEvents.removeEventListener("keydown", be));
      }));
    const n = this,
      r = { type: "change" },
      s = { type: "start" },
      o = { type: "end" },
      u = {
        NONE: -1,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2,
        TOUCH_ROTATE: 3,
        TOUCH_PAN: 4,
        TOUCH_DOLLY_PAN: 5,
        TOUCH_DOLLY_ROTATE: 6,
      };
    let h = u.NONE;
    const d = 1e-6,
      m = new F1(),
      v = new F1();
    let y = 1;
    const b = new te(),
      _ = new nt(),
      w = new nt(),
      E = new nt(),
      T = new nt(),
      C = new nt(),
      R = new nt(),
      L = new nt(),
      I = new nt(),
      O = new nt(),
      B = new te(),
      N = new nt();
    let F = !1;
    const j = [],
      q = {};
    function X() {
      return ((2 * Math.PI) / 60 / 60) * n.autoRotateSpeed;
    }
    function J() {
      return Math.pow(0.95, n.zoomSpeed);
    }
    function ee(re) {
      n.reverseOrbit || n.reverseHorizontalOrbit
        ? (v.theta += re)
        : (v.theta -= re);
    }
    function ne(re) {
      n.reverseOrbit || n.reverseVerticalOrbit ? (v.phi += re) : (v.phi -= re);
    }
    const W = (() => {
        const re = new te();
        return function (lt, ce) {
          (re.setFromMatrixColumn(ce, 0), re.multiplyScalar(-lt), b.add(re));
        };
      })(),
      $ = (() => {
        const re = new te();
        return function (lt, ce) {
          (n.screenSpacePanning === !0
            ? re.setFromMatrixColumn(ce, 1)
            : (re.setFromMatrixColumn(ce, 0), re.crossVectors(n.object.up, re)),
            re.multiplyScalar(lt),
            b.add(re));
        };
      })(),
      de = (() => {
        const re = new te();
        return function (lt, ce) {
          const Oe = n.domElement;
          if (Oe && n.object instanceof ir && n.object.isPerspectiveCamera) {
            const Ke = n.object.position;
            re.copy(Ke).sub(n.target);
            let dt = re.length();
            ((dt *= Math.tan(((n.object.fov / 2) * Math.PI) / 180)),
              W((2 * lt * dt) / Oe.clientHeight, n.object.matrix),
              $((2 * ce * dt) / Oe.clientHeight, n.object.matrix));
          } else
            Oe && n.object instanceof Wc && n.object.isOrthographicCamera
              ? (W(
                  (lt * (n.object.right - n.object.left)) /
                    n.object.zoom /
                    Oe.clientWidth,
                  n.object.matrix,
                ),
                $(
                  (ce * (n.object.top - n.object.bottom)) /
                    n.object.zoom /
                    Oe.clientHeight,
                  n.object.matrix,
                ))
              : (console.warn(
                  "WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.",
                ),
                (n.enablePan = !1));
        };
      })();
    function le(re) {
      (n.object instanceof ir && n.object.isPerspectiveCamera) ||
      (n.object instanceof Wc && n.object.isOrthographicCamera)
        ? (y = re)
        : (console.warn(
            "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.",
          ),
          (n.enableZoom = !1));
    }
    function fe(re) {
      le(y / re);
    }
    function V(re) {
      le(y * re);
    }
    function Z(re) {
      if (!n.zoomToCursor || !n.domElement) return;
      F = !0;
      const Se = n.domElement.getBoundingClientRect(),
        lt = re.clientX - Se.left,
        ce = re.clientY - Se.top,
        Oe = Se.width,
        Ke = Se.height;
      ((N.x = (lt / Oe) * 2 - 1),
        (N.y = -(ce / Ke) * 2 + 1),
        B.set(N.x, N.y, 1)
          .unproject(n.object)
          .sub(n.object.position)
          .normalize());
    }
    function se(re) {
      return Math.max(n.minDistance, Math.min(n.maxDistance, re));
    }
    function ue(re) {
      _.set(re.clientX, re.clientY);
    }
    function ge(re) {
      (Z(re), L.set(re.clientX, re.clientY));
    }
    function ae(re) {
      T.set(re.clientX, re.clientY);
    }
    function he(re) {
      (w.set(re.clientX, re.clientY),
        E.subVectors(w, _).multiplyScalar(n.rotateSpeed));
      const Se = n.domElement;
      (Se &&
        (ee((2 * Math.PI * E.x) / Se.clientHeight),
        ne((2 * Math.PI * E.y) / Se.clientHeight)),
        _.copy(w),
        n.update());
    }
    function ye(re) {
      (I.set(re.clientX, re.clientY),
        O.subVectors(I, L),
        O.y > 0 ? fe(J()) : O.y < 0 && V(J()),
        L.copy(I),
        n.update());
    }
    function ze(re) {
      (C.set(re.clientX, re.clientY),
        R.subVectors(C, T).multiplyScalar(n.panSpeed),
        de(R.x, R.y),
        T.copy(C),
        n.update());
    }
    function it(re) {
      (Z(re), re.deltaY < 0 ? V(J()) : re.deltaY > 0 && fe(J()), n.update());
    }
    function qe(re) {
      let Se = !1;
      switch (re.code) {
        case n.keys.UP:
          (de(0, n.keyPanSpeed), (Se = !0));
          break;
        case n.keys.BOTTOM:
          (de(0, -n.keyPanSpeed), (Se = !0));
          break;
        case n.keys.LEFT:
          (de(n.keyPanSpeed, 0), (Se = !0));
          break;
        case n.keys.RIGHT:
          (de(-n.keyPanSpeed, 0), (Se = !0));
          break;
      }
      Se && (re.preventDefault(), n.update());
    }
    function Ye() {
      if (j.length == 1) _.set(j[0].pageX, j[0].pageY);
      else {
        const re = 0.5 * (j[0].pageX + j[1].pageX),
          Se = 0.5 * (j[0].pageY + j[1].pageY);
        _.set(re, Se);
      }
    }
    function ft() {
      if (j.length == 1) T.set(j[0].pageX, j[0].pageY);
      else {
        const re = 0.5 * (j[0].pageX + j[1].pageX),
          Se = 0.5 * (j[0].pageY + j[1].pageY);
        T.set(re, Se);
      }
    }
    function Re() {
      const re = j[0].pageX - j[1].pageX,
        Se = j[0].pageY - j[1].pageY,
        lt = Math.sqrt(re * re + Se * Se);
      L.set(0, lt);
    }
    function Ie() {
      (n.enableZoom && Re(), n.enablePan && ft());
    }
    function De() {
      (n.enableZoom && Re(), n.enableRotate && Ye());
    }
    function Qe(re) {
      if (j.length == 1) w.set(re.pageX, re.pageY);
      else {
        const lt = Ze(re),
          ce = 0.5 * (re.pageX + lt.x),
          Oe = 0.5 * (re.pageY + lt.y);
        w.set(ce, Oe);
      }
      E.subVectors(w, _).multiplyScalar(n.rotateSpeed);
      const Se = n.domElement;
      (Se &&
        (ee((2 * Math.PI * E.x) / Se.clientHeight),
        ne((2 * Math.PI * E.y) / Se.clientHeight)),
        _.copy(w));
    }
    function K(re) {
      if (j.length == 1) C.set(re.pageX, re.pageY);
      else {
        const Se = Ze(re),
          lt = 0.5 * (re.pageX + Se.x),
          ce = 0.5 * (re.pageY + Se.y);
        C.set(lt, ce);
      }
      (R.subVectors(C, T).multiplyScalar(n.panSpeed), de(R.x, R.y), T.copy(C));
    }
    function rt(re) {
      const Se = Ze(re),
        lt = re.pageX - Se.x,
        ce = re.pageY - Se.y,
        Oe = Math.sqrt(lt * lt + ce * ce);
      (I.set(0, Oe),
        O.set(0, Math.pow(I.y / L.y, n.zoomSpeed)),
        fe(O.y),
        L.copy(I));
    }
    function je(re) {
      (n.enableZoom && rt(re), n.enablePan && K(re));
    }
    function Te(re) {
      (n.enableZoom && rt(re), n.enableRotate && Qe(re));
    }
    function ke(re) {
      var Se, lt;
      n.enabled !== !1 &&
        (j.length === 0 &&
          ((Se = n.domElement) == null ||
            Se.ownerDocument.addEventListener("pointermove", H),
          (lt = n.domElement) == null ||
            lt.ownerDocument.addEventListener("pointerup", k)),
        yt(re),
        re.pointerType === "touch" ? et(re) : oe(re));
    }
    function H(re) {
      n.enabled !== !1 && (re.pointerType === "touch" ? $e(re) : Ae(re));
    }
    function k(re) {
      var Se, lt, ce;
      (Ge(re),
        j.length === 0 &&
          ((Se = n.domElement) == null ||
            Se.releasePointerCapture(re.pointerId),
          (lt = n.domElement) == null ||
            lt.ownerDocument.removeEventListener("pointermove", H),
          (ce = n.domElement) == null ||
            ce.ownerDocument.removeEventListener("pointerup", k)),
        n.dispatchEvent(o),
        (h = u.NONE));
    }
    function oe(re) {
      let Se;
      switch (re.button) {
        case 0:
          Se = n.mouseButtons.LEFT;
          break;
        case 1:
          Se = n.mouseButtons.MIDDLE;
          break;
        case 2:
          Se = n.mouseButtons.RIGHT;
          break;
        default:
          Se = -1;
      }
      switch (Se) {
        case ph.DOLLY:
          if (n.enableZoom === !1) return;
          (ge(re), (h = u.DOLLY));
          break;
        case ph.ROTATE:
          if (re.ctrlKey || re.metaKey || re.shiftKey) {
            if (n.enablePan === !1) return;
            (ae(re), (h = u.PAN));
          } else {
            if (n.enableRotate === !1) return;
            (ue(re), (h = u.ROTATE));
          }
          break;
        case ph.PAN:
          if (re.ctrlKey || re.metaKey || re.shiftKey) {
            if (n.enableRotate === !1) return;
            (ue(re), (h = u.ROTATE));
          } else {
            if (n.enablePan === !1) return;
            (ae(re), (h = u.PAN));
          }
          break;
        default:
          h = u.NONE;
      }
      h !== u.NONE && n.dispatchEvent(s);
    }
    function Ae(re) {
      if (n.enabled !== !1)
        switch (h) {
          case u.ROTATE:
            if (n.enableRotate === !1) return;
            he(re);
            break;
          case u.DOLLY:
            if (n.enableZoom === !1) return;
            ye(re);
            break;
          case u.PAN:
            if (n.enablePan === !1) return;
            ze(re);
            break;
        }
    }
    function _e(re) {
      n.enabled === !1 ||
        n.enableZoom === !1 ||
        (h !== u.NONE && h !== u.ROTATE) ||
        (re.preventDefault(), n.dispatchEvent(s), it(re), n.dispatchEvent(o));
    }
    function be(re) {
      n.enabled === !1 || n.enablePan === !1 || qe(re);
    }
    function et(re) {
      switch ((Ve(re), j.length)) {
        case 1:
          switch (n.touches.ONE) {
            case mh.ROTATE:
              if (n.enableRotate === !1) return;
              (Ye(), (h = u.TOUCH_ROTATE));
              break;
            case mh.PAN:
              if (n.enablePan === !1) return;
              (ft(), (h = u.TOUCH_PAN));
              break;
            default:
              h = u.NONE;
          }
          break;
        case 2:
          switch (n.touches.TWO) {
            case mh.DOLLY_PAN:
              if (n.enableZoom === !1 && n.enablePan === !1) return;
              (Ie(), (h = u.TOUCH_DOLLY_PAN));
              break;
            case mh.DOLLY_ROTATE:
              if (n.enableZoom === !1 && n.enableRotate === !1) return;
              (De(), (h = u.TOUCH_DOLLY_ROTATE));
              break;
            default:
              h = u.NONE;
          }
          break;
        default:
          h = u.NONE;
      }
      h !== u.NONE && n.dispatchEvent(s);
    }
    function $e(re) {
      switch ((Ve(re), h)) {
        case u.TOUCH_ROTATE:
          if (n.enableRotate === !1) return;
          (Qe(re), n.update());
          break;
        case u.TOUCH_PAN:
          if (n.enablePan === !1) return;
          (K(re), n.update());
          break;
        case u.TOUCH_DOLLY_PAN:
          if (n.enableZoom === !1 && n.enablePan === !1) return;
          (je(re), n.update());
          break;
        case u.TOUCH_DOLLY_ROTATE:
          if (n.enableZoom === !1 && n.enableRotate === !1) return;
          (Te(re), n.update());
          break;
        default:
          h = u.NONE;
      }
    }
    function ht(re) {
      n.enabled !== !1 && re.preventDefault();
    }
    function yt(re) {
      j.push(re);
    }
    function Ge(re) {
      delete q[re.pointerId];
      for (let Se = 0; Se < j.length; Se++)
        if (j[Se].pointerId == re.pointerId) {
          j.splice(Se, 1);
          return;
        }
    }
    function Ve(re) {
      let Se = q[re.pointerId];
      (Se === void 0 && ((Se = new nt()), (q[re.pointerId] = Se)),
        Se.set(re.pageX, re.pageY));
    }
    function Ze(re) {
      const Se = re.pointerId === j[0].pointerId ? j[1] : j[0];
      return q[Se.pointerId];
    }
    ((this.dollyIn = (re = J()) => {
      (V(re), n.update());
    }),
      (this.dollyOut = (re = J()) => {
        (fe(re), n.update());
      }),
      (this.getScale = () => y),
      (this.setScale = (re) => {
        (le(re), n.update());
      }),
      (this.getZoomScale = () => J()),
      t !== void 0 && this.connect(t),
      this.update());
  }
};
const F3 = new sr(),
  mx = new te();
class TE extends Lb {
  constructor() {
    (super(),
      (this.isLineSegmentsGeometry = !0),
      (this.type = "LineSegmentsGeometry"));
    const e = [
        -1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1,
        -1, 0,
      ],
      t = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2],
      n = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];
    (this.setIndex(n),
      this.setAttribute("position", new Rt(e, 3)),
      this.setAttribute("uv", new Rt(t, 2)));
  }
  applyMatrix4(e) {
    const t = this.attributes.instanceStart,
      n = this.attributes.instanceEnd;
    return (
      t !== void 0 &&
        (t.applyMatrix4(e), n.applyMatrix4(e), (t.needsUpdate = !0)),
      this.boundingBox !== null && this.computeBoundingBox(),
      this.boundingSphere !== null && this.computeBoundingSphere(),
      this
    );
  }
  setPositions(e) {
    let t;
    e instanceof Float32Array
      ? (t = e)
      : Array.isArray(e) && (t = new Float32Array(e));
    const n = new O1(t, 6, 1);
    return (
      this.setAttribute("instanceStart", new Pa(n, 3, 0)),
      this.setAttribute("instanceEnd", new Pa(n, 3, 3)),
      this.computeBoundingBox(),
      this.computeBoundingSphere(),
      this
    );
  }
  setColors(e, t = 3) {
    let n;
    e instanceof Float32Array
      ? (n = e)
      : Array.isArray(e) && (n = new Float32Array(e));
    const r = new O1(n, t * 2, 1);
    return (
      this.setAttribute("instanceColorStart", new Pa(r, t, 0)),
      this.setAttribute("instanceColorEnd", new Pa(r, t, t)),
      this
    );
  }
  fromWireframeGeometry(e) {
    return (this.setPositions(e.attributes.position.array), this);
  }
  fromEdgesGeometry(e) {
    return (this.setPositions(e.attributes.position.array), this);
  }
  fromMesh(e) {
    return (this.fromWireframeGeometry(new sE(e.geometry)), this);
  }
  fromLineSegments(e) {
    const t = e.geometry;
    return (this.setPositions(t.attributes.position.array), this);
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new sr());
    const e = this.attributes.instanceStart,
      t = this.attributes.instanceEnd;
    e !== void 0 &&
      t !== void 0 &&
      (this.boundingBox.setFromBufferAttribute(e),
      F3.setFromBufferAttribute(t),
      this.boundingBox.union(F3));
  }
  computeBoundingSphere() {
    (this.boundingSphere === null && (this.boundingSphere = new mr()),
      this.boundingBox === null && this.computeBoundingBox());
    const e = this.attributes.instanceStart,
      t = this.attributes.instanceEnd;
    if (e !== void 0 && t !== void 0) {
      const n = this.boundingSphere.center;
      this.boundingBox.getCenter(n);
      let r = 0;
      for (let s = 0, o = e.count; s < o; s++)
        (mx.fromBufferAttribute(e, s),
          (r = Math.max(r, n.distanceToSquared(mx))),
          mx.fromBufferAttribute(t, s),
          (r = Math.max(r, n.distanceToSquared(mx))));
      ((this.boundingSphere.radius = Math.sqrt(r)),
        isNaN(this.boundingSphere.radius) &&
          console.error(
            "THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.",
            this,
          ));
    }
  }
  toJSON() {}
  applyMatrix(e) {
    return (
      console.warn(
        "THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().",
      ),
      this.applyMatrix4(e)
    );
  }
}
class wU extends TE {
  constructor() {
    (super(), (this.isLineGeometry = !0), (this.type = "LineGeometry"));
  }
  setPositions(e) {
    const t = e.length - 3,
      n = new Float32Array(2 * t);
    for (let r = 0; r < t; r += 3)
      ((n[2 * r] = e[r]),
        (n[2 * r + 1] = e[r + 1]),
        (n[2 * r + 2] = e[r + 2]),
        (n[2 * r + 3] = e[r + 3]),
        (n[2 * r + 4] = e[r + 4]),
        (n[2 * r + 5] = e[r + 5]));
    return (super.setPositions(n), this);
  }
  setColors(e, t = 3) {
    const n = e.length - t,
      r = new Float32Array(2 * n);
    if (t === 3)
      for (let s = 0; s < n; s += t)
        ((r[2 * s] = e[s]),
          (r[2 * s + 1] = e[s + 1]),
          (r[2 * s + 2] = e[s + 2]),
          (r[2 * s + 3] = e[s + 3]),
          (r[2 * s + 4] = e[s + 4]),
          (r[2 * s + 5] = e[s + 5]));
    else
      for (let s = 0; s < n; s += t)
        ((r[2 * s] = e[s]),
          (r[2 * s + 1] = e[s + 1]),
          (r[2 * s + 2] = e[s + 2]),
          (r[2 * s + 3] = e[s + 3]),
          (r[2 * s + 4] = e[s + 4]),
          (r[2 * s + 5] = e[s + 5]),
          (r[2 * s + 6] = e[s + 6]),
          (r[2 * s + 7] = e[s + 7]));
    return (super.setColors(r, t), this);
  }
  fromLine(e) {
    const t = e.geometry;
    return (this.setPositions(t.attributes.position.array), this);
  }
}
class EE extends ba {
  constructor(e) {
    (super({
      type: "LineMaterial",
      uniforms: g0.clone(
        g0.merge([
          Et.common,
          Et.fog,
          {
            worldUnits: { value: 1 },
            linewidth: { value: 1 },
            resolution: { value: new nt(1, 1) },
            dashOffset: { value: 0 },
            dashScale: { value: 1 },
            dashSize: { value: 1 },
            gapSize: { value: 1 },
          },
        ]),
      ),
      vertexShader: `
				#include <common>
				#include <fog_pars_vertex>
				#include <logdepthbuf_pars_vertex>
				#include <clipping_planes_pars_vertex>

				uniform float linewidth;
				uniform vec2 resolution;

				attribute vec3 instanceStart;
				attribute vec3 instanceEnd;

				#ifdef USE_COLOR
					#ifdef USE_LINE_COLOR_ALPHA
						varying vec4 vLineColor;
						attribute vec4 instanceColorStart;
						attribute vec4 instanceColorEnd;
					#else
						varying vec3 vLineColor;
						attribute vec3 instanceColorStart;
						attribute vec3 instanceColorEnd;
					#endif
				#endif

				#ifdef WORLD_UNITS

					varying vec4 worldPos;
					varying vec3 worldStart;
					varying vec3 worldEnd;

					#ifdef USE_DASH

						varying vec2 vUv;

					#endif

				#else

					varying vec2 vUv;

				#endif

				#ifdef USE_DASH

					uniform float dashScale;
					attribute float instanceDistanceStart;
					attribute float instanceDistanceEnd;
					varying float vLineDistance;

				#endif

				void trimSegment( const in vec4 start, inout vec4 end ) {

					// trim end segment so it terminates between the camera plane and the near plane

					// conservative estimate of the near plane
					float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
					float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
					float nearEstimate = - 0.5 * b / a;

					float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

					end.xyz = mix( start.xyz, end.xyz, alpha );

				}

				void main() {

					#ifdef USE_COLOR

						vLineColor = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

					#endif

					#ifdef USE_DASH

						vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
						vUv = uv;

					#endif

					float aspect = resolution.x / resolution.y;

					// camera space
					vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
					vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

					#ifdef WORLD_UNITS

						worldStart = start.xyz;
						worldEnd = end.xyz;

					#else

						vUv = uv;

					#endif

					// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
					// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
					// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
					// perhaps there is a more elegant solution -- WestLangley

					bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

					if ( perspective ) {

						if ( start.z < 0.0 && end.z >= 0.0 ) {

							trimSegment( start, end );

						} else if ( end.z < 0.0 && start.z >= 0.0 ) {

							trimSegment( end, start );

						}

					}

					// clip space
					vec4 clipStart = projectionMatrix * start;
					vec4 clipEnd = projectionMatrix * end;

					// ndc space
					vec3 ndcStart = clipStart.xyz / clipStart.w;
					vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

					// direction
					vec2 dir = ndcEnd.xy - ndcStart.xy;

					// account for clip-space aspect ratio
					dir.x *= aspect;
					dir = normalize( dir );

					#ifdef WORLD_UNITS

						// get the offset direction as perpendicular to the view vector
						vec3 worldDir = normalize( end.xyz - start.xyz );
						vec3 offset;
						if ( position.y < 0.5 ) {

							offset = normalize( cross( start.xyz, worldDir ) );

						} else {

							offset = normalize( cross( end.xyz, worldDir ) );

						}

						// sign flip
						if ( position.x < 0.0 ) offset *= - 1.0;

						float forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );

						// don't extend the line if we're rendering dashes because we
						// won't be rendering the endcaps
						#ifndef USE_DASH

							// extend the line bounds to encompass  endcaps
							start.xyz += - worldDir * linewidth * 0.5;
							end.xyz += worldDir * linewidth * 0.5;

							// shift the position of the quad so it hugs the forward edge of the line
							offset.xy -= dir * forwardOffset;
							offset.z += 0.5;

						#endif

						// endcaps
						if ( position.y > 1.0 || position.y < 0.0 ) {

							offset.xy += dir * 2.0 * forwardOffset;

						}

						// adjust for linewidth
						offset *= linewidth * 0.5;

						// set the world position
						worldPos = ( position.y < 0.5 ) ? start : end;
						worldPos.xyz += offset;

						// project the worldpos
						vec4 clip = projectionMatrix * worldPos;

						// shift the depth of the projected points so the line
						// segments overlap neatly
						vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
						clip.z = clipPose.z * clip.w;

					#else

						vec2 offset = vec2( dir.y, - dir.x );
						// undo aspect ratio adjustment
						dir.x /= aspect;
						offset.x /= aspect;

						// sign flip
						if ( position.x < 0.0 ) offset *= - 1.0;

						// endcaps
						if ( position.y < 0.0 ) {

							offset += - dir;

						} else if ( position.y > 1.0 ) {

							offset += dir;

						}

						// adjust for linewidth
						offset *= linewidth;

						// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
						offset /= resolution.y;

						// select end
						vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

						// back to clip space
						offset *= clip.w;

						clip.xy += offset;

					#endif

					gl_Position = clip;

					vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

					#include <logdepthbuf_vertex>
					#include <clipping_planes_vertex>
					#include <fog_vertex>

				}
			`,
      fragmentShader: `
				uniform vec3 diffuse;
				uniform float opacity;
				uniform float linewidth;

				#ifdef USE_DASH

					uniform float dashOffset;
					uniform float dashSize;
					uniform float gapSize;

				#endif

				varying float vLineDistance;

				#ifdef WORLD_UNITS

					varying vec4 worldPos;
					varying vec3 worldStart;
					varying vec3 worldEnd;

					#ifdef USE_DASH

						varying vec2 vUv;

					#endif

				#else

					varying vec2 vUv;

				#endif

				#include <common>
				#include <fog_pars_fragment>
				#include <logdepthbuf_pars_fragment>
				#include <clipping_planes_pars_fragment>

				#ifdef USE_COLOR
					#ifdef USE_LINE_COLOR_ALPHA
						varying vec4 vLineColor;
					#else
						varying vec3 vLineColor;
					#endif
				#endif

				vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

					float mua;
					float mub;

					vec3 p13 = p1 - p3;
					vec3 p43 = p4 - p3;

					vec3 p21 = p2 - p1;

					float d1343 = dot( p13, p43 );
					float d4321 = dot( p43, p21 );
					float d1321 = dot( p13, p21 );
					float d4343 = dot( p43, p43 );
					float d2121 = dot( p21, p21 );

					float denom = d2121 * d4343 - d4321 * d4321;

					float numer = d1343 * d4321 - d1321 * d4343;

					mua = numer / denom;
					mua = clamp( mua, 0.0, 1.0 );
					mub = ( d1343 + d4321 * ( mua ) ) / d4343;
					mub = clamp( mub, 0.0, 1.0 );

					return vec2( mua, mub );

				}

				void main() {

					#include <clipping_planes_fragment>

					#ifdef USE_DASH

						if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

						if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

					#endif

					float alpha = opacity;

					#ifdef WORLD_UNITS

						// Find the closest points on the view ray and the line segment
						vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
						vec3 lineDir = worldEnd - worldStart;
						vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

						vec3 p1 = worldStart + lineDir * params.x;
						vec3 p2 = rayEnd * params.y;
						vec3 delta = p1 - p2;
						float len = length( delta );
						float norm = len / linewidth;

						#ifndef USE_DASH

							#ifdef USE_ALPHA_TO_COVERAGE

								float dnorm = fwidth( norm );
								alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

							#else

								if ( norm > 0.5 ) {

									discard;

								}

							#endif

						#endif

					#else

						#ifdef USE_ALPHA_TO_COVERAGE

							// artifacts appear on some hardware if a derivative is taken within a conditional
							float a = vUv.x;
							float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
							float len2 = a * a + b * b;
							float dlen = fwidth( len2 );

							if ( abs( vUv.y ) > 1.0 ) {

								alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

							}

						#else

							if ( abs( vUv.y ) > 1.0 ) {

								float a = vUv.x;
								float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
								float len2 = a * a + b * b;

								if ( len2 > 1.0 ) discard;

							}

						#endif

					#endif

					vec4 diffuseColor = vec4( diffuse, alpha );
					#ifdef USE_COLOR
						#ifdef USE_LINE_COLOR_ALPHA
							diffuseColor *= vLineColor;
						#else
							diffuseColor.rgb *= vLineColor;
						#endif
					#endif

					#include <logdepthbuf_fragment>

					gl_FragColor = diffuseColor;

					#include <tonemapping_fragment>
					#include <${TU >= 154 ? "colorspace_fragment" : "encodings_fragment"}>
					#include <fog_fragment>
					#include <premultiplied_alpha_fragment>

				}
			`,
      clipping: !0,
    }),
      (this.isLineMaterial = !0),
      (this.onBeforeCompile = function () {
        this.transparent
          ? (this.defines.USE_LINE_COLOR_ALPHA = "1")
          : delete this.defines.USE_LINE_COLOR_ALPHA;
      }),
      Object.defineProperties(this, {
        color: {
          enumerable: !0,
          get: function () {
            return this.uniforms.diffuse.value;
          },
          set: function (t) {
            this.uniforms.diffuse.value = t;
          },
        },
        worldUnits: {
          enumerable: !0,
          get: function () {
            return "WORLD_UNITS" in this.defines;
          },
          set: function (t) {
            t === !0
              ? (this.defines.WORLD_UNITS = "")
              : delete this.defines.WORLD_UNITS;
          },
        },
        linewidth: {
          enumerable: !0,
          get: function () {
            return this.uniforms.linewidth.value;
          },
          set: function (t) {
            this.uniforms.linewidth.value = t;
          },
        },
        dashed: {
          enumerable: !0,
          get: function () {
            return "USE_DASH" in this.defines;
          },
          set(t) {
            (!!t != "USE_DASH" in this.defines && (this.needsUpdate = !0),
              t === !0
                ? (this.defines.USE_DASH = "")
                : delete this.defines.USE_DASH);
          },
        },
        dashScale: {
          enumerable: !0,
          get: function () {
            return this.uniforms.dashScale.value;
          },
          set: function (t) {
            this.uniforms.dashScale.value = t;
          },
        },
        dashSize: {
          enumerable: !0,
          get: function () {
            return this.uniforms.dashSize.value;
          },
          set: function (t) {
            this.uniforms.dashSize.value = t;
          },
        },
        dashOffset: {
          enumerable: !0,
          get: function () {
            return this.uniforms.dashOffset.value;
          },
          set: function (t) {
            this.uniforms.dashOffset.value = t;
          },
        },
        gapSize: {
          enumerable: !0,
          get: function () {
            return this.uniforms.gapSize.value;
          },
          set: function (t) {
            this.uniforms.gapSize.value = t;
          },
        },
        opacity: {
          enumerable: !0,
          get: function () {
            return this.uniforms.opacity.value;
          },
          set: function (t) {
            this.uniforms.opacity.value = t;
          },
        },
        resolution: {
          enumerable: !0,
          get: function () {
            return this.uniforms.resolution.value;
          },
          set: function (t) {
            this.uniforms.resolution.value.copy(t);
          },
        },
        alphaToCoverage: {
          enumerable: !0,
          get: function () {
            return "USE_ALPHA_TO_COVERAGE" in this.defines;
          },
          set: function (t) {
            (!!t != "USE_ALPHA_TO_COVERAGE" in this.defines &&
              (this.needsUpdate = !0),
              t === !0
                ? ((this.defines.USE_ALPHA_TO_COVERAGE = ""),
                  (this.extensions.derivatives = !0))
                : (delete this.defines.USE_ALPHA_TO_COVERAGE,
                  (this.extensions.derivatives = !1)));
          },
        },
      }),
      this.setValues(e));
  }
}
const kS = new Dn(),
  z3 = new te(),
  B3 = new te(),
  qr = new Dn(),
  Yr = new Dn(),
  zl = new Dn(),
  VS = new te(),
  GS = new qt(),
  Kr = new QN(),
  k3 = new te(),
  gx = new sr(),
  vx = new mr(),
  Bl = new Dn();
let Gl, Ch;
function V3(i, e, t) {
  return (
    Bl.set(0, 0, -e, 1).applyMatrix4(i.projectionMatrix),
    Bl.multiplyScalar(1 / Bl.w),
    (Bl.x = Ch / t.width),
    (Bl.y = Ch / t.height),
    Bl.applyMatrix4(i.projectionMatrixInverse),
    Bl.multiplyScalar(1 / Bl.w),
    Math.abs(Math.max(Bl.x, Bl.y))
  );
}
function X7(i, e) {
  const t = i.matrixWorld,
    n = i.geometry,
    r = n.attributes.instanceStart,
    s = n.attributes.instanceEnd,
    o = Math.min(n.instanceCount, r.count);
  for (let u = 0, h = o; u < h; u++) {
    (Kr.start.fromBufferAttribute(r, u),
      Kr.end.fromBufferAttribute(s, u),
      Kr.applyMatrix4(t));
    const d = new te(),
      m = new te();
    (Gl.distanceSqToSegment(Kr.start, Kr.end, m, d),
      m.distanceTo(d) < Ch * 0.5 &&
        e.push({
          point: m,
          pointOnLine: d,
          distance: Gl.origin.distanceTo(m),
          object: i,
          face: null,
          faceIndex: u,
          uv: null,
          [EU]: null,
        }));
  }
}
function q7(i, e, t) {
  const n = e.projectionMatrix,
    s = i.material.resolution,
    o = i.matrixWorld,
    u = i.geometry,
    h = u.attributes.instanceStart,
    d = u.attributes.instanceEnd,
    m = Math.min(u.instanceCount, h.count),
    v = -e.near;
  (Gl.at(1, zl),
    (zl.w = 1),
    zl.applyMatrix4(e.matrixWorldInverse),
    zl.applyMatrix4(n),
    zl.multiplyScalar(1 / zl.w),
    (zl.x *= s.x / 2),
    (zl.y *= s.y / 2),
    (zl.z = 0),
    VS.copy(zl),
    GS.multiplyMatrices(e.matrixWorldInverse, o));
  for (let y = 0, b = m; y < b; y++) {
    if (
      (qr.fromBufferAttribute(h, y),
      Yr.fromBufferAttribute(d, y),
      (qr.w = 1),
      (Yr.w = 1),
      qr.applyMatrix4(GS),
      Yr.applyMatrix4(GS),
      qr.z > v && Yr.z > v)
    )
      continue;
    if (qr.z > v) {
      const R = qr.z - Yr.z,
        L = (qr.z - v) / R;
      qr.lerp(Yr, L);
    } else if (Yr.z > v) {
      const R = Yr.z - qr.z,
        L = (Yr.z - v) / R;
      Yr.lerp(qr, L);
    }
    (qr.applyMatrix4(n),
      Yr.applyMatrix4(n),
      qr.multiplyScalar(1 / qr.w),
      Yr.multiplyScalar(1 / Yr.w),
      (qr.x *= s.x / 2),
      (qr.y *= s.y / 2),
      (Yr.x *= s.x / 2),
      (Yr.y *= s.y / 2),
      Kr.start.copy(qr),
      (Kr.start.z = 0),
      Kr.end.copy(Yr),
      (Kr.end.z = 0));
    const w = Kr.closestPointToPointParameter(VS, !0);
    Kr.at(w, k3);
    const E = jT.lerp(qr.z, Yr.z, w),
      T = E >= -1 && E <= 1,
      C = VS.distanceTo(k3) < Ch * 0.5;
    if (T && C) {
      (Kr.start.fromBufferAttribute(h, y),
        Kr.end.fromBufferAttribute(d, y),
        Kr.start.applyMatrix4(o),
        Kr.end.applyMatrix4(o));
      const R = new te(),
        L = new te();
      (Gl.distanceSqToSegment(Kr.start, Kr.end, L, R),
        t.push({
          point: L,
          pointOnLine: R,
          distance: Gl.origin.distanceTo(L),
          object: i,
          face: null,
          faceIndex: y,
          uv: null,
          [EU]: null,
        }));
    }
  }
}
class AU extends wi {
  constructor(e = new TE(), t = new EE({ color: Math.random() * 16777215 })) {
    (super(e, t), (this.isLineSegments2 = !0), (this.type = "LineSegments2"));
  }
  computeLineDistances() {
    const e = this.geometry,
      t = e.attributes.instanceStart,
      n = e.attributes.instanceEnd,
      r = new Float32Array(2 * t.count);
    for (let o = 0, u = 0, h = t.count; o < h; o++, u += 2)
      (z3.fromBufferAttribute(t, o),
        B3.fromBufferAttribute(n, o),
        (r[u] = u === 0 ? 0 : r[u - 1]),
        (r[u + 1] = r[u] + z3.distanceTo(B3)));
    const s = new O1(r, 2, 1);
    return (
      e.setAttribute("instanceDistanceStart", new Pa(s, 1, 0)),
      e.setAttribute("instanceDistanceEnd", new Pa(s, 1, 1)),
      this
    );
  }
  raycast(e, t) {
    const n = this.material.worldUnits,
      r = e.camera;
    r === null &&
      !n &&
      console.error(
        'LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.',
      );
    const s = (e.params.Line2 !== void 0 && e.params.Line2.threshold) || 0;
    Gl = e.ray;
    const o = this.matrixWorld,
      u = this.geometry,
      h = this.material;
    ((Ch = h.linewidth + s),
      u.boundingSphere === null && u.computeBoundingSphere(),
      vx.copy(u.boundingSphere).applyMatrix4(o));
    let d;
    if (n) d = Ch * 0.5;
    else {
      const v = Math.max(r.near, vx.distanceToPoint(Gl.origin));
      d = V3(r, v, h.resolution);
    }
    if (((vx.radius += d), Gl.intersectsSphere(vx) === !1)) return;
    (u.boundingBox === null && u.computeBoundingBox(),
      gx.copy(u.boundingBox).applyMatrix4(o));
    let m;
    if (n) m = Ch * 0.5;
    else {
      const v = Math.max(r.near, gx.distanceToPoint(Gl.origin));
      m = V3(r, v, h.resolution);
    }
    (gx.expandByScalar(m),
      Gl.intersectsBox(gx) !== !1 && (n ? X7(this, t) : q7(this, r, t)));
  }
  onBeforeRender(e) {
    const t = this.material.uniforms;
    t &&
      t.resolution &&
      (e.getViewport(kS),
      this.material.uniforms.resolution.value.set(kS.z, kS.w));
  }
}
class Y7 extends AU {
  constructor(e = new wU(), t = new EE({ color: Math.random() * 16777215 })) {
    (super(e, t), (this.isLine2 = !0), (this.type = "Line2"));
  }
}
const CU = ie.forwardRef(function (
  {
    points: e,
    color: t = 16777215,
    vertexColors: n,
    linewidth: r,
    lineWidth: s,
    segments: o,
    dashed: u,
    ...h
  },
  d,
) {
  var m, v;
  const y = Vl((T) => T.size),
    b = ie.useMemo(() => (o ? new AU() : new Y7()), [o]),
    [_] = ie.useState(() => new EE()),
    w = (n == null || (m = n[0]) == null ? void 0 : m.length) === 4 ? 4 : 3,
    E = ie.useMemo(() => {
      const T = o ? new TE() : new wU(),
        C = e.map((R) => {
          const L = Array.isArray(R);
          return R instanceof te || R instanceof Dn
            ? [R.x, R.y, R.z]
            : R instanceof nt
              ? [R.x, R.y, 0]
              : L && R.length === 3
                ? [R[0], R[1], R[2]]
                : L && R.length === 2
                  ? [R[0], R[1], 0]
                  : R;
        });
      if ((T.setPositions(C.flat()), n)) {
        t = 16777215;
        const R = n.map((L) => (L instanceof wt ? L.toArray() : L));
        T.setColors(R.flat(), w);
      }
      return T;
    }, [e, o, n, w]);
  return (
    ie.useLayoutEffect(() => {
      b.computeLineDistances();
    }, [e, b]),
    ie.useLayoutEffect(() => {
      (u ? (_.defines.USE_DASH = "") : delete _.defines.USE_DASH,
        (_.needsUpdate = !0));
    }, [u, _]),
    ie.useEffect(
      () => () => {
        (E.dispose(), _.dispose());
      },
      [E],
    ),
    ie.createElement(
      "primitive",
      cf({ object: b, ref: d }, h),
      ie.createElement("primitive", { object: E, attach: "geometry" }),
      ie.createElement(
        "primitive",
        cf(
          {
            object: _,
            attach: "material",
            color: t,
            vertexColors: !!n,
            resolution: [y.width, y.height],
            linewidth: (v = r ?? s) !== null && v !== void 0 ? v : 1,
            dashed: u,
            transparent: w === 4,
          },
          h,
        ),
      ),
    )
  );
});
function Z7() {
  var i = Object.create(null);
  function e(r, s) {
    var o = r.id,
      u = r.name,
      h = r.dependencies;
    h === void 0 && (h = []);
    var d = r.init;
    d === void 0 && (d = function () {});
    var m = r.getTransferables;
    if ((m === void 0 && (m = null), !i[o]))
      try {
        ((h = h.map(function (y) {
          return (
            y &&
              y.isWorkerModule &&
              (e(y, function (b) {
                if (b instanceof Error) throw b;
              }),
              (y = i[y.id].value)),
            y
          );
        })),
          (d = n("<" + u + ">.init", d)),
          m && (m = n("<" + u + ">.getTransferables", m)));
        var v = null;
        (typeof d == "function"
          ? (v = d.apply(void 0, h))
          : console.error("worker module init function failed to rehydrate"),
          (i[o] = { id: o, value: v, getTransferables: m }),
          s(v));
      } catch (y) {
        ((y && y.noLog) || console.error(y), s(y));
      }
  }
  function t(r, s) {
    var o,
      u = r.id,
      h = r.args;
    (!i[u] || typeof i[u].value != "function") &&
      s(
        new Error(
          "Worker module " +
            u +
            ": not found or its 'init' did not return a function",
        ),
      );
    try {
      var d = (o = i[u]).value.apply(o, h);
      d && typeof d.then == "function"
        ? d.then(m, function (v) {
            return s(v instanceof Error ? v : new Error("" + v));
          })
        : m(d);
    } catch (v) {
      s(v);
    }
    function m(v) {
      try {
        var y = i[u].getTransferables && i[u].getTransferables(v);
        ((!y || !Array.isArray(y) || !y.length) && (y = void 0), s(v, y));
      } catch (b) {
        (console.error(b), s(b));
      }
    }
  }
  function n(r, s) {
    var o = void 0;
    self.troikaDefine = function (h) {
      return (o = h);
    };
    var u = URL.createObjectURL(
      new Blob(
        [
          "/** " +
            r.replace(/\*/g, "") +
            ` **/

troikaDefine(
` +
            s +
            `
)`,
        ],
        { type: "application/javascript" },
      ),
    );
    try {
      importScripts(u);
    } catch (h) {
      console.error(h);
    }
    return (URL.revokeObjectURL(u), delete self.troikaDefine, o);
  }
  self.addEventListener("message", function (r) {
    var s = r.data,
      o = s.messageId,
      u = s.action,
      h = s.data;
    try {
      (u === "registerModule" &&
        e(h, function (d) {
          d instanceof Error
            ? postMessage({ messageId: o, success: !1, error: d.message })
            : postMessage({
                messageId: o,
                success: !0,
                result: { isCallable: typeof d == "function" },
              });
        }),
        u === "callModule" &&
          t(h, function (d, m) {
            d instanceof Error
              ? postMessage({ messageId: o, success: !1, error: d.message })
              : postMessage(
                  { messageId: o, success: !0, result: d },
                  m || void 0,
                );
          }));
    } catch (d) {
      postMessage({ messageId: o, success: !1, error: d.stack });
    }
  });
}
function K7(i) {
  var e = function () {
    for (var t = [], n = arguments.length; n--; ) t[n] = arguments[n];
    return e._getInitResult().then(function (r) {
      if (typeof r == "function") return r.apply(void 0, t);
      throw new Error(
        "Worker module function was called but `init` did not return a callable function",
      );
    });
  };
  return (
    (e._getInitResult = function () {
      var t = i.dependencies,
        n = i.init;
      t = Array.isArray(t)
        ? t.map(function (s) {
            return (
              s &&
                ((s = s.onMainThread || s),
                s._getInitResult && (s = s._getInitResult())),
              s
            );
          })
        : [];
      var r = Promise.all(t).then(function (s) {
        return n.apply(null, s);
      });
      return (
        (e._getInitResult = function () {
          return r;
        }),
        r
      );
    }),
    e
  );
}
var RU = function () {
    var i = !1;
    if (typeof window < "u" && typeof window.document < "u")
      try {
        var e = new Worker(
          URL.createObjectURL(
            new Blob([""], { type: "application/javascript" }),
          ),
        );
        (e.terminate(), (i = !0));
      } catch (t) {
        console.log(
          "Troika createWorkerModule: web workers not allowed; falling back to main thread execution. Cause: [" +
            t.message +
            "]",
        );
      }
    return (
      (RU = function () {
        return i;
      }),
      i
    );
  },
  Q7 = 0,
  J7 = 0,
  HS = !1,
  Zg = Object.create(null),
  Kg = Object.create(null),
  HM = Object.create(null);
function jp(i) {
  if ((!i || typeof i.init != "function") && !HS)
    throw new Error("requires `options.init` function");
  var e = i.dependencies,
    t = i.init,
    n = i.getTransferables,
    r = i.workerId,
    s = K7(i);
  r == null && (r = "#default");
  var o = "workerModule" + ++Q7,
    u = i.name || o,
    h = null;
  e =
    e &&
    e.map(function (m) {
      return (
        typeof m == "function" &&
          !m.workerModuleData &&
          ((HS = !0),
          (m = jp({
            workerId: r,
            name: "<" + u + "> function dependency: " + m.name,
            init:
              `function(){return (
` +
              Nx(m) +
              `
)}`,
          })),
          (HS = !1)),
        m && m.workerModuleData && (m = m.workerModuleData),
        m
      );
    });
  function d() {
    for (var m = [], v = arguments.length; v--; ) m[v] = arguments[v];
    if (!RU()) return s.apply(void 0, m);
    if (!h) {
      h = G3(r, "registerModule", d.workerModuleData);
      var y = function () {
        ((h = null), Kg[r].delete(y));
      };
      (Kg[r] || (Kg[r] = new Set())).add(y);
    }
    return h.then(function (b) {
      var _ = b.isCallable;
      if (_) return G3(r, "callModule", { id: o, args: m });
      throw new Error(
        "Worker module function was called but `init` did not return a callable function",
      );
    });
  }
  return (
    (d.workerModuleData = {
      isWorkerModule: !0,
      id: o,
      name: u,
      dependencies: e,
      init: Nx(t),
      getTransferables: n && Nx(n),
    }),
    (d.onMainThread = s),
    d
  );
}
function $7(i) {
  (Kg[i] &&
    Kg[i].forEach(function (e) {
      e();
    }),
    Zg[i] && (Zg[i].terminate(), delete Zg[i]));
}
function Nx(i) {
  var e = i.toString();
  return (
    !/^function/.test(e) && /^\w+\s*\(/.test(e) && (e = "function " + e),
    e
  );
}
function eW(i) {
  var e = Zg[i];
  if (!e) {
    var t = Nx(Z7);
    ((e = Zg[i] =
      new Worker(
        URL.createObjectURL(
          new Blob(
            [
              "/** Worker Module Bootstrap: " +
                i.replace(/\*/g, "") +
                ` **/

;(` +
                t +
                ")()",
            ],
            { type: "application/javascript" },
          ),
        ),
      )),
      (e.onmessage = function (n) {
        var r = n.data,
          s = r.messageId,
          o = HM[s];
        if (!o)
          throw new Error(
            "WorkerModule response with empty or unknown messageId",
          );
        (delete HM[s], o(r));
      }));
  }
  return e;
}
function G3(i, e, t) {
  return new Promise(function (n, r) {
    var s = ++J7;
    ((HM[s] = function (o) {
      o.success
        ? n(o.result)
        : r(new Error("Error in worker " + e + " call: " + o.error));
    }),
      eW(i).postMessage({ messageId: s, action: e, data: t }));
  });
}
function DU() {
  var i = (function (e) {
    function t(le, fe, V, Z, se, ue, ge, ae) {
      var he = 1 - ge;
      ((ae.x = he * he * le + 2 * he * ge * V + ge * ge * se),
        (ae.y = he * he * fe + 2 * he * ge * Z + ge * ge * ue));
    }
    function n(le, fe, V, Z, se, ue, ge, ae, he, ye) {
      var ze = 1 - he;
      ((ye.x =
        ze * ze * ze * le +
        3 * ze * ze * he * V +
        3 * ze * he * he * se +
        he * he * he * ge),
        (ye.y =
          ze * ze * ze * fe +
          3 * ze * ze * he * Z +
          3 * ze * he * he * ue +
          he * he * he * ae));
    }
    function r(le, fe) {
      for (
        var V = /([MLQCZ])([^MLQCZ]*)/g, Z, se, ue, ge, ae;
        (Z = V.exec(le));
      ) {
        var he = Z[2]
          .replace(/^\s*|\s*$/g, "")
          .split(/[,\s]+/)
          .map(function (ye) {
            return parseFloat(ye);
          });
        switch (Z[1]) {
          case "M":
            ((ge = se = he[0]), (ae = ue = he[1]));
            break;
          case "L":
            (he[0] !== ge || he[1] !== ae) &&
              fe("L", ge, ae, (ge = he[0]), (ae = he[1]));
            break;
          case "Q": {
            fe("Q", ge, ae, (ge = he[2]), (ae = he[3]), he[0], he[1]);
            break;
          }
          case "C": {
            fe(
              "C",
              ge,
              ae,
              (ge = he[4]),
              (ae = he[5]),
              he[0],
              he[1],
              he[2],
              he[3],
            );
            break;
          }
          case "Z":
            (ge !== se || ae !== ue) && fe("L", ge, ae, se, ue);
            break;
        }
      }
    }
    function s(le, fe, V) {
      V === void 0 && (V = 16);
      var Z = { x: 0, y: 0 };
      r(le, function (se, ue, ge, ae, he, ye, ze, it, qe) {
        switch (se) {
          case "L":
            fe(ue, ge, ae, he);
            break;
          case "Q": {
            for (var Ye = ue, ft = ge, Re = 1; Re < V; Re++)
              (t(ue, ge, ye, ze, ae, he, Re / (V - 1), Z),
                fe(Ye, ft, Z.x, Z.y),
                (Ye = Z.x),
                (ft = Z.y));
            break;
          }
          case "C": {
            for (var Ie = ue, De = ge, Qe = 1; Qe < V; Qe++)
              (n(ue, ge, ye, ze, it, qe, ae, he, Qe / (V - 1), Z),
                fe(Ie, De, Z.x, Z.y),
                (Ie = Z.x),
                (De = Z.y));
            break;
          }
        }
      });
    }
    var o =
        "precision highp float;attribute vec2 aUV;varying vec2 vUV;void main(){vUV=aUV;gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}",
      u =
        "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){gl_FragColor=texture2D(tex,vUV);}",
      h = new WeakMap(),
      d = {
        premultipliedAlpha: !1,
        preserveDrawingBuffer: !0,
        antialias: !1,
        depth: !1,
      };
    function m(le, fe) {
      var V = le.getContext ? le.getContext("webgl", d) : le,
        Z = h.get(V);
      if (!Z) {
        let Ie = function (Te) {
            var ke = ue[Te];
            if (!ke && ((ke = ue[Te] = V.getExtension(Te)), !ke))
              throw new Error(Te + " not supported");
            return ke;
          },
          De = function (Te, ke) {
            var H = V.createShader(ke);
            return (V.shaderSource(H, Te), V.compileShader(H), H);
          },
          Qe = function (Te, ke, H, k) {
            if (!ge[Te]) {
              var oe = {},
                Ae = {},
                _e = V.createProgram();
              (V.attachShader(_e, De(ke, V.VERTEX_SHADER)),
                V.attachShader(_e, De(H, V.FRAGMENT_SHADER)),
                V.linkProgram(_e),
                (ge[Te] = {
                  program: _e,
                  transaction: function (et) {
                    (V.useProgram(_e),
                      et({
                        setUniform: function (ht, yt) {
                          for (
                            var Ge = [], Ve = arguments.length - 2;
                            Ve-- > 0;
                          )
                            Ge[Ve] = arguments[Ve + 2];
                          var Ze =
                            Ae[yt] || (Ae[yt] = V.getUniformLocation(_e, yt));
                          V["uniform" + ht].apply(V, [Ze].concat(Ge));
                        },
                        setAttribute: function (ht, yt, Ge, Ve, Ze) {
                          var re = oe[ht];
                          (re ||
                            (re = oe[ht] =
                              {
                                buf: V.createBuffer(),
                                loc: V.getAttribLocation(_e, ht),
                                data: null,
                              }),
                            V.bindBuffer(V.ARRAY_BUFFER, re.buf),
                            V.vertexAttribPointer(
                              re.loc,
                              yt,
                              V.FLOAT,
                              !1,
                              0,
                              0,
                            ),
                            V.enableVertexAttribArray(re.loc),
                            se
                              ? V.vertexAttribDivisor(re.loc, Ve)
                              : Ie(
                                  "ANGLE_instanced_arrays",
                                ).vertexAttribDivisorANGLE(re.loc, Ve),
                            Ze !== re.data &&
                              (V.bufferData(V.ARRAY_BUFFER, Ze, Ge),
                              (re.data = Ze)));
                        },
                      }));
                  },
                }));
            }
            ge[Te].transaction(k);
          },
          K = function (Te, ke) {
            he++;
            try {
              V.activeTexture(V.TEXTURE0 + he);
              var H = ae[Te];
              (H ||
                ((H = ae[Te] = V.createTexture()),
                V.bindTexture(V.TEXTURE_2D, H),
                V.texParameteri(V.TEXTURE_2D, V.TEXTURE_MIN_FILTER, V.NEAREST),
                V.texParameteri(V.TEXTURE_2D, V.TEXTURE_MAG_FILTER, V.NEAREST)),
                V.bindTexture(V.TEXTURE_2D, H),
                ke(H, he));
            } finally {
              he--;
            }
          },
          rt = function (Te, ke, H) {
            var k = V.createFramebuffer();
            (ye.push(k),
              V.bindFramebuffer(V.FRAMEBUFFER, k),
              V.activeTexture(V.TEXTURE0 + ke),
              V.bindTexture(V.TEXTURE_2D, Te),
              V.framebufferTexture2D(
                V.FRAMEBUFFER,
                V.COLOR_ATTACHMENT0,
                V.TEXTURE_2D,
                Te,
                0,
              ));
            try {
              H(k);
            } finally {
              (V.deleteFramebuffer(k),
                V.bindFramebuffer(V.FRAMEBUFFER, ye[--ye.length - 1] || null));
            }
          },
          je = function () {
            ((ue = {}), (ge = {}), (ae = {}), (he = -1), (ye.length = 0));
          };
        var ze = Ie,
          it = De,
          qe = Qe,
          Ye = K,
          ft = rt,
          Re = je,
          se =
            typeof WebGL2RenderingContext < "u" &&
            V instanceof WebGL2RenderingContext,
          ue = {},
          ge = {},
          ae = {},
          he = -1,
          ye = [];
        (V.canvas.addEventListener(
          "webglcontextlost",
          function (Te) {
            (je(), Te.preventDefault());
          },
          !1,
        ),
          h.set(
            V,
            (Z = {
              gl: V,
              isWebGL2: se,
              getExtension: Ie,
              withProgram: Qe,
              withTexture: K,
              withTextureFramebuffer: rt,
              handleContextLoss: je,
            }),
          ));
      }
      fe(Z);
    }
    function v(le, fe, V, Z, se, ue, ge, ae) {
      (ge === void 0 && (ge = 15),
        ae === void 0 && (ae = null),
        m(le, function (he) {
          var ye = he.gl,
            ze = he.withProgram,
            it = he.withTexture;
          it("copy", function (qe, Ye) {
            (ye.texImage2D(
              ye.TEXTURE_2D,
              0,
              ye.RGBA,
              se,
              ue,
              0,
              ye.RGBA,
              ye.UNSIGNED_BYTE,
              fe,
            ),
              ze("copy", o, u, function (ft) {
                var Re = ft.setUniform,
                  Ie = ft.setAttribute;
                (Ie(
                  "aUV",
                  2,
                  ye.STATIC_DRAW,
                  0,
                  new Float32Array([0, 0, 2, 0, 0, 2]),
                ),
                  Re("1i", "image", Ye),
                  ye.bindFramebuffer(ye.FRAMEBUFFER, ae || null),
                  ye.disable(ye.BLEND),
                  ye.colorMask(ge & 8, ge & 4, ge & 2, ge & 1),
                  ye.viewport(V, Z, se, ue),
                  ye.scissor(V, Z, se, ue),
                  ye.drawArrays(ye.TRIANGLES, 0, 3));
              }));
          });
        }));
    }
    function y(le, fe, V) {
      var Z = le.width,
        se = le.height;
      m(le, function (ue) {
        var ge = ue.gl,
          ae = new Uint8Array(Z * se * 4);
        (ge.readPixels(0, 0, Z, se, ge.RGBA, ge.UNSIGNED_BYTE, ae),
          (le.width = fe),
          (le.height = V),
          v(ge, ae, 0, 0, Z, se));
      });
    }
    var b = Object.freeze({
      __proto__: null,
      withWebGLContext: m,
      renderImageData: v,
      resizeWebGLCanvasWithoutClearing: y,
    });
    function _(le, fe, V, Z, se, ue) {
      ue === void 0 && (ue = 1);
      var ge = new Uint8Array(le * fe),
        ae = Z[2] - Z[0],
        he = Z[3] - Z[1],
        ye = [];
      (s(V, function (Ie, De, Qe, K) {
        ye.push({
          x1: Ie,
          y1: De,
          x2: Qe,
          y2: K,
          minX: Math.min(Ie, Qe),
          minY: Math.min(De, K),
          maxX: Math.max(Ie, Qe),
          maxY: Math.max(De, K),
        });
      }),
        ye.sort(function (Ie, De) {
          return Ie.maxX - De.maxX;
        }));
      for (var ze = 0; ze < le; ze++)
        for (var it = 0; it < fe; it++) {
          var qe = ft(
              Z[0] + (ae * (ze + 0.5)) / le,
              Z[1] + (he * (it + 0.5)) / fe,
            ),
            Ye = Math.pow(1 - Math.abs(qe) / se, ue) / 2;
          (qe < 0 && (Ye = 1 - Ye),
            (Ye = Math.max(0, Math.min(255, Math.round(Ye * 255)))),
            (ge[it * le + ze] = Ye));
        }
      return ge;
      function ft(Ie, De) {
        for (var Qe = 1 / 0, K = 1 / 0, rt = ye.length; rt--; ) {
          var je = ye[rt];
          if (je.maxX + K <= Ie) break;
          if (Ie + K > je.minX && De - K < je.maxY && De + K > je.minY) {
            var Te = T(Ie, De, je.x1, je.y1, je.x2, je.y2);
            Te < Qe && ((Qe = Te), (K = Math.sqrt(Qe)));
          }
        }
        return (Re(Ie, De) && (K = -K), K);
      }
      function Re(Ie, De) {
        for (var Qe = 0, K = ye.length; K--; ) {
          var rt = ye[K];
          if (rt.maxX <= Ie) break;
          var je =
            rt.y1 > De != rt.y2 > De &&
            Ie < ((rt.x2 - rt.x1) * (De - rt.y1)) / (rt.y2 - rt.y1) + rt.x1;
          je && (Qe += rt.y1 < rt.y2 ? 1 : -1);
        }
        return Qe !== 0;
      }
    }
    function w(le, fe, V, Z, se, ue, ge, ae, he, ye) {
      (ue === void 0 && (ue = 1),
        ae === void 0 && (ae = 0),
        he === void 0 && (he = 0),
        ye === void 0 && (ye = 0),
        E(le, fe, V, Z, se, ue, ge, null, ae, he, ye));
    }
    function E(le, fe, V, Z, se, ue, ge, ae, he, ye, ze) {
      (ue === void 0 && (ue = 1),
        he === void 0 && (he = 0),
        ye === void 0 && (ye = 0),
        ze === void 0 && (ze = 0));
      for (
        var it = _(le, fe, V, Z, se, ue),
          qe = new Uint8Array(it.length * 4),
          Ye = 0;
        Ye < it.length;
        Ye++
      )
        qe[Ye * 4 + ze] = it[Ye];
      v(ge, qe, he, ye, le, fe, 1 << (3 - ze), ae);
    }
    function T(le, fe, V, Z, se, ue) {
      var ge = se - V,
        ae = ue - Z,
        he = ge * ge + ae * ae,
        ye = he
          ? Math.max(0, Math.min(1, ((le - V) * ge + (fe - Z) * ae) / he))
          : 0,
        ze = le - (V + ye * ge),
        it = fe - (Z + ye * ae);
      return ze * ze + it * it;
    }
    var C = Object.freeze({
        __proto__: null,
        generate: _,
        generateIntoCanvas: w,
        generateIntoFramebuffer: E,
      }),
      R =
        "precision highp float;uniform vec4 uGlyphBounds;attribute vec2 aUV;attribute vec4 aLineSegment;varying vec4 vLineSegment;varying vec2 vGlyphXY;void main(){vLineSegment=aLineSegment;vGlyphXY=mix(uGlyphBounds.xy,uGlyphBounds.zw,aUV);gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}",
      L =
        "precision highp float;uniform vec4 uGlyphBounds;uniform float uMaxDistance;uniform float uExponent;varying vec4 vLineSegment;varying vec2 vGlyphXY;float absDistToSegment(vec2 point,vec2 lineA,vec2 lineB){vec2 lineDir=lineB-lineA;float lenSq=dot(lineDir,lineDir);float t=lenSq==0.0 ? 0.0 : clamp(dot(point-lineA,lineDir)/lenSq,0.0,1.0);vec2 linePt=lineA+t*lineDir;return distance(point,linePt);}void main(){vec4 seg=vLineSegment;vec2 p=vGlyphXY;float dist=absDistToSegment(p,seg.xy,seg.zw);float val=pow(1.0-clamp(dist/uMaxDistance,0.0,1.0),uExponent)*0.5;bool crossing=(seg.y>p.y!=seg.w>p.y)&&(p.x<(seg.z-seg.x)*(p.y-seg.y)/(seg.w-seg.y)+seg.x);bool crossingUp=crossing&&vLineSegment.y<vLineSegment.w;gl_FragColor=vec4(crossingUp ? 1.0/255.0 : 0.0,crossing&&!crossingUp ? 1.0/255.0 : 0.0,0.0,val);}",
      I =
        "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){vec4 color=texture2D(tex,vUV);bool inside=color.r!=color.g;float val=inside ? 1.0-color.a : color.a;gl_FragColor=vec4(val);}",
      O = new Float32Array([0, 0, 2, 0, 0, 2]),
      B = null,
      N = !1,
      F = {},
      j = new WeakMap();
    function q(le) {
      if (!N && !ne(le)) throw new Error("WebGL generation not supported");
    }
    function X(le, fe, V, Z, se, ue, ge) {
      if (
        (ue === void 0 && (ue = 1),
        ge === void 0 && (ge = null),
        !ge && ((ge = B), !ge))
      ) {
        var ae =
          typeof OffscreenCanvas == "function"
            ? new OffscreenCanvas(1, 1)
            : typeof document < "u"
              ? document.createElement("canvas")
              : null;
        if (!ae) throw new Error("OffscreenCanvas or DOM canvas not supported");
        ge = B = ae.getContext("webgl", { depth: !1 });
      }
      q(ge);
      var he = new Uint8Array(le * fe * 4);
      m(ge, function (qe) {
        var Ye = qe.gl,
          ft = qe.withTexture,
          Re = qe.withTextureFramebuffer;
        ft("readable", function (Ie, De) {
          (Ye.texImage2D(
            Ye.TEXTURE_2D,
            0,
            Ye.RGBA,
            le,
            fe,
            0,
            Ye.RGBA,
            Ye.UNSIGNED_BYTE,
            null,
          ),
            Re(Ie, De, function (Qe) {
              (ee(le, fe, V, Z, se, ue, Ye, Qe, 0, 0, 0),
                Ye.readPixels(0, 0, le, fe, Ye.RGBA, Ye.UNSIGNED_BYTE, he));
            }));
        });
      });
      for (
        var ye = new Uint8Array(le * fe), ze = 0, it = 0;
        ze < he.length;
        ze += 4
      )
        ye[it++] = he[ze];
      return ye;
    }
    function J(le, fe, V, Z, se, ue, ge, ae, he, ye) {
      (ue === void 0 && (ue = 1),
        ae === void 0 && (ae = 0),
        he === void 0 && (he = 0),
        ye === void 0 && (ye = 0),
        ee(le, fe, V, Z, se, ue, ge, null, ae, he, ye));
    }
    function ee(le, fe, V, Z, se, ue, ge, ae, he, ye, ze) {
      (ue === void 0 && (ue = 1),
        he === void 0 && (he = 0),
        ye === void 0 && (ye = 0),
        ze === void 0 && (ze = 0),
        q(ge));
      var it = [];
      (s(V, function (qe, Ye, ft, Re) {
        it.push(qe, Ye, ft, Re);
      }),
        (it = new Float32Array(it)),
        m(ge, function (qe) {
          var Ye = qe.gl,
            ft = qe.isWebGL2,
            Re = qe.getExtension,
            Ie = qe.withProgram,
            De = qe.withTexture,
            Qe = qe.withTextureFramebuffer,
            K = qe.handleContextLoss;
          if (
            (De("rawDistances", function (rt, je) {
              ((le !== rt._lastWidth || fe !== rt._lastHeight) &&
                Ye.texImage2D(
                  Ye.TEXTURE_2D,
                  0,
                  Ye.RGBA,
                  (rt._lastWidth = le),
                  (rt._lastHeight = fe),
                  0,
                  Ye.RGBA,
                  Ye.UNSIGNED_BYTE,
                  null,
                ),
                Ie("main", R, L, function (Te) {
                  var ke = Te.setAttribute,
                    H = Te.setUniform,
                    k = !ft && Re("ANGLE_instanced_arrays"),
                    oe = !ft && Re("EXT_blend_minmax");
                  (ke("aUV", 2, Ye.STATIC_DRAW, 0, O),
                    ke("aLineSegment", 4, Ye.DYNAMIC_DRAW, 1, it),
                    H.apply(void 0, ["4f", "uGlyphBounds"].concat(Z)),
                    H("1f", "uMaxDistance", se),
                    H("1f", "uExponent", ue),
                    Qe(rt, je, function (Ae) {
                      (Ye.enable(Ye.BLEND),
                        Ye.colorMask(!0, !0, !0, !0),
                        Ye.viewport(0, 0, le, fe),
                        Ye.scissor(0, 0, le, fe),
                        Ye.blendFunc(Ye.ONE, Ye.ONE),
                        Ye.blendEquationSeparate(
                          Ye.FUNC_ADD,
                          ft ? Ye.MAX : oe.MAX_EXT,
                        ),
                        Ye.clear(Ye.COLOR_BUFFER_BIT),
                        ft
                          ? Ye.drawArraysInstanced(
                              Ye.TRIANGLES,
                              0,
                              3,
                              it.length / 4,
                            )
                          : k.drawArraysInstancedANGLE(
                              Ye.TRIANGLES,
                              0,
                              3,
                              it.length / 4,
                            ));
                    }));
                }),
                Ie("post", o, I, function (Te) {
                  (Te.setAttribute("aUV", 2, Ye.STATIC_DRAW, 0, O),
                    Te.setUniform("1i", "tex", je),
                    Ye.bindFramebuffer(Ye.FRAMEBUFFER, ae),
                    Ye.disable(Ye.BLEND),
                    Ye.colorMask(ze === 0, ze === 1, ze === 2, ze === 3),
                    Ye.viewport(he, ye, le, fe),
                    Ye.scissor(he, ye, le, fe),
                    Ye.drawArrays(Ye.TRIANGLES, 0, 3));
                }));
            }),
            Ye.isContextLost())
          )
            throw (K(), new Error("webgl context lost"));
        }));
    }
    function ne(le) {
      var fe = !le || le === B ? F : le.canvas || le,
        V = j.get(fe);
      if (V === void 0) {
        N = !0;
        var Z = null;
        try {
          var se = [
              97, 106, 97, 61, 99, 137, 118, 80, 80, 118, 137, 99, 61, 97, 106,
              97,
            ],
            ue = X(4, 4, "M8,8L16,8L24,24L16,24Z", [0, 0, 32, 32], 24, 1, le);
          ((V =
            ue &&
            se.length === ue.length &&
            ue.every(function (ge, ae) {
              return ge === se[ae];
            })),
            V || ((Z = "bad trial run results"), console.info(se, ue)));
        } catch (ge) {
          ((V = !1), (Z = ge.message));
        }
        (Z && console.warn("WebGL SDF generation not supported:", Z),
          (N = !1),
          j.set(fe, V));
      }
      return V;
    }
    var W = Object.freeze({
      __proto__: null,
      generate: X,
      generateIntoCanvas: J,
      generateIntoFramebuffer: ee,
      isSupported: ne,
    });
    function $(le, fe, V, Z, se, ue) {
      (se === void 0 && (se = Math.max(Z[2] - Z[0], Z[3] - Z[1]) / 2),
        ue === void 0 && (ue = 1));
      try {
        return X.apply(W, arguments);
      } catch (ge) {
        return (
          console.info("WebGL SDF generation failed, falling back to JS", ge),
          _.apply(C, arguments)
        );
      }
    }
    function de(le, fe, V, Z, se, ue, ge, ae, he, ye) {
      (se === void 0 && (se = Math.max(Z[2] - Z[0], Z[3] - Z[1]) / 2),
        ue === void 0 && (ue = 1),
        ae === void 0 && (ae = 0),
        he === void 0 && (he = 0),
        ye === void 0 && (ye = 0));
      try {
        return J.apply(W, arguments);
      } catch (ze) {
        return (
          console.info("WebGL SDF generation failed, falling back to JS", ze),
          w.apply(C, arguments)
        );
      }
    }
    return (
      (e.forEachPathCommand = r),
      (e.generate = $),
      (e.generateIntoCanvas = de),
      (e.javascript = C),
      (e.pathToLineSegments = s),
      (e.webgl = W),
      (e.webglUtils = b),
      Object.defineProperty(e, "__esModule", { value: !0 }),
      e
    );
  })({});
  return i;
}
function tW() {
  var i = (function (e) {
    var t = {
        R: "13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73",
        EN: "1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9",
        ES: "17,2,6dp+1,f+1,av,16vr,mx+1,4o,2",
        ET: "z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj",
        AN: "16o+5,2j+9,2+1,35,ed,1ff2+9,87+u",
        CS: "18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b",
        B: "a,3,f+2,2v,690",
        S: "9,2,k",
        WS: "c,k,4f4,1vk+a,u,1j,335",
        ON: "x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i",
        BN: "0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1",
        NSM: "lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n",
        AL: "16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d",
        LRO: "6ct",
        RLO: "6cu",
        LRE: "6cq",
        RLE: "6cr",
        PDF: "6cs",
        LRI: "6ee",
        RLI: "6ef",
        FSI: "6eg",
        PDI: "6eh",
      },
      n = {},
      r = {};
    ((n.L = 1),
      (r[1] = "L"),
      Object.keys(t).forEach(function (K, rt) {
        ((n[K] = 1 << (rt + 1)), (r[n[K]] = K));
      }),
      Object.freeze(n));
    var s = n.LRI | n.RLI | n.FSI,
      o = n.L | n.R | n.AL,
      u = n.B | n.S | n.WS | n.ON | n.FSI | n.LRI | n.RLI | n.PDI,
      h = n.BN | n.RLE | n.LRE | n.RLO | n.LRO | n.PDF,
      d = n.S | n.WS | n.B | s | n.PDI | h,
      m = null;
    function v() {
      if (!m) {
        m = new Map();
        var K = function (je) {
          if (t.hasOwnProperty(je)) {
            var Te = 0;
            t[je].split(",").forEach(function (ke) {
              var H = ke.split("+"),
                k = H[0],
                oe = H[1];
              ((k = parseInt(k, 36)),
                (oe = oe ? parseInt(oe, 36) : 0),
                m.set((Te += k), n[je]));
              for (var Ae = 0; Ae < oe; Ae++) m.set(++Te, n[je]);
            });
          }
        };
        for (var rt in t) K(rt);
      }
    }
    function y(K) {
      return (v(), m.get(K.codePointAt(0)) || n.L);
    }
    function b(K) {
      return r[y(K)];
    }
    var _ = {
      pairs:
        "14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1",
      canonical:
        "6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye",
    };
    function w(K, rt) {
      var je = 36,
        Te = 0,
        ke = new Map(),
        H = rt && new Map(),
        k;
      return (
        K.split(",").forEach(function oe(Ae) {
          if (Ae.indexOf("+") !== -1) for (var _e = +Ae; _e--; ) oe(k);
          else {
            k = Ae;
            var be = Ae.split(">"),
              et = be[0],
              $e = be[1];
            ((et = String.fromCodePoint((Te += parseInt(et, je)))),
              ($e = String.fromCodePoint((Te += parseInt($e, je)))),
              ke.set(et, $e),
              rt && H.set($e, et));
          }
        }),
        { map: ke, reverseMap: H }
      );
    }
    var E, T, C;
    function R() {
      if (!E) {
        var K = w(_.pairs, !0),
          rt = K.map,
          je = K.reverseMap;
        ((E = rt), (T = je), (C = w(_.canonical, !1).map));
      }
    }
    function L(K) {
      return (R(), E.get(K) || null);
    }
    function I(K) {
      return (R(), T.get(K) || null);
    }
    function O(K) {
      return (R(), C.get(K) || null);
    }
    var B = n.L,
      N = n.R,
      F = n.EN,
      j = n.ES,
      q = n.ET,
      X = n.AN,
      J = n.CS,
      ee = n.B,
      ne = n.S,
      W = n.ON,
      $ = n.BN,
      de = n.NSM,
      le = n.AL,
      fe = n.LRO,
      V = n.RLO,
      Z = n.LRE,
      se = n.RLE,
      ue = n.PDF,
      ge = n.LRI,
      ae = n.RLI,
      he = n.FSI,
      ye = n.PDI;
    function ze(K, rt) {
      for (
        var je = 125, Te = new Uint32Array(K.length), ke = 0;
        ke < K.length;
        ke++
      )
        Te[ke] = y(K[ke]);
      var H = new Map();
      function k(vr, As) {
        var Cr = Te[vr];
        ((Te[vr] = As),
          H.set(Cr, H.get(Cr) - 1),
          Cr & u && H.set(u, H.get(u) - 1),
          H.set(As, (H.get(As) || 0) + 1),
          As & u && H.set(u, (H.get(u) || 0) + 1));
      }
      for (
        var oe = new Uint8Array(K.length),
          Ae = new Map(),
          _e = [],
          be = null,
          et = 0;
        et < K.length;
        et++
      )
        (be ||
          _e.push(
            (be = {
              start: et,
              end: K.length - 1,
              level: rt === "rtl" ? 1 : rt === "ltr" ? 0 : nu(et, !1),
            }),
          ),
          Te[et] & ee && ((be.end = et), (be = null)));
      for (
        var $e = se | Z | V | fe | s | ye | ue | ee,
          ht = function (vr) {
            return vr + (vr & 1 ? 1 : 2);
          },
          yt = function (vr) {
            return vr + (vr & 1 ? 2 : 1);
          },
          Ge = 0;
        Ge < _e.length;
        Ge++
      ) {
        be = _e[Ge];
        var Ve = [{ _level: be.level, _override: 0, _isolate: 0 }],
          Ze = void 0,
          re = 0,
          Se = 0,
          lt = 0;
        H.clear();
        for (var ce = be.start; ce <= be.end; ce++) {
          var Oe = Te[ce];
          if (
            ((Ze = Ve[Ve.length - 1]),
            H.set(Oe, (H.get(Oe) || 0) + 1),
            Oe & u && H.set(u, (H.get(u) || 0) + 1),
            Oe & $e)
          )
            if (Oe & (se | Z)) {
              oe[ce] = Ze._level;
              var Ke = (Oe === se ? yt : ht)(Ze._level);
              Ke <= je && !re && !Se
                ? Ve.push({ _level: Ke, _override: 0, _isolate: 0 })
                : re || Se++;
            } else if (Oe & (V | fe)) {
              oe[ce] = Ze._level;
              var dt = (Oe === V ? yt : ht)(Ze._level);
              dt <= je && !re && !Se
                ? Ve.push({
                    _level: dt,
                    _override: Oe & V ? N : B,
                    _isolate: 0,
                  })
                : re || Se++;
            } else if (Oe & s) {
              (Oe & he && (Oe = nu(ce + 1, !0) === 1 ? ae : ge),
                (oe[ce] = Ze._level),
                Ze._override && k(ce, Ze._override));
              var Je = (Oe === ae ? yt : ht)(Ze._level);
              Je <= je && re === 0 && Se === 0
                ? (lt++,
                  Ve.push({
                    _level: Je,
                    _override: 0,
                    _isolate: 1,
                    _isolInitIndex: ce,
                  }))
                : re++;
            } else if (Oe & ye) {
              if (re > 0) re--;
              else if (lt > 0) {
                for (Se = 0; !Ve[Ve.length - 1]._isolate; ) Ve.pop();
                var Ee = Ve[Ve.length - 1]._isolInitIndex;
                (Ee != null && (Ae.set(Ee, ce), Ae.set(ce, Ee)),
                  Ve.pop(),
                  lt--);
              }
              ((Ze = Ve[Ve.length - 1]),
                (oe[ce] = Ze._level),
                Ze._override && k(ce, Ze._override));
            } else
              Oe & ue
                ? (re === 0 &&
                    (Se > 0
                      ? Se--
                      : !Ze._isolate &&
                        Ve.length > 1 &&
                        (Ve.pop(), (Ze = Ve[Ve.length - 1]))),
                  (oe[ce] = Ze._level))
                : Oe & ee && (oe[ce] = be.level);
          else
            ((oe[ce] = Ze._level),
              Ze._override && Oe !== $ && k(ce, Ze._override));
        }
        for (var ct = [], Mt = null, St = be.start; St <= be.end; St++) {
          var Dt = Te[St];
          if (!(Dt & h)) {
            var hn = oe[St],
              bn = Dt & s,
              Bn = Dt === ye;
            Mt && hn === Mt._level
              ? ((Mt._end = St), (Mt._endsWithIsolInit = bn))
              : ct.push(
                  (Mt = {
                    _start: St,
                    _end: St,
                    _level: hn,
                    _startsWithPDI: Bn,
                    _endsWithIsolInit: bn,
                  }),
                );
          }
        }
        for (var Ai = [], $r = 0; $r < ct.length; $r++) {
          var Zi = ct[$r];
          if (!Zi._startsWithPDI || (Zi._startsWithPDI && !Ae.has(Zi._start))) {
            for (
              var ar = [(Mt = Zi)], zi = void 0;
              Mt && Mt._endsWithIsolInit && (zi = Ae.get(Mt._end)) != null;
            )
              for (var xi = $r + 1; xi < ct.length; xi++)
                if (ct[xi]._start === zi) {
                  ar.push((Mt = ct[xi]));
                  break;
                }
            for (var Hn = [], Un = 0; Un < ar.length; Un++)
              for (var ii = ar[Un], Ir = ii._start; Ir <= ii._end; Ir++)
                Hn.push(Ir);
            for (
              var gr = oe[Hn[0]], es = be.level, _s = Hn[0] - 1;
              _s >= 0;
              _s--
            )
              if (!(Te[_s] & h)) {
                es = oe[_s];
                break;
              }
            var Ba = Hn[Hn.length - 1],
              Ss = oe[Ba],
              Xs = be.level;
            if (!(Te[Ba] & s)) {
              for (var ts = Ba + 1; ts <= be.end; ts++)
                if (!(Te[ts] & h)) {
                  Xs = oe[ts];
                  break;
                }
            }
            Ai.push({
              _seqIndices: Hn,
              _sosType: Math.max(es, gr) % 2 ? N : B,
              _eosType: Math.max(Xs, Ss) % 2 ? N : B,
            });
          }
        }
        for (var Ms = 0; Ms < Ai.length; Ms++) {
          var qs = Ai[Ms],
            G = qs._seqIndices,
            ve = qs._sosType,
            Fe = qs._eosType,
            Le = oe[G[0]] & 1 ? N : B;
          if (H.get(de))
            for (var Ce = 0; Ce < G.length; Ce++) {
              var pt = G[Ce];
              if (Te[pt] & de) {
                for (var bt = ve, _t = Ce - 1; _t >= 0; _t--)
                  if (!(Te[G[_t]] & h)) {
                    bt = Te[G[_t]];
                    break;
                  }
                k(pt, bt & (s | ye) ? W : bt);
              }
            }
          if (H.get(F))
            for (var gt = 0; gt < G.length; gt++) {
              var Lt = G[gt];
              if (Te[Lt] & F)
                for (var zt = gt - 1; zt >= -1; zt--) {
                  var Wt = zt === -1 ? ve : Te[G[zt]];
                  if (Wt & o) {
                    Wt === le && k(Lt, X);
                    break;
                  }
                }
            }
          if (H.get(le))
            for (var At = 0; At < G.length; At++) {
              var Kt = G[At];
              Te[Kt] & le && k(Kt, N);
            }
          if (H.get(j) || H.get(J))
            for (var Ln = 1; Ln < G.length - 1; Ln++) {
              var On = G[Ln];
              if (Te[On] & (j | J)) {
                for (
                  var rn = 0, mn = 0, vt = Ln - 1;
                  vt >= 0 && ((rn = Te[G[vt]]), !!(rn & h));
                  vt--
                );
                for (
                  var bi = Ln + 1;
                  bi < G.length && ((mn = Te[G[bi]]), !!(mn & h));
                  bi++
                );
                rn === mn &&
                  (Te[On] === j ? rn === F : rn & (F | X)) &&
                  k(On, rn);
              }
            }
          if (H.get(F))
            for (var Pt = 0; Pt < G.length; Pt++) {
              var Bi = G[Pt];
              if (Te[Bi] & F) {
                for (var ki = Pt - 1; ki >= 0 && Te[G[ki]] & (q | h); ki--)
                  k(G[ki], F);
                for (Pt++; Pt < G.length && Te[G[Pt]] & (q | h | F); Pt++)
                  Te[G[Pt]] !== F && k(G[Pt], F);
              }
            }
          if (H.get(q) || H.get(j) || H.get(J))
            for (var ei = 0; ei < G.length; ei++) {
              var Ki = G[ei];
              if (Te[Ki] & (q | j | J)) {
                k(Ki, W);
                for (var gn = ei - 1; gn >= 0 && Te[G[gn]] & h; gn--)
                  k(G[gn], W);
                for (var qn = ei + 1; qn < G.length && Te[G[qn]] & h; qn++)
                  k(G[qn], W);
              }
            }
          if (H.get(F))
            for (var Vi = 0, ri = ve; Vi < G.length; Vi++) {
              var Or = G[Vi],
                ns = Te[Or];
              ns & F ? ri === B && k(Or, B) : ns & o && (ri = ns);
            }
          if (H.get(u)) {
            var Ts = N | F | X,
              gf = Ts | B,
              el = [];
            {
              for (var Ys = [], wr = 0; wr < G.length; wr++)
                if (Te[G[wr]] & u) {
                  var ka = K[G[wr]],
                    nc = void 0;
                  if (L(ka) !== null)
                    if (Ys.length < 63) Ys.push({ char: ka, seqIndex: wr });
                    else break;
                  else if ((nc = I(ka)) !== null)
                    for (var Es = Ys.length - 1; Es >= 0; Es--) {
                      var Zs = Ys[Es].char;
                      if (Zs === nc || Zs === I(O(ka)) || L(O(Zs)) === ka) {
                        (el.push([Ys[Es].seqIndex, wr]), (Ys.length = Es));
                        break;
                      }
                    }
                }
              el.sort(function (vr, As) {
                return vr[0] - As[0];
              });
            }
            for (var ic = 0; ic < el.length; ic++) {
              for (
                var rc = el[ic],
                  tl = rc[0],
                  Va = rc[1],
                  ws = !1,
                  Fr = 0,
                  Ga = tl + 1;
                Ga < Va;
                Ga++
              ) {
                var Ar = G[Ga];
                if (Te[Ar] & gf) {
                  ws = !0;
                  var sc = Te[Ar] & Ts ? N : B;
                  if (sc === Le) {
                    Fr = sc;
                    break;
                  }
                }
              }
              if (ws && !Fr) {
                Fr = ve;
                for (var Sa = tl - 1; Sa >= 0; Sa--) {
                  var nl = G[Sa];
                  if (Te[nl] & gf) {
                    var il = Te[nl] & Ts ? N : B;
                    il !== Le ? (Fr = il) : (Fr = Le);
                    break;
                  }
                }
              }
              if (Fr) {
                if (((Te[G[tl]] = Te[G[Va]] = Fr), Fr !== Le)) {
                  for (var Ks = tl + 1; Ks < G.length; Ks++)
                    if (!(Te[G[Ks]] & h)) {
                      y(K[G[Ks]]) & de && (Te[G[Ks]] = Fr);
                      break;
                    }
                }
                if (Fr !== Le) {
                  for (var rl = Va + 1; rl < G.length; rl++)
                    if (!(Te[G[rl]] & h)) {
                      y(K[G[rl]]) & de && (Te[G[rl]] = Fr);
                      break;
                    }
                }
              }
            }
            for (var si = 0; si < G.length; si++)
              if (Te[G[si]] & u) {
                for (var Ma = si, So = si, Ha = ve, sl = si - 1; sl >= 0; sl--)
                  if (Te[G[sl]] & h) Ma = sl;
                  else {
                    Ha = Te[G[sl]] & Ts ? N : B;
                    break;
                  }
                for (var al = Fe, ja = si + 1; ja < G.length; ja++)
                  if (Te[G[ja]] & (u | h)) So = ja;
                  else {
                    al = Te[G[ja]] & Ts ? N : B;
                    break;
                  }
                for (var Wa = Ma; Wa <= So; Wa++)
                  Te[G[Wa]] = Ha === al ? Ha : Le;
                si = So;
              }
          }
        }
        for (var Gi = be.start; Gi <= be.end; Gi++) {
          var vf = oe[Gi],
            ac = Te[Gi];
          if (
            (vf & 1
              ? ac & (B | F | X) && oe[Gi]++
              : ac & N
                ? oe[Gi]++
                : ac & (X | F) && (oe[Gi] += 2),
            ac & h && (oe[Gi] = Gi === 0 ? be.level : oe[Gi - 1]),
            Gi === be.end || y(K[Gi]) & (ne | ee))
          )
            for (var oc = Gi; oc >= 0 && y(K[oc]) & d; oc--) oe[oc] = be.level;
        }
      }
      return { levels: oe, paragraphs: _e };
      function nu(vr, As) {
        for (var Cr = vr; Cr < K.length; Cr++) {
          var Ta = Te[Cr];
          if (Ta & (N | le)) return 1;
          if (Ta & (ee | B) || (As && Ta === ye)) return 0;
          if (Ta & s) {
            var ol = iu(Cr);
            Cr = ol === -1 ? K.length : ol;
          }
        }
        return 0;
      }
      function iu(vr) {
        for (var As = 1, Cr = vr + 1; Cr < K.length; Cr++) {
          var Ta = Te[Cr];
          if (Ta & ee) break;
          if (Ta & ye) {
            if (--As === 0) return Cr;
          } else Ta & s && As++;
        }
        return -1;
      }
    }
    var it =
        "14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1",
      qe;
    function Ye() {
      if (!qe) {
        var K = w(it, !0),
          rt = K.map,
          je = K.reverseMap;
        (je.forEach(function (Te, ke) {
          rt.set(ke, Te);
        }),
          (qe = rt));
      }
    }
    function ft(K) {
      return (Ye(), qe.get(K) || null);
    }
    function Re(K, rt, je, Te) {
      var ke = K.length;
      ((je = Math.max(0, je == null ? 0 : +je)),
        (Te = Math.min(ke - 1, Te == null ? ke - 1 : +Te)));
      for (var H = new Map(), k = je; k <= Te; k++)
        if (rt[k] & 1) {
          var oe = ft(K[k]);
          oe !== null && H.set(k, oe);
        }
      return H;
    }
    function Ie(K, rt, je, Te) {
      var ke = K.length;
      ((je = Math.max(0, je == null ? 0 : +je)),
        (Te = Math.min(ke - 1, Te == null ? ke - 1 : +Te)));
      var H = [];
      return (
        rt.paragraphs.forEach(function (k) {
          var oe = Math.max(je, k.start),
            Ae = Math.min(Te, k.end);
          if (oe < Ae) {
            for (
              var _e = rt.levels.slice(oe, Ae + 1), be = Ae;
              be >= oe && y(K[be]) & d;
              be--
            )
              _e[be] = k.level;
            for (var et = k.level, $e = 1 / 0, ht = 0; ht < _e.length; ht++) {
              var yt = _e[ht];
              (yt > et && (et = yt), yt < $e && ($e = yt | 1));
            }
            for (var Ge = et; Ge >= $e; Ge--)
              for (var Ve = 0; Ve < _e.length; Ve++)
                if (_e[Ve] >= Ge) {
                  for (var Ze = Ve; Ve + 1 < _e.length && _e[Ve + 1] >= Ge; )
                    Ve++;
                  Ve > Ze && H.push([Ze + oe, Ve + oe]);
                }
          }
        }),
        H
      );
    }
    function De(K, rt, je, Te) {
      var ke = Qe(K, rt, je, Te),
        H = [].concat(K);
      return (
        ke.forEach(function (k, oe) {
          H[oe] = (rt.levels[k] & 1 ? ft(K[k]) : null) || K[k];
        }),
        H.join("")
      );
    }
    function Qe(K, rt, je, Te) {
      for (var ke = Ie(K, rt, je, Te), H = [], k = 0; k < K.length; k++)
        H[k] = k;
      return (
        ke.forEach(function (oe) {
          for (
            var Ae = oe[0],
              _e = oe[1],
              be = H.slice(Ae, _e + 1),
              et = be.length;
            et--;
          )
            H[_e - et] = be[et];
        }),
        H
      );
    }
    return (
      (e.closingToOpeningBracket = I),
      (e.getBidiCharType = y),
      (e.getBidiCharTypeName = b),
      (e.getCanonicalBracket = O),
      (e.getEmbeddingLevels = ze),
      (e.getMirroredCharacter = ft),
      (e.getMirroredCharactersMap = Re),
      (e.getReorderSegments = Ie),
      (e.getReorderedIndices = Qe),
      (e.getReorderedString = De),
      (e.openingToClosingBracket = L),
      Object.defineProperty(e, "__esModule", { value: !0 }),
      e
    );
  })({});
  return i;
}
const LU = /\bvoid\s+main\s*\(\s*\)\s*{/g;
function jM(i) {
  const e = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function t(n, r) {
    let s = cn[r];
    return s ? jM(s) : n;
  }
  return i.replace(e, t);
}
const Zr = [];
for (let i = 0; i < 256; i++) Zr[i] = (i < 16 ? "0" : "") + i.toString(16);
function nW() {
  const i = (Math.random() * 4294967295) | 0,
    e = (Math.random() * 4294967295) | 0,
    t = (Math.random() * 4294967295) | 0,
    n = (Math.random() * 4294967295) | 0;
  return (
    Zr[i & 255] +
    Zr[(i >> 8) & 255] +
    Zr[(i >> 16) & 255] +
    Zr[(i >> 24) & 255] +
    "-" +
    Zr[e & 255] +
    Zr[(e >> 8) & 255] +
    "-" +
    Zr[((e >> 16) & 15) | 64] +
    Zr[(e >> 24) & 255] +
    "-" +
    Zr[(t & 63) | 128] +
    Zr[(t >> 8) & 255] +
    "-" +
    Zr[(t >> 16) & 255] +
    Zr[(t >> 24) & 255] +
    Zr[n & 255] +
    Zr[(n >> 8) & 255] +
    Zr[(n >> 16) & 255] +
    Zr[(n >> 24) & 255]
  ).toUpperCase();
}
const hh =
    Object.assign ||
    function () {
      let i = arguments[0];
      for (let e = 1, t = arguments.length; e < t; e++) {
        let n = arguments[e];
        if (n)
          for (let r in n)
            Object.prototype.hasOwnProperty.call(n, r) && (i[r] = n[r]);
      }
      return i;
    },
  iW = Date.now(),
  H3 = new WeakMap(),
  j3 = new Map();
let rW = 1e10;
function WM(i, e) {
  const t = lW(e);
  let n = H3.get(i);
  if ((n || H3.set(i, (n = Object.create(null))), n[t])) return new n[t]();
  const r = `_onBeforeCompile${t}`,
    s = function (d, m) {
      i.onBeforeCompile.call(this, d, m);
      const v =
        this.customProgramCacheKey() +
        "|" +
        d.vertexShader +
        "|" +
        d.fragmentShader;
      let y = j3[v];
      if (!y) {
        const b = sW(this, d, e, t);
        y = j3[v] = b;
      }
      ((d.vertexShader = y.vertexShader),
        (d.fragmentShader = y.fragmentShader),
        hh(d.uniforms, this.uniforms),
        e.timeUniform &&
          (d.uniforms[e.timeUniform] = {
            get value() {
              return Date.now() - iW;
            },
          }),
        this[r] && this[r](d));
    },
    o = function () {
      return u(e.chained ? i : i.clone());
    },
    u = function (d) {
      const m = Object.create(d, h);
      return (
        Object.defineProperty(m, "baseMaterial", { value: i }),
        Object.defineProperty(m, "id", { value: rW++ }),
        (m.uuid = nW()),
        (m.uniforms = hh({}, d.uniforms, e.uniforms)),
        (m.defines = hh({}, d.defines, e.defines)),
        (m.defines[`TROIKA_DERIVED_MATERIAL_${t}`] = ""),
        (m.extensions = hh({}, d.extensions, e.extensions)),
        (m._listeners = void 0),
        m
      );
    },
    h = {
      constructor: { value: o },
      isDerivedMaterial: { value: !0 },
      type: {
        get: () => i.type,
        set: (d) => {
          i.type = d;
        },
      },
      isDerivedFrom: {
        writable: !0,
        configurable: !0,
        value: function (d) {
          const m = this.baseMaterial;
          return d === m || (m.isDerivedMaterial && m.isDerivedFrom(d)) || !1;
        },
      },
      customProgramCacheKey: {
        writable: !0,
        configurable: !0,
        value: function () {
          return i.customProgramCacheKey() + "|" + t;
        },
      },
      onBeforeCompile: {
        get() {
          return s;
        },
        set(d) {
          this[r] = d;
        },
      },
      copy: {
        writable: !0,
        configurable: !0,
        value: function (d) {
          return (
            i.copy.call(this, d),
            !i.isShaderMaterial &&
              !i.isDerivedMaterial &&
              (hh(this.extensions, d.extensions),
              hh(this.defines, d.defines),
              hh(this.uniforms, g0.clone(d.uniforms))),
            this
          );
        },
      },
      clone: {
        writable: !0,
        configurable: !0,
        value: function () {
          const d = new i.constructor();
          return u(d).copy(this);
        },
      },
      getDepthMaterial: {
        writable: !0,
        configurable: !0,
        value: function () {
          let d = this._depthMaterial;
          return (
            d ||
              ((d = this._depthMaterial =
                WM(
                  i.isDerivedMaterial
                    ? i.getDepthMaterial()
                    : new Ab({ depthPacking: GL }),
                  e,
                )),
              (d.defines.IS_DEPTH_MATERIAL = ""),
              (d.uniforms = this.uniforms)),
            d
          );
        },
      },
      getDistanceMaterial: {
        writable: !0,
        configurable: !0,
        value: function () {
          let d = this._distanceMaterial;
          return (
            d ||
              ((d = this._distanceMaterial =
                WM(
                  i.isDerivedMaterial ? i.getDistanceMaterial() : new Cb(),
                  e,
                )),
              (d.defines.IS_DISTANCE_MATERIAL = ""),
              (d.uniforms = this.uniforms)),
            d
          );
        },
      },
      dispose: {
        writable: !0,
        configurable: !0,
        value() {
          const { _depthMaterial: d, _distanceMaterial: m } = this;
          (d && d.dispose(), m && m.dispose(), i.dispose.call(this));
        },
      },
    };
  return ((n[t] = o), new o());
}
function sW(i, { vertexShader: e, fragmentShader: t }, n, r) {
  let {
    vertexDefs: s,
    vertexMainIntro: o,
    vertexMainOutro: u,
    vertexTransform: h,
    fragmentDefs: d,
    fragmentMainIntro: m,
    fragmentMainOutro: v,
    fragmentColorTransform: y,
    customRewriter: b,
    timeUniform: _,
  } = n;
  if (
    ((s = s || ""),
    (o = o || ""),
    (u = u || ""),
    (d = d || ""),
    (m = m || ""),
    (v = v || ""),
    (h || b) && (e = jM(e)),
    (y || b) &&
      ((t = t.replace(
        /^[ \t]*#include <((?:tonemapping|encodings|colorspace|fog|premultiplied_alpha|dithering)_fragment)>/gm,
        `
//!BEGIN_POST_CHUNK $1
$&
//!END_POST_CHUNK
`,
      )),
      (t = jM(t))),
    b)
  ) {
    let w = b({ vertexShader: e, fragmentShader: t });
    ((e = w.vertexShader), (t = w.fragmentShader));
  }
  if (y) {
    let w = [];
    ((t = t.replace(
      /^\/\/!BEGIN_POST_CHUNK[^]+?^\/\/!END_POST_CHUNK/gm,
      (E) => (w.push(E), ""),
    )),
      (v = `${y}
${w.join(`
`)}
${v}`));
  }
  if (_) {
    const w = `
uniform float ${_};
`;
    ((s = w + s), (d = w + d));
  }
  return (
    h &&
      ((e = `vec3 troika_position_${r};
vec3 troika_normal_${r};
vec2 troika_uv_${r};
${e}
`),
      (s = `${s}
void troikaVertexTransform${r}(inout vec3 position, inout vec3 normal, inout vec2 uv) {
  ${h}
}
`),
      (o = `
troika_position_${r} = vec3(position);
troika_normal_${r} = vec3(normal);
troika_uv_${r} = vec2(uv);
troikaVertexTransform${r}(troika_position_${r}, troika_normal_${r}, troika_uv_${r});
${o}
`),
      (e = e.replace(/\b(position|normal|uv)\b/g, (w, E, T, C) =>
        /\battribute\s+vec[23]\s+$/.test(C.substr(0, T))
          ? E
          : `troika_${E}_${r}`,
      )),
      (i.map && i.map.channel > 0) ||
        (e = e.replace(/\bMAP_UV\b/g, `troika_uv_${r}`))),
    (e = W3(e, r, s, o, u)),
    (t = W3(t, r, d, m, v)),
    { vertexShader: e, fragmentShader: t }
  );
}
function W3(i, e, t, n, r) {
  return (
    (n || r || t) &&
      ((i = i.replace(
        LU,
        `
${t}
void troikaOrigMain${e}() {`,
      )),
      (i += `
void main() {
  ${n}
  troikaOrigMain${e}();
  ${r}
}`)),
    i
  );
}
function aW(i, e) {
  return i === "uniforms" ? void 0 : typeof e == "function" ? e.toString() : e;
}
let oW = 0;
const X3 = new Map();
function lW(i) {
  const e = JSON.stringify(i, aW);
  let t = X3.get(e);
  return (t == null && X3.set(e, (t = ++oW)), t);
}
/*!
Custom build of Typr.ts (https://github.com/fredli74/Typr.ts) for use in Troika text rendering.
Original MIT license applies: https://github.com/fredli74/Typr.ts/blob/master/LICENSE
*/ function cW() {
  return (
    typeof window > "u" && (self.window = self),
    (function (i) {
      var e = {
        parse: function (r) {
          var s = e._bin,
            o = new Uint8Array(r);
          if (s.readASCII(o, 0, 4) == "ttcf") {
            var u = 4;
            (s.readUshort(o, u), (u += 2), s.readUshort(o, u), (u += 2));
            var h = s.readUint(o, u);
            u += 4;
            for (var d = [], m = 0; m < h; m++) {
              var v = s.readUint(o, u);
              ((u += 4), d.push(e._readFont(o, v)));
            }
            return d;
          }
          return [e._readFont(o, 0)];
        },
        _readFont: function (r, s) {
          var o = e._bin,
            u = s;
          (o.readFixed(r, s), (s += 4));
          var h = o.readUshort(r, s);
          ((s += 2),
            o.readUshort(r, s),
            (s += 2),
            o.readUshort(r, s),
            (s += 2),
            o.readUshort(r, s),
            (s += 2));
          for (
            var d = [
                "cmap",
                "head",
                "hhea",
                "maxp",
                "hmtx",
                "name",
                "OS/2",
                "post",
                "loca",
                "glyf",
                "kern",
                "CFF ",
                "GDEF",
                "GPOS",
                "GSUB",
                "SVG ",
              ],
              m = { _data: r, _offset: u },
              v = {},
              y = 0;
            y < h;
            y++
          ) {
            var b = o.readASCII(r, s, 4);
            ((s += 4), o.readUint(r, s), (s += 4));
            var _ = o.readUint(r, s);
            s += 4;
            var w = o.readUint(r, s);
            ((s += 4), (v[b] = { offset: _, length: w }));
          }
          for (y = 0; y < d.length; y++) {
            var E = d[y];
            v[E] &&
              (m[E.trim()] = e[E.trim()].parse(r, v[E].offset, v[E].length, m));
          }
          return m;
        },
        _tabOffset: function (r, s, o) {
          for (
            var u = e._bin, h = u.readUshort(r, o + 4), d = o + 12, m = 0;
            m < h;
            m++
          ) {
            var v = u.readASCII(r, d, 4);
            ((d += 4), u.readUint(r, d), (d += 4));
            var y = u.readUint(r, d);
            if (((d += 4), u.readUint(r, d), (d += 4), v == s)) return y;
          }
          return 0;
        },
      };
      ((e._bin = {
        readFixed: function (r, s) {
          return (
            ((r[s] << 8) | r[s + 1]) + ((r[s + 2] << 8) | r[s + 3]) / 65540
          );
        },
        readF2dot14: function (r, s) {
          return e._bin.readShort(r, s) / 16384;
        },
        readInt: function (r, s) {
          return e._bin._view(r).getInt32(s);
        },
        readInt8: function (r, s) {
          return e._bin._view(r).getInt8(s);
        },
        readShort: function (r, s) {
          return e._bin._view(r).getInt16(s);
        },
        readUshort: function (r, s) {
          return e._bin._view(r).getUint16(s);
        },
        readUshorts: function (r, s, o) {
          for (var u = [], h = 0; h < o; h++)
            u.push(e._bin.readUshort(r, s + 2 * h));
          return u;
        },
        readUint: function (r, s) {
          return e._bin._view(r).getUint32(s);
        },
        readUint64: function (r, s) {
          return 4294967296 * e._bin.readUint(r, s) + e._bin.readUint(r, s + 4);
        },
        readASCII: function (r, s, o) {
          for (var u = "", h = 0; h < o; h++)
            u += String.fromCharCode(r[s + h]);
          return u;
        },
        readUnicode: function (r, s, o) {
          for (var u = "", h = 0; h < o; h++) {
            var d = (r[s++] << 8) | r[s++];
            u += String.fromCharCode(d);
          }
          return u;
        },
        _tdec:
          typeof window < "u" && window.TextDecoder
            ? new window.TextDecoder()
            : null,
        readUTF8: function (r, s, o) {
          var u = e._bin._tdec;
          return u && s == 0 && o == r.length
            ? u.decode(r)
            : e._bin.readASCII(r, s, o);
        },
        readBytes: function (r, s, o) {
          for (var u = [], h = 0; h < o; h++) u.push(r[s + h]);
          return u;
        },
        readASCIIArray: function (r, s, o) {
          for (var u = [], h = 0; h < o; h++)
            u.push(String.fromCharCode(r[s + h]));
          return u;
        },
        _view: function (r) {
          return (
            r._dataView ||
            (r._dataView = r.buffer
              ? new DataView(r.buffer, r.byteOffset, r.byteLength)
              : new DataView(new Uint8Array(r).buffer))
          );
        },
      }),
        (e._lctf = {}),
        (e._lctf.parse = function (r, s, o, u, h) {
          var d = e._bin,
            m = {},
            v = s;
          (d.readFixed(r, s), (s += 4));
          var y = d.readUshort(r, s);
          s += 2;
          var b = d.readUshort(r, s);
          s += 2;
          var _ = d.readUshort(r, s);
          return (
            (s += 2),
            (m.scriptList = e._lctf.readScriptList(r, v + y)),
            (m.featureList = e._lctf.readFeatureList(r, v + b)),
            (m.lookupList = e._lctf.readLookupList(r, v + _, h)),
            m
          );
        }),
        (e._lctf.readLookupList = function (r, s, o) {
          var u = e._bin,
            h = s,
            d = [],
            m = u.readUshort(r, s);
          s += 2;
          for (var v = 0; v < m; v++) {
            var y = u.readUshort(r, s);
            s += 2;
            var b = e._lctf.readLookupTable(r, h + y, o);
            d.push(b);
          }
          return d;
        }),
        (e._lctf.readLookupTable = function (r, s, o) {
          var u = e._bin,
            h = s,
            d = { tabs: [] };
          ((d.ltype = u.readUshort(r, s)),
            (s += 2),
            (d.flag = u.readUshort(r, s)),
            (s += 2));
          var m = u.readUshort(r, s);
          s += 2;
          for (var v = d.ltype, y = 0; y < m; y++) {
            var b = u.readUshort(r, s);
            s += 2;
            var _ = o(r, v, h + b, d);
            d.tabs.push(_);
          }
          return d;
        }),
        (e._lctf.numOfOnes = function (r) {
          for (var s = 0, o = 0; o < 32; o++) ((r >>> o) & 1) != 0 && s++;
          return s;
        }),
        (e._lctf.readClassDef = function (r, s) {
          var o = e._bin,
            u = [],
            h = o.readUshort(r, s);
          if (((s += 2), h == 1)) {
            var d = o.readUshort(r, s);
            s += 2;
            var m = o.readUshort(r, s);
            s += 2;
            for (var v = 0; v < m; v++)
              (u.push(d + v),
                u.push(d + v),
                u.push(o.readUshort(r, s)),
                (s += 2));
          }
          if (h == 2) {
            var y = o.readUshort(r, s);
            for (s += 2, v = 0; v < y; v++)
              (u.push(o.readUshort(r, s)),
                (s += 2),
                u.push(o.readUshort(r, s)),
                (s += 2),
                u.push(o.readUshort(r, s)),
                (s += 2));
          }
          return u;
        }),
        (e._lctf.getInterval = function (r, s) {
          for (var o = 0; o < r.length; o += 3) {
            var u = r[o],
              h = r[o + 1];
            if ((r[o + 2], u <= s && s <= h)) return o;
          }
          return -1;
        }),
        (e._lctf.readCoverage = function (r, s) {
          var o = e._bin,
            u = {};
          ((u.fmt = o.readUshort(r, s)), (s += 2));
          var h = o.readUshort(r, s);
          return (
            (s += 2),
            u.fmt == 1 && (u.tab = o.readUshorts(r, s, h)),
            u.fmt == 2 && (u.tab = o.readUshorts(r, s, 3 * h)),
            u
          );
        }),
        (e._lctf.coverageIndex = function (r, s) {
          var o = r.tab;
          if (r.fmt == 1) return o.indexOf(s);
          if (r.fmt == 2) {
            var u = e._lctf.getInterval(o, s);
            if (u != -1) return o[u + 2] + (s - o[u]);
          }
          return -1;
        }),
        (e._lctf.readFeatureList = function (r, s) {
          var o = e._bin,
            u = s,
            h = [],
            d = o.readUshort(r, s);
          s += 2;
          for (var m = 0; m < d; m++) {
            var v = o.readASCII(r, s, 4);
            s += 4;
            var y = o.readUshort(r, s);
            s += 2;
            var b = e._lctf.readFeatureTable(r, u + y);
            ((b.tag = v.trim()), h.push(b));
          }
          return h;
        }),
        (e._lctf.readFeatureTable = function (r, s) {
          var o = e._bin,
            u = s,
            h = {},
            d = o.readUshort(r, s);
          ((s += 2), d > 0 && (h.featureParams = u + d));
          var m = o.readUshort(r, s);
          ((s += 2), (h.tab = []));
          for (var v = 0; v < m; v++) h.tab.push(o.readUshort(r, s + 2 * v));
          return h;
        }),
        (e._lctf.readScriptList = function (r, s) {
          var o = e._bin,
            u = s,
            h = {},
            d = o.readUshort(r, s);
          s += 2;
          for (var m = 0; m < d; m++) {
            var v = o.readASCII(r, s, 4);
            s += 4;
            var y = o.readUshort(r, s);
            ((s += 2), (h[v.trim()] = e._lctf.readScriptTable(r, u + y)));
          }
          return h;
        }),
        (e._lctf.readScriptTable = function (r, s) {
          var o = e._bin,
            u = s,
            h = {},
            d = o.readUshort(r, s);
          ((s += 2), d > 0 && (h.default = e._lctf.readLangSysTable(r, u + d)));
          var m = o.readUshort(r, s);
          s += 2;
          for (var v = 0; v < m; v++) {
            var y = o.readASCII(r, s, 4);
            s += 4;
            var b = o.readUshort(r, s);
            ((s += 2), (h[y.trim()] = e._lctf.readLangSysTable(r, u + b)));
          }
          return h;
        }),
        (e._lctf.readLangSysTable = function (r, s) {
          var o = e._bin,
            u = {};
          (o.readUshort(r, s),
            (s += 2),
            (u.reqFeature = o.readUshort(r, s)),
            (s += 2));
          var h = o.readUshort(r, s);
          return ((s += 2), (u.features = o.readUshorts(r, s, h)), u);
        }),
        (e.CFF = {}),
        (e.CFF.parse = function (r, s, o) {
          var u = e._bin;
          ((r = new Uint8Array(r.buffer, s, o))[(s = 0)],
            r[++s],
            r[++s],
            r[++s],
            s++);
          var h = [];
          s = e.CFF.readIndex(r, s, h);
          for (var d = [], m = 0; m < h.length - 1; m++)
            d.push(u.readASCII(r, s + h[m], h[m + 1] - h[m]));
          s += h[h.length - 1];
          var v = [];
          s = e.CFF.readIndex(r, s, v);
          var y = [];
          for (m = 0; m < v.length - 1; m++)
            y.push(e.CFF.readDict(r, s + v[m], s + v[m + 1]));
          s += v[v.length - 1];
          var b = y[0],
            _ = [];
          s = e.CFF.readIndex(r, s, _);
          var w = [];
          for (m = 0; m < _.length - 1; m++)
            w.push(u.readASCII(r, s + _[m], _[m + 1] - _[m]));
          if (
            ((s += _[_.length - 1]), e.CFF.readSubrs(r, s, b), b.CharStrings)
          ) {
            ((s = b.CharStrings), (_ = []), (s = e.CFF.readIndex(r, s, _)));
            var E = [];
            for (m = 0; m < _.length - 1; m++)
              E.push(u.readBytes(r, s + _[m], _[m + 1] - _[m]));
            b.CharStrings = E;
          }
          if (b.ROS) {
            s = b.FDArray;
            var T = [];
            for (
              s = e.CFF.readIndex(r, s, T), b.FDArray = [], m = 0;
              m < T.length - 1;
              m++
            ) {
              var C = e.CFF.readDict(r, s + T[m], s + T[m + 1]);
              (e.CFF._readFDict(r, C, w), b.FDArray.push(C));
            }
            ((s += T[T.length - 1]), (s = b.FDSelect), (b.FDSelect = []));
            var R = r[s];
            if ((s++, R != 3)) throw R;
            var L = u.readUshort(r, s);
            for (s += 2, m = 0; m < L + 1; m++)
              (b.FDSelect.push(u.readUshort(r, s), r[s + 2]), (s += 3));
          }
          return (
            b.Encoding &&
              (b.Encoding = e.CFF.readEncoding(
                r,
                b.Encoding,
                b.CharStrings.length,
              )),
            b.charset &&
              (b.charset = e.CFF.readCharset(
                r,
                b.charset,
                b.CharStrings.length,
              )),
            e.CFF._readFDict(r, b, w),
            b
          );
        }),
        (e.CFF._readFDict = function (r, s, o) {
          var u;
          for (var h in (s.Private &&
            ((u = s.Private[1]),
            (s.Private = e.CFF.readDict(r, u, u + s.Private[0])),
            s.Private.Subrs &&
              e.CFF.readSubrs(r, u + s.Private.Subrs, s.Private)),
          s))
            [
              "FamilyName",
              "FontName",
              "FullName",
              "Notice",
              "version",
              "Copyright",
            ].indexOf(h) != -1 && (s[h] = o[s[h] - 426 + 35]);
        }),
        (e.CFF.readSubrs = function (r, s, o) {
          var u = e._bin,
            h = [];
          s = e.CFF.readIndex(r, s, h);
          var d,
            m = h.length;
          ((d = m < 1240 ? 107 : m < 33900 ? 1131 : 32768),
            (o.Bias = d),
            (o.Subrs = []));
          for (var v = 0; v < h.length - 1; v++)
            o.Subrs.push(u.readBytes(r, s + h[v], h[v + 1] - h[v]));
        }),
        (e.CFF.tableSE = [
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13,
          14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,
          31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
          48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64,
          65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81,
          82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106,
          107, 108, 109, 110, 0, 111, 112, 113, 114, 0, 115, 116, 117, 118, 119,
          120, 121, 122, 0, 123, 0, 124, 125, 126, 127, 128, 129, 130, 131, 0,
          132, 133, 0, 134, 135, 136, 137, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 138, 0, 139, 0, 0, 0, 0, 140, 141, 142, 143, 0, 0, 0, 0,
          0, 144, 0, 0, 0, 145, 0, 0, 146, 147, 148, 149, 0, 0, 0, 0,
        ]),
        (e.CFF.glyphByUnicode = function (r, s) {
          for (var o = 0; o < r.charset.length; o++)
            if (r.charset[o] == s) return o;
          return -1;
        }),
        (e.CFF.glyphBySE = function (r, s) {
          return s < 0 || s > 255
            ? -1
            : e.CFF.glyphByUnicode(r, e.CFF.tableSE[s]);
        }),
        (e.CFF.readEncoding = function (r, s, o) {
          e._bin;
          var u = [".notdef"],
            h = r[s];
          if ((s++, h != 0)) throw "error: unknown encoding format: " + h;
          var d = r[s];
          s++;
          for (var m = 0; m < d; m++) u.push(r[s + m]);
          return u;
        }),
        (e.CFF.readCharset = function (r, s, o) {
          var u = e._bin,
            h = [".notdef"],
            d = r[s];
          if ((s++, d == 0))
            for (var m = 0; m < o; m++) {
              var v = u.readUshort(r, s);
              ((s += 2), h.push(v));
            }
          else {
            if (d != 1 && d != 2) throw "error: format: " + d;
            for (; h.length < o; ) {
              ((v = u.readUshort(r, s)), (s += 2));
              var y = 0;
              for (
                d == 1
                  ? ((y = r[s]), s++)
                  : ((y = u.readUshort(r, s)), (s += 2)),
                  m = 0;
                m <= y;
                m++
              )
                (h.push(v), v++);
            }
          }
          return h;
        }),
        (e.CFF.readIndex = function (r, s, o) {
          var u = e._bin,
            h = u.readUshort(r, s) + 1,
            d = r[(s += 2)];
          if ((s++, d == 1)) for (var m = 0; m < h; m++) o.push(r[s + m]);
          else if (d == 2)
            for (m = 0; m < h; m++) o.push(u.readUshort(r, s + 2 * m));
          else if (d == 3)
            for (m = 0; m < h; m++)
              o.push(16777215 & u.readUint(r, s + 3 * m - 1));
          else if (h != 1)
            throw "unsupported offset size: " + d + ", count: " + h;
          return (s += h * d) - 1;
        }),
        (e.CFF.getCharString = function (r, s, o) {
          var u = e._bin,
            h = r[s],
            d = r[s + 1];
          (r[s + 2], r[s + 3], r[s + 4]);
          var m = 1,
            v = null,
            y = null;
          (h <= 20 && ((v = h), (m = 1)),
            h == 12 && ((v = 100 * h + d), (m = 2)),
            21 <= h && h <= 27 && ((v = h), (m = 1)),
            h == 28 && ((y = u.readShort(r, s + 1)), (m = 3)),
            29 <= h && h <= 31 && ((v = h), (m = 1)),
            32 <= h && h <= 246 && ((y = h - 139), (m = 1)),
            247 <= h && h <= 250 && ((y = 256 * (h - 247) + d + 108), (m = 2)),
            251 <= h && h <= 254 && ((y = 256 * -(h - 251) - d - 108), (m = 2)),
            h == 255 && ((y = u.readInt(r, s + 1) / 65535), (m = 5)),
            (o.val = y ?? "o" + v),
            (o.size = m));
        }),
        (e.CFF.readCharString = function (r, s, o) {
          for (var u = s + o, h = e._bin, d = []; s < u; ) {
            var m = r[s],
              v = r[s + 1];
            (r[s + 2], r[s + 3], r[s + 4]);
            var y = 1,
              b = null,
              _ = null;
            (m <= 20 && ((b = m), (y = 1)),
              m == 12 && ((b = 100 * m + v), (y = 2)),
              (m != 19 && m != 20) || ((b = m), (y = 2)),
              21 <= m && m <= 27 && ((b = m), (y = 1)),
              m == 28 && ((_ = h.readShort(r, s + 1)), (y = 3)),
              29 <= m && m <= 31 && ((b = m), (y = 1)),
              32 <= m && m <= 246 && ((_ = m - 139), (y = 1)),
              247 <= m &&
                m <= 250 &&
                ((_ = 256 * (m - 247) + v + 108), (y = 2)),
              251 <= m &&
                m <= 254 &&
                ((_ = 256 * -(m - 251) - v - 108), (y = 2)),
              m == 255 && ((_ = h.readInt(r, s + 1) / 65535), (y = 5)),
              d.push(_ ?? "o" + b),
              (s += y));
          }
          return d;
        }),
        (e.CFF.readDict = function (r, s, o) {
          for (var u = e._bin, h = {}, d = []; s < o; ) {
            var m = r[s],
              v = r[s + 1];
            (r[s + 2], r[s + 3], r[s + 4]);
            var y = 1,
              b = null,
              _ = null;
            if (
              (m == 28 && ((_ = u.readShort(r, s + 1)), (y = 3)),
              m == 29 && ((_ = u.readInt(r, s + 1)), (y = 5)),
              32 <= m && m <= 246 && ((_ = m - 139), (y = 1)),
              247 <= m &&
                m <= 250 &&
                ((_ = 256 * (m - 247) + v + 108), (y = 2)),
              251 <= m &&
                m <= 254 &&
                ((_ = 256 * -(m - 251) - v - 108), (y = 2)),
              m == 255)
            )
              throw (
                (_ = u.readInt(r, s + 1) / 65535),
                (y = 5),
                "unknown number"
              );
            if (m == 30) {
              var w = [];
              for (y = 1; ; ) {
                var E = r[s + y];
                y++;
                var T = E >> 4,
                  C = 15 & E;
                if ((T != 15 && w.push(T), C != 15 && w.push(C), C == 15))
                  break;
              }
              for (
                var R = "",
                  L = [
                    0,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    ".",
                    "e",
                    "e-",
                    "reserved",
                    "-",
                    "endOfNumber",
                  ],
                  I = 0;
                I < w.length;
                I++
              )
                R += L[w[I]];
              _ = parseFloat(R);
            }
            (m <= 21 &&
              ((b = [
                "version",
                "Notice",
                "FullName",
                "FamilyName",
                "Weight",
                "FontBBox",
                "BlueValues",
                "OtherBlues",
                "FamilyBlues",
                "FamilyOtherBlues",
                "StdHW",
                "StdVW",
                "escape",
                "UniqueID",
                "XUID",
                "charset",
                "Encoding",
                "CharStrings",
                "Private",
                "Subrs",
                "defaultWidthX",
                "nominalWidthX",
              ][m]),
              (y = 1),
              m == 12 &&
                ((b = [
                  "Copyright",
                  "isFixedPitch",
                  "ItalicAngle",
                  "UnderlinePosition",
                  "UnderlineThickness",
                  "PaintType",
                  "CharstringType",
                  "FontMatrix",
                  "StrokeWidth",
                  "BlueScale",
                  "BlueShift",
                  "BlueFuzz",
                  "StemSnapH",
                  "StemSnapV",
                  "ForceBold",
                  0,
                  0,
                  "LanguageGroup",
                  "ExpansionFactor",
                  "initialRandomSeed",
                  "SyntheticBase",
                  "PostScript",
                  "BaseFontName",
                  "BaseFontBlend",
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  "ROS",
                  "CIDFontVersion",
                  "CIDFontRevision",
                  "CIDFontType",
                  "CIDCount",
                  "UIDBase",
                  "FDArray",
                  "FDSelect",
                  "FontName",
                ][v]),
                (y = 2))),
              b != null
                ? ((h[b] = d.length == 1 ? d[0] : d), (d = []))
                : d.push(_),
              (s += y));
          }
          return h;
        }),
        (e.cmap = {}),
        (e.cmap.parse = function (r, s, o) {
          ((r = new Uint8Array(r.buffer, s, o)), (s = 0));
          var u = e._bin,
            h = {};
          (u.readUshort(r, s), (s += 2));
          var d = u.readUshort(r, s);
          s += 2;
          var m = [];
          h.tables = [];
          for (var v = 0; v < d; v++) {
            var y = u.readUshort(r, s);
            s += 2;
            var b = u.readUshort(r, s);
            s += 2;
            var _ = u.readUint(r, s);
            s += 4;
            var w = "p" + y + "e" + b,
              E = m.indexOf(_);
            if (E == -1) {
              var T;
              ((E = h.tables.length), m.push(_));
              var C = u.readUshort(r, _);
              (C == 0
                ? (T = e.cmap.parse0(r, _))
                : C == 4
                  ? (T = e.cmap.parse4(r, _))
                  : C == 6
                    ? (T = e.cmap.parse6(r, _))
                    : C == 12
                      ? (T = e.cmap.parse12(r, _))
                      : console.debug("unknown format: " + C, y, b, _),
                h.tables.push(T));
            }
            if (h[w] != null) throw "multiple tables for one platform+encoding";
            h[w] = E;
          }
          return h;
        }),
        (e.cmap.parse0 = function (r, s) {
          var o = e._bin,
            u = {};
          ((u.format = o.readUshort(r, s)), (s += 2));
          var h = o.readUshort(r, s);
          ((s += 2), o.readUshort(r, s), (s += 2), (u.map = []));
          for (var d = 0; d < h - 6; d++) u.map.push(r[s + d]);
          return u;
        }),
        (e.cmap.parse4 = function (r, s) {
          var o = e._bin,
            u = s,
            h = {};
          ((h.format = o.readUshort(r, s)), (s += 2));
          var d = o.readUshort(r, s);
          ((s += 2), o.readUshort(r, s), (s += 2));
          var m = o.readUshort(r, s);
          s += 2;
          var v = m / 2;
          ((h.searchRange = o.readUshort(r, s)),
            (s += 2),
            (h.entrySelector = o.readUshort(r, s)),
            (s += 2),
            (h.rangeShift = o.readUshort(r, s)),
            (s += 2),
            (h.endCount = o.readUshorts(r, s, v)),
            (s += 2 * v),
            (s += 2),
            (h.startCount = o.readUshorts(r, s, v)),
            (s += 2 * v),
            (h.idDelta = []));
          for (var y = 0; y < v; y++)
            (h.idDelta.push(o.readShort(r, s)), (s += 2));
          for (
            h.idRangeOffset = o.readUshorts(r, s, v),
              s += 2 * v,
              h.glyphIdArray = [];
            s < u + d;
          )
            (h.glyphIdArray.push(o.readUshort(r, s)), (s += 2));
          return h;
        }),
        (e.cmap.parse6 = function (r, s) {
          var o = e._bin,
            u = {};
          ((u.format = o.readUshort(r, s)),
            (s += 2),
            o.readUshort(r, s),
            (s += 2),
            o.readUshort(r, s),
            (s += 2),
            (u.firstCode = o.readUshort(r, s)),
            (s += 2));
          var h = o.readUshort(r, s);
          ((s += 2), (u.glyphIdArray = []));
          for (var d = 0; d < h; d++)
            (u.glyphIdArray.push(o.readUshort(r, s)), (s += 2));
          return u;
        }),
        (e.cmap.parse12 = function (r, s) {
          var o = e._bin,
            u = {};
          ((u.format = o.readUshort(r, s)),
            (s += 2),
            (s += 2),
            o.readUint(r, s),
            (s += 4),
            o.readUint(r, s),
            (s += 4));
          var h = o.readUint(r, s);
          ((s += 4), (u.groups = []));
          for (var d = 0; d < h; d++) {
            var m = s + 12 * d,
              v = o.readUint(r, m + 0),
              y = o.readUint(r, m + 4),
              b = o.readUint(r, m + 8);
            u.groups.push([v, y, b]);
          }
          return u;
        }),
        (e.glyf = {}),
        (e.glyf.parse = function (r, s, o, u) {
          for (var h = [], d = 0; d < u.maxp.numGlyphs; d++) h.push(null);
          return h;
        }),
        (e.glyf._parseGlyf = function (r, s) {
          var o = e._bin,
            u = r._data,
            h = e._tabOffset(u, "glyf", r._offset) + r.loca[s];
          if (r.loca[s] == r.loca[s + 1]) return null;
          var d = {};
          if (
            ((d.noc = o.readShort(u, h)),
            (h += 2),
            (d.xMin = o.readShort(u, h)),
            (h += 2),
            (d.yMin = o.readShort(u, h)),
            (h += 2),
            (d.xMax = o.readShort(u, h)),
            (h += 2),
            (d.yMax = o.readShort(u, h)),
            (h += 2),
            d.xMin >= d.xMax || d.yMin >= d.yMax)
          )
            return null;
          if (d.noc > 0) {
            d.endPts = [];
            for (var m = 0; m < d.noc; m++)
              (d.endPts.push(o.readUshort(u, h)), (h += 2));
            var v = o.readUshort(u, h);
            if (((h += 2), u.length - h < v)) return null;
            ((d.instructions = o.readBytes(u, h, v)), (h += v));
            var y = d.endPts[d.noc - 1] + 1;
            for (d.flags = [], m = 0; m < y; m++) {
              var b = u[h];
              if ((h++, d.flags.push(b), (8 & b) != 0)) {
                var _ = u[h];
                h++;
                for (var w = 0; w < _; w++) (d.flags.push(b), m++);
              }
            }
            for (d.xs = [], m = 0; m < y; m++) {
              var E = (2 & d.flags[m]) != 0,
                T = (16 & d.flags[m]) != 0;
              E
                ? (d.xs.push(T ? u[h] : -u[h]), h++)
                : T
                  ? d.xs.push(0)
                  : (d.xs.push(o.readShort(u, h)), (h += 2));
            }
            for (d.ys = [], m = 0; m < y; m++)
              ((E = (4 & d.flags[m]) != 0),
                (T = (32 & d.flags[m]) != 0),
                E
                  ? (d.ys.push(T ? u[h] : -u[h]), h++)
                  : T
                    ? d.ys.push(0)
                    : (d.ys.push(o.readShort(u, h)), (h += 2)));
            var C = 0,
              R = 0;
            for (m = 0; m < y; m++)
              ((C += d.xs[m]), (R += d.ys[m]), (d.xs[m] = C), (d.ys[m] = R));
          } else {
            var L;
            d.parts = [];
            do {
              ((L = o.readUshort(u, h)), (h += 2));
              var I = {
                m: { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0 },
                p1: -1,
                p2: -1,
              };
              if (
                (d.parts.push(I),
                (I.glyphIndex = o.readUshort(u, h)),
                (h += 2),
                1 & L)
              ) {
                var O = o.readShort(u, h);
                h += 2;
                var B = o.readShort(u, h);
                h += 2;
              } else ((O = o.readInt8(u, h)), h++, (B = o.readInt8(u, h)), h++);
              (2 & L ? ((I.m.tx = O), (I.m.ty = B)) : ((I.p1 = O), (I.p2 = B)),
                8 & L
                  ? ((I.m.a = I.m.d = o.readF2dot14(u, h)), (h += 2))
                  : 64 & L
                    ? ((I.m.a = o.readF2dot14(u, h)),
                      (h += 2),
                      (I.m.d = o.readF2dot14(u, h)),
                      (h += 2))
                    : 128 & L &&
                      ((I.m.a = o.readF2dot14(u, h)),
                      (h += 2),
                      (I.m.b = o.readF2dot14(u, h)),
                      (h += 2),
                      (I.m.c = o.readF2dot14(u, h)),
                      (h += 2),
                      (I.m.d = o.readF2dot14(u, h)),
                      (h += 2)));
            } while (32 & L);
            if (256 & L) {
              var N = o.readUshort(u, h);
              for (h += 2, d.instr = [], m = 0; m < N; m++)
                (d.instr.push(u[h]), h++);
            }
          }
          return d;
        }),
        (e.GDEF = {}),
        (e.GDEF.parse = function (r, s, o, u) {
          var h = s;
          s += 4;
          var d = e._bin.readUshort(r, s);
          return {
            glyphClassDef: d === 0 ? null : e._lctf.readClassDef(r, h + d),
          };
        }),
        (e.GPOS = {}),
        (e.GPOS.parse = function (r, s, o, u) {
          return e._lctf.parse(r, s, o, u, e.GPOS.subt);
        }),
        (e.GPOS.subt = function (r, s, o, u) {
          var h = e._bin,
            d = o,
            m = {};
          if (
            ((m.fmt = h.readUshort(r, o)),
            (o += 2),
            s == 1 || s == 2 || s == 3 || s == 7 || (s == 8 && m.fmt <= 2))
          ) {
            var v = h.readUshort(r, o);
            ((o += 2), (m.coverage = e._lctf.readCoverage(r, v + d)));
          }
          if (s == 1 && m.fmt == 1) {
            var y = h.readUshort(r, o);
            ((o += 2), y != 0 && (m.pos = e.GPOS.readValueRecord(r, o, y)));
          } else if (s == 2 && m.fmt >= 1 && m.fmt <= 2) {
            ((y = h.readUshort(r, o)), (o += 2));
            var b = h.readUshort(r, o);
            o += 2;
            var _ = e._lctf.numOfOnes(y),
              w = e._lctf.numOfOnes(b);
            if (m.fmt == 1) {
              m.pairsets = [];
              var E = h.readUshort(r, o);
              o += 2;
              for (var T = 0; T < E; T++) {
                var C = d + h.readUshort(r, o);
                o += 2;
                var R = h.readUshort(r, C);
                C += 2;
                for (var L = [], I = 0; I < R; I++) {
                  var O = h.readUshort(r, C);
                  ((C += 2),
                    y != 0 &&
                      ((X = e.GPOS.readValueRecord(r, C, y)), (C += 2 * _)),
                    b != 0 &&
                      ((J = e.GPOS.readValueRecord(r, C, b)), (C += 2 * w)),
                    L.push({ gid2: O, val1: X, val2: J }));
                }
                m.pairsets.push(L);
              }
            }
            if (m.fmt == 2) {
              var B = h.readUshort(r, o);
              o += 2;
              var N = h.readUshort(r, o);
              o += 2;
              var F = h.readUshort(r, o);
              o += 2;
              var j = h.readUshort(r, o);
              for (
                o += 2,
                  m.classDef1 = e._lctf.readClassDef(r, d + B),
                  m.classDef2 = e._lctf.readClassDef(r, d + N),
                  m.matrix = [],
                  T = 0;
                T < F;
                T++
              ) {
                var q = [];
                for (I = 0; I < j; I++) {
                  var X = null,
                    J = null;
                  (y != 0 &&
                    ((X = e.GPOS.readValueRecord(r, o, y)), (o += 2 * _)),
                    b != 0 &&
                      ((J = e.GPOS.readValueRecord(r, o, b)), (o += 2 * w)),
                    q.push({ val1: X, val2: J }));
                }
                m.matrix.push(q);
              }
            }
          } else if (s == 4 && m.fmt == 1)
            ((m.markCoverage = e._lctf.readCoverage(r, h.readUshort(r, o) + d)),
              (m.baseCoverage = e._lctf.readCoverage(
                r,
                h.readUshort(r, o + 2) + d,
              )),
              (m.markClassCount = h.readUshort(r, o + 4)),
              (m.markArray = e.GPOS.readMarkArray(
                r,
                h.readUshort(r, o + 6) + d,
              )),
              (m.baseArray = e.GPOS.readBaseArray(
                r,
                h.readUshort(r, o + 8) + d,
                m.markClassCount,
              )));
          else if (s == 6 && m.fmt == 1)
            ((m.mark1Coverage = e._lctf.readCoverage(
              r,
              h.readUshort(r, o) + d,
            )),
              (m.mark2Coverage = e._lctf.readCoverage(
                r,
                h.readUshort(r, o + 2) + d,
              )),
              (m.markClassCount = h.readUshort(r, o + 4)),
              (m.mark1Array = e.GPOS.readMarkArray(
                r,
                h.readUshort(r, o + 6) + d,
              )),
              (m.mark2Array = e.GPOS.readBaseArray(
                r,
                h.readUshort(r, o + 8) + d,
                m.markClassCount,
              )));
          else {
            if (s == 9 && m.fmt == 1) {
              var ee = h.readUshort(r, o);
              o += 2;
              var ne = h.readUint(r, o);
              if (((o += 4), u.ltype == 9)) u.ltype = ee;
              else if (u.ltype != ee) throw "invalid extension substitution";
              return e.GPOS.subt(r, u.ltype, d + ne);
            }
            console.debug(
              "unsupported GPOS table LookupType",
              s,
              "format",
              m.fmt,
            );
          }
          return m;
        }),
        (e.GPOS.readValueRecord = function (r, s, o) {
          var u = e._bin,
            h = [];
          return (
            h.push(1 & o ? u.readShort(r, s) : 0),
            (s += 1 & o ? 2 : 0),
            h.push(2 & o ? u.readShort(r, s) : 0),
            (s += 2 & o ? 2 : 0),
            h.push(4 & o ? u.readShort(r, s) : 0),
            (s += 4 & o ? 2 : 0),
            h.push(8 & o ? u.readShort(r, s) : 0),
            (s += 8 & o ? 2 : 0),
            h
          );
        }),
        (e.GPOS.readBaseArray = function (r, s, o) {
          var u = e._bin,
            h = [],
            d = s,
            m = u.readUshort(r, s);
          s += 2;
          for (var v = 0; v < m; v++) {
            for (var y = [], b = 0; b < o; b++)
              (y.push(e.GPOS.readAnchorRecord(r, d + u.readUshort(r, s))),
                (s += 2));
            h.push(y);
          }
          return h;
        }),
        (e.GPOS.readMarkArray = function (r, s) {
          var o = e._bin,
            u = [],
            h = s,
            d = o.readUshort(r, s);
          s += 2;
          for (var m = 0; m < d; m++) {
            var v = e.GPOS.readAnchorRecord(r, o.readUshort(r, s + 2) + h);
            ((v.markClass = o.readUshort(r, s)), u.push(v), (s += 4));
          }
          return u;
        }),
        (e.GPOS.readAnchorRecord = function (r, s) {
          var o = e._bin,
            u = {};
          return (
            (u.fmt = o.readUshort(r, s)),
            (u.x = o.readShort(r, s + 2)),
            (u.y = o.readShort(r, s + 4)),
            u
          );
        }),
        (e.GSUB = {}),
        (e.GSUB.parse = function (r, s, o, u) {
          return e._lctf.parse(r, s, o, u, e.GSUB.subt);
        }),
        (e.GSUB.subt = function (r, s, o, u) {
          var h = e._bin,
            d = o,
            m = {};
          if (
            ((m.fmt = h.readUshort(r, o)),
            (o += 2),
            s != 1 && s != 2 && s != 4 && s != 5 && s != 6)
          )
            return null;
          if (
            s == 1 ||
            s == 2 ||
            s == 4 ||
            (s == 5 && m.fmt <= 2) ||
            (s == 6 && m.fmt <= 2)
          ) {
            var v = h.readUshort(r, o);
            ((o += 2), (m.coverage = e._lctf.readCoverage(r, d + v)));
          }
          if (s == 1 && m.fmt >= 1 && m.fmt <= 2) {
            if (m.fmt == 1) ((m.delta = h.readShort(r, o)), (o += 2));
            else if (m.fmt == 2) {
              var y = h.readUshort(r, o);
              ((o += 2),
                (m.newg = h.readUshorts(r, o, y)),
                (o += 2 * m.newg.length));
            }
          } else if (s == 2 && m.fmt == 1) {
            ((y = h.readUshort(r, o)), (o += 2), (m.seqs = []));
            for (var b = 0; b < y; b++) {
              var _ = h.readUshort(r, o) + d;
              o += 2;
              var w = h.readUshort(r, _);
              m.seqs.push(h.readUshorts(r, _ + 2, w));
            }
          } else if (s == 4)
            for (
              m.vals = [], y = h.readUshort(r, o), o += 2, b = 0;
              b < y;
              b++
            ) {
              var E = h.readUshort(r, o);
              ((o += 2), m.vals.push(e.GSUB.readLigatureSet(r, d + E)));
            }
          else if (s == 5 && m.fmt == 2) {
            if (m.fmt == 2) {
              var T = h.readUshort(r, o);
              ((o += 2),
                (m.cDef = e._lctf.readClassDef(r, d + T)),
                (m.scset = []));
              var C = h.readUshort(r, o);
              for (o += 2, b = 0; b < C; b++) {
                var R = h.readUshort(r, o);
                ((o += 2),
                  m.scset.push(
                    R == 0 ? null : e.GSUB.readSubClassSet(r, d + R),
                  ));
              }
            }
          } else if (s == 6 && m.fmt == 3) {
            if (m.fmt == 3) {
              for (b = 0; b < 3; b++) {
                ((y = h.readUshort(r, o)), (o += 2));
                for (var L = [], I = 0; I < y; I++)
                  L.push(
                    e._lctf.readCoverage(r, d + h.readUshort(r, o + 2 * I)),
                  );
                ((o += 2 * y),
                  b == 0 && (m.backCvg = L),
                  b == 1 && (m.inptCvg = L),
                  b == 2 && (m.ahedCvg = L));
              }
              ((y = h.readUshort(r, o)),
                (o += 2),
                (m.lookupRec = e.GSUB.readSubstLookupRecords(r, o, y)));
            }
          } else {
            if (s == 7 && m.fmt == 1) {
              var O = h.readUshort(r, o);
              o += 2;
              var B = h.readUint(r, o);
              if (((o += 4), u.ltype == 9)) u.ltype = O;
              else if (u.ltype != O) throw "invalid extension substitution";
              return e.GSUB.subt(r, u.ltype, d + B);
            }
            console.debug(
              "unsupported GSUB table LookupType",
              s,
              "format",
              m.fmt,
            );
          }
          return m;
        }),
        (e.GSUB.readSubClassSet = function (r, s) {
          var o = e._bin.readUshort,
            u = s,
            h = [],
            d = o(r, s);
          s += 2;
          for (var m = 0; m < d; m++) {
            var v = o(r, s);
            ((s += 2), h.push(e.GSUB.readSubClassRule(r, u + v)));
          }
          return h;
        }),
        (e.GSUB.readSubClassRule = function (r, s) {
          var o = e._bin.readUshort,
            u = {},
            h = o(r, s),
            d = o(r, (s += 2));
          ((s += 2), (u.input = []));
          for (var m = 0; m < h - 1; m++) (u.input.push(o(r, s)), (s += 2));
          return (
            (u.substLookupRecords = e.GSUB.readSubstLookupRecords(r, s, d)),
            u
          );
        }),
        (e.GSUB.readSubstLookupRecords = function (r, s, o) {
          for (var u = e._bin.readUshort, h = [], d = 0; d < o; d++)
            (h.push(u(r, s), u(r, s + 2)), (s += 4));
          return h;
        }),
        (e.GSUB.readChainSubClassSet = function (r, s) {
          var o = e._bin,
            u = s,
            h = [],
            d = o.readUshort(r, s);
          s += 2;
          for (var m = 0; m < d; m++) {
            var v = o.readUshort(r, s);
            ((s += 2), h.push(e.GSUB.readChainSubClassRule(r, u + v)));
          }
          return h;
        }),
        (e.GSUB.readChainSubClassRule = function (r, s) {
          for (
            var o = e._bin,
              u = {},
              h = ["backtrack", "input", "lookahead"],
              d = 0;
            d < h.length;
            d++
          ) {
            var m = o.readUshort(r, s);
            ((s += 2),
              d == 1 && m--,
              (u[h[d]] = o.readUshorts(r, s, m)),
              (s += 2 * u[h[d]].length));
          }
          return (
            (m = o.readUshort(r, s)),
            (s += 2),
            (u.subst = o.readUshorts(r, s, 2 * m)),
            (s += 2 * u.subst.length),
            u
          );
        }),
        (e.GSUB.readLigatureSet = function (r, s) {
          var o = e._bin,
            u = s,
            h = [],
            d = o.readUshort(r, s);
          s += 2;
          for (var m = 0; m < d; m++) {
            var v = o.readUshort(r, s);
            ((s += 2), h.push(e.GSUB.readLigature(r, u + v)));
          }
          return h;
        }),
        (e.GSUB.readLigature = function (r, s) {
          var o = e._bin,
            u = { chain: [] };
          ((u.nglyph = o.readUshort(r, s)), (s += 2));
          var h = o.readUshort(r, s);
          s += 2;
          for (var d = 0; d < h - 1; d++)
            (u.chain.push(o.readUshort(r, s)), (s += 2));
          return u;
        }),
        (e.head = {}),
        (e.head.parse = function (r, s, o) {
          var u = e._bin,
            h = {};
          return (
            u.readFixed(r, s),
            (s += 4),
            (h.fontRevision = u.readFixed(r, s)),
            (s += 4),
            u.readUint(r, s),
            (s += 4),
            u.readUint(r, s),
            (s += 4),
            (h.flags = u.readUshort(r, s)),
            (s += 2),
            (h.unitsPerEm = u.readUshort(r, s)),
            (s += 2),
            (h.created = u.readUint64(r, s)),
            (s += 8),
            (h.modified = u.readUint64(r, s)),
            (s += 8),
            (h.xMin = u.readShort(r, s)),
            (s += 2),
            (h.yMin = u.readShort(r, s)),
            (s += 2),
            (h.xMax = u.readShort(r, s)),
            (s += 2),
            (h.yMax = u.readShort(r, s)),
            (s += 2),
            (h.macStyle = u.readUshort(r, s)),
            (s += 2),
            (h.lowestRecPPEM = u.readUshort(r, s)),
            (s += 2),
            (h.fontDirectionHint = u.readShort(r, s)),
            (s += 2),
            (h.indexToLocFormat = u.readShort(r, s)),
            (s += 2),
            (h.glyphDataFormat = u.readShort(r, s)),
            (s += 2),
            h
          );
        }),
        (e.hhea = {}),
        (e.hhea.parse = function (r, s, o) {
          var u = e._bin,
            h = {};
          return (
            u.readFixed(r, s),
            (s += 4),
            (h.ascender = u.readShort(r, s)),
            (s += 2),
            (h.descender = u.readShort(r, s)),
            (s += 2),
            (h.lineGap = u.readShort(r, s)),
            (s += 2),
            (h.advanceWidthMax = u.readUshort(r, s)),
            (s += 2),
            (h.minLeftSideBearing = u.readShort(r, s)),
            (s += 2),
            (h.minRightSideBearing = u.readShort(r, s)),
            (s += 2),
            (h.xMaxExtent = u.readShort(r, s)),
            (s += 2),
            (h.caretSlopeRise = u.readShort(r, s)),
            (s += 2),
            (h.caretSlopeRun = u.readShort(r, s)),
            (s += 2),
            (h.caretOffset = u.readShort(r, s)),
            (s += 2),
            (s += 8),
            (h.metricDataFormat = u.readShort(r, s)),
            (s += 2),
            (h.numberOfHMetrics = u.readUshort(r, s)),
            (s += 2),
            h
          );
        }),
        (e.hmtx = {}),
        (e.hmtx.parse = function (r, s, o, u) {
          for (
            var h = e._bin,
              d = { aWidth: [], lsBearing: [] },
              m = 0,
              v = 0,
              y = 0;
            y < u.maxp.numGlyphs;
            y++
          )
            (y < u.hhea.numberOfHMetrics &&
              ((m = h.readUshort(r, s)),
              (s += 2),
              (v = h.readShort(r, s)),
              (s += 2)),
              d.aWidth.push(m),
              d.lsBearing.push(v));
          return d;
        }),
        (e.kern = {}),
        (e.kern.parse = function (r, s, o, u) {
          var h = e._bin,
            d = h.readUshort(r, s);
          if (((s += 2), d == 1)) return e.kern.parseV1(r, s - 2, o, u);
          var m = h.readUshort(r, s);
          s += 2;
          for (var v = { glyph1: [], rval: [] }, y = 0; y < m; y++) {
            ((s += 2), (o = h.readUshort(r, s)), (s += 2));
            var b = h.readUshort(r, s);
            s += 2;
            var _ = b >>> 8;
            if ((_ &= 15) != 0) throw "unknown kern table format: " + _;
            s = e.kern.readFormat0(r, s, v);
          }
          return v;
        }),
        (e.kern.parseV1 = function (r, s, o, u) {
          var h = e._bin;
          (h.readFixed(r, s), (s += 4));
          var d = h.readUint(r, s);
          s += 4;
          for (var m = { glyph1: [], rval: [] }, v = 0; v < d; v++) {
            (h.readUint(r, s), (s += 4));
            var y = h.readUshort(r, s);
            ((s += 2), h.readUshort(r, s), (s += 2));
            var b = y >>> 8;
            if ((b &= 15) != 0) throw "unknown kern table format: " + b;
            s = e.kern.readFormat0(r, s, m);
          }
          return m;
        }),
        (e.kern.readFormat0 = function (r, s, o) {
          var u = e._bin,
            h = -1,
            d = u.readUshort(r, s);
          ((s += 2),
            u.readUshort(r, s),
            (s += 2),
            u.readUshort(r, s),
            (s += 2),
            u.readUshort(r, s),
            (s += 2));
          for (var m = 0; m < d; m++) {
            var v = u.readUshort(r, s);
            s += 2;
            var y = u.readUshort(r, s);
            s += 2;
            var b = u.readShort(r, s);
            ((s += 2),
              v != h &&
                (o.glyph1.push(v), o.rval.push({ glyph2: [], vals: [] })));
            var _ = o.rval[o.rval.length - 1];
            (_.glyph2.push(y), _.vals.push(b), (h = v));
          }
          return s;
        }),
        (e.loca = {}),
        (e.loca.parse = function (r, s, o, u) {
          var h = e._bin,
            d = [],
            m = u.head.indexToLocFormat,
            v = u.maxp.numGlyphs + 1;
          if (m == 0)
            for (var y = 0; y < v; y++)
              d.push(h.readUshort(r, s + (y << 1)) << 1);
          if (m == 1)
            for (y = 0; y < v; y++) d.push(h.readUint(r, s + (y << 2)));
          return d;
        }),
        (e.maxp = {}),
        (e.maxp.parse = function (r, s, o) {
          var u = e._bin,
            h = {},
            d = u.readUint(r, s);
          return (
            (s += 4),
            (h.numGlyphs = u.readUshort(r, s)),
            (s += 2),
            d == 65536 &&
              ((h.maxPoints = u.readUshort(r, s)),
              (s += 2),
              (h.maxContours = u.readUshort(r, s)),
              (s += 2),
              (h.maxCompositePoints = u.readUshort(r, s)),
              (s += 2),
              (h.maxCompositeContours = u.readUshort(r, s)),
              (s += 2),
              (h.maxZones = u.readUshort(r, s)),
              (s += 2),
              (h.maxTwilightPoints = u.readUshort(r, s)),
              (s += 2),
              (h.maxStorage = u.readUshort(r, s)),
              (s += 2),
              (h.maxFunctionDefs = u.readUshort(r, s)),
              (s += 2),
              (h.maxInstructionDefs = u.readUshort(r, s)),
              (s += 2),
              (h.maxStackElements = u.readUshort(r, s)),
              (s += 2),
              (h.maxSizeOfInstructions = u.readUshort(r, s)),
              (s += 2),
              (h.maxComponentElements = u.readUshort(r, s)),
              (s += 2),
              (h.maxComponentDepth = u.readUshort(r, s)),
              (s += 2)),
            h
          );
        }),
        (e.name = {}),
        (e.name.parse = function (r, s, o) {
          var u = e._bin,
            h = {};
          (u.readUshort(r, s), (s += 2));
          var d = u.readUshort(r, s);
          ((s += 2), u.readUshort(r, s));
          for (
            var m,
              v = [
                "copyright",
                "fontFamily",
                "fontSubfamily",
                "ID",
                "fullName",
                "version",
                "postScriptName",
                "trademark",
                "manufacturer",
                "designer",
                "description",
                "urlVendor",
                "urlDesigner",
                "licence",
                "licenceURL",
                "---",
                "typoFamilyName",
                "typoSubfamilyName",
                "compatibleFull",
                "sampleText",
                "postScriptCID",
                "wwsFamilyName",
                "wwsSubfamilyName",
                "lightPalette",
                "darkPalette",
              ],
              y = (s += 2),
              b = 0;
            b < d;
            b++
          ) {
            var _ = u.readUshort(r, s);
            s += 2;
            var w = u.readUshort(r, s);
            s += 2;
            var E = u.readUshort(r, s);
            s += 2;
            var T = u.readUshort(r, s);
            s += 2;
            var C = u.readUshort(r, s);
            s += 2;
            var R = u.readUshort(r, s);
            s += 2;
            var L,
              I = v[T],
              O = y + 12 * d + R;
            if (_ == 0) L = u.readUnicode(r, O, C / 2);
            else if (_ == 3 && w == 0) L = u.readUnicode(r, O, C / 2);
            else if (w == 0) L = u.readASCII(r, O, C);
            else if (w == 1) L = u.readUnicode(r, O, C / 2);
            else if (w == 3) L = u.readUnicode(r, O, C / 2);
            else {
              if (_ != 1) throw "unknown encoding " + w + ", platformID: " + _;
              ((L = u.readASCII(r, O, C)),
                console.debug(
                  "reading unknown MAC encoding " + w + " as ASCII",
                ));
            }
            var B = "p" + _ + "," + E.toString(16);
            (h[B] == null && (h[B] = {}),
              (h[B][I !== void 0 ? I : T] = L),
              (h[B]._lang = E));
          }
          for (var N in h)
            if (h[N].postScriptName != null && h[N]._lang == 1033) return h[N];
          for (var N in h)
            if (h[N].postScriptName != null && h[N]._lang == 0) return h[N];
          for (var N in h)
            if (h[N].postScriptName != null && h[N]._lang == 3084) return h[N];
          for (var N in h) if (h[N].postScriptName != null) return h[N];
          for (var N in h) {
            m = N;
            break;
          }
          return (
            console.debug("returning name table with languageID " + h[m]._lang),
            h[m]
          );
        }),
        (e["OS/2"] = {}),
        (e["OS/2"].parse = function (r, s, o) {
          var u = e._bin.readUshort(r, s);
          s += 2;
          var h = {};
          if (u == 0) e["OS/2"].version0(r, s, h);
          else if (u == 1) e["OS/2"].version1(r, s, h);
          else if (u == 2 || u == 3 || u == 4) e["OS/2"].version2(r, s, h);
          else {
            if (u != 5) throw "unknown OS/2 table version: " + u;
            e["OS/2"].version5(r, s, h);
          }
          return h;
        }),
        (e["OS/2"].version0 = function (r, s, o) {
          var u = e._bin;
          return (
            (o.xAvgCharWidth = u.readShort(r, s)),
            (s += 2),
            (o.usWeightClass = u.readUshort(r, s)),
            (s += 2),
            (o.usWidthClass = u.readUshort(r, s)),
            (s += 2),
            (o.fsType = u.readUshort(r, s)),
            (s += 2),
            (o.ySubscriptXSize = u.readShort(r, s)),
            (s += 2),
            (o.ySubscriptYSize = u.readShort(r, s)),
            (s += 2),
            (o.ySubscriptXOffset = u.readShort(r, s)),
            (s += 2),
            (o.ySubscriptYOffset = u.readShort(r, s)),
            (s += 2),
            (o.ySuperscriptXSize = u.readShort(r, s)),
            (s += 2),
            (o.ySuperscriptYSize = u.readShort(r, s)),
            (s += 2),
            (o.ySuperscriptXOffset = u.readShort(r, s)),
            (s += 2),
            (o.ySuperscriptYOffset = u.readShort(r, s)),
            (s += 2),
            (o.yStrikeoutSize = u.readShort(r, s)),
            (s += 2),
            (o.yStrikeoutPosition = u.readShort(r, s)),
            (s += 2),
            (o.sFamilyClass = u.readShort(r, s)),
            (s += 2),
            (o.panose = u.readBytes(r, s, 10)),
            (s += 10),
            (o.ulUnicodeRange1 = u.readUint(r, s)),
            (s += 4),
            (o.ulUnicodeRange2 = u.readUint(r, s)),
            (s += 4),
            (o.ulUnicodeRange3 = u.readUint(r, s)),
            (s += 4),
            (o.ulUnicodeRange4 = u.readUint(r, s)),
            (s += 4),
            (o.achVendID = [
              u.readInt8(r, s),
              u.readInt8(r, s + 1),
              u.readInt8(r, s + 2),
              u.readInt8(r, s + 3),
            ]),
            (s += 4),
            (o.fsSelection = u.readUshort(r, s)),
            (s += 2),
            (o.usFirstCharIndex = u.readUshort(r, s)),
            (s += 2),
            (o.usLastCharIndex = u.readUshort(r, s)),
            (s += 2),
            (o.sTypoAscender = u.readShort(r, s)),
            (s += 2),
            (o.sTypoDescender = u.readShort(r, s)),
            (s += 2),
            (o.sTypoLineGap = u.readShort(r, s)),
            (s += 2),
            (o.usWinAscent = u.readUshort(r, s)),
            (s += 2),
            (o.usWinDescent = u.readUshort(r, s)),
            (s += 2)
          );
        }),
        (e["OS/2"].version1 = function (r, s, o) {
          var u = e._bin;
          return (
            (s = e["OS/2"].version0(r, s, o)),
            (o.ulCodePageRange1 = u.readUint(r, s)),
            (s += 4),
            (o.ulCodePageRange2 = u.readUint(r, s)),
            (s += 4)
          );
        }),
        (e["OS/2"].version2 = function (r, s, o) {
          var u = e._bin;
          return (
            (s = e["OS/2"].version1(r, s, o)),
            (o.sxHeight = u.readShort(r, s)),
            (s += 2),
            (o.sCapHeight = u.readShort(r, s)),
            (s += 2),
            (o.usDefault = u.readUshort(r, s)),
            (s += 2),
            (o.usBreak = u.readUshort(r, s)),
            (s += 2),
            (o.usMaxContext = u.readUshort(r, s)),
            (s += 2)
          );
        }),
        (e["OS/2"].version5 = function (r, s, o) {
          var u = e._bin;
          return (
            (s = e["OS/2"].version2(r, s, o)),
            (o.usLowerOpticalPointSize = u.readUshort(r, s)),
            (s += 2),
            (o.usUpperOpticalPointSize = u.readUshort(r, s)),
            (s += 2)
          );
        }),
        (e.post = {}),
        (e.post.parse = function (r, s, o) {
          var u = e._bin,
            h = {};
          return (
            (h.version = u.readFixed(r, s)),
            (s += 4),
            (h.italicAngle = u.readFixed(r, s)),
            (s += 4),
            (h.underlinePosition = u.readShort(r, s)),
            (s += 2),
            (h.underlineThickness = u.readShort(r, s)),
            (s += 2),
            h
          );
        }),
        e == null && (e = {}),
        e.U == null && (e.U = {}),
        (e.U.codeToGlyph = function (r, s) {
          var o = r.cmap,
            u = -1;
          if (
            (o.p0e4 != null
              ? (u = o.p0e4)
              : o.p3e1 != null
                ? (u = o.p3e1)
                : o.p1e0 != null
                  ? (u = o.p1e0)
                  : o.p0e3 != null && (u = o.p0e3),
            u == -1)
          )
            throw "no familiar platform and encoding!";
          var h = o.tables[u];
          if (h.format == 0) return s >= h.map.length ? 0 : h.map[s];
          if (h.format == 4) {
            for (var d = -1, m = 0; m < h.endCount.length; m++)
              if (s <= h.endCount[m]) {
                d = m;
                break;
              }
            return d == -1 || h.startCount[d] > s
              ? 0
              : 65535 &
                  (h.idRangeOffset[d] != 0
                    ? h.glyphIdArray[
                        s -
                          h.startCount[d] +
                          (h.idRangeOffset[d] >> 1) -
                          (h.idRangeOffset.length - d)
                      ]
                    : s + h.idDelta[d]);
          }
          if (h.format == 12) {
            if (s > h.groups[h.groups.length - 1][1]) return 0;
            for (m = 0; m < h.groups.length; m++) {
              var v = h.groups[m];
              if (v[0] <= s && s <= v[1]) return v[2] + (s - v[0]);
            }
            return 0;
          }
          throw "unknown cmap table format " + h.format;
        }),
        (e.U.glyphToPath = function (r, s) {
          var o = { cmds: [], crds: [] };
          if (r.SVG && r.SVG.entries[s]) {
            var u = r.SVG.entries[s];
            return u == null
              ? o
              : (typeof u == "string" &&
                  ((u = e.SVG.toPath(u)), (r.SVG.entries[s] = u)),
                u);
          }
          if (r.CFF) {
            var h = {
                x: 0,
                y: 0,
                stack: [],
                nStems: 0,
                haveWidth: !1,
                width: r.CFF.Private ? r.CFF.Private.defaultWidthX : 0,
                open: !1,
              },
              d = r.CFF,
              m = r.CFF.Private;
            if (d.ROS) {
              for (var v = 0; d.FDSelect[v + 2] <= s; ) v += 2;
              m = d.FDArray[d.FDSelect[v + 1]].Private;
            }
            e.U._drawCFF(r.CFF.CharStrings[s], h, d, m, o);
          } else r.glyf && e.U._drawGlyf(s, r, o);
          return o;
        }),
        (e.U._drawGlyf = function (r, s, o) {
          var u = s.glyf[r];
          (u == null && (u = s.glyf[r] = e.glyf._parseGlyf(s, r)),
            u != null &&
              (u.noc > -1 ? e.U._simpleGlyph(u, o) : e.U._compoGlyph(u, s, o)));
        }),
        (e.U._simpleGlyph = function (r, s) {
          for (var o = 0; o < r.noc; o++) {
            for (
              var u = o == 0 ? 0 : r.endPts[o - 1] + 1, h = r.endPts[o], d = u;
              d <= h;
              d++
            ) {
              var m = d == u ? h : d - 1,
                v = d == h ? u : d + 1,
                y = 1 & r.flags[d],
                b = 1 & r.flags[m],
                _ = 1 & r.flags[v],
                w = r.xs[d],
                E = r.ys[d];
              if (d == u)
                if (y) {
                  if (!b) {
                    e.U.P.moveTo(s, w, E);
                    continue;
                  }
                  e.U.P.moveTo(s, r.xs[m], r.ys[m]);
                } else
                  b
                    ? e.U.P.moveTo(s, r.xs[m], r.ys[m])
                    : e.U.P.moveTo(s, (r.xs[m] + w) / 2, (r.ys[m] + E) / 2);
              y
                ? b && e.U.P.lineTo(s, w, E)
                : _
                  ? e.U.P.qcurveTo(s, w, E, r.xs[v], r.ys[v])
                  : e.U.P.qcurveTo(
                      s,
                      w,
                      E,
                      (w + r.xs[v]) / 2,
                      (E + r.ys[v]) / 2,
                    );
            }
            e.U.P.closePath(s);
          }
        }),
        (e.U._compoGlyph = function (r, s, o) {
          for (var u = 0; u < r.parts.length; u++) {
            var h = { cmds: [], crds: [] },
              d = r.parts[u];
            e.U._drawGlyf(d.glyphIndex, s, h);
            for (var m = d.m, v = 0; v < h.crds.length; v += 2) {
              var y = h.crds[v],
                b = h.crds[v + 1];
              (o.crds.push(y * m.a + b * m.b + m.tx),
                o.crds.push(y * m.c + b * m.d + m.ty));
            }
            for (v = 0; v < h.cmds.length; v++) o.cmds.push(h.cmds[v]);
          }
        }),
        (e.U._getGlyphClass = function (r, s) {
          var o = e._lctf.getInterval(s, r);
          return o == -1 ? 0 : s[o + 2];
        }),
        (e.U._applySubs = function (r, s, o, u) {
          for (var h = r.length - s - 1, d = 0; d < o.tabs.length; d++)
            if (o.tabs[d] != null) {
              var m,
                v = o.tabs[d];
              if (
                !v.coverage ||
                (m = e._lctf.coverageIndex(v.coverage, r[s])) != -1
              ) {
                if (o.ltype == 1)
                  (r[s],
                    v.fmt == 1 ? (r[s] = r[s] + v.delta) : (r[s] = v.newg[m]));
                else if (o.ltype == 4)
                  for (var y = v.vals[m], b = 0; b < y.length; b++) {
                    var _ = y[b],
                      w = _.chain.length;
                    if (!(w > h)) {
                      for (var E = !0, T = 0, C = 0; C < w; C++) {
                        for (; r[s + T + (1 + C)] == -1; ) T++;
                        _.chain[C] != r[s + T + (1 + C)] && (E = !1);
                      }
                      if (E) {
                        for (r[s] = _.nglyph, C = 0; C < w + T; C++)
                          r[s + C + 1] = -1;
                        break;
                      }
                    }
                  }
                else if (o.ltype == 5 && v.fmt == 2)
                  for (
                    var R = e._lctf.getInterval(v.cDef, r[s]),
                      L = v.cDef[R + 2],
                      I = v.scset[L],
                      O = 0;
                    O < I.length;
                    O++
                  ) {
                    var B = I[O],
                      N = B.input;
                    if (!(N.length > h)) {
                      for (E = !0, C = 0; C < N.length; C++) {
                        var F = e._lctf.getInterval(v.cDef, r[s + 1 + C]);
                        if (R == -1 && v.cDef[F + 2] != N[C]) {
                          E = !1;
                          break;
                        }
                      }
                      if (E) {
                        var j = B.substLookupRecords;
                        for (b = 0; b < j.length; b += 2) (j[b], j[b + 1]);
                      }
                    }
                  }
                else if (o.ltype == 6 && v.fmt == 3) {
                  if (
                    !e.U._glsCovered(r, v.backCvg, s - v.backCvg.length) ||
                    !e.U._glsCovered(r, v.inptCvg, s) ||
                    !e.U._glsCovered(r, v.ahedCvg, s + v.inptCvg.length)
                  )
                    continue;
                  var q = v.lookupRec;
                  for (O = 0; O < q.length; O += 2) {
                    R = q[O];
                    var X = u[q[O + 1]];
                    e.U._applySubs(r, s + R, X, u);
                  }
                }
              }
            }
        }),
        (e.U._glsCovered = function (r, s, o) {
          for (var u = 0; u < s.length; u++)
            if (e._lctf.coverageIndex(s[u], r[o + u]) == -1) return !1;
          return !0;
        }),
        (e.U.glyphsToPath = function (r, s, o) {
          for (
            var u = { cmds: [], crds: [] }, h = 0, d = 0;
            d < s.length;
            d++
          ) {
            var m = s[d];
            if (m != -1) {
              for (
                var v = d < s.length - 1 && s[d + 1] != -1 ? s[d + 1] : 0,
                  y = e.U.glyphToPath(r, m),
                  b = 0;
                b < y.crds.length;
                b += 2
              )
                (u.crds.push(y.crds[b] + h), u.crds.push(y.crds[b + 1]));
              for (o && u.cmds.push(o), b = 0; b < y.cmds.length; b++)
                u.cmds.push(y.cmds[b]);
              (o && u.cmds.push("X"),
                (h += r.hmtx.aWidth[m]),
                d < s.length - 1 && (h += e.U.getPairAdjustment(r, m, v)));
            }
          }
          return u;
        }),
        (e.U.P = {}),
        (e.U.P.moveTo = function (r, s, o) {
          (r.cmds.push("M"), r.crds.push(s, o));
        }),
        (e.U.P.lineTo = function (r, s, o) {
          (r.cmds.push("L"), r.crds.push(s, o));
        }),
        (e.U.P.curveTo = function (r, s, o, u, h, d, m) {
          (r.cmds.push("C"), r.crds.push(s, o, u, h, d, m));
        }),
        (e.U.P.qcurveTo = function (r, s, o, u, h) {
          (r.cmds.push("Q"), r.crds.push(s, o, u, h));
        }),
        (e.U.P.closePath = function (r) {
          r.cmds.push("Z");
        }),
        (e.U._drawCFF = function (r, s, o, u, h) {
          for (
            var d = s.stack,
              m = s.nStems,
              v = s.haveWidth,
              y = s.width,
              b = s.open,
              _ = 0,
              w = s.x,
              E = s.y,
              T = 0,
              C = 0,
              R = 0,
              L = 0,
              I = 0,
              O = 0,
              B = 0,
              N = 0,
              F = 0,
              j = 0,
              q = { val: 0, size: 0 };
            _ < r.length;
          ) {
            e.CFF.getCharString(r, _, q);
            var X = q.val;
            if (((_ += q.size), X == "o1" || X == "o18"))
              (d.length % 2 != 0 && !v && (y = d.shift() + u.nominalWidthX),
                (m += d.length >> 1),
                (d.length = 0),
                (v = !0));
            else if (X == "o3" || X == "o23")
              (d.length % 2 != 0 && !v && (y = d.shift() + u.nominalWidthX),
                (m += d.length >> 1),
                (d.length = 0),
                (v = !0));
            else if (X == "o4")
              (d.length > 1 &&
                !v &&
                ((y = d.shift() + u.nominalWidthX), (v = !0)),
                b && e.U.P.closePath(h),
                (E += d.pop()),
                e.U.P.moveTo(h, w, E),
                (b = !0));
            else if (X == "o5")
              for (; d.length > 0; )
                ((w += d.shift()), (E += d.shift()), e.U.P.lineTo(h, w, E));
            else if (X == "o6" || X == "o7")
              for (var J = d.length, ee = X == "o6", ne = 0; ne < J; ne++) {
                var W = d.shift();
                (ee ? (w += W) : (E += W), (ee = !ee), e.U.P.lineTo(h, w, E));
              }
            else if (X == "o8" || X == "o24") {
              J = d.length;
              for (var $ = 0; $ + 6 <= J; )
                ((T = w + d.shift()),
                  (C = E + d.shift()),
                  (R = T + d.shift()),
                  (L = C + d.shift()),
                  (w = R + d.shift()),
                  (E = L + d.shift()),
                  e.U.P.curveTo(h, T, C, R, L, w, E),
                  ($ += 6));
              X == "o24" &&
                ((w += d.shift()), (E += d.shift()), e.U.P.lineTo(h, w, E));
            } else {
              if (X == "o11") break;
              if (X == "o1234" || X == "o1235" || X == "o1236" || X == "o1237")
                (X == "o1234" &&
                  ((C = E),
                  (R = (T = w + d.shift()) + d.shift()),
                  (j = L = C + d.shift()),
                  (O = L),
                  (N = E),
                  (w =
                    (B = (I = (F = R + d.shift()) + d.shift()) + d.shift()) +
                    d.shift()),
                  e.U.P.curveTo(h, T, C, R, L, F, j),
                  e.U.P.curveTo(h, I, O, B, N, w, E)),
                  X == "o1235" &&
                    ((T = w + d.shift()),
                    (C = E + d.shift()),
                    (R = T + d.shift()),
                    (L = C + d.shift()),
                    (F = R + d.shift()),
                    (j = L + d.shift()),
                    (I = F + d.shift()),
                    (O = j + d.shift()),
                    (B = I + d.shift()),
                    (N = O + d.shift()),
                    (w = B + d.shift()),
                    (E = N + d.shift()),
                    d.shift(),
                    e.U.P.curveTo(h, T, C, R, L, F, j),
                    e.U.P.curveTo(h, I, O, B, N, w, E)),
                  X == "o1236" &&
                    ((T = w + d.shift()),
                    (C = E + d.shift()),
                    (R = T + d.shift()),
                    (j = L = C + d.shift()),
                    (O = L),
                    (B = (I = (F = R + d.shift()) + d.shift()) + d.shift()),
                    (N = O + d.shift()),
                    (w = B + d.shift()),
                    e.U.P.curveTo(h, T, C, R, L, F, j),
                    e.U.P.curveTo(h, I, O, B, N, w, E)),
                  X == "o1237" &&
                    ((T = w + d.shift()),
                    (C = E + d.shift()),
                    (R = T + d.shift()),
                    (L = C + d.shift()),
                    (F = R + d.shift()),
                    (j = L + d.shift()),
                    (I = F + d.shift()),
                    (O = j + d.shift()),
                    (B = I + d.shift()),
                    (N = O + d.shift()),
                    Math.abs(B - w) > Math.abs(N - E)
                      ? (w = B + d.shift())
                      : (E = N + d.shift()),
                    e.U.P.curveTo(h, T, C, R, L, F, j),
                    e.U.P.curveTo(h, I, O, B, N, w, E)));
              else if (X == "o14") {
                if (
                  (d.length > 0 &&
                    !v &&
                    ((y = d.shift() + o.nominalWidthX), (v = !0)),
                  d.length == 4)
                ) {
                  var de = d.shift(),
                    le = d.shift(),
                    fe = d.shift(),
                    V = d.shift(),
                    Z = e.CFF.glyphBySE(o, fe),
                    se = e.CFF.glyphBySE(o, V);
                  (e.U._drawCFF(o.CharStrings[Z], s, o, u, h),
                    (s.x = de),
                    (s.y = le),
                    e.U._drawCFF(o.CharStrings[se], s, o, u, h));
                }
                b && (e.U.P.closePath(h), (b = !1));
              } else if (X == "o19" || X == "o20")
                (d.length % 2 != 0 && !v && (y = d.shift() + u.nominalWidthX),
                  (m += d.length >> 1),
                  (d.length = 0),
                  (v = !0),
                  (_ += (m + 7) >> 3));
              else if (X == "o21")
                (d.length > 2 &&
                  !v &&
                  ((y = d.shift() + u.nominalWidthX), (v = !0)),
                  (E += d.pop()),
                  (w += d.pop()),
                  b && e.U.P.closePath(h),
                  e.U.P.moveTo(h, w, E),
                  (b = !0));
              else if (X == "o22")
                (d.length > 1 &&
                  !v &&
                  ((y = d.shift() + u.nominalWidthX), (v = !0)),
                  (w += d.pop()),
                  b && e.U.P.closePath(h),
                  e.U.P.moveTo(h, w, E),
                  (b = !0));
              else if (X == "o25") {
                for (; d.length > 6; )
                  ((w += d.shift()), (E += d.shift()), e.U.P.lineTo(h, w, E));
                ((T = w + d.shift()),
                  (C = E + d.shift()),
                  (R = T + d.shift()),
                  (L = C + d.shift()),
                  (w = R + d.shift()),
                  (E = L + d.shift()),
                  e.U.P.curveTo(h, T, C, R, L, w, E));
              } else if (X == "o26")
                for (d.length % 2 && (w += d.shift()); d.length > 0; )
                  ((T = w),
                    (C = E + d.shift()),
                    (w = R = T + d.shift()),
                    (E = (L = C + d.shift()) + d.shift()),
                    e.U.P.curveTo(h, T, C, R, L, w, E));
              else if (X == "o27")
                for (d.length % 2 && (E += d.shift()); d.length > 0; )
                  ((C = E),
                    (R = (T = w + d.shift()) + d.shift()),
                    (L = C + d.shift()),
                    (w = R + d.shift()),
                    (E = L),
                    e.U.P.curveTo(h, T, C, R, L, w, E));
              else if (X == "o10" || X == "o29") {
                var ue = X == "o10" ? u : o;
                if (d.length == 0) console.debug("error: empty stack");
                else {
                  var ge = d.pop(),
                    ae = ue.Subrs[ge + ue.Bias];
                  ((s.x = w),
                    (s.y = E),
                    (s.nStems = m),
                    (s.haveWidth = v),
                    (s.width = y),
                    (s.open = b),
                    e.U._drawCFF(ae, s, o, u, h),
                    (w = s.x),
                    (E = s.y),
                    (m = s.nStems),
                    (v = s.haveWidth),
                    (y = s.width),
                    (b = s.open));
                }
              } else if (X == "o30" || X == "o31") {
                var he = d.length,
                  ye = (($ = 0), X == "o31");
                for ($ += he - (J = -3 & he); $ < J; )
                  (ye
                    ? ((C = E),
                      (R = (T = w + d.shift()) + d.shift()),
                      (E = (L = C + d.shift()) + d.shift()),
                      J - $ == 5 ? ((w = R + d.shift()), $++) : (w = R),
                      (ye = !1))
                    : ((T = w),
                      (C = E + d.shift()),
                      (R = T + d.shift()),
                      (L = C + d.shift()),
                      (w = R + d.shift()),
                      J - $ == 5 ? ((E = L + d.shift()), $++) : (E = L),
                      (ye = !0)),
                    e.U.P.curveTo(h, T, C, R, L, w, E),
                    ($ += 4));
              } else {
                if ((X + "").charAt(0) == "o")
                  throw (console.debug("Unknown operation: " + X, r), X);
                d.push(X);
              }
            }
          }
          ((s.x = w),
            (s.y = E),
            (s.nStems = m),
            (s.haveWidth = v),
            (s.width = y),
            (s.open = b));
        }));
      var t = e,
        n = { Typr: t };
      return (
        (i.Typr = t),
        (i.default = n),
        Object.defineProperty(i, "__esModule", { value: !0 }),
        i
      );
    })({}).Typr
  );
}
/*!
Custom bundle of woff2otf (https://github.com/arty-name/woff2otf) with fflate
(https://github.com/101arrowz/fflate) for use in Troika text rendering. 
Original licenses apply: 
- fflate: https://github.com/101arrowz/fflate/blob/master/LICENSE (MIT)
- woff2otf.js: https://github.com/arty-name/woff2otf/blob/master/woff2otf.js (Apache2)
*/ function uW() {
  return (function (i) {
    var e = Uint8Array,
      t = Uint16Array,
      n = Uint32Array,
      r = new e([
        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4,
        5, 5, 5, 5, 0, 0, 0, 0,
      ]),
      s = new e([
        0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10,
        10, 11, 11, 12, 12, 13, 13, 0, 0,
      ]),
      o = new e([
        16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15,
      ]),
      u = function (X, J) {
        for (var ee = new t(31), ne = 0; ne < 31; ++ne)
          ee[ne] = J += 1 << X[ne - 1];
        var W = new n(ee[30]);
        for (ne = 1; ne < 30; ++ne)
          for (var $ = ee[ne]; $ < ee[ne + 1]; ++$)
            W[$] = (($ - ee[ne]) << 5) | ne;
        return [ee, W];
      },
      h = u(r, 2),
      d = h[0],
      m = h[1];
    ((d[28] = 258), (m[258] = 28));
    for (var v = u(s, 0)[0], y = new t(32768), b = 0; b < 32768; ++b) {
      var _ = ((43690 & b) >>> 1) | ((21845 & b) << 1);
      ((_ =
        ((61680 & (_ = ((52428 & _) >>> 2) | ((13107 & _) << 2))) >>> 4) |
        ((3855 & _) << 4)),
        (y[b] = (((65280 & _) >>> 8) | ((255 & _) << 8)) >>> 1));
    }
    var w = function (X, J, ee) {
        for (var ne = X.length, W = 0, $ = new t(J); W < ne; ++W) ++$[X[W] - 1];
        var de,
          le = new t(J);
        for (W = 0; W < J; ++W) le[W] = (le[W - 1] + $[W - 1]) << 1;
        {
          de = new t(1 << J);
          var fe = 15 - J;
          for (W = 0; W < ne; ++W)
            if (X[W])
              for (
                var V = (W << 4) | X[W],
                  Z = J - X[W],
                  se = le[X[W] - 1]++ << Z,
                  ue = se | ((1 << Z) - 1);
                se <= ue;
                ++se
              )
                de[y[se] >>> fe] = V;
        }
        return de;
      },
      E = new e(288);
    for (b = 0; b < 144; ++b) E[b] = 8;
    for (b = 144; b < 256; ++b) E[b] = 9;
    for (b = 256; b < 280; ++b) E[b] = 7;
    for (b = 280; b < 288; ++b) E[b] = 8;
    var T = new e(32);
    for (b = 0; b < 32; ++b) T[b] = 5;
    var C = w(E, 9),
      R = w(T, 5),
      L = function (X) {
        for (var J = X[0], ee = 1; ee < X.length; ++ee)
          X[ee] > J && (J = X[ee]);
        return J;
      },
      I = function (X, J, ee) {
        var ne = (J / 8) | 0;
        return ((X[ne] | (X[ne + 1] << 8)) >> (7 & J)) & ee;
      },
      O = function (X, J) {
        var ee = (J / 8) | 0;
        return (X[ee] | (X[ee + 1] << 8) | (X[ee + 2] << 16)) >> (7 & J);
      },
      B = [
        "unexpected EOF",
        "invalid block type",
        "invalid length/literal",
        "invalid distance",
        "stream finished",
        "no stream handler",
        ,
        "no callback",
        "invalid UTF-8 data",
        "extra field too long",
        "date not in range 1980-2099",
        "filename too long",
        "stream finishing",
        "invalid zip data",
      ],
      N = function (X, J, ee) {
        var ne = new Error(J || B[X]);
        if (
          ((ne.code = X),
          Error.captureStackTrace && Error.captureStackTrace(ne, N),
          !ee)
        )
          throw ne;
        return ne;
      },
      F = function (X, J, ee) {
        var ne = X.length;
        if (!ne || (ee && !ee.l && ne < 5)) return J || new e(0);
        var W = !J || ee,
          $ = !ee || ee.i;
        (ee || (ee = {}), J || (J = new e(3 * ne)));
        var de,
          le = function (Ze) {
            var re = J.length;
            if (Ze > re) {
              var Se = new e(Math.max(2 * re, Ze));
              (Se.set(J), (J = Se));
            }
          },
          fe = ee.f || 0,
          V = ee.p || 0,
          Z = ee.b || 0,
          se = ee.l,
          ue = ee.d,
          ge = ee.m,
          ae = ee.n,
          he = 8 * ne;
        do {
          if (!se) {
            ee.f = fe = I(X, V, 1);
            var ye = I(X, V + 1, 3);
            if (((V += 3), !ye)) {
              var ze =
                  X[(je = (((de = V) / 8) | 0) + (7 & de && 1) + 4) - 4] |
                  (X[je - 3] << 8),
                it = je + ze;
              if (it > ne) {
                $ && N(0);
                break;
              }
              (W && le(Z + ze),
                J.set(X.subarray(je, it), Z),
                (ee.b = Z += ze),
                (ee.p = V = 8 * it));
              continue;
            }
            if (ye == 1) ((se = C), (ue = R), (ge = 9), (ae = 5));
            else if (ye == 2) {
              var qe = I(X, V, 31) + 257,
                Ye = I(X, V + 10, 15) + 4,
                ft = qe + I(X, V + 5, 31) + 1;
              V += 14;
              for (var Re = new e(ft), Ie = new e(19), De = 0; De < Ye; ++De)
                Ie[o[De]] = I(X, V + 3 * De, 7);
              V += 3 * Ye;
              var Qe = L(Ie),
                K = (1 << Qe) - 1,
                rt = w(Ie, Qe);
              for (De = 0; De < ft; ) {
                var je,
                  Te = rt[I(X, V, K)];
                if (((V += 15 & Te), (je = Te >>> 4) < 16)) Re[De++] = je;
                else {
                  var ke = 0,
                    H = 0;
                  for (
                    je == 16
                      ? ((H = 3 + I(X, V, 3)), (V += 2), (ke = Re[De - 1]))
                      : je == 17
                        ? ((H = 3 + I(X, V, 7)), (V += 3))
                        : je == 18 && ((H = 11 + I(X, V, 127)), (V += 7));
                    H--;
                  )
                    Re[De++] = ke;
                }
              }
              var k = Re.subarray(0, qe),
                oe = Re.subarray(qe);
              ((ge = L(k)), (ae = L(oe)), (se = w(k, ge)), (ue = w(oe, ae)));
            } else N(1);
            if (V > he) {
              $ && N(0);
              break;
            }
          }
          W && le(Z + 131072);
          for (var Ae = (1 << ge) - 1, _e = (1 << ae) - 1, be = V; ; be = V) {
            var et = (ke = se[O(X, V) & Ae]) >>> 4;
            if ((V += 15 & ke) > he) {
              $ && N(0);
              break;
            }
            if ((ke || N(2), et < 256)) J[Z++] = et;
            else {
              if (et == 256) {
                ((be = V), (se = null));
                break;
              }
              var $e = et - 254;
              if (et > 264) {
                var ht = r[(De = et - 257)];
                (($e = I(X, V, (1 << ht) - 1) + d[De]), (V += ht));
              }
              var yt = ue[O(X, V) & _e],
                Ge = yt >>> 4;
              if (
                (yt || N(3),
                (V += 15 & yt),
                (oe = v[Ge]),
                Ge > 3 &&
                  ((ht = s[Ge]), (oe += O(X, V) & ((1 << ht) - 1)), (V += ht)),
                V > he)
              ) {
                $ && N(0);
                break;
              }
              W && le(Z + 131072);
              for (var Ve = Z + $e; Z < Ve; Z += 4)
                ((J[Z] = J[Z - oe]),
                  (J[Z + 1] = J[Z + 1 - oe]),
                  (J[Z + 2] = J[Z + 2 - oe]),
                  (J[Z + 3] = J[Z + 3 - oe]));
              Z = Ve;
            }
          }
          ((ee.l = se),
            (ee.p = be),
            (ee.b = Z),
            se && ((fe = 1), (ee.m = ge), (ee.d = ue), (ee.n = ae)));
        } while (!fe);
        return Z == J.length
          ? J
          : (function (Ze, re, Se) {
              (Se == null || Se > Ze.length) && (Se = Ze.length);
              var lt = new (Ze instanceof t ? t : Ze instanceof n ? n : e)(
                Se - re,
              );
              return (lt.set(Ze.subarray(re, Se)), lt);
            })(J, 0, Z);
      },
      j = new e(0),
      q = typeof TextDecoder < "u" && new TextDecoder();
    try {
      q.decode(j, { stream: !0 });
    } catch {}
    return (
      (i.convert_streams = function (X) {
        var J = new DataView(X),
          ee = 0;
        function ne() {
          var qe = J.getUint16(ee);
          return ((ee += 2), qe);
        }
        function W() {
          var qe = J.getUint32(ee);
          return ((ee += 4), qe);
        }
        function $(qe) {
          (ze.setUint16(it, qe), (it += 2));
        }
        function de(qe) {
          (ze.setUint32(it, qe), (it += 4));
        }
        for (
          var le = {
              signature: W(),
              flavor: W(),
              length: W(),
              numTables: ne(),
              reserved: ne(),
              totalSfntSize: W(),
              majorVersion: ne(),
              minorVersion: ne(),
              metaOffset: W(),
              metaLength: W(),
              metaOrigLength: W(),
              privOffset: W(),
              privLength: W(),
            },
            fe = 0;
          Math.pow(2, fe) <= le.numTables;
        )
          fe++;
        fe--;
        for (
          var V = 16 * Math.pow(2, fe),
            Z = 16 * le.numTables - V,
            se = 12,
            ue = [],
            ge = 0;
          ge < le.numTables;
          ge++
        )
          (ue.push({
            tag: W(),
            offset: W(),
            compLength: W(),
            origLength: W(),
            origChecksum: W(),
          }),
            (se += 16));
        var ae,
          he = new Uint8Array(
            12 +
              16 * ue.length +
              ue.reduce(function (qe, Ye) {
                return qe + Ye.origLength + 4;
              }, 0),
          ),
          ye = he.buffer,
          ze = new DataView(ye),
          it = 0;
        return (
          de(le.flavor),
          $(le.numTables),
          $(V),
          $(fe),
          $(Z),
          ue.forEach(function (qe) {
            (de(qe.tag),
              de(qe.origChecksum),
              de(se),
              de(qe.origLength),
              (qe.outOffset = se),
              (se += qe.origLength) % 4 != 0 && (se += 4 - (se % 4)));
          }),
          ue.forEach(function (qe) {
            var Ye,
              ft = X.slice(qe.offset, qe.offset + qe.compLength);
            if (qe.compLength != qe.origLength) {
              var Re = new Uint8Array(qe.origLength);
              ((Ye = new Uint8Array(ft, 2)), F(Ye, Re));
            } else Re = new Uint8Array(ft);
            he.set(Re, qe.outOffset);
            var Ie = 0;
            ((se = qe.outOffset + qe.origLength) % 4 != 0 &&
              (Ie = 4 - (se % 4)),
              he.set(new Uint8Array(Ie).buffer, qe.outOffset + qe.origLength),
              (ae = se + Ie));
          }),
          ye.slice(0, ae)
        );
      }),
      Object.defineProperty(i, "__esModule", { value: !0 }),
      i
    );
  })({}).convert_streams;
}
function fW(i, e) {
  const t = { M: 2, L: 2, Q: 4, C: 6, Z: 0 },
    n = {
      C: "18g,ca,368,1kz",
      D: "17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v",
      R: "17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6",
      L: "x9u,jff,a,fd,jv",
      T: "4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n",
    },
    r = 1,
    s = 2,
    o = 4,
    u = 8,
    h = 16,
    d = 32;
  let m;
  function v(B) {
    if (!m) {
      const N = { R: s, L: r, D: o, C: h, U: d, T: u };
      m = new Map();
      for (let F in n) {
        let j = 0;
        n[F].split(",").forEach((q) => {
          let [X, J] = q.split("+");
          ((X = parseInt(X, 36)),
            (J = J ? parseInt(J, 36) : 0),
            m.set((j += X), N[F]));
          for (let ee = J; ee--; ) m.set(++j, N[F]);
        });
      }
    }
    return m.get(B) || d;
  }
  const y = 1,
    b = 2,
    _ = 3,
    w = 4,
    E = [null, "isol", "init", "fina", "medi"];
  function T(B) {
    const N = new Uint8Array(B.length);
    let F = d,
      j = y,
      q = -1;
    for (let X = 0; X < B.length; X++) {
      const J = B.codePointAt(X);
      let ee = v(J) | 0,
        ne = y;
      ee & u ||
        (F & (r | o | h)
          ? ee & (s | o | h)
            ? ((ne = _), (j === y || j === _) && N[q]++)
            : ee & (r | d) && (j === b || j === w) && N[q]--
          : F & (s | d) && (j === b || j === w) && N[q]--,
        (j = N[X] = ne),
        (F = ee),
        (q = X),
        J > 65535 && X++);
    }
    return N;
  }
  function C(B, N) {
    const F = [];
    for (let q = 0; q < N.length; q++) {
      const X = N.codePointAt(q);
      (X > 65535 && q++, F.push(i.U.codeToGlyph(B, X)));
    }
    const j = B.GSUB;
    if (j) {
      const { lookupList: q, featureList: X } = j;
      let J;
      const ee = /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws|ccmp)$/,
        ne = [];
      X.forEach((W) => {
        if (ee.test(W.tag))
          for (let $ = 0; $ < W.tab.length; $++) {
            if (ne[W.tab[$]]) continue;
            ne[W.tab[$]] = !0;
            const de = q[W.tab[$]],
              le = /^(isol|init|fina|medi)$/.test(W.tag);
            le && !J && (J = T(N));
            for (let fe = 0; fe < F.length; fe++)
              (!J || !le || E[J[fe]] === W.tag) && i.U._applySubs(F, fe, de, q);
          }
      });
    }
    return F;
  }
  function R(B, N) {
    const F = new Int16Array(N.length * 3);
    let j = 0;
    for (; j < N.length; j++) {
      const ee = N[j];
      if (ee === -1) continue;
      F[j * 3 + 2] = B.hmtx.aWidth[ee];
      const ne = B.GPOS;
      if (ne) {
        const W = ne.lookupList;
        for (let $ = 0; $ < W.length; $++) {
          const de = W[$];
          for (let le = 0; le < de.tabs.length; le++) {
            const fe = de.tabs[le];
            if (de.ltype === 1) {
              if (i._lctf.coverageIndex(fe.coverage, ee) !== -1 && fe.pos) {
                J(fe.pos, j);
                break;
              }
            } else if (de.ltype === 2) {
              let V = null,
                Z = q();
              if (Z !== -1) {
                const se = i._lctf.coverageIndex(fe.coverage, N[Z]);
                if (se !== -1) {
                  if (fe.fmt === 1) {
                    const ue = fe.pairsets[se];
                    for (let ge = 0; ge < ue.length; ge++)
                      ue[ge].gid2 === ee && (V = ue[ge]);
                  } else if (fe.fmt === 2) {
                    const ue = i.U._getGlyphClass(N[Z], fe.classDef1),
                      ge = i.U._getGlyphClass(ee, fe.classDef2);
                    V = fe.matrix[ue][ge];
                  }
                  if (V) {
                    (V.val1 && J(V.val1, Z), V.val2 && J(V.val2, j));
                    break;
                  }
                }
              }
            } else if (de.ltype === 4) {
              const V = i._lctf.coverageIndex(fe.markCoverage, ee);
              if (V !== -1) {
                const Z = q(X),
                  se =
                    Z === -1
                      ? -1
                      : i._lctf.coverageIndex(fe.baseCoverage, N[Z]);
                if (se !== -1) {
                  const ue = fe.markArray[V],
                    ge = fe.baseArray[se][ue.markClass];
                  ((F[j * 3] = ge.x - ue.x + F[Z * 3] - F[Z * 3 + 2]),
                    (F[j * 3 + 1] = ge.y - ue.y + F[Z * 3 + 1]));
                  break;
                }
              }
            } else if (de.ltype === 6) {
              const V = i._lctf.coverageIndex(fe.mark1Coverage, ee);
              if (V !== -1) {
                const Z = q();
                if (Z !== -1) {
                  const se = N[Z];
                  if (L(B, se) === 3) {
                    const ue = i._lctf.coverageIndex(fe.mark2Coverage, se);
                    if (ue !== -1) {
                      const ge = fe.mark1Array[V],
                        ae = fe.mark2Array[ue][ge.markClass];
                      ((F[j * 3] = ae.x - ge.x + F[Z * 3] - F[Z * 3 + 2]),
                        (F[j * 3 + 1] = ae.y - ge.y + F[Z * 3 + 1]));
                      break;
                    }
                  }
                }
              }
            }
          }
        }
      } else if (B.kern && !B.cff) {
        const W = q();
        if (W !== -1) {
          const $ = B.kern.glyph1.indexOf(N[W]);
          if ($ !== -1) {
            const de = B.kern.rval[$].glyph2.indexOf(ee);
            de !== -1 && (F[W * 3 + 2] += B.kern.rval[$].vals[de]);
          }
        }
      }
    }
    return F;
    function q(ee) {
      for (let ne = j - 1; ne >= 0; ne--)
        if (N[ne] !== -1 && (!ee || ee(N[ne]))) return ne;
      return -1;
    }
    function X(ee) {
      return L(B, ee) === 1;
    }
    function J(ee, ne) {
      for (let W = 0; W < 3; W++) F[ne * 3 + W] += ee[W] || 0;
    }
  }
  function L(B, N) {
    const F = B.GDEF && B.GDEF.glyphClassDef;
    return F ? i.U._getGlyphClass(N, F) : 0;
  }
  function I(...B) {
    for (let N = 0; N < B.length; N++) if (typeof B[N] == "number") return B[N];
  }
  function O(B) {
    const N = Object.create(null),
      F = B["OS/2"],
      j = B.hhea,
      q = B.head.unitsPerEm,
      X = I(F && F.sTypoAscender, j && j.ascender, q),
      J = {
        unitsPerEm: q,
        ascender: X,
        descender: I(F && F.sTypoDescender, j && j.descender, 0),
        capHeight: I(F && F.sCapHeight, X),
        xHeight: I(F && F.sxHeight, X),
        lineGap: I(F && F.sTypoLineGap, j && j.lineGap),
        supportsCodePoint(ee) {
          return i.U.codeToGlyph(B, ee) > 0;
        },
        forEachGlyph(ee, ne, W, $) {
          let de = 0;
          const le = (1 / J.unitsPerEm) * ne,
            fe = C(B, ee);
          let V = 0;
          const Z = R(B, fe);
          return (
            fe.forEach((se, ue) => {
              if (se !== -1) {
                let ge = N[se];
                if (!ge) {
                  const { cmds: ae, crds: he } = i.U.glyphToPath(B, se);
                  let ye = "",
                    ze = 0;
                  for (let Re = 0, Ie = ae.length; Re < Ie; Re++) {
                    const De = t[ae[Re]];
                    ye += ae[Re];
                    for (let Qe = 1; Qe <= De; Qe++)
                      ye += (Qe > 1 ? "," : "") + he[ze++];
                  }
                  let it, qe, Ye, ft;
                  if (he.length) {
                    ((it = qe = 1 / 0), (Ye = ft = -1 / 0));
                    for (let Re = 0, Ie = he.length; Re < Ie; Re += 2) {
                      let De = he[Re],
                        Qe = he[Re + 1];
                      (De < it && (it = De),
                        Qe < qe && (qe = Qe),
                        De > Ye && (Ye = De),
                        Qe > ft && (ft = Qe));
                    }
                  } else it = Ye = qe = ft = 0;
                  ge = N[se] = {
                    index: se,
                    advanceWidth: B.hmtx.aWidth[se],
                    xMin: it,
                    yMin: qe,
                    xMax: Ye,
                    yMax: ft,
                    path: ye,
                  };
                }
                ($.call(null, ge, de + Z[ue * 3] * le, Z[ue * 3 + 1] * le, V),
                  (de += Z[ue * 3 + 2] * le),
                  W && (de += W * ne));
              }
              V += ee.codePointAt(V) > 65535 ? 2 : 1;
            }),
            de
          );
        },
      };
    return J;
  }
  return function (N) {
    const F = new Uint8Array(N, 0, 4),
      j = i._bin.readASCII(F, 0, 4);
    if (j === "wOFF") N = e(N);
    else if (j === "wOF2") throw new Error("woff2 fonts not supported");
    return O(i.parse(N)[0]);
  };
}
const hW = jp({
  name: "Typr Font Parser",
  dependencies: [cW, uW, fW],
  init(i, e, t) {
    const n = i(),
      r = e();
    return t(n, r);
  },
});
/*!
Custom bundle of @unicode-font-resolver/client v1.0.2 (https://github.com/lojjic/unicode-font-resolver)
for use in Troika text rendering. 
Original MIT license applies
*/ function dW() {
  return (function (i) {
    var e = function () {
      this.buckets = new Map();
    };
    ((e.prototype.add = function (R) {
      var L = R >> 5;
      this.buckets.set(L, (this.buckets.get(L) || 0) | (1 << (31 & R)));
    }),
      (e.prototype.has = function (R) {
        var L = this.buckets.get(R >> 5);
        return L !== void 0 && (L & (1 << (31 & R))) != 0;
      }),
      (e.prototype.serialize = function () {
        var R = [];
        return (
          this.buckets.forEach(function (L, I) {
            R.push((+I).toString(36) + ":" + L.toString(36));
          }),
          R.join(",")
        );
      }),
      (e.prototype.deserialize = function (R) {
        var L = this;
        (this.buckets.clear(),
          R.split(",").forEach(function (I) {
            var O = I.split(":");
            L.buckets.set(parseInt(O[0], 36), parseInt(O[1], 36));
          }));
      }));
    var t = Math.pow(2, 8),
      n = t - 1,
      r = ~n;
    function s(R) {
      var L = (function (O) {
          return O & r;
        })(R).toString(16),
        I = (function (O) {
          return (O & r) + t - 1;
        })(R).toString(16);
      return "codepoint-index/plane" + (R >> 16) + "/" + L + "-" + I + ".json";
    }
    function o(R, L) {
      var I = R & n,
        O = L.codePointAt((I / 6) | 0);
      return ((O = (O || 48) - 48) & (1 << (I % 6))) != 0;
    }
    function u(R, L) {
      var I;
      ((I = R),
      I.replace(/U\+/gi, "")
        .replace(/^,+|,+$/g, "")
        .split(/,+/)
        .map(function (O) {
          return O.split("-").map(function (B) {
            return parseInt(B.trim(), 16);
          });
        })).forEach(function (O) {
        var B = O[0],
          N = O[1];
        (N === void 0 && (N = B), L(B, N));
      });
    }
    function h(R, L) {
      u(R, function (I, O) {
        for (var B = I; B <= O; B++) L(B);
      });
    }
    var d = {},
      m = {},
      v = new WeakMap(),
      y =
        "https://cdn.jsdelivr.net/gh/lojjic/unicode-font-resolver@v1.0.1/packages/data";
    function b(R) {
      var L = v.get(R);
      return (
        L ||
          ((L = new e()),
          h(R.ranges, function (I) {
            return L.add(I);
          }),
          v.set(R, L)),
        L
      );
    }
    var _,
      w = new Map();
    function E(R, L, I) {
      return R[L]
        ? L
        : R[I]
          ? I
          : (function (O) {
              for (var B in O) return B;
            })(R);
    }
    function T(R, L) {
      var I = L;
      if (!R.includes(I)) {
        I = 1 / 0;
        for (var O = 0; O < R.length; O++)
          Math.abs(R[O] - L) < Math.abs(I - L) && (I = R[O]);
      }
      return I;
    }
    function C(R) {
      return (
        _ ||
          ((_ = new Set()),
          h("9-D,20,85,A0,1680,2000-200A,2028-202F,205F,3000", function (L) {
            _.add(L);
          })),
        _.has(R)
      );
    }
    return (
      (i.CodePointSet = e),
      (i.clearCache = function () {
        ((d = {}), (m = {}));
      }),
      (i.getFontsForString = function (R, L) {
        L === void 0 && (L = {});
        var I,
          O = L.lang;
        O === void 0 &&
          (O = new RegExp("\\p{Script=Hangul}", "u").test((I = R))
            ? "ko"
            : new RegExp("\\p{Script=Hiragana}|\\p{Script=Katakana}", "u").test(
                  I,
                )
              ? "ja"
              : "en");
        var B = L.category;
        B === void 0 && (B = "sans-serif");
        var N = L.style;
        N === void 0 && (N = "normal");
        var F = L.weight;
        F === void 0 && (F = 400);
        var j = (L.dataUrl || y).replace(/\/$/g, ""),
          q = new Map(),
          X = new Uint8Array(R.length),
          J = {},
          ee = {},
          ne = new Array(R.length),
          W = new Map(),
          $ = !1;
        function de(V) {
          var Z = w.get(V);
          return (
            Z ||
              ((Z = fetch(j + "/" + V)
                .then(function (se) {
                  if (!se.ok) throw new Error(se.statusText);
                  return se.json().then(function (ue) {
                    if (!Array.isArray(ue) || ue[0] !== 1)
                      throw new Error(
                        "Incorrect schema version; need 1, got " + ue[0],
                      );
                    return ue[1];
                  });
                })
                .catch(function (se) {
                  if (j !== y)
                    return (
                      $ ||
                        (console.error(
                          'unicode-font-resolver: Failed loading from dataUrl "' +
                            j +
                            '", trying default CDN. ' +
                            se.message,
                        ),
                        ($ = !0)),
                      (j = y),
                      w.delete(V),
                      de(V)
                    );
                  throw se;
                })),
              w.set(V, Z)),
            Z
          );
        }
        for (
          var le = function (V) {
              var Z = R.codePointAt(V),
                se = s(Z);
              ((ne[V] = se),
                d[se] ||
                  W.has(se) ||
                  W.set(
                    se,
                    de(se).then(function (ue) {
                      d[se] = ue;
                    }),
                  ),
                Z > 65535 && (V++, (fe = V)));
            },
            fe = 0;
          fe < R.length;
          fe++
        )
          le(fe);
        return Promise.all(W.values())
          .then(function () {
            W.clear();
            for (
              var V = function (se) {
                  var ue = R.codePointAt(se),
                    ge = null,
                    ae = d[ne[se]],
                    he = void 0;
                  for (var ye in ae) {
                    var ze = ee[ye];
                    if (
                      (ze === void 0 &&
                        (ze = ee[ye] = new RegExp(ye).test(O || "en")),
                      ze)
                    ) {
                      for (var it in ((he = ye), ae[ye]))
                        if (o(ue, ae[ye][it])) {
                          ge = it;
                          break;
                        }
                      break;
                    }
                  }
                  if (!ge) {
                    e: for (var qe in ae)
                      if (qe !== he) {
                        for (var Ye in ae[qe])
                          if (o(ue, ae[qe][Ye])) {
                            ge = Ye;
                            break e;
                          }
                      }
                  }
                  (ge ||
                    (console.debug("No font coverage for U+" + ue.toString(16)),
                    (ge = "latin")),
                    (ne[se] = ge),
                    m[ge] ||
                      W.has(ge) ||
                      W.set(
                        ge,
                        de("font-meta/" + ge + ".json").then(function (ft) {
                          m[ge] = ft;
                        }),
                      ),
                    ue > 65535 && (se++, (Z = se)));
                },
                Z = 0;
              Z < R.length;
              Z++
            )
              V(Z);
            return Promise.all(W.values());
          })
          .then(function () {
            for (var V, Z = null, se = 0; se < R.length; se++) {
              var ue = R.codePointAt(se);
              if (Z && (C(ue) || b(Z).has(ue))) X[se] = X[se - 1];
              else {
                Z = m[ne[se]];
                var ge = J[Z.id];
                if (!ge) {
                  var ae = Z.typeforms,
                    he = E(ae, B, "sans-serif"),
                    ye = E(ae[he], N, "normal"),
                    ze = T(
                      (V = ae[he]) === null || V === void 0 ? void 0 : V[ye],
                      F,
                    );
                  ge = J[Z.id] =
                    j +
                    "/font-files/" +
                    Z.id +
                    "/" +
                    he +
                    "." +
                    ye +
                    "." +
                    ze +
                    ".woff";
                }
                var it = q.get(ge);
                (it == null && ((it = q.size), q.set(ge, it)), (X[se] = it));
              }
              ue > 65535 && (se++, (X[se] = X[se - 1]));
            }
            return { fontUrls: Array.from(q.keys()), chars: X };
          });
      }),
      Object.defineProperty(i, "__esModule", { value: !0 }),
      i
    );
  })({});
}
function pW(i, e) {
  const t = Object.create(null),
    n = Object.create(null);
  function r(o, u) {
    const h = (d) => {
      console.error(`Failure loading font ${o}`, d);
    };
    try {
      const d = new XMLHttpRequest();
      (d.open("get", o, !0),
        (d.responseType = "arraybuffer"),
        (d.onload = function () {
          if (d.status >= 400) h(new Error(d.statusText));
          else if (d.status > 0)
            try {
              const m = i(d.response);
              ((m.src = o), u(m));
            } catch (m) {
              h(m);
            }
        }),
        (d.onerror = h),
        d.send());
    } catch (d) {
      h(d);
    }
  }
  function s(o, u) {
    let h = t[o];
    h
      ? u(h)
      : n[o]
        ? n[o].push(u)
        : ((n[o] = [u]),
          r(o, (d) => {
            ((d.src = o), (t[o] = d), n[o].forEach((m) => m(d)), delete n[o]);
          }));
  }
  return function (
    o,
    u,
    {
      lang: h,
      fonts: d = [],
      style: m = "normal",
      weight: v = "normal",
      unicodeFontsURL: y,
    } = {},
  ) {
    const b = new Uint8Array(o.length),
      _ = [];
    o.length || C();
    const w = new Map(),
      E = [];
    if (
      (m !== "italic" && (m = "normal"),
      typeof v != "number" && (v = v === "bold" ? 700 : 400),
      d && !Array.isArray(d) && (d = [d]),
      (d = d
        .slice()
        .filter((L) => !L.lang || L.lang.test(h))
        .reverse()),
      d.length)
    ) {
      let B = 0;
      (function N(F = 0) {
        for (let j = F, q = o.length; j < q; j++) {
          const X = o.codePointAt(j);
          if (
            (B === 1 && _[b[j - 1]].supportsCodePoint(X)) ||
            (j > 0 && /\s/.test(o[j]))
          )
            ((b[j] = b[j - 1]), B === 2 && (E[E.length - 1][1] = j));
          else
            for (let J = b[j], ee = d.length; J <= ee; J++)
              if (J === ee) {
                const ne = B === 2 ? E[E.length - 1] : (E[E.length] = [j, j]);
                ((ne[1] = j), (B = 2));
              } else {
                b[j] = J;
                const { src: ne, unicodeRange: W } = d[J];
                if (!W || R(X, W)) {
                  const $ = t[ne];
                  if (!$) {
                    s(ne, () => {
                      N(j);
                    });
                    return;
                  }
                  if ($.supportsCodePoint(X)) {
                    let de = w.get($);
                    (typeof de != "number" &&
                      ((de = _.length), _.push($), w.set($, de)),
                      (b[j] = de),
                      (B = 1));
                    break;
                  }
                }
              }
          X > 65535 &&
            j + 1 < q &&
            ((b[j + 1] = b[j]), j++, B === 2 && (E[E.length - 1][1] = j));
        }
        T();
      })();
    } else (E.push([0, o.length - 1]), T());
    function T() {
      if (E.length) {
        const L = E.map((I) => o.substring(I[0], I[1] + 1)).join(`
`);
        e.getFontsForString(L, {
          lang: h || void 0,
          style: m,
          weight: v,
          dataUrl: y,
        }).then(({ fontUrls: I, chars: O }) => {
          const B = _.length;
          let N = 0;
          E.forEach((j) => {
            for (let q = 0, X = j[1] - j[0]; q <= X; q++)
              b[j[0] + q] = O[N++] + B;
            N++;
          });
          let F = 0;
          I.forEach((j, q) => {
            s(j, (X) => {
              ((_[q + B] = X), ++F === I.length && C());
            });
          });
        });
      } else C();
    }
    function C() {
      u({ chars: b, fonts: _ });
    }
    function R(L, I) {
      for (let O = 0; O < I.length; O++) {
        const [B, N = B] = I[O];
        if (B <= L && L <= N) return !0;
      }
      return !1;
    }
  };
}
const mW = jp({
  name: "FontResolver",
  dependencies: [pW, hW, dW],
  init(i, e, t) {
    return i(e, t());
  },
});
function gW(i, e) {
  const n =
      /[\u00AD\u034F\u061C\u115F-\u1160\u17B4-\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8]/,
    r = "[^\\S\\u00A0]",
    s = new RegExp(
      `${r}|[\\-\\u007C\\u00AD\\u2010\\u2012-\\u2014\\u2027\\u2056\\u2E17\\u2E40]`,
    );
  function o(
    {
      text: _,
      lang: w,
      fonts: E,
      style: T,
      weight: C,
      preResolvedFonts: R,
      unicodeFontsURL: L,
    },
    I,
  ) {
    const O = ({ chars: B, fonts: N }) => {
      let F, j;
      const q = [];
      for (let X = 0; X < B.length; X++)
        B[X] !== j
          ? ((j = B[X]), q.push((F = { start: X, end: X, fontObj: N[B[X]] })))
          : (F.end = X);
      I(q);
    };
    R
      ? O(R)
      : i(_, O, { lang: w, fonts: E, style: T, weight: C, unicodeFontsURL: L });
  }
  function u(
    {
      text: _ = "",
      font: w,
      lang: E,
      sdfGlyphSize: T = 64,
      fontSize: C = 400,
      fontWeight: R = 1,
      fontStyle: L = "normal",
      letterSpacing: I = 0,
      lineHeight: O = "normal",
      maxWidth: B = 1 / 0,
      direction: N,
      textAlign: F = "left",
      textIndent: j = 0,
      whiteSpace: q = "normal",
      overflowWrap: X = "normal",
      anchorX: J = 0,
      anchorY: ee = 0,
      metricsOnly: ne = !1,
      unicodeFontsURL: W,
      preResolvedFonts: $ = null,
      includeCaretPositions: de = !1,
      chunkedBoundsSize: le = 8192,
      colorRanges: fe = null,
    },
    V,
  ) {
    const Z = v(),
      se = { fontLoad: 0, typesetting: 0 };
    (_.indexOf("\r") > -1 &&
      (console.info("Typesetter: got text with \\r chars; normalizing to \\n"),
      (_ = _.replace(
        /\r\n/g,
        `
`,
      ).replace(
        /\r/g,
        `
`,
      ))),
      (C = +C),
      (I = +I),
      (B = +B),
      (O = O || "normal"),
      (j = +j),
      o(
        {
          text: _,
          lang: E,
          style: L,
          weight: R,
          fonts: typeof w == "string" ? [{ src: w }] : w,
          unicodeFontsURL: W,
          preResolvedFonts: $,
        },
        (ue) => {
          se.fontLoad = v() - Z;
          const ge = isFinite(B);
          let ae = null,
            he = null,
            ye = null,
            ze = null,
            it = null,
            qe = null,
            Ye = null,
            ft = null,
            Re = 0,
            Ie = 0,
            De = q !== "nowrap";
          const Qe = new Map(),
            K = v();
          let rt = j,
            je = 0,
            Te = new y();
          const ke = [Te];
          ue.forEach((_e) => {
            const { fontObj: be } = _e,
              {
                ascender: et,
                descender: $e,
                unitsPerEm: ht,
                lineGap: yt,
                capHeight: Ge,
                xHeight: Ve,
              } = be;
            let Ze = Qe.get(be);
            if (!Ze) {
              const Oe = C / ht,
                Ke = O === "normal" ? (et - $e + yt) * Oe : O * C,
                dt = (Ke - (et - $e) * Oe) / 2,
                Je = Math.min(Ke, (et - $e) * Oe),
                Ee = ((et + $e) / 2) * Oe + Je / 2;
              ((Ze = {
                index: Qe.size,
                src: be.src,
                fontObj: be,
                fontSizeMult: Oe,
                unitsPerEm: ht,
                ascender: et * Oe,
                descender: $e * Oe,
                capHeight: Ge * Oe,
                xHeight: Ve * Oe,
                lineHeight: Ke,
                baseline: -dt - et * Oe,
                caretTop: Ee,
                caretBottom: Ee - Je,
              }),
                Qe.set(be, Ze));
            }
            const { fontSizeMult: re } = Ze,
              Se = _.slice(_e.start, _e.end + 1);
            let lt, ce;
            (be.forEachGlyph(Se, C, I, (Oe, Ke, dt, Je) => {
              ((Ke += je), (Je += _e.start), (lt = Ke), (ce = Oe));
              const Ee = _.charAt(Je),
                ct = Oe.advanceWidth * re,
                Mt = Te.count;
              let St;
              if (
                ("isEmpty" in Oe ||
                  ((Oe.isWhitespace = !!Ee && new RegExp(r).test(Ee)),
                  (Oe.canBreakAfter = !!Ee && s.test(Ee)),
                  (Oe.isEmpty =
                    Oe.xMin === Oe.xMax || Oe.yMin === Oe.yMax || n.test(Ee))),
                !Oe.isWhitespace && !Oe.isEmpty && Ie++,
                De && ge && !Oe.isWhitespace && Ke + ct + rt > B && Mt)
              ) {
                if (Te.glyphAt(Mt - 1).glyphObj.canBreakAfter)
                  ((St = new y()), (rt = -Ke));
                else
                  for (let hn = Mt; hn--; )
                    if (hn === 0 && X === "break-word") {
                      ((St = new y()), (rt = -Ke));
                      break;
                    } else if (Te.glyphAt(hn).glyphObj.canBreakAfter) {
                      St = Te.splitAt(hn + 1);
                      const bn = St.glyphAt(0).x;
                      rt -= bn;
                      for (let Bn = St.count; Bn--; ) St.glyphAt(Bn).x -= bn;
                      break;
                    }
                St &&
                  ((Te.isSoftWrapped = !0), (Te = St), ke.push(Te), (Re = B));
              }
              let Dt = Te.glyphAt(Te.count);
              ((Dt.glyphObj = Oe),
                (Dt.x = Ke + rt),
                (Dt.y = dt),
                (Dt.width = ct),
                (Dt.charIndex = Je),
                (Dt.fontData = Ze),
                Ee ===
                  `
` && ((Te = new y()), ke.push(Te), (rt = -(Ke + ct + I * C) + j)));
            }),
              (je = lt + ce.advanceWidth * re + I * C));
          });
          let H = 0;
          ke.forEach((_e) => {
            let be = !0;
            for (let et = _e.count; et--; ) {
              const $e = _e.glyphAt(et);
              be &&
                !$e.glyphObj.isWhitespace &&
                ((_e.width = $e.x + $e.width),
                _e.width > Re && (Re = _e.width),
                (be = !1));
              let {
                lineHeight: ht,
                capHeight: yt,
                xHeight: Ge,
                baseline: Ve,
              } = $e.fontData;
              ht > _e.lineHeight && (_e.lineHeight = ht);
              const Ze = Ve - _e.baseline;
              (Ze < 0 && ((_e.baseline += Ze), (_e.cap += Ze), (_e.ex += Ze)),
                (_e.cap = Math.max(_e.cap, _e.baseline + yt)),
                (_e.ex = Math.max(_e.ex, _e.baseline + Ge)));
            }
            ((_e.baseline -= H),
              (_e.cap -= H),
              (_e.ex -= H),
              (H += _e.lineHeight));
          });
          let k = 0,
            oe = 0;
          if (
            (J &&
              (typeof J == "number"
                ? (k = -J)
                : typeof J == "string" &&
                  (k =
                    -Re *
                    (J === "left"
                      ? 0
                      : J === "center"
                        ? 0.5
                        : J === "right"
                          ? 1
                          : d(J)))),
            ee &&
              (typeof ee == "number"
                ? (oe = -ee)
                : typeof ee == "string" &&
                  (oe =
                    ee === "top"
                      ? 0
                      : ee === "top-baseline"
                        ? -ke[0].baseline
                        : ee === "top-cap"
                          ? -ke[0].cap
                          : ee === "top-ex"
                            ? -ke[0].ex
                            : ee === "middle"
                              ? H / 2
                              : ee === "bottom"
                                ? H
                                : ee === "bottom-baseline"
                                  ? -ke[ke.length - 1].baseline
                                  : d(ee) * H)),
            !ne)
          ) {
            const _e = e.getEmbeddingLevels(_, N);
            ((ae = new Uint16Array(Ie)),
              (he = new Uint8Array(Ie)),
              (ye = new Float32Array(Ie * 2)),
              (ze = {}),
              (Ye = [1 / 0, 1 / 0, -1 / 0, -1 / 0]),
              (ft = []),
              de && (qe = new Float32Array(_.length * 4)),
              fe && (it = new Uint8Array(Ie * 3)));
            let be = 0,
              et = -1,
              $e = -1,
              ht,
              yt;
            if (
              (ke.forEach((Ge, Ve) => {
                let { count: Ze, width: re } = Ge;
                if (Ze > 0) {
                  let Se = 0;
                  for (
                    let Je = Ze;
                    Je-- && Ge.glyphAt(Je).glyphObj.isWhitespace;
                  )
                    Se++;
                  let lt = 0,
                    ce = 0;
                  if (F === "center") lt = (Re - re) / 2;
                  else if (F === "right") lt = Re - re;
                  else if (F === "justify" && Ge.isSoftWrapped) {
                    let Je = 0;
                    for (let Ee = Ze - Se; Ee--; )
                      Ge.glyphAt(Ee).glyphObj.isWhitespace && Je++;
                    ce = (Re - re) / Je;
                  }
                  if (ce || lt) {
                    let Je = 0;
                    for (let Ee = 0; Ee < Ze; Ee++) {
                      let ct = Ge.glyphAt(Ee);
                      const Mt = ct.glyphObj;
                      ((ct.x += lt + Je),
                        ce !== 0 &&
                          Mt.isWhitespace &&
                          Ee < Ze - Se &&
                          ((Je += ce), (ct.width += ce)));
                    }
                  }
                  const Oe = e.getReorderSegments(
                    _,
                    _e,
                    Ge.glyphAt(0).charIndex,
                    Ge.glyphAt(Ge.count - 1).charIndex,
                  );
                  for (let Je = 0; Je < Oe.length; Je++) {
                    const [Ee, ct] = Oe[Je];
                    let Mt = 1 / 0,
                      St = -1 / 0;
                    for (let Dt = 0; Dt < Ze; Dt++)
                      if (Ge.glyphAt(Dt).charIndex >= Ee) {
                        let hn = Dt,
                          bn = Dt;
                        for (; bn < Ze; bn++) {
                          let Bn = Ge.glyphAt(bn);
                          if (Bn.charIndex > ct) break;
                          bn < Ze - Se &&
                            ((Mt = Math.min(Mt, Bn.x)),
                            (St = Math.max(St, Bn.x + Bn.width)));
                        }
                        for (let Bn = hn; Bn < bn; Bn++) {
                          const Ai = Ge.glyphAt(Bn);
                          Ai.x = St - (Ai.x + Ai.width - Mt);
                        }
                        break;
                      }
                  }
                  let Ke;
                  const dt = (Je) => (Ke = Je);
                  for (let Je = 0; Je < Ze; Je++) {
                    const Ee = Ge.glyphAt(Je);
                    Ke = Ee.glyphObj;
                    const ct = Ke.index,
                      Mt = _e.levels[Ee.charIndex] & 1;
                    if (Mt) {
                      const St = e.getMirroredCharacter(_[Ee.charIndex]);
                      St && Ee.fontData.fontObj.forEachGlyph(St, 0, 0, dt);
                    }
                    if (de) {
                      const { charIndex: St, fontData: Dt } = Ee,
                        hn = Ee.x + k,
                        bn = Ee.x + Ee.width + k;
                      ((qe[St * 4] = Mt ? bn : hn),
                        (qe[St * 4 + 1] = Mt ? hn : bn),
                        (qe[St * 4 + 2] = Ge.baseline + Dt.caretBottom + oe),
                        (qe[St * 4 + 3] = Ge.baseline + Dt.caretTop + oe));
                      const Bn = St - et;
                      (Bn > 1 && m(qe, et, Bn), (et = St));
                    }
                    if (fe) {
                      const { charIndex: St } = Ee;
                      for (; St > $e; )
                        ($e++, fe.hasOwnProperty($e) && (yt = fe[$e]));
                    }
                    if (!Ke.isWhitespace && !Ke.isEmpty) {
                      const St = be++,
                        { fontSizeMult: Dt, src: hn, index: bn } = Ee.fontData,
                        Bn = ze[hn] || (ze[hn] = {});
                      Bn[ct] ||
                        (Bn[ct] = {
                          path: Ke.path,
                          pathBounds: [Ke.xMin, Ke.yMin, Ke.xMax, Ke.yMax],
                        });
                      const Ai = Ee.x + k,
                        $r = Ee.y + Ge.baseline + oe;
                      ((ye[St * 2] = Ai), (ye[St * 2 + 1] = $r));
                      const Zi = Ai + Ke.xMin * Dt,
                        ar = $r + Ke.yMin * Dt,
                        zi = Ai + Ke.xMax * Dt,
                        xi = $r + Ke.yMax * Dt;
                      (Zi < Ye[0] && (Ye[0] = Zi),
                        ar < Ye[1] && (Ye[1] = ar),
                        zi > Ye[2] && (Ye[2] = zi),
                        xi > Ye[3] && (Ye[3] = xi),
                        St % le === 0 &&
                          ((ht = {
                            start: St,
                            end: St,
                            rect: [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                          }),
                          ft.push(ht)),
                        ht.end++);
                      const Hn = ht.rect;
                      if (
                        (Zi < Hn[0] && (Hn[0] = Zi),
                        ar < Hn[1] && (Hn[1] = ar),
                        zi > Hn[2] && (Hn[2] = zi),
                        xi > Hn[3] && (Hn[3] = xi),
                        (ae[St] = ct),
                        (he[St] = bn),
                        fe)
                      ) {
                        const Un = St * 3;
                        ((it[Un] = (yt >> 16) & 255),
                          (it[Un + 1] = (yt >> 8) & 255),
                          (it[Un + 2] = yt & 255));
                      }
                    }
                  }
                }
              }),
              qe)
            ) {
              const Ge = _.length - et;
              Ge > 1 && m(qe, et, Ge);
            }
          }
          const Ae = [];
          (Qe.forEach(
            ({
              index: _e,
              src: be,
              unitsPerEm: et,
              ascender: $e,
              descender: ht,
              lineHeight: yt,
              capHeight: Ge,
              xHeight: Ve,
            }) => {
              Ae[_e] = {
                src: be,
                unitsPerEm: et,
                ascender: $e,
                descender: ht,
                lineHeight: yt,
                capHeight: Ge,
                xHeight: Ve,
              };
            },
          ),
            (se.typesetting = v() - K),
            V({
              glyphIds: ae,
              glyphFontIndices: he,
              glyphPositions: ye,
              glyphData: ze,
              fontData: Ae,
              caretPositions: qe,
              glyphColors: it,
              chunkedBounds: ft,
              fontSize: C,
              topBaseline: oe + ke[0].baseline,
              blockBounds: [k, oe - H, k + Re, oe],
              visibleBounds: Ye,
              timings: se,
            }));
        },
      ));
  }
  function h(_, w) {
    u({ ..._, metricsOnly: !0 }, (E) => {
      const [T, C, R, L] = E.blockBounds;
      w({ width: R - T, height: L - C });
    });
  }
  function d(_) {
    let w = _.match(/^([\d.]+)%$/),
      E = w ? parseFloat(w[1]) : NaN;
    return isNaN(E) ? 0 : E / 100;
  }
  function m(_, w, E) {
    const T = _[w * 4],
      C = _[w * 4 + 1],
      R = _[w * 4 + 2],
      L = _[w * 4 + 3],
      I = (C - T) / E;
    for (let O = 0; O < E; O++) {
      const B = (w + O) * 4;
      ((_[B] = T + I * O),
        (_[B + 1] = T + I * (O + 1)),
        (_[B + 2] = R),
        (_[B + 3] = L));
    }
  }
  function v() {
    return (self.performance || Date).now();
  }
  function y() {
    this.data = [];
  }
  const b = ["glyphObj", "x", "y", "width", "charIndex", "fontData"];
  return (
    (y.prototype = {
      width: 0,
      lineHeight: 0,
      baseline: 0,
      cap: 0,
      ex: 0,
      isSoftWrapped: !1,
      get count() {
        return Math.ceil(this.data.length / b.length);
      },
      glyphAt(_) {
        let w = y.flyweight;
        return ((w.data = this.data), (w.index = _), w);
      },
      splitAt(_) {
        let w = new y();
        return ((w.data = this.data.splice(_ * b.length)), w);
      },
    }),
    (y.flyweight = b.reduce(
      (_, w, E, T) => (
        Object.defineProperty(_, w, {
          get() {
            return this.data[this.index * b.length + E];
          },
          set(C) {
            this.data[this.index * b.length + E] = C;
          },
        }),
        _
      ),
      { data: null, index: 0 },
    )),
    { typeset: u, measure: h }
  );
}
const Rh = () => (self.performance || Date).now(),
  Ib = DU();
let q3;
function vW(i, e, t, n, r, s, o, u, h, d, m = !0) {
  return m
    ? xW(i, e, t, n, r, s, o, u, h, d).then(
        null,
        (v) => (
          q3 ||
            (console.warn("WebGL SDF generation failed, falling back to JS", v),
            (q3 = !0)),
          Z3(i, e, t, n, r, s, o, u, h, d)
        ),
      )
    : Z3(i, e, t, n, r, s, o, u, h, d);
}
const Ux = [],
  yW = 5;
let XM = 0;
function NU() {
  const i = Rh();
  for (; Ux.length && Rh() - i < yW; ) Ux.shift()();
  XM = Ux.length ? setTimeout(NU, 0) : 0;
}
const xW = (...i) =>
    new Promise((e, t) => {
      (Ux.push(() => {
        const n = Rh();
        try {
          (Ib.webgl.generateIntoCanvas(...i), e({ timing: Rh() - n }));
        } catch (r) {
          t(r);
        }
      }),
        XM || (XM = setTimeout(NU, 0)));
    }),
  bW = 4,
  _W = 2e3,
  Y3 = {};
let SW = 0;
function Z3(i, e, t, n, r, s, o, u, h, d) {
  const m = "TroikaTextSDFGenerator_JS_" + (SW++ % bW);
  let v = Y3[m];
  return (
    v ||
      (v = Y3[m] =
        {
          workerModule: jp({
            name: m,
            workerId: m,
            dependencies: [DU, Rh],
            init(y, b) {
              const _ = y().javascript.generate;
              return function (...w) {
                const E = b();
                return { textureData: _(...w), timing: b() - E };
              };
            },
            getTransferables(y) {
              return [y.textureData.buffer];
            },
          }),
          requests: 0,
          idleTimer: null,
        }),
    v.requests++,
    clearTimeout(v.idleTimer),
    v.workerModule(i, e, t, n, r, s).then(({ textureData: y, timing: b }) => {
      const _ = Rh(),
        w = new Uint8Array(y.length * 4);
      for (let E = 0; E < y.length; E++) w[E * 4 + d] = y[E];
      return (
        Ib.webglUtils.renderImageData(o, w, u, h, i, e, 1 << (3 - d)),
        (b += Rh() - _),
        --v.requests === 0 &&
          (v.idleTimer = setTimeout(() => {
            $7(m);
          }, _W)),
        { timing: b }
      );
    })
  );
}
function MW(i) {
  i._warm || (Ib.webgl.isSupported(i), (i._warm = !0));
}
const TW = Ib.webglUtils.resizeWebGLCanvasWithoutClearing,
  Ng = {
    unicodeFontsURL: null,
    sdfGlyphSize: 64,
    sdfMargin: 1 / 16,
    sdfExponent: 9,
    textureWidth: 2048,
  },
  EW = new wt();
function up() {
  return (self.performance || Date).now();
}
const K3 = Object.create(null);
function UU(i, e) {
  i = CW({}, i);
  const t = up(),
    n = [];
  if (
    (i.font && n.push({ label: "user", src: RW(i.font) }),
    (i.font = n),
    (i.text = "" + i.text),
    (i.sdfGlyphSize = i.sdfGlyphSize || Ng.sdfGlyphSize),
    (i.unicodeFontsURL = i.unicodeFontsURL || Ng.unicodeFontsURL),
    i.colorRanges != null)
  ) {
    let y = {};
    for (let b in i.colorRanges)
      if (i.colorRanges.hasOwnProperty(b)) {
        let _ = i.colorRanges[b];
        (typeof _ != "number" && (_ = EW.set(_).getHex()), (y[b] = _));
      }
    i.colorRanges = y;
  }
  Object.freeze(i);
  const { textureWidth: r, sdfExponent: s } = Ng,
    { sdfGlyphSize: o } = i,
    u = (r / o) * 4;
  let h = K3[o];
  if (!h) {
    const y = document.createElement("canvas");
    ((y.width = r),
      (y.height = (o * 256) / u),
      (h = K3[o] =
        {
          glyphCount: 0,
          sdfGlyphSize: o,
          sdfCanvas: y,
          sdfTexture: new Fi(y, void 0, void 0, void 0, ni, ni),
          contextLost: !1,
          glyphsByFont: new Map(),
        }),
      (h.sdfTexture.generateMipmaps = !1),
      wW(h));
  }
  const { sdfTexture: d, sdfCanvas: m } = h;
  (OU(i).then((y) => {
    const {
        glyphIds: b,
        glyphFontIndices: _,
        fontData: w,
        glyphPositions: E,
        fontSize: T,
        timings: C,
      } = y,
      R = [],
      L = new Float32Array(b.length * 4);
    let I = 0,
      O = 0;
    const B = up(),
      N = w.map((J) => {
        let ee = h.glyphsByFont.get(J.src);
        return (ee || h.glyphsByFont.set(J.src, (ee = new Map())), ee);
      });
    (b.forEach((J, ee) => {
      const ne = _[ee],
        { src: W, unitsPerEm: $ } = w[ne];
      let de = N[ne].get(J);
      if (!de) {
        const { path: se, pathBounds: ue } = y.glyphData[W][J],
          ge =
            (Math.max(ue[2] - ue[0], ue[3] - ue[1]) / o) *
            (Ng.sdfMargin * o + 0.5),
          ae = h.glyphCount++,
          he = [ue[0] - ge, ue[1] - ge, ue[2] + ge, ue[3] + ge];
        (N[ne].set(J, (de = { path: se, atlasIndex: ae, sdfViewBox: he })),
          R.push(de));
      }
      const { sdfViewBox: le } = de,
        fe = E[O++],
        V = E[O++],
        Z = T / $;
      ((L[I++] = fe + le[0] * Z),
        (L[I++] = V + le[1] * Z),
        (L[I++] = fe + le[2] * Z),
        (L[I++] = V + le[3] * Z),
        (b[ee] = de.atlasIndex));
    }),
      (C.quads = (C.quads || 0) + (up() - B)));
    const F = up();
    C.sdf = {};
    const j = m.height,
      q = Math.ceil(h.glyphCount / u),
      X = Math.pow(2, Math.ceil(Math.log2(q * o)));
    (X > j &&
      (console.info(`Increasing SDF texture size ${j}->${X}`),
      TW(m, r, X),
      d.dispose()),
      Promise.all(
        R.map((J) =>
          PU(J, h, i.gpuAccelerateSDF).then(({ timing: ee }) => {
            C.sdf[J.atlasIndex] = ee;
          }),
        ),
      ).then(() => {
        (R.length && !h.contextLost && (IU(h), (d.needsUpdate = !0)),
          (C.sdfTotal = up() - F),
          (C.total = up() - t),
          e(
            Object.freeze({
              parameters: i,
              sdfTexture: d,
              sdfGlyphSize: o,
              sdfExponent: s,
              glyphBounds: L,
              glyphAtlasIndices: b,
              glyphColors: y.glyphColors,
              caretPositions: y.caretPositions,
              chunkedBounds: y.chunkedBounds,
              ascender: y.ascender,
              descender: y.descender,
              lineHeight: y.lineHeight,
              capHeight: y.capHeight,
              xHeight: y.xHeight,
              topBaseline: y.topBaseline,
              blockBounds: y.blockBounds,
              visibleBounds: y.visibleBounds,
              timings: y.timings,
            }),
          ));
      }));
  }),
    Promise.resolve().then(() => {
      h.contextLost || MW(m);
    }));
}
function PU(
  { path: i, atlasIndex: e, sdfViewBox: t },
  { sdfGlyphSize: n, sdfCanvas: r, contextLost: s },
  o,
) {
  if (s) return Promise.resolve({ timing: -1 });
  const { textureWidth: u, sdfExponent: h } = Ng,
    d = Math.max(t[2] - t[0], t[3] - t[1]),
    m = Math.floor(e / 4),
    v = (m % (u / n)) * n,
    y = Math.floor(m / (u / n)) * n,
    b = e % 4;
  return vW(n, n, i, t, d, h, r, v, y, b, o);
}
function wW(i) {
  const e = i.sdfCanvas;
  (e.addEventListener("webglcontextlost", (t) => {
    (console.log("Context Lost", t), t.preventDefault(), (i.contextLost = !0));
  }),
    e.addEventListener("webglcontextrestored", (t) => {
      (console.log("Context Restored", t), (i.contextLost = !1));
      const n = [];
      (i.glyphsByFont.forEach((r) => {
        r.forEach((s) => {
          n.push(PU(s, i, !0));
        });
      }),
        Promise.all(n).then(() => {
          (IU(i), (i.sdfTexture.needsUpdate = !0));
        }));
    }));
}
function AW({ font: i, characters: e, sdfGlyphSize: t }, n) {
  let r = Array.isArray(e)
    ? e.join(`
`)
    : "" + e;
  UU({ font: i, sdfGlyphSize: t, text: r }, n);
}
function CW(i, e) {
  for (let t in e) e.hasOwnProperty(t) && (i[t] = e[t]);
  return i;
}
let yx;
function RW(i) {
  return (
    yx || (yx = typeof document > "u" ? {} : document.createElement("a")),
    (yx.href = i),
    yx.href
  );
}
function IU(i) {
  if (typeof createImageBitmap != "function") {
    console.info("Safari<15: applying SDF canvas workaround");
    const { sdfCanvas: e, sdfTexture: t } = i,
      { width: n, height: r } = e,
      s = i.sdfCanvas.getContext("webgl");
    let o = t.image.data;
    ((!o || o.length !== n * r * 4) &&
      ((o = new Uint8Array(n * r * 4)),
      (t.image = { width: n, height: r, data: o }),
      (t.flipY = !1),
      (t.isDataTexture = !0)),
      s.readPixels(0, 0, n, r, s.RGBA, s.UNSIGNED_BYTE, o));
  }
}
const DW = jp({
    name: "Typesetter",
    dependencies: [gW, mW, tW],
    init(i, e, t) {
      return i(e, t());
    },
  }),
  OU = jp({
    name: "Typesetter",
    dependencies: [DW],
    init(i) {
      return function (e) {
        return new Promise((t) => {
          i.typeset(e, t);
        });
      };
    },
    getTransferables(i) {
      const e = [];
      for (let t in i) i[t] && i[t].buffer && e.push(i[t].buffer);
      return e;
    },
  });
OU.onMainThread;
const Q3 = {};
function LW(i) {
  let e = Q3[i];
  return (e || (e = Q3[i] = new $c(1, 1, i, i).translate(0.5, 0.5, 0)), e);
}
const NW = "aTroikaGlyphBounds",
  J3 = "aTroikaGlyphIndex",
  UW = "aTroikaGlyphColor";
class PW extends Lb {
  constructor() {
    (super(),
      (this.detail = 1),
      (this.curveRadius = 0),
      (this.groups = [
        { start: 0, count: 1 / 0, materialIndex: 0 },
        { start: 0, count: 1 / 0, materialIndex: 1 },
      ]),
      (this.boundingSphere = new mr()),
      (this.boundingBox = new sr()));
  }
  computeBoundingSphere() {}
  computeBoundingBox() {}
  set detail(e) {
    if (e !== this._detail) {
      ((this._detail = e), (typeof e != "number" || e < 1) && (e = 1));
      let t = LW(e);
      (["position", "normal", "uv"].forEach((n) => {
        this.attributes[n] = t.attributes[n].clone();
      }),
        this.setIndex(t.getIndex().clone()));
    }
  }
  get detail() {
    return this._detail;
  }
  set curveRadius(e) {
    e !== this._curveRadius && ((this._curveRadius = e), this._updateBounds());
  }
  get curveRadius() {
    return this._curveRadius;
  }
  updateGlyphs(e, t, n, r, s) {
    (this.updateAttributeData(NW, e, 4),
      this.updateAttributeData(J3, t, 1),
      this.updateAttributeData(UW, s, 3),
      (this._blockBounds = n),
      (this._chunkedBounds = r),
      (this.instanceCount = t.length),
      this._updateBounds());
  }
  _updateBounds() {
    const e = this._blockBounds;
    if (e) {
      const { curveRadius: t, boundingBox: n } = this;
      if (t) {
        const { PI: r, floor: s, min: o, max: u, sin: h, cos: d } = Math,
          m = r / 2,
          v = r * 2,
          y = Math.abs(t),
          b = e[0] / y,
          _ = e[2] / y,
          w = s((b + m) / v) !== s((_ + m) / v) ? -y : o(h(b) * y, h(_) * y),
          E = s((b - m) / v) !== s((_ - m) / v) ? y : u(h(b) * y, h(_) * y),
          T =
            s((b + r) / v) !== s((_ + r) / v)
              ? y * 2
              : u(y - d(b) * y, y - d(_) * y);
        (n.min.set(w, e[1], t < 0 ? -T : 0), n.max.set(E, e[3], t < 0 ? 0 : T));
      } else (n.min.set(e[0], e[1], 0), n.max.set(e[2], e[3], 0));
      n.getBoundingSphere(this.boundingSphere);
    }
  }
  applyClipRect(e) {
    let t = this.getAttribute(J3).count,
      n = this._chunkedBounds;
    if (n)
      for (let r = n.length; r--; ) {
        t = n[r].end;
        let s = n[r].rect;
        if (s[1] < e.w && s[3] > e.y && s[0] < e.z && s[2] > e.x) break;
      }
    this.instanceCount = t;
  }
  updateAttributeData(e, t, n) {
    const r = this.getAttribute(e);
    t
      ? r && r.array.length === t.length
        ? (r.array.set(t), (r.needsUpdate = !0))
        : (this.setAttribute(e, new Uh(t, n)),
          delete this._maxInstanceCount,
          this.dispose())
      : r && this.deleteAttribute(e);
  }
}
const IW = `
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform vec4 uTroikaTotalBounds;
uniform vec4 uTroikaClipRect;
uniform mat3 uTroikaOrient;
uniform bool uTroikaUseGlyphColors;
uniform float uTroikaEdgeOffset;
uniform float uTroikaBlurRadius;
uniform vec2 uTroikaPositionOffset;
uniform float uTroikaCurveRadius;
attribute vec4 aTroikaGlyphBounds;
attribute float aTroikaGlyphIndex;
attribute vec3 aTroikaGlyphColor;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec3 vTroikaGlyphColor;
varying vec2 vTroikaGlyphDimensions;
`,
  OW = `
vec4 bounds = aTroikaGlyphBounds;
bounds.xz += uTroikaPositionOffset.x;
bounds.yw -= uTroikaPositionOffset.y;

vec4 outlineBounds = vec4(
  bounds.xy - uTroikaEdgeOffset - uTroikaBlurRadius,
  bounds.zw + uTroikaEdgeOffset + uTroikaBlurRadius
);
vec4 clippedBounds = vec4(
  clamp(outlineBounds.xy, uTroikaClipRect.xy, uTroikaClipRect.zw),
  clamp(outlineBounds.zw, uTroikaClipRect.xy, uTroikaClipRect.zw)
);

vec2 clippedXY = (mix(clippedBounds.xy, clippedBounds.zw, position.xy) - bounds.xy) / (bounds.zw - bounds.xy);

position.xy = mix(bounds.xy, bounds.zw, clippedXY);

uv = (position.xy - uTroikaTotalBounds.xy) / (uTroikaTotalBounds.zw - uTroikaTotalBounds.xy);

float rad = uTroikaCurveRadius;
if (rad != 0.0) {
  float angle = position.x / rad;
  position.xz = vec2(sin(angle) * rad, rad - cos(angle) * rad);
  normal.xz = vec2(sin(angle), cos(angle));
}
  
position = uTroikaOrient * position;
normal = uTroikaOrient * normal;

vTroikaGlyphUV = clippedXY.xy;
vTroikaGlyphDimensions = vec2(bounds[2] - bounds[0], bounds[3] - bounds[1]);


float txCols = uTroikaSDFTextureSize.x / uTroikaSDFGlyphSize;
vec2 txUvPerSquare = uTroikaSDFGlyphSize / uTroikaSDFTextureSize;
vec2 txStartUV = txUvPerSquare * vec2(
  mod(floor(aTroikaGlyphIndex / 4.0), txCols),
  floor(floor(aTroikaGlyphIndex / 4.0) / txCols)
);
vTroikaTextureUVBounds = vec4(txStartUV, vec2(txStartUV) + txUvPerSquare);
vTroikaTextureChannel = mod(aTroikaGlyphIndex, 4.0);
`,
  FW = `
uniform sampler2D uTroikaSDFTexture;
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform float uTroikaSDFExponent;
uniform float uTroikaEdgeOffset;
uniform float uTroikaFillOpacity;
uniform float uTroikaBlurRadius;
uniform vec3 uTroikaStrokeColor;
uniform float uTroikaStrokeWidth;
uniform float uTroikaStrokeOpacity;
uniform bool uTroikaSDFDebug;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec2 vTroikaGlyphDimensions;

float troikaSdfValueToSignedDistance(float alpha) {
  // Inverse of exponential encoding in webgl-sdf-generator
  
  float maxDimension = max(vTroikaGlyphDimensions.x, vTroikaGlyphDimensions.y);
  float absDist = (1.0 - pow(2.0 * (alpha > 0.5 ? 1.0 - alpha : alpha), 1.0 / uTroikaSDFExponent)) * maxDimension;
  float signedDist = absDist * (alpha > 0.5 ? -1.0 : 1.0);
  return signedDist;
}

float troikaGlyphUvToSdfValue(vec2 glyphUV) {
  vec2 textureUV = mix(vTroikaTextureUVBounds.xy, vTroikaTextureUVBounds.zw, glyphUV);
  vec4 rgba = texture2D(uTroikaSDFTexture, textureUV);
  float ch = floor(vTroikaTextureChannel + 0.5); //NOTE: can't use round() in WebGL1
  return ch == 0.0 ? rgba.r : ch == 1.0 ? rgba.g : ch == 2.0 ? rgba.b : rgba.a;
}

float troikaGlyphUvToDistance(vec2 uv) {
  return troikaSdfValueToSignedDistance(troikaGlyphUvToSdfValue(uv));
}

float troikaGetAADist() {
  
  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300
  return length(fwidth(vTroikaGlyphUV * vTroikaGlyphDimensions)) * 0.5;
  #else
  return vTroikaGlyphDimensions.x / 64.0;
  #endif
}

float troikaGetFragDistValue() {
  vec2 clampedGlyphUV = clamp(vTroikaGlyphUV, 0.5 / uTroikaSDFGlyphSize, 1.0 - 0.5 / uTroikaSDFGlyphSize);
  float distance = troikaGlyphUvToDistance(clampedGlyphUV);
 
  // Extrapolate distance when outside bounds:
  distance += clampedGlyphUV == vTroikaGlyphUV ? 0.0 : 
    length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);

  

  return distance;
}

float troikaGetEdgeAlpha(float distance, float distanceOffset, float aaDist) {
  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)
  float alpha = step(-distanceOffset, -distance);
  #else

  float alpha = smoothstep(
    distanceOffset + aaDist,
    distanceOffset - aaDist,
    distance
  );
  #endif

  return alpha;
}
`,
  zW = `
float aaDist = troikaGetAADist();
float fragDistance = troikaGetFragDistValue();
float edgeAlpha = uTroikaSDFDebug ?
  troikaGlyphUvToSdfValue(vTroikaGlyphUV) :
  troikaGetEdgeAlpha(fragDistance, uTroikaEdgeOffset, max(aaDist, uTroikaBlurRadius));

#if !defined(IS_DEPTH_MATERIAL) && !defined(IS_DISTANCE_MATERIAL)
vec4 fillRGBA = gl_FragColor;
fillRGBA.a *= uTroikaFillOpacity;
vec4 strokeRGBA = uTroikaStrokeWidth == 0.0 ? fillRGBA : vec4(uTroikaStrokeColor, uTroikaStrokeOpacity);
if (fillRGBA.a == 0.0) fillRGBA.rgb = strokeRGBA.rgb;
gl_FragColor = mix(fillRGBA, strokeRGBA, smoothstep(
  -uTroikaStrokeWidth - aaDist,
  -uTroikaStrokeWidth + aaDist,
  fragDistance
));
gl_FragColor.a *= edgeAlpha;
#endif

if (edgeAlpha == 0.0) {
  discard;
}
`;
function BW(i) {
  const e = WM(i, {
    chained: !0,
    extensions: { derivatives: !0 },
    uniforms: {
      uTroikaSDFTexture: { value: null },
      uTroikaSDFTextureSize: { value: new nt() },
      uTroikaSDFGlyphSize: { value: 0 },
      uTroikaSDFExponent: { value: 0 },
      uTroikaTotalBounds: { value: new Dn(0, 0, 0, 0) },
      uTroikaClipRect: { value: new Dn(0, 0, 0, 0) },
      uTroikaEdgeOffset: { value: 0 },
      uTroikaFillOpacity: { value: 1 },
      uTroikaPositionOffset: { value: new nt() },
      uTroikaCurveRadius: { value: 0 },
      uTroikaBlurRadius: { value: 0 },
      uTroikaStrokeWidth: { value: 0 },
      uTroikaStrokeColor: { value: new wt() },
      uTroikaStrokeOpacity: { value: 1 },
      uTroikaOrient: { value: new tn() },
      uTroikaUseGlyphColors: { value: !0 },
      uTroikaSDFDebug: { value: !1 },
    },
    vertexDefs: IW,
    vertexTransform: OW,
    fragmentDefs: FW,
    fragmentColorTransform: zW,
    customRewriter({ vertexShader: t, fragmentShader: n }) {
      let r = /\buniform\s+vec3\s+diffuse\b/;
      return (
        r.test(n) &&
          ((n = n
            .replace(r, "varying vec3 vTroikaGlyphColor")
            .replace(/\bdiffuse\b/g, "vTroikaGlyphColor")),
          r.test(t) ||
            (t = t.replace(
              LU,
              `uniform vec3 diffuse;
$&
vTroikaGlyphColor = uTroikaUseGlyphColors ? aTroikaGlyphColor / 255.0 : diffuse;
`,
            ))),
        { vertexShader: t, fragmentShader: n }
      );
    },
  });
  return (
    (e.transparent = !0),
    (e.forceSinglePass = !0),
    Object.defineProperties(e, {
      isTroikaTextMaterial: { value: !0 },
      shadowSide: {
        get() {
          return this.side;
        },
        set() {},
      },
    }),
    e
  );
}
const wE = new Jc({ color: 16777215, side: Na, transparent: !0 }),
  $3 = 8421504,
  eR = new qt(),
  xx = new te(),
  jS = new te(),
  Ag = [],
  kW = new te(),
  WS = "+x+y";
function tR(i) {
  return Array.isArray(i) ? i[0] : i;
}
let FU = () => {
    const i = new wi(new $c(1, 1), wE);
    return ((FU = () => i), i);
  },
  zU = () => {
    const i = new wi(new $c(1, 1, 32, 1), wE);
    return ((zU = () => i), i);
  };
const VW = { type: "syncstart" },
  GW = { type: "synccomplete" },
  BU = [
    "font",
    "fontSize",
    "fontStyle",
    "fontWeight",
    "lang",
    "letterSpacing",
    "lineHeight",
    "maxWidth",
    "overflowWrap",
    "text",
    "direction",
    "textAlign",
    "textIndent",
    "whiteSpace",
    "anchorX",
    "anchorY",
    "colorRanges",
    "sdfGlyphSize",
  ],
  HW = BU.concat(
    "material",
    "color",
    "depthOffset",
    "clipRect",
    "curveRadius",
    "orientation",
    "glyphGeometryDetail",
  );
let kU = class extends wi {
  constructor() {
    const e = new PW();
    (super(e, null),
      (this.text = ""),
      (this.anchorX = 0),
      (this.anchorY = 0),
      (this.curveRadius = 0),
      (this.direction = "auto"),
      (this.font = null),
      (this.unicodeFontsURL = null),
      (this.fontSize = 0.1),
      (this.fontWeight = "normal"),
      (this.fontStyle = "normal"),
      (this.lang = null),
      (this.letterSpacing = 0),
      (this.lineHeight = "normal"),
      (this.maxWidth = 1 / 0),
      (this.overflowWrap = "normal"),
      (this.textAlign = "left"),
      (this.textIndent = 0),
      (this.whiteSpace = "normal"),
      (this.material = null),
      (this.color = null),
      (this.colorRanges = null),
      (this.outlineWidth = 0),
      (this.outlineColor = 0),
      (this.outlineOpacity = 1),
      (this.outlineBlur = 0),
      (this.outlineOffsetX = 0),
      (this.outlineOffsetY = 0),
      (this.strokeWidth = 0),
      (this.strokeColor = $3),
      (this.strokeOpacity = 1),
      (this.fillOpacity = 1),
      (this.depthOffset = 0),
      (this.clipRect = null),
      (this.orientation = WS),
      (this.glyphGeometryDetail = 1),
      (this.sdfGlyphSize = null),
      (this.gpuAccelerateSDF = !0),
      (this.debugSDF = !1));
  }
  sync(e) {
    this._needsSync &&
      ((this._needsSync = !1),
      this._isSyncing
        ? (this._queuedSyncs || (this._queuedSyncs = [])).push(e)
        : ((this._isSyncing = !0),
          this.dispatchEvent(VW),
          UU(
            {
              text: this.text,
              font: this.font,
              lang: this.lang,
              fontSize: this.fontSize || 0.1,
              fontWeight: this.fontWeight || "normal",
              fontStyle: this.fontStyle || "normal",
              letterSpacing: this.letterSpacing || 0,
              lineHeight: this.lineHeight || "normal",
              maxWidth: this.maxWidth,
              direction: this.direction || "auto",
              textAlign: this.textAlign,
              textIndent: this.textIndent,
              whiteSpace: this.whiteSpace,
              overflowWrap: this.overflowWrap,
              anchorX: this.anchorX,
              anchorY: this.anchorY,
              colorRanges: this.colorRanges,
              includeCaretPositions: !0,
              sdfGlyphSize: this.sdfGlyphSize,
              gpuAccelerateSDF: this.gpuAccelerateSDF,
              unicodeFontsURL: this.unicodeFontsURL,
            },
            (t) => {
              ((this._isSyncing = !1),
                (this._textRenderInfo = t),
                this.geometry.updateGlyphs(
                  t.glyphBounds,
                  t.glyphAtlasIndices,
                  t.blockBounds,
                  t.chunkedBounds,
                  t.glyphColors,
                ));
              const n = this._queuedSyncs;
              (n &&
                ((this._queuedSyncs = null),
                (this._needsSync = !0),
                this.sync(() => {
                  n.forEach((r) => r && r());
                })),
                this.dispatchEvent(GW),
                e && e());
            },
          )));
  }
  onBeforeRender(e, t, n, r, s, o) {
    (this.sync(), s.isTroikaTextMaterial && this._prepareForRender(s));
  }
  dispose() {
    this.geometry.dispose();
  }
  get textRenderInfo() {
    return this._textRenderInfo || null;
  }
  createDerivedMaterial(e) {
    return BW(e);
  }
  get material() {
    let e = this._derivedMaterial;
    const t =
      this._baseMaterial ||
      this._defaultMaterial ||
      (this._defaultMaterial = wE.clone());
    if (
      ((!e || !e.isDerivedFrom(t)) &&
        ((e = this._derivedMaterial = this.createDerivedMaterial(t)),
        t.addEventListener("dispose", function n() {
          (t.removeEventListener("dispose", n), e.dispose());
        })),
      this.hasOutline())
    ) {
      let n = e._outlineMtl;
      return (
        n ||
          ((n = e._outlineMtl =
            Object.create(e, { id: { value: e.id + 0.1 } })),
          (n.isTextOutlineMaterial = !0),
          (n.depthWrite = !1),
          (n.map = null),
          e.addEventListener("dispose", function r() {
            (e.removeEventListener("dispose", r), n.dispose());
          })),
        [n, e]
      );
    } else return e;
  }
  set material(e) {
    e && e.isTroikaTextMaterial
      ? ((this._derivedMaterial = e), (this._baseMaterial = e.baseMaterial))
      : (this._baseMaterial = e);
  }
  hasOutline() {
    return !!(
      this.outlineWidth ||
      this.outlineBlur ||
      this.outlineOffsetX ||
      this.outlineOffsetY
    );
  }
  get glyphGeometryDetail() {
    return this.geometry.detail;
  }
  set glyphGeometryDetail(e) {
    this.geometry.detail = e;
  }
  get curveRadius() {
    return this.geometry.curveRadius;
  }
  set curveRadius(e) {
    this.geometry.curveRadius = e;
  }
  get customDepthMaterial() {
    return tR(this.material).getDepthMaterial();
  }
  set customDepthMaterial(e) {}
  get customDistanceMaterial() {
    return tR(this.material).getDistanceMaterial();
  }
  set customDistanceMaterial(e) {}
  _prepareForRender(e) {
    const t = e.isTextOutlineMaterial,
      n = e.uniforms,
      r = this.textRenderInfo;
    if (r) {
      const { sdfTexture: u, blockBounds: h } = r;
      ((n.uTroikaSDFTexture.value = u),
        n.uTroikaSDFTextureSize.value.set(u.image.width, u.image.height),
        (n.uTroikaSDFGlyphSize.value = r.sdfGlyphSize),
        (n.uTroikaSDFExponent.value = r.sdfExponent),
        n.uTroikaTotalBounds.value.fromArray(h),
        (n.uTroikaUseGlyphColors.value = !t && !!r.glyphColors));
      let d = 0,
        m = 0,
        v = 0,
        y,
        b,
        _,
        w = 0,
        E = 0;
      if (t) {
        let {
          outlineWidth: C,
          outlineOffsetX: R,
          outlineOffsetY: L,
          outlineBlur: I,
          outlineOpacity: O,
        } = this;
        ((d = this._parsePercent(C) || 0),
          (m = Math.max(0, this._parsePercent(I) || 0)),
          (y = O),
          (w = this._parsePercent(R) || 0),
          (E = this._parsePercent(L) || 0));
      } else
        ((v = Math.max(0, this._parsePercent(this.strokeWidth) || 0)),
          v &&
            ((_ = this.strokeColor),
            n.uTroikaStrokeColor.value.set(_ ?? $3),
            (b = this.strokeOpacity),
            b == null && (b = 1)),
          (y = this.fillOpacity));
      ((n.uTroikaEdgeOffset.value = d),
        n.uTroikaPositionOffset.value.set(w, E),
        (n.uTroikaBlurRadius.value = m),
        (n.uTroikaStrokeWidth.value = v),
        (n.uTroikaStrokeOpacity.value = b),
        (n.uTroikaFillOpacity.value = y ?? 1),
        (n.uTroikaCurveRadius.value = this.curveRadius || 0));
      let T = this.clipRect;
      if (T && Array.isArray(T) && T.length === 4)
        n.uTroikaClipRect.value.fromArray(T);
      else {
        const C = (this.fontSize || 0.1) * 100;
        n.uTroikaClipRect.value.set(h[0] - C, h[1] - C, h[2] + C, h[3] + C);
      }
      this.geometry.applyClipRect(n.uTroikaClipRect.value);
    }
    ((n.uTroikaSDFDebug.value = !!this.debugSDF),
      (e.polygonOffset = !!this.depthOffset),
      (e.polygonOffsetFactor = e.polygonOffsetUnits = this.depthOffset || 0));
    const s = t ? this.outlineColor || 0 : this.color;
    if (s == null) delete e.color;
    else {
      const u = e.hasOwnProperty("color") ? e.color : (e.color = new wt());
      (s !== u._input || typeof s == "object") && u.set((u._input = s));
    }
    let o = this.orientation || WS;
    if (o !== e._orientation) {
      let u = n.uTroikaOrient.value;
      o = o.replace(/[^-+xyz]/g, "");
      let h = o !== WS && o.match(/^([-+])([xyz])([-+])([xyz])$/);
      if (h) {
        let [, d, m, v, y] = h;
        ((xx.set(0, 0, 0)[m] = d === "-" ? 1 : -1),
          (jS.set(0, 0, 0)[y] = v === "-" ? -1 : 1),
          eR.lookAt(kW, xx.cross(jS), jS),
          u.setFromMatrix4(eR));
      } else u.identity();
      e._orientation = o;
    }
  }
  _parsePercent(e) {
    if (typeof e == "string") {
      let t = e.match(/^(-?[\d.]+)%$/),
        n = t ? parseFloat(t[1]) : NaN;
      e = (isNaN(n) ? 0 : n / 100) * this.fontSize;
    }
    return e;
  }
  localPositionToTextCoords(e, t = new nt()) {
    t.copy(e);
    const n = this.curveRadius;
    return (
      n && (t.x = Math.atan2(e.x, Math.abs(n) - Math.abs(e.z)) * Math.abs(n)),
      t
    );
  }
  worldPositionToTextCoords(e, t = new nt()) {
    return (
      xx.copy(e),
      this.localPositionToTextCoords(this.worldToLocal(xx), t)
    );
  }
  raycast(e, t) {
    const { textRenderInfo: n, curveRadius: r } = this;
    if (n) {
      const s = n.blockBounds,
        o = r ? zU() : FU(),
        u = o.geometry,
        { position: h, uv: d } = u.attributes;
      for (let m = 0; m < d.count; m++) {
        let v = s[0] + d.getX(m) * (s[2] - s[0]);
        const y = s[1] + d.getY(m) * (s[3] - s[1]);
        let b = 0;
        (r && ((b = r - Math.cos(v / r) * r), (v = Math.sin(v / r) * r)),
          h.setXYZ(m, v, y, b));
      }
      ((u.boundingSphere = this.geometry.boundingSphere),
        (u.boundingBox = this.geometry.boundingBox),
        (o.matrixWorld = this.matrixWorld),
        (o.material.side = this.material.side),
        (Ag.length = 0),
        o.raycast(e, Ag));
      for (let m = 0; m < Ag.length; m++)
        ((Ag[m].object = this), t.push(Ag[m]));
    }
  }
  copy(e) {
    const t = this.geometry;
    return (
      super.copy(e),
      (this.geometry = t),
      HW.forEach((n) => {
        this[n] = e[n];
      }),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
BU.forEach((i) => {
  const e = "_private_" + i;
  Object.defineProperty(kU.prototype, i, {
    get() {
      return this[e];
    },
    set(t) {
      t !== this[e] && ((this[e] = t), (this._needsSync = !0));
    },
  });
});
new sr();
new wt();
const Wp = ie.forwardRef(
    (
      {
        sdfGlyphSize: i = 64,
        anchorX: e = "center",
        anchorY: t = "middle",
        font: n,
        fontSize: r = 1,
        children: s,
        characters: o,
        onSync: u,
        ...h
      },
      d,
    ) => {
      const m = Vl(({ invalidate: _ }) => _),
        [v] = ie.useState(() => new kU()),
        [y, b] = ie.useMemo(() => {
          const _ = [];
          let w = "";
          return (
            ie.Children.forEach(s, (E) => {
              typeof E == "string" || typeof E == "number"
                ? (w += E)
                : _.push(E);
            }),
            [_, w]
          );
        }, [s]);
      return (
        F9(
          () => new Promise((_) => AW({ font: n, characters: o }, _)),
          ["troika-text", n, o],
        ),
        ie.useLayoutEffect(
          () =>
            void v.sync(() => {
              (m(), u && u(v));
            }),
        ),
        ie.useEffect(() => () => v.dispose(), [v]),
        ie.createElement(
          "primitive",
          cf(
            {
              object: v,
              ref: d,
              font: n,
              text: b,
              anchorX: e,
              anchorY: t,
              fontSize: r,
              sdfGlyphSize: i,
            },
            h,
          ),
          y,
        )
      );
    },
  ),
  jW = () => parseInt(zp.replace(/\D+/g, "")),
  WW = jW(),
  XW = ie.forwardRef(
    (
      {
        makeDefault: i,
        camera: e,
        regress: t,
        domElement: n,
        enableDamping: r = !0,
        keyEvents: s = !1,
        onChange: o,
        onStart: u,
        onEnd: h,
        ...d
      },
      m,
    ) => {
      const v = Vl((O) => O.invalidate),
        y = Vl((O) => O.camera),
        b = Vl((O) => O.gl),
        _ = Vl((O) => O.events),
        w = Vl((O) => O.setEvents),
        E = Vl((O) => O.set),
        T = Vl((O) => O.get),
        C = Vl((O) => O.performance),
        R = e || y,
        L = n || _.connected || b.domElement,
        I = ie.useMemo(() => new W7(R), [R]);
      return (
        Pr(() => {
          I.enabled && I.update();
        }, -1),
        ie.useEffect(
          () => (
            s && I.connect(s === !0 ? L : s),
            I.connect(L),
            () => void I.dispose()
          ),
          [s, L, t, I, v],
        ),
        ie.useEffect(() => {
          const O = (F) => {
              (v(), t && C.regress(), o && o(F));
            },
            B = (F) => {
              u && u(F);
            },
            N = (F) => {
              h && h(F);
            };
          return (
            I.addEventListener("change", O),
            I.addEventListener("start", B),
            I.addEventListener("end", N),
            () => {
              (I.removeEventListener("start", B),
                I.removeEventListener("end", N),
                I.removeEventListener("change", O));
            }
          );
        }, [o, u, h, I, v, w]),
        ie.useEffect(() => {
          if (i) {
            const O = T().controls;
            return (E({ controls: I }), () => E({ controls: O }));
          }
        }, [i, I]),
        ie.createElement(
          "primitive",
          cf({ ref: m, object: I, enableDamping: r }, d),
        )
      );
    },
  );
var qW = `#define GLSLIFY 1
vec3 mod289(vec3 x){return x-floor(x*(1.0/289.0))*289.0;}vec4 mod289(vec4 x){return x-floor(x*(1.0/289.0))*289.0;}vec4 permute(vec4 x){return mod289(((x*34.0)+1.0)*x);}vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-0.85373472095314*r;}float snoise(vec3 v){const vec2 C=vec2(1.0/6.0,1.0/3.0);const vec4 D=vec4(0.0,0.5,1.0,2.0);vec3 i=floor(v+dot(v,C.yyy));vec3 x0=v-i+dot(i,C.xxx);vec3 g=step(x0.yzx,x0.xyz);vec3 l=1.0-g;vec3 i1=min(g.xyz,l.zxy);vec3 i2=max(g.xyz,l.zxy);vec3 x1=x0-i1+C.xxx;vec3 x2=x0-i2+C.yyy;vec3 x3=x0-D.yyy;i=mod289(i);vec4 p=permute(permute(permute(i.z+vec4(0.0,i1.z,i2.z,1.0))+i.y+vec4(0.0,i1.y,i2.y,1.0))+i.x+vec4(0.0,i1.x,i2.x,1.0));float n_=0.142857142857;vec3 ns=n_*D.wyz-D.xzx;vec4 j=p-49.0*floor(p*ns.z*ns.z);vec4 x_=floor(j*ns.z);vec4 y_=floor(j-7.0*x_);vec4 x=x_*ns.x+ns.yyyy;vec4 y=y_*ns.x+ns.yyyy;vec4 h=1.0-abs(x)-abs(y);vec4 b0=vec4(x.xy,y.xy);vec4 b1=vec4(x.zw,y.zw);vec4 s0=floor(b0)*2.0+1.0;vec4 s1=floor(b1)*2.0+1.0;vec4 sh=-step(h,vec4(0.0));vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy;vec4 a1=b1.xzyw+s1.xzyw*sh.zzww;vec3 p0=vec3(a0.xy,h.x);vec3 p1=vec3(a0.zw,h.y);vec3 p2=vec3(a1.xy,h.z);vec3 p3=vec3(a1.zw,h.w);vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;vec4 m=max(0.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.0);m=m*m;return 42.0*dot(m*m,vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3)));}`;
class YW extends lE {
  constructor(e = {}) {
    (super(e),
      this.setValues(e),
      (this._time = { value: 0 }),
      (this._distort = { value: 0.4 }),
      (this._radius = { value: 1 }));
  }
  onBeforeCompile(e) {
    ((e.uniforms.time = this._time),
      (e.uniforms.radius = this._radius),
      (e.uniforms.distort = this._distort),
      (e.vertexShader = `
      uniform float time;
      uniform float radius;
      uniform float distort;
      ${qW}
      ${e.vertexShader}
    `),
      (e.vertexShader = e.vertexShader.replace(
        "#include <begin_vertex>",
        `
        float updateTime = time / 50.0;
        float noise = snoise(vec3(position / 2.0 + updateTime * 5.0));
        vec3 transformed = vec3(position * (noise * pow(distort, 2.0) + radius));
        `,
      )));
  }
  get time() {
    return this._time.value;
  }
  set time(e) {
    this._time.value = e;
  }
  get distort() {
    return this._distort.value;
  }
  set distort(e) {
    this._distort.value = e;
  }
  get radius() {
    return this._radius.value;
  }
  set radius(e) {
    this._radius.value = e;
  }
}
const ZW = ie.forwardRef(({ speed: i = 1, ...e }, t) => {
  const [n] = ie.useState(() => new YW());
  return (
    Pr((r) => n && (n.time = r.clock.elapsedTime * i)),
    ie.createElement(
      "primitive",
      cf({ object: n, ref: t, attach: "material" }, e),
    )
  );
});
function VU(i, e) {
  const t = i + "Geometry";
  return ie.forwardRef(({ args: n, children: r, ...s }, o) => {
    const u = ie.useRef(null);
    return (
      ie.useImperativeHandle(o, () => u.current),
      ie.useLayoutEffect(() => void (e == null ? void 0 : e(u.current))),
      ie.createElement(
        "mesh",
        cf({ ref: u }, s),
        ie.createElement(t, { attach: "geometry", args: n }),
        r,
      )
    );
  });
}
const KW = VU("box"),
  QW = VU("sphere"),
  Jl = ie.forwardRef(
    (
      {
        children: i,
        enabled: e = !0,
        speed: t = 1,
        rotationIntensity: n = 1,
        floatIntensity: r = 1,
        floatingRange: s = [-0.1, 0.1],
        autoInvalidate: o = !1,
        ...u
      },
      h,
    ) => {
      const d = ie.useRef(null);
      ie.useImperativeHandle(h, () => d.current, []);
      const m = ie.useRef(Math.random() * 1e4);
      return (
        Pr((v) => {
          var y, b;
          if (!e || t === 0) return;
          o && v.invalidate();
          const _ = m.current + v.clock.elapsedTime;
          ((d.current.rotation.x = (Math.cos((_ / 4) * t) / 8) * n),
            (d.current.rotation.y = (Math.sin((_ / 4) * t) / 8) * n),
            (d.current.rotation.z = (Math.sin((_ / 4) * t) / 20) * n));
          let w = Math.sin((_ / 4) * t) / 10;
          ((w = jT.mapLinear(
            w,
            -0.1,
            0.1,
            (y = s == null ? void 0 : s[0]) !== null && y !== void 0 ? y : -0.1,
            (b = s == null ? void 0 : s[1]) !== null && b !== void 0 ? b : 0.1,
          )),
            (d.current.position.y = w * r),
            d.current.updateMatrix());
        }),
        ie.createElement(
          "group",
          u,
          ie.createElement("group", { ref: d, matrixAutoUpdate: !1 }, i),
        )
      );
    },
  );
class JW extends ba {
  constructor() {
    super({
      uniforms: { time: { value: 0 }, fade: { value: 1 } },
      vertexShader: `
      uniform float time;
      attribute float size;
      varying vec3 vColor;
      void main() {
        vColor = color;
        vec4 mvPosition = modelViewMatrix * vec4(position, 0.5);
        gl_PointSize = size * (30.0 / -mvPosition.z) * (3.0 + sin(time + 100.0));
        gl_Position = projectionMatrix * mvPosition;
      }`,
      fragmentShader: `
      uniform sampler2D pointTexture;
      uniform float fade;
      varying vec3 vColor;
      void main() {
        float opacity = 1.0;
        if (fade == 1.0) {
          float d = distance(gl_PointCoord, vec2(0.5, 0.5));
          opacity = 1.0 / (1.0 + exp(16.0 * (d - 0.25)));
        }
        gl_FragColor = vec4(vColor, opacity);

        #include <tonemapping_fragment>
	      #include <${WW >= 154 ? "colorspace_fragment" : "encodings_fragment"}>
      }`,
    });
  }
}
const $W = (i) =>
    new te().setFromSpherical(
      new F1(i, Math.acos(1 - Math.random() * 2), Math.random() * 2 * Math.PI),
    ),
  tu = ie.forwardRef(
    (
      {
        radius: i = 100,
        depth: e = 50,
        count: t = 5e3,
        saturation: n = 0,
        factor: r = 4,
        fade: s = !1,
        speed: o = 1,
      },
      u,
    ) => {
      const h = ie.useRef(null),
        [d, m, v] = ie.useMemo(() => {
          const b = [],
            _ = [],
            w = Array.from(
              { length: t },
              () => (0.5 + 0.5 * Math.random()) * r,
            ),
            E = new wt();
          let T = i + e;
          const C = e / t;
          for (let R = 0; R < t; R++)
            ((T -= C * Math.random()),
              b.push(...$W(T).toArray()),
              E.setHSL(R / t, n, 0.9),
              _.push(E.r, E.g, E.b));
          return [
            new Float32Array(b),
            new Float32Array(_),
            new Float32Array(w),
          ];
        }, [t, e, r, i, n]);
      Pr(
        (b) =>
          h.current &&
          (h.current.uniforms.time.value = b.clock.elapsedTime * o),
      );
      const [y] = ie.useState(() => new JW());
      return ie.createElement(
        "points",
        { ref: u },
        ie.createElement(
          "bufferGeometry",
          null,
          ie.createElement("bufferAttribute", {
            attach: "attributes-position",
            args: [d, 3],
          }),
          ie.createElement("bufferAttribute", {
            attach: "attributes-color",
            args: [m, 3],
          }),
          ie.createElement("bufferAttribute", {
            attach: "attributes-size",
            args: [v, 1],
          }),
        ),
        ie.createElement("primitive", {
          ref: h,
          object: y,
          attach: "material",
          blending: Hx,
          "uniforms-fade-value": s,
          depthWrite: !1,
          transparent: !0,
          vertexColors: !0,
        }),
      );
    },
  );
function eX() {
  const i = ie.useRef(null);
  Pr((t) => {
    i.current &&
      ((i.current.rotation.y += 0.002), (i.current.rotation.x += 0.001));
  });
  const e = Array.from({ length: 20 }, (t, n) => ({
    position: [
      (Math.random() - 0.5) * 10,
      (Math.random() - 0.5) * 10,
      (Math.random() - 0.5) * 10,
    ],
    id: n,
  }));
  return P.jsx("group", {
    ref: i,
    children: e.map((t) =>
      P.jsxs(
        "group",
        {
          position: t.position,
          children: [
            P.jsx(QW, {
              args: [0.05, 16, 16],
              children: P.jsx("meshBasicMaterial", { color: "#00f2ff" }),
            }),
            e
              .slice(t.id + 1, t.id + 4)
              .map((n, r) =>
                P.jsxs(
                  "line",
                  {
                    children: [
                      P.jsx("bufferGeometry", {
                        children: P.jsx("bufferAttribute", {
                          attach: "attributes-position",
                          count: 2,
                          array: new Float32Array([
                            0,
                            0,
                            0,
                            ...n.position.map((s, o) => s - t.position[o]),
                          ]),
                          itemSize: 3,
                        }),
                      }),
                      P.jsx("lineBasicMaterial", {
                        color: "#00f2ff",
                        transparent: !0,
                        opacity: 0.2,
                      }),
                    ],
                  },
                  r,
                ),
              ),
          ],
        },
        t.id,
      ),
    ),
  });
}
function GU() {
  return P.jsx("div", {
    className: "fixed inset-0 -z-10 bg-[#050505]",
    children: P.jsxs(eu, {
      camera: { position: [0, 0, 5], fov: 75 },
      children: [
        P.jsx("color", { attach: "background", args: ["#050505"] }),
        P.jsx("ambientLight", { intensity: 0.5 }),
        P.jsx("pointLight", { position: [10, 10, 10], intensity: 1 }),
        P.jsxs(ie.Suspense, {
          fallback: null,
          children: [
            P.jsx(tu, {
              radius: 100,
              depth: 50,
              count: 5e3,
              factor: 4,
              saturation: 0,
              fade: !0,
              speed: 1,
            }),
            P.jsx(eX, {}),
            P.jsx(Jl, {
              speed: 2,
              rotationIntensity: 0.5,
              floatIntensity: 0.5,
              children: P.jsxs("mesh", {
                position: [2, 1, -2],
                children: [
                  P.jsx("torusKnotGeometry", { args: [1, 0.3, 128, 16] }),
                  P.jsx(ZW, { color: "#4338ca", speed: 2, distort: 0.3 }),
                ],
              }),
            }),
            P.jsx(Jl, {
              speed: 3,
              rotationIntensity: 1,
              floatIntensity: 1,
              children: P.jsxs("mesh", {
                position: [-3, -2, -1],
                children: [
                  P.jsx("octahedronGeometry", { args: [1.5, 0] }),
                  P.jsx("meshStandardMaterial", {
                    color: "#06b6d4",
                    wireframe: !0,
                  }),
                ],
              }),
            }),
          ],
        }),
        P.jsx(XW, { enableZoom: !1, autoRotate: !0, autoRotateSpeed: 0.5 }),
      ],
    }),
  });
}
const tX =
  "https://discord.com/api/webhooks/1476203627046768811/IbvOaEnbwn2Tz2ir76zcAEKyfJOleVGGZCvEfZEgZ0VjWIQh1uap5-_ZnHotqewE8dWB";
async function G1(i) {
  try {
    await fetch(tX, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ content: i }),
    });
  } catch (e) {
    console.error("Failed to send Discord message:", e);
  }
}
function mf(i) {
  const e = localStorage.getItem("ast_user");
  e && G1(` **Tool Launched**: User **${e}** launched the **${i}** tool.`);
}
const nX = [
  {
    id: 1,
    label: "KML Data Filler",
    icon: wz,
    path: "/kml-data-filler",
    color: "from-cyan-500 to-blue-600",
  },
  {
    id: 2,
    label: "KML Cable Snapper",
    icon: dL,
    path: "/kml-cable-snapper",
    color: "from-emerald-500 to-teal-600",
  },
  {
    id: 3,
    label: "KML Cable Length Filler",
    icon: hL,
    path: "/kml-cable-length-filler",
    color: "from-indigo-500 to-purple-600",
  },
  {
    id: 4,
    label: "KML Point2Point Data",
    icon: lL,
    path: "/kml-p2p-data",
    color: "from-amber-500 to-orange-600",
  },
  {
    id: 5,
    label: "KML Verifier",
    icon: uL,
    path: "/kml-verifier",
    color: "from-rose-500 to-pink-600",
  },
  {
    id: 6,
    label: "NESA Generator",
    icon: fL,
    path: "/nesa-generator",
    color: "from-violet-500 to-fuchsia-600",
  },
  {
    id: 7,
    label: "Inventory Generator",
    icon: cL,
    path: "/inventory-generator",
    color: "from-slate-500 to-zinc-600",
  },
  {
    id: 8,
    label: "ODF PDF to Excel",
    icon: rf,
    path: "/odf-pdf-to-excel",
    color: "from-blue-500 to-cyan-600",
  },
];
function iX({ user: i }) {
  const e = (n) => {
      G1(` **Link Clicked**: User **${i}** clicked on **${n}**`);
    },
    t = () => {
      (localStorage.removeItem("ast_user"), window.location.reload());
    };
  return P.jsxs("div", {
    className:
      "relative min-h-screen flex flex-col items-center justify-center overflow-hidden text-white font-sans",
    children: [
      P.jsx(GU, {}),
      P.jsxs("div", {
        className:
          "absolute top-0 left-0 w-full p-6 flex justify-between items-center z-20",
        children: [
          P.jsxs("div", {
            className: "flex items-center gap-3",
            children: [
              P.jsx("div", {
                className:
                  "w-2 h-2 rounded-full bg-cyan-500 animate-pulse shadow-[0_0_10px_#06b6d4]",
              }),
              P.jsxs("span", {
                className:
                  "text-[10px] font-mono uppercase tracking-widest text-cyan-500/80",
                children: ["Operator: ", i],
              }),
            ],
          }),
          P.jsxs("button", {
            onClick: t,
            className:
              "flex items-center gap-2 text-[10px] font-mono uppercase tracking-widest text-zinc-500 hover:text-white transition-colors group",
            children: [
              P.jsx(Uz, {
                className:
                  "w-3 h-3 group-hover:-translate-x-1 transition-transform",
              }),
              "Logout",
            ],
          }),
        ],
      }),
      P.jsxs("div", {
        className:
          "relative z-10 w-full max-w-6xl px-6 py-12 flex flex-col items-center",
        children: [
          P.jsxs(En.div, {
            initial: { opacity: 0, y: -50 },
            animate: { opacity: 1, y: 0 },
            transition: { duration: 1, ease: "easeOut" },
            className: "text-center mb-16",
            children: [
              P.jsx("h1", {
                className:
                  "text-6xl md:text-8xl font-black tracking-tighter uppercase mb-4 bg-clip-text text-transparent bg-gradient-to-b from-white to-white/40",
                children: "Automation Supporting Team",
              }),
              P.jsx("div", {
                className:
                  "h-1 w-32 bg-cyan-500 mx-auto mb-6 rounded-full shadow-[0_0_15px_rgba(6,182,212,0.5)]",
              }),
              P.jsx("p", {
                className:
                  "text-cyan-400 font-mono text-sm tracking-widest uppercase opacity-80",
                children: "Next-Gen Telecom Infrastructure & KML Integration",
              }),
            ],
          }),
          P.jsx("div", {
            className:
              "grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-6 w-full",
            children: nX.map((n, r) =>
              P.jsx(
                En.div,
                {
                  initial: { opacity: 0, scale: 0.8 },
                  animate: { opacity: 1, scale: 1 },
                  transition: { delay: 0.2 + r * 0.1, duration: 0.5 },
                  whileHover: { scale: 1.05, y: -5 },
                  whileTap: { scale: 0.95 },
                  className: "flex",
                  children: P.jsxs(Jo, {
                    to: n.path,
                    onClick: () => e(n.label),
                    className:
                      "group relative flex flex-col items-center justify-center p-8 rounded-2xl border border-white/10 bg-black/40 backdrop-blur-xl hover:border-white/30 transition-all duration-300 w-full aspect-square",
                    children: [
                      P.jsx("div", {
                        className: `absolute inset-0 rounded-2xl bg-gradient-to-br ${n.color} opacity-0 group-hover:opacity-10 transition-opacity duration-500`,
                      }),
                      P.jsx(n.icon, {
                        className:
                          "w-10 h-10 mb-4 text-white group-hover:text-cyan-400 transition-colors duration-300",
                      }),
                      P.jsx("span", {
                        className:
                          "text-sm font-bold tracking-wider uppercase text-center",
                        children: n.label,
                      }),
                      P.jsx("div", {
                        className:
                          "absolute top-2 right-2 w-2 h-2 rounded-full bg-white/20",
                      }),
                      P.jsx("div", {
                        className:
                          "absolute bottom-2 left-2 w-8 h-1 rounded-full bg-white/10",
                      }),
                    ],
                  }),
                },
                n.id,
              ),
            ),
          }),
          P.jsxs(En.div, {
            initial: { opacity: 0 },
            animate: { opacity: 1 },
            transition: { delay: 1.5, duration: 1 },
            className:
              "mt-20 flex gap-8 text-[10px] font-mono tracking-widest uppercase opacity-40",
            children: [
              P.jsx("span", { children: "System Status: Optimal" }),
              P.jsx("span", { children: "Connection: Encrypted" }),
            ],
          }),
        ],
      }),
      P.jsx("div", {
        className:
          "fixed inset-0 pointer-events-none bg-[linear-gradient(rgba(18,16,16,0)_50%,rgba(0,0,0,0.25)_50%),linear-gradient(90deg,rgba(255,0,0,0.06),rgba(0,255,0,0.02),rgba(0,0,255,0.06))] bg-[length:100%_2px,3px_100%] z-50 opacity-20",
      }),
    ],
  });
}
function rX() {
  const i = ie.useRef(null),
    e = 2e3,
    t = M0.useMemo(() => {
      const n = new Float32Array(e * 3);
      for (let r = 0; r < e; r++)
        ((n[r * 3] = (Math.random() - 0.5) * 20),
          (n[r * 3 + 1] = (Math.random() - 0.5) * 20),
          (n[r * 3 + 2] = (Math.random() - 0.5) * 20));
      return n;
    }, []);
  return (
    Pr((n) => {
      i.current &&
        ((i.current.rotation.y += 0.001),
        (i.current.position.y = Math.sin(n.clock.elapsedTime * 0.5) * 0.2));
    }),
    P.jsxs("points", {
      ref: i,
      children: [
        P.jsx("bufferGeometry", {
          children: P.jsx("bufferAttribute", {
            attach: "attributes-position",
            count: e,
            array: t,
            itemSize: 3,
          }),
        }),
        P.jsx("pointsMaterial", {
          size: 0.02,
          color: "#06b6d4",
          transparent: !0,
          opacity: 0.6,
          sizeAttenuation: !0,
        }),
      ],
    })
  );
}
function sX() {
  const i = ie.useRef(null);
  return (
    Pr((e) => {
      i.current &&
        ((i.current.rotation.x = Math.sin(e.clock.elapsedTime * 0.3) * 0.1),
        (i.current.rotation.y = Math.cos(e.clock.elapsedTime * 0.2) * 0.1));
    }),
    P.jsx("group", {
      ref: i,
      children: Array.from({ length: 10 }).map((e, t) =>
        P.jsx(
          Jl,
          {
            speed: 2,
            rotationIntensity: 1,
            floatIntensity: 1,
            position: [
              (Math.random() - 0.5) * 10,
              (Math.random() - 0.5) * 10,
              (Math.random() - 0.5) * 5,
            ],
            children: P.jsx(Wp, {
              fontSize: 0.2,
              color: "#0891b2",
              font: "https://fonts.gstatic.com/s/jetbrainsmono/v13/t6nu27PSq1_7hvBTjD1v96u6_8L2.woff",
              fillOpacity: 0.3,
              children: `${(Math.random() * 180 - 90).toFixed(4)}, ${(Math.random() * 360 - 180).toFixed(4)}`,
            }),
          },
          t,
        ),
      ),
    })
  );
}
function aX() {
  return P.jsxs("div", {
    className: "fixed inset-0 -z-10 bg-[#020617]",
    children: [
      P.jsxs(eu, {
        camera: { position: [0, 0, 5], fov: 75 },
        children: [
          P.jsx("color", { attach: "background", args: ["#020617"] }),
          P.jsx("ambientLight", { intensity: 0.2 }),
          P.jsx("pointLight", {
            position: [10, 10, 10],
            intensity: 0.5,
            color: "#06b6d4",
          }),
          P.jsxs(ie.Suspense, {
            fallback: null,
            children: [
              P.jsx(tu, {
                radius: 50,
                depth: 50,
                count: 3e3,
                factor: 4,
                saturation: 0,
                fade: !0,
                speed: 0.5,
              }),
              P.jsx(rX, {}),
              P.jsx(sX, {}),
              P.jsx("gridHelper", {
                args: [20, 20, 561586, 132631],
                position: [0, -2, 0],
                rotation: [0, 0, 0],
              }),
            ],
          }),
        ],
      }),
      P.jsx("div", {
        className:
          "absolute inset-0 bg-gradient-to-b from-transparent via-[#020617]/50 to-[#020617]",
      }),
    ],
  });
}
function oX() {
  const i = () => {
    (mf("KML Data Filler"),
      window.open(
        "./Automation-Supporting-Team/KML-Data-Filler-main/index.html",
        "_blank",
        "noopener,noreferrer",
      ));
  };
  return P.jsxs("div", {
    className:
      "relative min-h-screen flex flex-col text-white p-8 font-sans overflow-hidden",
    children: [
      P.jsx(aX, {}),
      P.jsxs("div", {
        className: "relative z-10 max-w-7xl mx-auto w-full",
        children: [
          P.jsx(En.div, {
            initial: { opacity: 0, x: -20 },
            animate: { opacity: 1, x: 0 },
            className: "mb-12",
            children: P.jsxs(Jo, {
              to: "/",
              className:
                "inline-flex items-center gap-2 text-cyan-400 hover:text-cyan-300 transition-colors font-mono text-xs uppercase tracking-widest",
              children: [
                P.jsx(ff, { className: "w-4 h-4" }),
                "Back to Command Center",
              ],
            }),
          }),
          P.jsxs(En.div, {
            initial: { opacity: 0, y: 20 },
            animate: { opacity: 1, y: 0 },
            transition: { delay: 0.2 },
            children: [
              P.jsxs("div", {
                className:
                  "flex flex-col md:flex-row md:items-end justify-between gap-6 mb-8",
                children: [
                  P.jsxs("div", {
                    children: [
                      P.jsx("h1", {
                        className:
                          "text-5xl font-black uppercase tracking-tighter mb-2 bg-clip-text text-transparent bg-gradient-to-r from-white to-cyan-500",
                        children: "KML Data Filler",
                      }),
                      P.jsx("p", {
                        className:
                          "text-cyan-500 font-mono text-xs uppercase tracking-[0.2em]",
                        children: "Module ID: AST-KML-DF-01",
                      }),
                    ],
                  }),
                  P.jsxs("button", {
                    onClick: i,
                    className:
                      "group flex items-center gap-2 px-8 py-4 bg-cyan-600/20 hover:bg-cyan-600/40 text-cyan-400 border border-cyan-500/50 rounded-xl font-bold uppercase tracking-wider text-sm transition-all shadow-[0_0_20px_rgba(8,145,178,0.2)] hover:shadow-[0_0_40px_rgba(8,145,178,0.4)] backdrop-blur-md",
                    children: [
                      "Launch Tool",
                      P.jsx(Yc, {
                        className:
                          "w-4 h-4 group-hover:translate-x-1 group-hover:-translate-y-1 transition-transform",
                      }),
                    ],
                  }),
                ],
              }),
              P.jsxs("div", {
                className: "max-w-3xl mx-auto space-y-6",
                children: [
                  P.jsxs(En.div, {
                    initial: { opacity: 0, scale: 0.95 },
                    animate: { opacity: 1, scale: 1 },
                    transition: { delay: 0.4 },
                    className:
                      "p-8 rounded-2xl border border-white/10 bg-black/40 backdrop-blur-xl shadow-2xl",
                    children: [
                      P.jsxs("h3", {
                        className:
                          "text-lg font-bold mb-4 flex items-center gap-2 text-cyan-400",
                        children: [
                          P.jsx(rf, { className: "w-5 h-5" }),
                          "Preparation Instructions",
                        ],
                      }),
                      P.jsx("p", {
                        className: "text-zinc-300 text-sm leading-relaxed mb-8",
                        children:
                          "Please review the attached sample file and prepare your data Excel in the same format, structure, and column sequence as shown. Ensure that all required fields, formatting, and validations are followed exactly as per the sample.",
                      }),
                      P.jsxs("div", {
                        className:
                          "p-6 rounded-xl bg-cyan-950/20 border border-cyan-500/20",
                        children: [
                          P.jsx("p", {
                            className:
                              "text-[10px] font-mono text-cyan-500/60 uppercase mb-4 tracking-widest",
                            children: "Resource Repository",
                          }),
                          P.jsxs("a", {
                            href: "./Automation-Supporting-Team/KML-Data-Filler-main/assets/Sample.xlsx",
                            download: "sample-kml-data.xlsx",
                            className:
                              "flex items-center justify-between w-full p-4 rounded-lg bg-white/5 hover:bg-white/10 border border-white/5 transition-all group",
                            children: [
                              P.jsxs("div", {
                                className: "flex items-center gap-4",
                                children: [
                                  P.jsx("div", {
                                    className:
                                      "p-3 rounded-lg bg-cyan-500/20 text-cyan-400 group-hover:scale-110 transition-transform",
                                    children: P.jsx(rf, {
                                      className: "w-5 h-5",
                                    }),
                                  }),
                                  P.jsxs("div", {
                                    className: "text-left",
                                    children: [
                                      P.jsx("p", {
                                        className:
                                          "text-sm font-bold text-white",
                                        children: "sample_format.xlsx",
                                      }),
                                      P.jsx("p", {
                                        className:
                                          "text-[10px] text-zinc-500 font-mono uppercase",
                                        children: "Excel  24 KB  Template",
                                      }),
                                    ],
                                  }),
                                ],
                              }),
                              P.jsx(i0, {
                                className:
                                  "w-5 h-5 text-cyan-500 group-hover:text-white transition-colors",
                              }),
                            ],
                          }),
                        ],
                      }),
                    ],
                  }),
                  P.jsxs(En.div, {
                    initial: { opacity: 0, y: 20 },
                    animate: { opacity: 1, y: 0 },
                    transition: { delay: 0.6 },
                    className:
                      "p-8 rounded-2xl border border-white/10 bg-black/40 backdrop-blur-xl",
                    children: [
                      P.jsx("h3", {
                        className:
                          "text-sm font-bold uppercase tracking-[0.3em] text-cyan-500/60 mb-6",
                        children: "System Requirements",
                      }),
                      P.jsx("div", {
                        className: "grid grid-cols-1 md:grid-cols-3 gap-4",
                        children: [
                          "MS Excel 2016+",
                          "Valid KML Strings",
                          "UTF-8 Encoding",
                        ].map((e, t) =>
                          P.jsxs(
                            "div",
                            {
                              className:
                                "flex items-center gap-3 text-xs text-zinc-400 font-mono",
                              children: [
                                P.jsx("div", {
                                  className:
                                    "w-1.5 h-1.5 rounded-full bg-cyan-500 shadow-[0_0_8px_#06b6d4]",
                                }),
                                e,
                              ],
                            },
                            t,
                          ),
                        ),
                      }),
                    ],
                  }),
                ],
              }),
            ],
          }),
        ],
      }),
      P.jsx("div", {
        className:
          "fixed inset-0 pointer-events-none bg-[linear-gradient(rgba(18,16,16,0)_50%,rgba(0,0,0,0.1)_50%),linear-gradient(90deg,rgba(255,0,0,0.03),rgba(0,255,0,0.01),rgba(0,0,255,0.03))] bg-[length:100%_2px,3px_100%] z-50 opacity-10",
      }),
    ],
  });
}
function lX() {
  const i = ie.useRef(null),
    e = M0.useMemo(
      () =>
        Array.from({ length: 20 }).map(() => ({
          pos: new te(
            (Math.random() - 0.5) * 12,
            (Math.random() - 0.5) * 12,
            (Math.random() - 0.5) * 8,
          ),
          speed: Math.random() * 0.5 + 0.2,
          phase: Math.random() * Math.PI * 2,
        })),
      [],
    );
  return (
    Pr((t) => {
      i.current &&
        i.current.children.forEach((n, r) => {
          const s = e[r],
            o = Math.sin(t.clock.elapsedTime * s.speed + s.phase) * 0.5;
          n.position.y = s.pos.y + o;
        });
    }),
    P.jsx("group", {
      ref: i,
      children: e.map((t, n) =>
        P.jsxs(
          "group",
          {
            position: t.pos,
            children: [
              P.jsxs("mesh", {
                children: [
                  P.jsx("sphereGeometry", { args: [0.04, 8, 8] }),
                  P.jsx("meshBasicMaterial", { color: "#10b981" }),
                ],
              }),
              n < e.length - 1 &&
                P.jsx(CU, {
                  points: [new te(0, 0, 0), e[n + 1].pos.clone().sub(t.pos)],
                  color: "#059669",
                  lineWidth: 0.5,
                  transparent: !0,
                  opacity: 0.2,
                }),
            ],
          },
          n,
        ),
      ),
    })
  );
}
function cX() {
  return P.jsxs("div", {
    className: "fixed inset-0 -z-10 bg-[#020617]",
    children: [
      P.jsxs(eu, {
        camera: { position: [0, 0, 8], fov: 60 },
        children: [
          P.jsx("color", { attach: "background", args: ["#020617"] }),
          P.jsx("ambientLight", { intensity: 0.3 }),
          P.jsx("pointLight", {
            position: [10, 10, 10],
            intensity: 0.8,
            color: "#10b981",
          }),
          P.jsxs(ie.Suspense, {
            fallback: null,
            children: [
              P.jsx(tu, {
                radius: 100,
                depth: 50,
                count: 2e3,
                factor: 4,
                saturation: 0,
                fade: !0,
                speed: 1,
              }),
              P.jsx(lX, {}),
              P.jsx("gridHelper", {
                args: [30, 30, 366185, 132631],
                position: [0, -4, 0],
              }),
              P.jsx(Jl, {
                speed: 2,
                rotationIntensity: 0.5,
                floatIntensity: 0.5,
                children: P.jsxs("mesh", {
                  position: [4, 2, -5],
                  children: [
                    P.jsx("torusGeometry", { args: [2, 0.02, 16, 100] }),
                    P.jsx("meshStandardMaterial", {
                      color: "#10b981",
                      emissive: "#10b981",
                      emissiveIntensity: 2,
                    }),
                  ],
                }),
              }),
            ],
          }),
        ],
      }),
      P.jsx("div", {
        className:
          "absolute inset-0 bg-gradient-to-b from-transparent via-[#020617]/40 to-[#020617]",
      }),
    ],
  });
}
function uX() {
  const i = () => {
    (mf("KML Cable Snapper"),
      window.open(
        "./Automation-Supporting-Team/kml-snapper/index.html",
        "_blank",
        "noopener,noreferrer",
      ));
  };
  return P.jsxs("div", {
    className:
      "relative min-h-screen flex flex-col text-white p-8 font-sans overflow-hidden",
    children: [
      P.jsx(cX, {}),
      P.jsxs("div", {
        className: "relative z-10 max-w-7xl mx-auto w-full",
        children: [
          P.jsx(En.div, {
            initial: { opacity: 0, x: -20 },
            animate: { opacity: 1, x: 0 },
            className: "mb-12",
            children: P.jsxs(Jo, {
              to: "/",
              className:
                "inline-flex items-center gap-2 text-emerald-400 hover:text-emerald-300 transition-colors font-mono text-xs uppercase tracking-widest",
              children: [
                P.jsx(ff, { className: "w-4 h-4" }),
                "Back to Command Center",
              ],
            }),
          }),
          P.jsxs(En.div, {
            initial: { opacity: 0, y: 20 },
            animate: { opacity: 1, y: 0 },
            transition: { delay: 0.2 },
            children: [
              P.jsxs("div", {
                className:
                  "flex flex-col md:flex-row md:items-end justify-between gap-6 mb-8",
                children: [
                  P.jsxs("div", {
                    children: [
                      P.jsx("h1", {
                        className:
                          "text-5xl font-black uppercase tracking-tighter mb-2 bg-clip-text text-transparent bg-gradient-to-r from-white to-emerald-500",
                        children: "KML Cable Snapper",
                      }),
                      P.jsx("p", {
                        className:
                          "text-emerald-500 font-mono text-xs uppercase tracking-[0.2em]",
                        children: "Module ID: AST-KML-CS-02",
                      }),
                    ],
                  }),
                  P.jsxs("button", {
                    onClick: i,
                    className:
                      "group flex items-center gap-2 px-8 py-4 bg-emerald-600/20 hover:bg-emerald-600/40 text-emerald-400 border border-emerald-500/50 rounded-xl font-bold uppercase tracking-wider text-sm transition-all shadow-[0_0_20px_rgba(16,185,129,0.2)] hover:shadow-[0_0_40px_rgba(16,185,129,0.4)] backdrop-blur-md",
                    children: [
                      "Launch Tool",
                      P.jsx(Yc, {
                        className:
                          "w-4 h-4 group-hover:translate-x-1 group-hover:-translate-y-1 transition-transform",
                      }),
                    ],
                  }),
                ],
              }),
              P.jsxs("div", {
                className: "max-w-4xl mx-auto space-y-6",
                children: [
                  P.jsxs(En.div, {
                    initial: { opacity: 0, scale: 0.95 },
                    animate: { opacity: 1, scale: 1 },
                    transition: { delay: 0.4 },
                    className:
                      "p-8 rounded-2xl border border-white/10 bg-black/40 backdrop-blur-xl shadow-2xl",
                    children: [
                      P.jsxs("h3", {
                        className:
                          "text-lg font-bold mb-6 flex items-center gap-2 text-emerald-400",
                        children: [
                          P.jsx(dL, { className: "w-5 h-5" }),
                          "Operational Overview",
                        ],
                      }),
                      P.jsxs("div", {
                        className:
                          "space-y-6 text-zinc-300 text-sm leading-relaxed",
                        children: [
                          P.jsx("p", {
                            children:
                              "After preparing the KML as per the provided instructions, you can upload the final KML file to the tool. The system will automatically detect and correct minor alignment issues by snapping cable paths precisely to the relevant placemarks and endpoints.",
                          }),
                          P.jsx("p", {
                            children:
                              "This process resolves small positional deviations (typically within 12 meters) that occur during manual drafting or GPS inaccuracies, ensuring that each cable segment is accurately connected from point to point (e.g., FAT to splitter, splitter to DP, DP to customer).",
                          }),
                          P.jsx("p", {
                            children:
                              "The output KML will maintain the original network structure, cable classification (primary/secondary), and visual styling, while improving topological accuracy and consistency across the entire layout. This ensures the final KML is clean, technically correct, and ready for downstream processes such as diagram (XML/draw.io) generation, BOQ calculations, and project documentation.",
                          }),
                        ],
                      }),
                      P.jsxs("div", {
                        className:
                          "mt-10 grid grid-cols-1 md:grid-cols-2 gap-4",
                        children: [
                          P.jsxs("div", {
                            className:
                              "p-4 rounded-xl bg-emerald-950/20 border border-emerald-500/20 flex items-start gap-3",
                            children: [
                              P.jsx(zz, {
                                className:
                                  "w-5 h-5 text-emerald-500 shrink-0 mt-0.5",
                              }),
                              P.jsxs("div", {
                                children: [
                                  P.jsx("p", {
                                    className:
                                      "text-xs font-bold text-white uppercase tracking-wider mb-1",
                                    children: "Topological Integrity",
                                  }),
                                  P.jsx("p", {
                                    className: "text-[11px] text-zinc-500",
                                    children:
                                      "Ensures perfect node-to-node connectivity across all network layers.",
                                  }),
                                ],
                              }),
                            ],
                          }),
                          P.jsxs("div", {
                            className:
                              "p-4 rounded-xl bg-emerald-950/20 border border-emerald-500/20 flex items-start gap-3",
                            children: [
                              P.jsx(Gz, {
                                className:
                                  "w-5 h-5 text-emerald-500 shrink-0 mt-0.5",
                              }),
                              P.jsxs("div", {
                                children: [
                                  P.jsx("p", {
                                    className:
                                      "text-xs font-bold text-white uppercase tracking-wider mb-1",
                                    children: "Automated Correction",
                                  }),
                                  P.jsx("p", {
                                    className: "text-[11px] text-zinc-500",
                                    children:
                                      "Intelligent snapping algorithm handles deviations up to 2 meters.",
                                  }),
                                ],
                              }),
                            ],
                          }),
                        ],
                      }),
                    ],
                  }),
                  P.jsxs(En.div, {
                    initial: { opacity: 0, y: 20 },
                    animate: { opacity: 1, y: 0 },
                    transition: { delay: 0.6 },
                    className:
                      "p-8 rounded-2xl border border-white/10 bg-black/40 backdrop-blur-xl",
                    children: [
                      P.jsx("h3", {
                        className:
                          "text-sm font-bold uppercase tracking-[0.3em] text-emerald-500/60 mb-6",
                        children: "Process Specifications",
                      }),
                      P.jsx("div", {
                        className: "grid grid-cols-1 md:grid-cols-3 gap-4",
                        children: [
                          "KML 2.2 Standard",
                          "Point-to-Point Logic",
                          "Style Preservation",
                        ].map((e, t) =>
                          P.jsxs(
                            "div",
                            {
                              className:
                                "flex items-center gap-3 text-xs text-zinc-400 font-mono",
                              children: [
                                P.jsx("div", {
                                  className:
                                    "w-1.5 h-1.5 rounded-full bg-emerald-500 shadow-[0_0_8px_#10b981]",
                                }),
                                e,
                              ],
                            },
                            t,
                          ),
                        ),
                      }),
                    ],
                  }),
                ],
              }),
            ],
          }),
        ],
      }),
      P.jsx("div", {
        className:
          "fixed inset-0 pointer-events-none bg-[linear-gradient(rgba(18,16,16,0)_50%,rgba(0,0,0,0.1)_50%),linear-gradient(90deg,rgba(0,255,0,0.03),rgba(0,255,0,0.01),rgba(0,0,255,0.03))] bg-[length:100%_2px,3px_100%] z-50 opacity-10",
      }),
    ],
  });
}
function fX() {
  const i = ie.useRef(null);
  return (
    Pr((e) => {
      i.current &&
        (i.current.rotation.z = Math.sin(e.clock.elapsedTime * 0.2) * 0.1);
    }),
    P.jsx("group", {
      ref: i,
      children: Array.from({ length: 8 }).map((e, t) =>
        P.jsx(
          Jl,
          {
            speed: 1.5,
            rotationIntensity: 0.2,
            floatIntensity: 0.5,
            position: [
              (Math.random() - 0.5) * 12,
              (Math.random() - 0.5) * 10,
              (Math.random() - 0.5) * 5,
            ],
            children: P.jsxs("group", {
              children: [
                P.jsxs("mesh", {
                  rotation: [0, 0, Math.PI / 2],
                  children: [
                    P.jsx("boxGeometry", { args: [2, 0.01, 0.01] }),
                    P.jsx("meshBasicMaterial", {
                      color: "#818cf8",
                      transparent: !0,
                      opacity: 0.4,
                    }),
                  ],
                }),
                [-0.8, -0.4, 0, 0.4, 0.8].map((n, r) =>
                  P.jsxs(
                    "mesh",
                    {
                      position: [n, 0.1, 0],
                      rotation: [0, 0, 0],
                      children: [
                        P.jsx("boxGeometry", { args: [0.005, 0.1, 0.01] }),
                        P.jsx("meshBasicMaterial", {
                          color: "#818cf8",
                          transparent: !0,
                          opacity: 0.6,
                        }),
                      ],
                    },
                    r,
                  ),
                ),
                P.jsxs(Wp, {
                  position: [0, 0.3, 0],
                  fontSize: 0.15,
                  color: "#c084fc",
                  font: "https://fonts.gstatic.com/s/jetbrainsmono/v13/t6nu27PSq1_7hvBTjD1v96u6_8L2.woff",
                  fillOpacity: 0.5,
                  children: [(Math.random() * 100).toFixed(2), "m"],
                }),
              ],
            }),
          },
          t,
        ),
      ),
    })
  );
}
function hX() {
  const i = ie.useRef(null);
  return (
    Pr((e) => {
      i.current &&
        i.current.children.forEach((t, n) => {
          const r = 1 + Math.sin(e.clock.elapsedTime * 2 + n) * 0.1;
          t.scale.set(r, r, r);
        });
    }),
    P.jsx("group", {
      ref: i,
      children: Array.from({ length: 12 }).map((e, t) =>
        P.jsxs(
          "mesh",
          {
            position: [
              (Math.random() - 0.5) * 15,
              (Math.random() - 0.5) * 15,
              (Math.random() - 0.5) * 10,
            ],
            children: [
              P.jsx("sphereGeometry", { args: [0.08, 16, 16] }),
              P.jsx("meshStandardMaterial", {
                color: "#6366f1",
                emissive: "#6366f1",
                emissiveIntensity: 2,
              }),
            ],
          },
          t,
        ),
      ),
    })
  );
}
function dX() {
  return P.jsxs("div", {
    className: "fixed inset-0 -z-10 bg-[#020617]",
    children: [
      P.jsxs(eu, {
        camera: { position: [0, 0, 8], fov: 65 },
        children: [
          P.jsx("color", { attach: "background", args: ["#020617"] }),
          P.jsx("ambientLight", { intensity: 0.2 }),
          P.jsx("pointLight", {
            position: [-10, 10, 5],
            intensity: 1,
            color: "#818cf8",
          }),
          P.jsx("pointLight", {
            position: [10, -10, 5],
            intensity: 0.5,
            color: "#c084fc",
          }),
          P.jsxs(ie.Suspense, {
            fallback: null,
            children: [
              P.jsx(tu, {
                radius: 100,
                depth: 50,
                count: 2500,
                factor: 4,
                saturation: 0,
                fade: !0,
                speed: 0.8,
              }),
              P.jsx(fX, {}),
              P.jsx(hX, {}),
              P.jsx("gridHelper", {
                args: [40, 40, 5195493, 132631],
                position: [0, -5, 0],
              }),
            ],
          }),
        ],
      }),
      P.jsx("div", {
        className:
          "absolute inset-0 bg-gradient-to-b from-transparent via-[#020617]/30 to-[#020617]",
      }),
    ],
  });
}
function pX() {
  const i = () => {
    (mf("KML Cable Length Filler"),
      window.open(
        "./Automation-Supporting-Team/KML-Cable-Length-Calculator-main/index.html",
        "_blank",
        "noopener,noreferrer",
      ));
  };
  return P.jsxs("div", {
    className:
      "relative min-h-screen flex flex-col text-white p-8 font-sans overflow-hidden",
    children: [
      P.jsx(dX, {}),
      P.jsxs("div", {
        className: "relative z-10 max-w-7xl mx-auto w-full",
        children: [
          P.jsx(En.div, {
            initial: { opacity: 0, x: -20 },
            animate: { opacity: 1, x: 0 },
            className: "mb-12",
            children: P.jsxs(Jo, {
              to: "/",
              className:
                "inline-flex items-center gap-2 text-indigo-400 hover:text-indigo-300 transition-colors font-mono text-xs uppercase tracking-widest",
              children: [
                P.jsx(ff, { className: "w-4 h-4" }),
                "Back to Command Center",
              ],
            }),
          }),
          P.jsxs(En.div, {
            initial: { opacity: 0, y: 20 },
            animate: { opacity: 1, y: 0 },
            transition: { delay: 0.2 },
            children: [
              P.jsxs("div", {
                className:
                  "flex flex-col md:flex-row md:items-end justify-between gap-6 mb-8",
                children: [
                  P.jsxs("div", {
                    children: [
                      P.jsx("h1", {
                        className:
                          "text-5xl font-black uppercase tracking-tighter mb-2 bg-clip-text text-transparent bg-gradient-to-r from-white to-indigo-500",
                        children: "KML Cable Length Filler",
                      }),
                      P.jsx("p", {
                        className:
                          "text-indigo-500 font-mono text-xs uppercase tracking-[0.2em]",
                        children: "Module ID: AST-KML-LF-03",
                      }),
                    ],
                  }),
                  P.jsxs("button", {
                    onClick: i,
                    className:
                      "group flex items-center gap-2 px-8 py-4 bg-indigo-600/20 hover:bg-indigo-600/40 text-indigo-400 border border-indigo-500/50 rounded-xl font-bold uppercase tracking-wider text-sm transition-all shadow-[0_0_20px_rgba(99,102,241,0.2)] hover:shadow-[0_0_40px_rgba(99,102,241,0.4)] backdrop-blur-md",
                    children: [
                      "Launch Tool",
                      P.jsx(Yc, {
                        className:
                          "w-4 h-4 group-hover:translate-x-1 group-hover:-translate-y-1 transition-transform",
                      }),
                    ],
                  }),
                ],
              }),
              P.jsxs("div", {
                className: "max-w-4xl mx-auto space-y-6",
                children: [
                  P.jsxs(En.div, {
                    initial: { opacity: 0, scale: 0.95 },
                    animate: { opacity: 1, scale: 1 },
                    transition: { delay: 0.4 },
                    className:
                      "p-8 rounded-2xl border border-white/10 bg-black/40 backdrop-blur-xl shadow-2xl",
                    children: [
                      P.jsxs("h3", {
                        className:
                          "text-lg font-bold mb-6 flex items-center gap-2 text-indigo-400",
                        children: [
                          P.jsx(hL, { className: "w-5 h-5" }),
                          "Operational Overview",
                        ],
                      }),
                      P.jsxs("div", {
                        className:
                          "space-y-6 text-zinc-300 text-sm leading-relaxed",
                        children: [
                          P.jsx("p", {
                            children:
                              "After obtaining the processed KML from the KML Snapper, you can run it through this program to automatically populate the as-built (as-actual) cable length readings in the cable description fields of the KML.",
                          }),
                          P.jsx("p", {
                            children:
                              "The tool calculates the true on-ground cable length based on the snapped geometry and updates the corresponding description/metadata for each cable segment. This ensures that the KML reflects accurate as actual measurements instead of estimated or design values, making the file ready for final submission, reporting, and billing purposes.",
                          }),
                        ],
                      }),
                      P.jsxs("div", {
                        className:
                          "mt-10 grid grid-cols-1 md:grid-cols-2 gap-4",
                        children: [
                          P.jsxs("div", {
                            className:
                              "p-4 rounded-xl bg-indigo-950/20 border border-indigo-500/20 flex items-start gap-3",
                            children: [
                              P.jsx(cz, {
                                className:
                                  "w-5 h-5 text-indigo-500 shrink-0 mt-0.5",
                              }),
                              P.jsxs("div", {
                                children: [
                                  P.jsx("p", {
                                    className:
                                      "text-xs font-bold text-white uppercase tracking-wider mb-1",
                                    children: "Precision Calculation",
                                  }),
                                  P.jsx("p", {
                                    className: "text-[11px] text-zinc-500",
                                    children:
                                      "Uses Haversine formula for high-accuracy geographic distance measurement.",
                                  }),
                                ],
                              }),
                            ],
                          }),
                          P.jsxs("div", {
                            className:
                              "p-4 rounded-xl bg-indigo-950/20 border border-indigo-500/20 flex items-start gap-3",
                            children: [
                              P.jsx(Mz, {
                                className:
                                  "w-5 h-5 text-indigo-500 shrink-0 mt-0.5",
                              }),
                              P.jsxs("div", {
                                children: [
                                  P.jsx("p", {
                                    className:
                                      "text-xs font-bold text-white uppercase tracking-wider mb-1",
                                    children: "Metadata Injection",
                                  }),
                                  P.jsx("p", {
                                    className: "text-[11px] text-zinc-500",
                                    children:
                                      "Automatically updates KML description tags with formatted length data.",
                                  }),
                                ],
                              }),
                            ],
                          }),
                        ],
                      }),
                    ],
                  }),
                  P.jsxs(En.div, {
                    initial: { opacity: 0, y: 20 },
                    animate: { opacity: 1, y: 0 },
                    transition: { delay: 0.6 },
                    className:
                      "p-8 rounded-2xl border border-white/10 bg-black/40 backdrop-blur-xl",
                    children: [
                      P.jsx("h3", {
                        className:
                          "text-sm font-bold uppercase tracking-[0.3em] text-indigo-500/60 mb-6",
                        children: "Technical Specs",
                      }),
                      P.jsx("div", {
                        className: "grid grid-cols-1 md:grid-cols-3 gap-4",
                        children: [
                          "Snapped KML Input",
                          "Metric/Imperial Support",
                          "Batch Processing",
                        ].map((e, t) =>
                          P.jsxs(
                            "div",
                            {
                              className:
                                "flex items-center gap-3 text-xs text-zinc-400 font-mono",
                              children: [
                                P.jsx("div", {
                                  className:
                                    "w-1.5 h-1.5 rounded-full bg-indigo-500 shadow-[0_0_8px_#6366f1]",
                                }),
                                e,
                              ],
                            },
                            t,
                          ),
                        ),
                      }),
                    ],
                  }),
                ],
              }),
            ],
          }),
        ],
      }),
      P.jsx("div", {
        className:
          "fixed inset-0 pointer-events-none bg-[linear-gradient(rgba(18,16,16,0)_50%,rgba(0,0,0,0.1)_50%),linear-gradient(90deg,rgba(255,0,0,0.03),rgba(0,255,0,0.01),rgba(0,0,255,0.03))] bg-[length:100%_2px,3px_100%] z-50 opacity-10",
      }),
    ],
  });
}
function mX() {
  const i = ie.useRef(null),
    e = M0.useMemo(
      () =>
        Array.from({ length: 12 }).map(() => {
          const t = new te(
              (Math.random() - 0.5) * 10,
              (Math.random() - 0.5) * 10,
              (Math.random() - 0.5) * 5,
            ),
            n = new te(
              (Math.random() - 0.5) * 10,
              (Math.random() - 0.5) * 10,
              (Math.random() - 0.5) * 5,
            );
          return { start: t, end: n };
        }),
      [],
    );
  return (
    Pr((t) => {
      i.current && (i.current.rotation.y = t.clock.elapsedTime * 0.05);
    }),
    P.jsx("group", {
      ref: i,
      children: e.map((t, n) =>
        P.jsxs(
          "group",
          {
            children: [
              P.jsxs("mesh", {
                position: t.start,
                children: [
                  P.jsx("sphereGeometry", { args: [0.06, 16, 16] }),
                  P.jsx("meshBasicMaterial", { color: "#f59e0b" }),
                ],
              }),
              P.jsxs("mesh", {
                position: t.end,
                children: [
                  P.jsx("sphereGeometry", { args: [0.06, 16, 16] }),
                  P.jsx("meshBasicMaterial", { color: "#f59e0b" }),
                ],
              }),
              P.jsx(CU, {
                points: [t.start, t.end],
                color: "#f59e0b",
                lineWidth: 0.5,
                transparent: !0,
                opacity: 0.2,
              }),
              P.jsx(Jl, {
                speed: 2,
                rotationIntensity: 0,
                floatIntensity: 0.5,
                children: P.jsxs("mesh", {
                  position: t.start
                    .clone()
                    .lerp(t.end, (Math.sin(Date.now() * 0.001 + n) + 1) / 2),
                  children: [
                    P.jsx("sphereGeometry", { args: [0.03, 8, 8] }),
                    P.jsx("meshBasicMaterial", { color: "#fbbf24" }),
                  ],
                }),
              }),
            ],
          },
          n,
        ),
      ),
    })
  );
}
function gX() {
  return P.jsxs("div", {
    className: "fixed inset-0 -z-10 bg-[#020617]",
    children: [
      P.jsxs(eu, {
        camera: { position: [0, 0, 8], fov: 60 },
        children: [
          P.jsx("color", { attach: "background", args: ["#020617"] }),
          P.jsx("ambientLight", { intensity: 0.2 }),
          P.jsx("pointLight", {
            position: [10, 10, 10],
            intensity: 1,
            color: "#f59e0b",
          }),
          P.jsxs(ie.Suspense, {
            fallback: null,
            children: [
              P.jsx(tu, {
                radius: 100,
                depth: 50,
                count: 2e3,
                factor: 4,
                saturation: 0,
                fade: !0,
                speed: 0.5,
              }),
              P.jsx(mX, {}),
              P.jsx("gridHelper", {
                args: [30, 30, 11817737, 132631],
                position: [0, -4, 0],
              }),
            ],
          }),
        ],
      }),
      P.jsx("div", {
        className:
          "absolute inset-0 bg-gradient-to-b from-transparent via-[#020617]/50 to-[#020617]",
      }),
    ],
  });
}
function vX() {
  const i = () => {
    (mf("KML Point2Point Data"),
      window.open(
        "./Automation-Supporting-Team/Cable_Reader-main/index.html",
        "_blank",
        "noopener,noreferrer",
      ));
  };
  return P.jsxs("div", {
    className:
      "relative min-h-screen flex flex-col text-white p-8 font-sans overflow-hidden",
    children: [
      P.jsx(gX, {}),
      P.jsxs("div", {
        className: "relative z-10 max-w-7xl mx-auto w-full",
        children: [
          P.jsx(En.div, {
            initial: { opacity: 0, x: -20 },
            animate: { opacity: 1, x: 0 },
            className: "mb-12",
            children: P.jsxs(Jo, {
              to: "/",
              className:
                "inline-flex items-center gap-2 text-amber-400 hover:text-amber-300 transition-colors font-mono text-xs uppercase tracking-widest",
              children: [
                P.jsx(ff, { className: "w-4 h-4" }),
                "Back to Command Center",
              ],
            }),
          }),
          P.jsxs(En.div, {
            initial: { opacity: 0, y: 20 },
            animate: { opacity: 1, y: 0 },
            transition: { delay: 0.2 },
            children: [
              P.jsxs("div", {
                className:
                  "flex flex-col md:flex-row md:items-end justify-between gap-6 mb-8",
                children: [
                  P.jsxs("div", {
                    children: [
                      P.jsx("h1", {
                        className:
                          "text-5xl font-black uppercase tracking-tighter mb-2 bg-clip-text text-transparent bg-gradient-to-r from-white to-amber-500",
                        children: "KML Point2Point Data",
                      }),
                      P.jsx("p", {
                        className:
                          "text-amber-500 font-mono text-xs uppercase tracking-[0.2em]",
                        children: "Module ID: AST-KML-P2P-04",
                      }),
                    ],
                  }),
                  P.jsxs("button", {
                    onClick: i,
                    className:
                      "group flex items-center gap-2 px-8 py-4 bg-amber-600/20 hover:bg-amber-600/40 text-amber-400 border border-amber-500/50 rounded-xl font-bold uppercase tracking-wider text-sm transition-all shadow-[0_0_20px_rgba(245,158,11,0.2)] hover:shadow-[0_0_40_rgba(245,158,11,0.4)] backdrop-blur-md",
                    children: [
                      "Launch Tool",
                      P.jsx(Yc, {
                        className:
                          "w-4 h-4 group-hover:translate-x-1 group-hover:-translate-y-1 transition-transform",
                      }),
                    ],
                  }),
                ],
              }),
              P.jsxs("div", {
                className: "max-w-4xl mx-auto space-y-6",
                children: [
                  P.jsxs(En.div, {
                    initial: { opacity: 0, scale: 0.95 },
                    animate: { opacity: 1, scale: 1 },
                    transition: { delay: 0.4 },
                    className:
                      "p-8 rounded-2xl border border-white/10 bg-black/40 backdrop-blur-xl shadow-2xl",
                    children: [
                      P.jsxs("h3", {
                        className:
                          "text-lg font-bold mb-6 flex items-center gap-2 text-amber-400",
                        children: [
                          P.jsx(lL, { className: "w-5 h-5" }),
                          "Operational Overview",
                        ],
                      }),
                      P.jsxs("div", {
                        className:
                          "space-y-6 text-zinc-300 text-sm leading-relaxed",
                        children: [
                          P.jsx("p", {
                            children:
                              "This module exports detailed cable reading data from the KML for both Primary and Secondary cable networks into an Excel report.",
                          }),
                          P.jsxs("div", {
                            className:
                              "p-4 rounded-xl bg-amber-950/20 border border-amber-500/30 flex items-start gap-4",
                            children: [
                              P.jsx(kz, {
                                className:
                                  "w-6 h-6 text-amber-500 shrink-0 mt-1",
                              }),
                              P.jsxs("div", {
                                children: [
                                  P.jsx("p", {
                                    className:
                                      "text-sm font-bold text-amber-400 uppercase tracking-wider mb-1",
                                    children: "Disclaimer",
                                  }),
                                  P.jsx("p", {
                                    className:
                                      "text-zinc-400 text-xs leading-relaxed",
                                    children:
                                      "The Secondary cable readings are generated with high accuracy. However, Primary cable readings may be subject to design variations, routing assumptions, or legacy mapping inconsistencies. Therefore, all Primary cable data should be independently reviewed and verified before final use.",
                                  }),
                                ],
                              }),
                            ],
                          }),
                          P.jsx("p", {
                            children:
                              "The exported Excel output from this tool should be uploaded into the KML Verifier module to validate network completeness. The verifier will check for missing or unlinked cable segments, such as FATs or intermediate placemarks that do not have corresponding cable connections in the KML.",
                          }),
                          P.jsx("p", {
                            children:
                              "This tool is intended as a quality-assurance step to assess the overall health and correctness of the final KML. A lower number of missed or unconnected placemarks indicates higher KML quality and better network completeness.",
                          }),
                        ],
                      }),
                      P.jsxs("div", {
                        className:
                          "mt-10 grid grid-cols-1 md:grid-cols-2 gap-4",
                        children: [
                          P.jsxs("div", {
                            className:
                              "p-4 rounded-xl bg-amber-950/20 border border-amber-500/20 flex items-start gap-3",
                            children: [
                              P.jsx(fz, {
                                className:
                                  "w-5 h-5 text-amber-500 shrink-0 mt-0.5",
                              }),
                              P.jsxs("div", {
                                children: [
                                  P.jsx("p", {
                                    className:
                                      "text-xs font-bold text-white uppercase tracking-wider mb-1",
                                    children: "QA Assessment",
                                  }),
                                  P.jsx("p", {
                                    className: "text-[11px] text-zinc-500",
                                    children:
                                      "Evaluates network health through connectivity gap analysis.",
                                  }),
                                ],
                              }),
                            ],
                          }),
                          P.jsxs("div", {
                            className:
                              "p-4 rounded-xl bg-amber-950/20 border border-amber-500/20 flex items-start gap-3",
                            children: [
                              P.jsx(Yc, {
                                className:
                                  "w-5 h-5 text-amber-500 shrink-0 mt-0.5",
                              }),
                              P.jsxs("div", {
                                children: [
                                  P.jsx("p", {
                                    className:
                                      "text-xs font-bold text-white uppercase tracking-wider mb-1",
                                    children: "Verifier Integration",
                                  }),
                                  P.jsx("p", {
                                    className: "text-[11px] text-zinc-500",
                                    children:
                                      "Directly compatible with the KML Verifier validation suite.",
                                  }),
                                ],
                              }),
                            ],
                          }),
                        ],
                      }),
                    ],
                  }),
                  P.jsxs(En.div, {
                    initial: { opacity: 0, y: 20 },
                    animate: { opacity: 1, y: 0 },
                    transition: { delay: 0.6 },
                    className:
                      "p-8 rounded-2xl border border-white/10 bg-black/40 backdrop-blur-xl",
                    children: [
                      P.jsx("h3", {
                        className:
                          "text-sm font-bold uppercase tracking-[0.3em] text-amber-500/60 mb-6",
                        children: "Module Specifications",
                      }),
                      P.jsx("div", {
                        className: "grid grid-cols-1 md:grid-cols-3 gap-4",
                        children: [
                          "Primary/Secondary Export",
                          "Excel Report Format",
                          "QA Health Metrics",
                        ].map((e, t) =>
                          P.jsxs(
                            "div",
                            {
                              className:
                                "flex items-center gap-3 text-xs text-zinc-400 font-mono",
                              children: [
                                P.jsx("div", {
                                  className:
                                    "w-1.5 h-1.5 rounded-full bg-amber-500 shadow-[0_0_8px_#f59e0b]",
                                }),
                                e,
                              ],
                            },
                            t,
                          ),
                        ),
                      }),
                    ],
                  }),
                ],
              }),
            ],
          }),
        ],
      }),
      P.jsx("div", {
        className:
          "fixed inset-0 pointer-events-none bg-[linear-gradient(rgba(18,16,16,0)_50%,rgba(0,0,0,0.1)_50%),linear-gradient(90deg,rgba(255,0,0,0.03),rgba(0,255,0,0.01),rgba(0,0,255,0.03))] bg-[length:100%_2px,3px_100%] z-50 opacity-10",
      }),
    ],
  });
}
function yX() {
  const i = ie.useRef(null);
  return (
    Pr((e) => {
      i.current && (i.current.rotation.y = e.clock.elapsedTime * 0.1);
    }),
    P.jsx("group", {
      ref: i,
      children: Array.from({ length: 15 }).map((e, t) => {
        const n = Math.random() > 0.7,
          r = n ? "#ef4444" : "#22c55e";
        return P.jsxs(
          Jl,
          {
            speed: 2,
            rotationIntensity: 0.5,
            floatIntensity: 0.5,
            position: [
              (Math.random() - 0.5) * 12,
              (Math.random() - 0.5) * 10,
              (Math.random() - 0.5) * 5,
            ],
            children: [
              P.jsxs("mesh", {
                children: [
                  P.jsx("octahedronGeometry", { args: [0.15, 0] }),
                  P.jsx("meshStandardMaterial", {
                    color: r,
                    emissive: r,
                    emissiveIntensity: n ? 2 : 0.5,
                  }),
                ],
              }),
              n &&
                P.jsx(Wp, {
                  position: [0, 0.3, 0],
                  fontSize: 0.1,
                  color: "#ef4444",
                  font: "https://fonts.gstatic.com/s/jetbrainsmono/v13/t6nu27PSq1_7hvBTjD1v96u6_8L2.woff",
                  children: "ERROR_DETECTED",
                }),
            ],
          },
          t,
        );
      }),
    })
  );
}
function xX() {
  return P.jsxs("div", {
    className: "fixed inset-0 -z-10 bg-[#020617]",
    children: [
      P.jsxs(eu, {
        camera: { position: [0, 0, 8], fov: 60 },
        children: [
          P.jsx("color", { attach: "background", args: ["#020617"] }),
          P.jsx("ambientLight", { intensity: 0.2 }),
          P.jsx("pointLight", {
            position: [10, 10, 10],
            intensity: 1,
            color: "#ef4444",
          }),
          P.jsx("pointLight", {
            position: [-10, -10, 10],
            intensity: 0.5,
            color: "#22c55e",
          }),
          P.jsxs(ie.Suspense, {
            fallback: null,
            children: [
              P.jsx(tu, {
                radius: 100,
                depth: 50,
                count: 2e3,
                factor: 4,
                saturation: 0,
                fade: !0,
                speed: 0.5,
              }),
              P.jsx(yX, {}),
              P.jsx("gridHelper", {
                args: [30, 30, 10033947, 132631],
                position: [0, -4, 0],
              }),
            ],
          }),
        ],
      }),
      P.jsx("div", {
        className:
          "absolute inset-0 bg-gradient-to-b from-transparent via-[#020617]/50 to-[#020617]",
      }),
    ],
  });
}
function bX() {
  const i = () => {
    (mf("KML Verifier"),
      window.open(
        "./Automation-Supporting-Team/KML_Verifier-Seconadry-Cable-Reading-main/index.html",
        "_blank",
        "noopener,noreferrer",
      ));
  };
  return P.jsxs("div", {
    className:
      "relative min-h-screen flex flex-col text-white p-8 font-sans overflow-hidden",
    children: [
      P.jsx(xX, {}),
      P.jsxs("div", {
        className: "relative z-10 max-w-7xl mx-auto w-full",
        children: [
          P.jsx(En.div, {
            initial: { opacity: 0, x: -20 },
            animate: { opacity: 1, x: 0 },
            className: "mb-12",
            children: P.jsxs(Jo, {
              to: "/",
              className:
                "inline-flex items-center gap-2 text-rose-400 hover:text-rose-300 transition-colors font-mono text-xs uppercase tracking-widest",
              children: [
                P.jsx(ff, { className: "w-4 h-4" }),
                "Back to Command Center",
              ],
            }),
          }),
          P.jsxs(En.div, {
            initial: { opacity: 0, y: 20 },
            animate: { opacity: 1, y: 0 },
            transition: { delay: 0.2 },
            children: [
              P.jsxs("div", {
                className:
                  "flex flex-col md:flex-row md:items-end justify-between gap-6 mb-8",
                children: [
                  P.jsxs("div", {
                    children: [
                      P.jsx("h1", {
                        className:
                          "text-5xl font-black uppercase tracking-tighter mb-2 bg-clip-text text-transparent bg-gradient-to-r from-white to-rose-500",
                        children: "KML Verifier",
                      }),
                      P.jsx("p", {
                        className:
                          "text-rose-500 font-mono text-xs uppercase tracking-[0.2em]",
                        children: "Module ID: AST-KML-VR-05",
                      }),
                    ],
                  }),
                  P.jsxs("button", {
                    onClick: i,
                    className:
                      "group flex items-center gap-2 px-8 py-4 bg-rose-600/20 hover:bg-rose-600/40 text-rose-400 border border-rose-500/50 rounded-xl font-bold uppercase tracking-wider text-sm transition-all shadow-[0_0_20px_rgba(225,29,72,0.2)] hover:shadow-[0_0_40px_rgba(225,29,72,0.4)] backdrop-blur-md",
                    children: [
                      "Launch Tool",
                      P.jsx(Yc, {
                        className:
                          "w-4 h-4 group-hover:translate-x-1 group-hover:-translate-y-1 transition-transform",
                      }),
                    ],
                  }),
                ],
              }),
              P.jsxs("div", {
                className: "max-w-4xl mx-auto space-y-6",
                children: [
                  P.jsxs(En.div, {
                    initial: { opacity: 0, scale: 0.95 },
                    animate: { opacity: 1, scale: 1 },
                    transition: { delay: 0.4 },
                    className:
                      "p-8 rounded-2xl border border-white/10 bg-black/40 backdrop-blur-xl shadow-2xl",
                    children: [
                      P.jsxs("h3", {
                        className:
                          "text-lg font-bold mb-6 flex items-center gap-2 text-rose-400",
                        children: [
                          P.jsx(yM, { className: "w-5 h-5" }),
                          "Operational Overview",
                        ],
                      }),
                      P.jsxs("div", {
                        className:
                          "space-y-6 text-zinc-300 text-sm leading-relaxed",
                        children: [
                          P.jsx("p", {
                            children:
                              "This tool is primarily designed to identify and validate connectivity-related errors in KML files for Secondary networks only, enabling teams to detect and fix issues at an early stage.",
                          }),
                          P.jsx("p", {
                            children:
                              "In addition, it exports Secondary cable data in point-to-point format as per the required standard, providing accurate, structured cable readings for reporting, verification, and final submission.",
                          }),
                          P.jsx("p", {
                            children:
                              "By highlighting errors in time and generating correctly formatted point-to-point Secondary cable data, the tool helps improve the overall quality, completeness, and reliability of the final KML deliverables.",
                          }),
                        ],
                      }),
                      P.jsxs("div", {
                        className: "mt-10 space-y-4",
                        children: [
                          P.jsx("p", {
                            className:
                              "text-[10px] font-mono text-rose-500/60 uppercase tracking-widest",
                            children: "Validation Templates",
                          }),
                          P.jsxs("div", {
                            className: "grid grid-cols-1 md:grid-cols-2 gap-4",
                            children: [
                              P.jsxs("a", {
                                href: "./Automation-Supporting-Team/KML-Data-Filler-main/assets/Sample.xlsx",
                                download: "verifier_connectivity_template.xlsx",
                                className:
                                  "flex items-center justify-between p-4 rounded-xl bg-white/5 hover:bg-white/10 border border-white/5 transition-all group",
                                children: [
                                  P.jsxs("div", {
                                    className: "flex items-center gap-4",
                                    children: [
                                      P.jsx("div", {
                                        className:
                                          "p-3 rounded-lg bg-rose-500/20 text-rose-400 group-hover:scale-110 transition-transform",
                                        children: P.jsx(rf, {
                                          className: "w-5 h-5",
                                        }),
                                      }),
                                      P.jsxs("div", {
                                        className: "text-left",
                                        children: [
                                          P.jsx("p", {
                                            className:
                                              "text-sm font-bold text-white",
                                            children: "Connectivity Template",
                                          }),
                                          P.jsx("p", {
                                            className:
                                              "text-[10px] text-zinc-500 font-mono uppercase",
                                            children: "Excel  18 KB",
                                          }),
                                        ],
                                      }),
                                    ],
                                  }),
                                  P.jsx(i0, {
                                    className:
                                      "w-5 h-5 text-rose-500 group-hover:text-white transition-colors",
                                  }),
                                ],
                              }),
                              P.jsxs("a", {
                                href: "./Automation-Supporting-Team/KML-Data-Filler-main/assets/GeoLink_Analysis_Export.xlsx",
                                download: "verifier_p2p_standard.xlsx",
                                className:
                                  "flex items-center justify-between p-4 rounded-xl bg-white/5 hover:bg-white/10 border border-white/5 transition-all group",
                                children: [
                                  P.jsxs("div", {
                                    className: "flex items-center gap-4",
                                    children: [
                                      P.jsx("div", {
                                        className:
                                          "p-3 rounded-lg bg-rose-500/20 text-rose-400 group-hover:scale-110 transition-transform",
                                        children: P.jsx(rf, {
                                          className: "w-5 h-5",
                                        }),
                                      }),
                                      P.jsxs("div", {
                                        className: "text-left",
                                        children: [
                                          P.jsx("p", {
                                            className:
                                              "text-sm font-bold text-white",
                                            children: "P2P Standard Format",
                                          }),
                                          P.jsx("p", {
                                            className:
                                              "text-[10px] text-zinc-500 font-mono uppercase",
                                            children: "Excel  22 KB",
                                          }),
                                        ],
                                      }),
                                    ],
                                  }),
                                  P.jsx(i0, {
                                    className:
                                      "w-5 h-5 text-rose-500 group-hover:text-white transition-colors",
                                  }),
                                ],
                              }),
                            ],
                          }),
                        ],
                      }),
                      P.jsxs("div", {
                        className:
                          "mt-10 grid grid-cols-1 md:grid-cols-2 gap-4",
                        children: [
                          P.jsxs("div", {
                            className:
                              "p-4 rounded-xl bg-rose-950/20 border border-rose-500/20 flex items-start gap-3",
                            children: [
                              P.jsx(yM, {
                                className:
                                  "w-5 h-5 text-rose-500 shrink-0 mt-0.5",
                              }),
                              P.jsxs("div", {
                                children: [
                                  P.jsx("p", {
                                    className:
                                      "text-xs font-bold text-white uppercase tracking-wider mb-1",
                                    children: "Error Detection",
                                  }),
                                  P.jsx("p", {
                                    className: "text-[11px] text-zinc-500",
                                    children:
                                      "Identifies broken links, missing nodes, and topological gaps.",
                                  }),
                                ],
                              }),
                            ],
                          }),
                          P.jsxs("div", {
                            className:
                              "p-4 rounded-xl bg-rose-950/20 border border-rose-500/20 flex items-start gap-3",
                            children: [
                              P.jsx(uL, {
                                className:
                                  "w-5 h-5 text-rose-500 shrink-0 mt-0.5",
                              }),
                              P.jsxs("div", {
                                children: [
                                  P.jsx("p", {
                                    className:
                                      "text-xs font-bold text-white uppercase tracking-wider mb-1",
                                    children: "Standard Compliance",
                                  }),
                                  P.jsx("p", {
                                    className: "text-[11px] text-zinc-500",
                                    children:
                                      "Ensures all exports meet final submission requirements.",
                                  }),
                                ],
                              }),
                            ],
                          }),
                        ],
                      }),
                    ],
                  }),
                  P.jsxs(En.div, {
                    initial: { opacity: 0, y: 20 },
                    animate: { opacity: 1, y: 0 },
                    transition: { delay: 0.6 },
                    className:
                      "p-8 rounded-2xl border border-white/10 bg-black/40 backdrop-blur-xl",
                    children: [
                      P.jsx("h3", {
                        className:
                          "text-sm font-bold uppercase tracking-[0.3em] text-rose-500/60 mb-6",
                        children: "Validation Specs",
                      }),
                      P.jsx("div", {
                        className: "grid grid-cols-1 md:grid-cols-3 gap-4",
                        children: [
                          "Secondary Only",
                          "Point-to-Point Export",
                          "Connectivity Audit",
                        ].map((e, t) =>
                          P.jsxs(
                            "div",
                            {
                              className:
                                "flex items-center gap-3 text-xs text-zinc-400 font-mono",
                              children: [
                                P.jsx("div", {
                                  className:
                                    "w-1.5 h-1.5 rounded-full bg-rose-500 shadow-[0_0_8px_#f43f5e]",
                                }),
                                e,
                              ],
                            },
                            t,
                          ),
                        ),
                      }),
                    ],
                  }),
                ],
              }),
            ],
          }),
        ],
      }),
      P.jsx("div", {
        className:
          "fixed inset-0 pointer-events-none bg-[linear-gradient(rgba(18,16,16,0)_50%,rgba(0,0,0,0.1)_50%),linear-gradient(90deg,rgba(255,0,0,0.03),rgba(0,255,0,0.01),rgba(0,0,255,0.03))] bg-[length:100%_2px,3px_100%] z-50 opacity-10",
      }),
    ],
  });
}
function _X() {
  const i = ie.useRef(null);
  return (
    Pr((e) => {
      i.current &&
        ((i.current.rotation.x = e.clock.elapsedTime * 0.1),
        (i.current.rotation.y = e.clock.elapsedTime * 0.15));
    }),
    P.jsx("group", {
      ref: i,
      children: Array.from({ length: 12 }).map((e, t) =>
        P.jsxs(
          Jl,
          {
            speed: 2,
            rotationIntensity: 1,
            floatIntensity: 1,
            position: [
              (Math.random() - 0.5) * 10,
              (Math.random() - 0.5) * 10,
              (Math.random() - 0.5) * 5,
            ],
            children: [
              P.jsxs("mesh", {
                children: [
                  P.jsx("boxGeometry", { args: [0.3, 0.3, 0.3] }),
                  P.jsx("meshStandardMaterial", {
                    color: "#8b5cf6",
                    emissive: "#8b5cf6",
                    emissiveIntensity: 0.5,
                    wireframe: !0,
                  }),
                ],
              }),
              P.jsxs(Wp, {
                position: [0, 0.4, 0],
                fontSize: 0.1,
                color: "#d946ef",
                font: "https://fonts.gstatic.com/s/jetbrainsmono/v13/t6nu27PSq1_7hvBTjD1v96u6_8L2.woff",
                children: ["DATA_CHUNK_", t],
              }),
            ],
          },
          t,
        ),
      ),
    })
  );
}
function SX() {
  const i = ie.useRef(null);
  return (
    Pr((e) => {
      i.current && (i.current.rotation.z = e.clock.elapsedTime * 0.5);
    }),
    P.jsxs("mesh", {
      ref: i,
      rotation: [Math.PI / 2, 0, 0],
      children: [
        P.jsx("torusGeometry", { args: [4, 0.02, 16, 100] }),
        P.jsx("meshStandardMaterial", {
          color: "#d946ef",
          emissive: "#d946ef",
          emissiveIntensity: 2,
        }),
      ],
    })
  );
}
function MX() {
  return P.jsxs("div", {
    className: "fixed inset-0 -z-10 bg-[#020617]",
    children: [
      P.jsxs(eu, {
        camera: { position: [0, 0, 8], fov: 60 },
        children: [
          P.jsx("color", { attach: "background", args: ["#020617"] }),
          P.jsx("ambientLight", { intensity: 0.2 }),
          P.jsx("pointLight", {
            position: [10, 10, 10],
            intensity: 1,
            color: "#8b5cf6",
          }),
          P.jsx("pointLight", {
            position: [-10, -10, 10],
            intensity: 0.5,
            color: "#d946ef",
          }),
          P.jsxs(ie.Suspense, {
            fallback: null,
            children: [
              P.jsx(tu, {
                radius: 100,
                depth: 50,
                count: 2e3,
                factor: 4,
                saturation: 0,
                fade: !0,
                speed: 0.5,
              }),
              P.jsx(_X, {}),
              P.jsx(SX, {}),
              P.jsx("gridHelper", {
                args: [30, 30, 5972406, 132631],
                position: [0, -4, 0],
              }),
            ],
          }),
        ],
      }),
      P.jsx("div", {
        className:
          "absolute inset-0 bg-gradient-to-b from-transparent via-[#020617]/50 to-[#020617]",
      }),
    ],
  });
}
function TX() {
  const i = () => {
    (mf("NESA Generator"),
      window.open(
        "./Automation-Supporting-Team/NESA-file-Generator-main/index.html",
        "_blank",
        "noopener,noreferrer",
      ));
  };
  return P.jsxs("div", {
    className:
      "relative min-h-screen flex flex-col text-white p-8 font-sans overflow-hidden",
    children: [
      P.jsx(MX, {}),
      P.jsxs("div", {
        className: "relative z-10 max-w-7xl mx-auto w-full",
        children: [
          P.jsx(En.div, {
            initial: { opacity: 0, x: -20 },
            animate: { opacity: 1, x: 0 },
            className: "mb-12",
            children: P.jsxs(Jo, {
              to: "/",
              className:
                "inline-flex items-center gap-2 text-violet-400 hover:text-violet-300 transition-colors font-mono text-xs uppercase tracking-widest",
              children: [
                P.jsx(ff, { className: "w-4 h-4" }),
                "Back to Command Center",
              ],
            }),
          }),
          P.jsxs(En.div, {
            initial: { opacity: 0, y: 20 },
            animate: { opacity: 1, y: 0 },
            transition: { delay: 0.2 },
            children: [
              P.jsxs("div", {
                className:
                  "flex flex-col md:flex-row md:items-end justify-between gap-6 mb-8",
                children: [
                  P.jsxs("div", {
                    children: [
                      P.jsx("h1", {
                        className:
                          "text-5xl font-black uppercase tracking-tighter mb-2 bg-clip-text text-transparent bg-gradient-to-r from-white to-violet-500",
                        children: "NESA Generator",
                      }),
                      P.jsx("p", {
                        className:
                          "text-violet-500 font-mono text-xs uppercase tracking-[0.2em]",
                        children: "Module ID: AST-NESA-GEN-06",
                      }),
                    ],
                  }),
                  P.jsxs("button", {
                    onClick: i,
                    className:
                      "group flex items-center gap-2 px-8 py-4 bg-violet-600/20 hover:bg-violet-600/40 text-violet-400 border border-violet-500/50 rounded-xl font-bold uppercase tracking-wider text-sm transition-all shadow-[0_0_20px_rgba(139,92,246,0.2)] hover:shadow-[0_0_40px_rgba(139,92,246,0.4)] backdrop-blur-md",
                    children: [
                      "Launch Tool",
                      P.jsx(Yc, {
                        className:
                          "w-4 h-4 group-hover:translate-x-1 group-hover:-translate-y-1 transition-transform",
                      }),
                    ],
                  }),
                ],
              }),
              P.jsxs("div", {
                className: "max-w-4xl mx-auto space-y-6",
                children: [
                  P.jsxs(En.div, {
                    initial: { opacity: 0, scale: 0.95 },
                    animate: { opacity: 1, scale: 1 },
                    transition: { delay: 0.4 },
                    className:
                      "p-8 rounded-2xl border border-white/10 bg-black/40 backdrop-blur-xl shadow-2xl",
                    children: [
                      P.jsxs("h3", {
                        className:
                          "text-lg font-bold mb-6 flex items-center gap-2 text-violet-400",
                        children: [
                          P.jsx(vM, { className: "w-5 h-5" }),
                          "Operational Overview",
                        ],
                      }),
                      P.jsxs("div", {
                        className:
                          "space-y-6 text-zinc-300 text-sm leading-relaxed",
                        children: [
                          P.jsx("p", {
                            children:
                              "Upload the Excel file in the prescribed template format. The system will process the data and generate the NESA file in the required standard format, ready for submission or further use.",
                          }),
                          P.jsx("p", {
                            children:
                              "This module automates the complex transformation of network datasets into NESA-compliant structures, ensuring that all mandatory fields, relationships, and formatting rules are strictly adhered to.",
                          }),
                        ],
                      }),
                      P.jsxs("div", {
                        className: "mt-10 space-y-4",
                        children: [
                          P.jsx("p", {
                            className:
                              "text-[10px] font-mono text-violet-500/60 uppercase tracking-widest",
                            children: "Input Template",
                          }),
                          P.jsx("div", {
                            className: "max-w-md",
                            children: P.jsxs("a", {
                              href: "./Automation-Supporting-Team/NESA-file-Generator-main/assets/NESA-Sample-File.csv",
                              download: "nesa_input_template.csv",
                              className:
                                "flex items-center justify-between p-4 rounded-xl bg-white/5 hover:bg-white/10 border border-white/5 transition-all group",
                              children: [
                                P.jsxs("div", {
                                  className: "flex items-center gap-4",
                                  children: [
                                    P.jsx("div", {
                                      className:
                                        "p-3 rounded-lg bg-violet-500/20 text-violet-400 group-hover:scale-110 transition-transform",
                                      children: P.jsx(rf, {
                                        className: "w-5 h-5",
                                      }),
                                    }),
                                    P.jsxs("div", {
                                      className: "text-left",
                                      children: [
                                        P.jsx("p", {
                                          className:
                                            "text-sm font-bold text-white",
                                          children: "NESA Input Template",
                                        }),
                                        P.jsx("p", {
                                          className:
                                            "text-[10px] text-zinc-500 font-mono uppercase",
                                          children:
                                            "Excel  32 KB  Required Format",
                                        }),
                                      ],
                                    }),
                                  ],
                                }),
                                P.jsx(i0, {
                                  className:
                                    "w-5 h-5 text-violet-500 group-hover:text-white transition-colors",
                                }),
                              ],
                            }),
                          }),
                        ],
                      }),
                      P.jsxs("div", {
                        className:
                          "mt-10 grid grid-cols-1 md:grid-cols-2 gap-4",
                        children: [
                          P.jsxs("div", {
                            className:
                              "p-4 rounded-xl bg-violet-950/20 border border-violet-500/20 flex items-start gap-3",
                            children: [
                              P.jsx(fL, {
                                className:
                                  "w-5 h-5 text-violet-500 shrink-0 mt-0.5",
                              }),
                              P.jsxs("div", {
                                children: [
                                  P.jsx("p", {
                                    className:
                                      "text-xs font-bold text-white uppercase tracking-wider mb-1",
                                    children: "Standard Output",
                                  }),
                                  P.jsx("p", {
                                    className: "text-[11px] text-zinc-500",
                                    children:
                                      "Generates validated NESA files compatible with regulatory submission portals.",
                                  }),
                                ],
                              }),
                            ],
                          }),
                          P.jsxs("div", {
                            className:
                              "p-4 rounded-xl bg-violet-950/20 border border-violet-500/20 flex items-start gap-3",
                            children: [
                              P.jsx(vM, {
                                className:
                                  "w-5 h-5 text-violet-500 shrink-0 mt-0.5",
                              }),
                              P.jsxs("div", {
                                children: [
                                  P.jsx("p", {
                                    className:
                                      "text-xs font-bold text-white uppercase tracking-wider mb-1",
                                    children: "Automated Mapping",
                                  }),
                                  P.jsx("p", {
                                    className: "text-[11px] text-zinc-500",
                                    children:
                                      "Intelligent field mapping reduces manual data entry errors by 95%.",
                                  }),
                                ],
                              }),
                            ],
                          }),
                        ],
                      }),
                    ],
                  }),
                  P.jsxs(En.div, {
                    initial: { opacity: 0, y: 20 },
                    animate: { opacity: 1, y: 0 },
                    transition: { delay: 0.6 },
                    className:
                      "p-8 rounded-2xl border border-white/10 bg-black/40 backdrop-blur-xl",
                    children: [
                      P.jsx("h3", {
                        className:
                          "text-sm font-bold uppercase tracking-[0.3em] text-violet-500/60 mb-6",
                        children: "Processing Specs",
                      }),
                      P.jsx("div", {
                        className: "grid grid-cols-1 md:grid-cols-3 gap-4",
                        children: [
                          "NESA v2.1 Support",
                          "Batch Conversion",
                          "Schema Validation",
                        ].map((e, t) =>
                          P.jsxs(
                            "div",
                            {
                              className:
                                "flex items-center gap-3 text-xs text-zinc-400 font-mono",
                              children: [
                                P.jsx("div", {
                                  className:
                                    "w-1.5 h-1.5 rounded-full bg-violet-500 shadow-[0_0_8px_#8b5cf6]",
                                }),
                                e,
                              ],
                            },
                            t,
                          ),
                        ),
                      }),
                    ],
                  }),
                ],
              }),
            ],
          }),
        ],
      }),
      P.jsx("div", {
        className:
          "fixed inset-0 pointer-events-none bg-[linear-gradient(rgba(18,16,16,0)_50%,rgba(0,0,0,0.1)_50%),linear-gradient(90deg,rgba(255,0,0,0.03),rgba(0,255,0,0.01),rgba(0,0,255,0.03))] bg-[length:100%_2px,3px_100%] z-50 opacity-10",
      }),
    ],
  });
}
function EX() {
  const i = ie.useRef(null);
  return (
    Pr((e) => {
      i.current && (i.current.rotation.y = e.clock.elapsedTime * 0.05);
    }),
    P.jsx("group", {
      ref: i,
      children: Array.from({ length: 15 }).map((e, t) =>
        P.jsx(
          Jl,
          {
            speed: 1.5,
            rotationIntensity: 0.5,
            floatIntensity: 0.5,
            position: [
              (Math.random() - 0.5) * 12,
              (Math.random() - 0.5) * 10,
              (Math.random() - 0.5) * 5,
            ],
            children: P.jsxs("group", {
              children: [
                P.jsx(KW, {
                  args: [0.4, 0.4, 0.4],
                  children: P.jsx("meshStandardMaterial", {
                    color: "#64748b",
                    emissive: "#334155",
                    emissiveIntensity: 0.5,
                    wireframe: !0,
                  }),
                }),
                P.jsxs(Wp, {
                  position: [0, 0.4, 0],
                  fontSize: 0.08,
                  color: "#94a3b8",
                  font: "https://fonts.gstatic.com/s/jetbrainsmono/v13/t6nu27PSq1_7hvBTjD1v96u6_8L2.woff",
                  children: ["ASSET_ID_", 1e3 + t],
                }),
              ],
            }),
          },
          t,
        ),
      ),
    })
  );
}
function wX() {
  const i = ie.useRef(null);
  return (
    Pr((e) => {
      i.current && (i.current.position.y = Math.sin(e.clock.elapsedTime) * 4);
    }),
    P.jsxs("mesh", {
      ref: i,
      rotation: [Math.PI / 2, 0, 0],
      children: [
        P.jsx("planeGeometry", { args: [20, 0.05] }),
        P.jsx("meshBasicMaterial", {
          color: "#38bdf8",
          transparent: !0,
          opacity: 0.2,
          side: Na,
        }),
      ],
    })
  );
}
function AX() {
  return P.jsxs("div", {
    className: "fixed inset-0 -z-10 bg-[#020617]",
    children: [
      P.jsxs(eu, {
        camera: { position: [0, 0, 8], fov: 60 },
        children: [
          P.jsx("color", { attach: "background", args: ["#020617"] }),
          P.jsx("ambientLight", { intensity: 0.2 }),
          P.jsx("pointLight", {
            position: [10, 10, 10],
            intensity: 1,
            color: "#64748b",
          }),
          P.jsx("pointLight", {
            position: [-10, -10, 10],
            intensity: 0.5,
            color: "#38bdf8",
          }),
          P.jsxs(ie.Suspense, {
            fallback: null,
            children: [
              P.jsx(tu, {
                radius: 100,
                depth: 50,
                count: 2e3,
                factor: 4,
                saturation: 0,
                fade: !0,
                speed: 0.5,
              }),
              P.jsx(EX, {}),
              P.jsx(wX, {}),
              P.jsx("gridHelper", {
                args: [30, 30, 3359061, 132631],
                position: [0, -4, 0],
              }),
            ],
          }),
        ],
      }),
      P.jsx("div", {
        className:
          "absolute inset-0 bg-gradient-to-b from-transparent via-[#020617]/50 to-[#020617]",
      }),
    ],
  });
}
function CX() {
  const i = () => {
    (mf("Inventory Generator"),
      window.open(
        "./Automation-Supporting-Team/Inventory-Export-Automation-main/index.html",
        "_blank",
        "noopener,noreferrer",
      ));
  };
  return P.jsxs("div", {
    className:
      "relative min-h-screen flex flex-col text-white p-8 font-sans overflow-hidden",
    children: [
      P.jsx(AX, {}),
      P.jsxs("div", {
        className: "relative z-10 max-w-7xl mx-auto w-full",
        children: [
          P.jsx(En.div, {
            initial: { opacity: 0, x: -20 },
            animate: { opacity: 1, x: 0 },
            className: "mb-12",
            children: P.jsxs(Jo, {
              to: "/",
              className:
                "inline-flex items-center gap-2 text-slate-400 hover:text-slate-300 transition-colors font-mono text-xs uppercase tracking-widest",
              children: [
                P.jsx(ff, { className: "w-4 h-4" }),
                "Back to Command Center",
              ],
            }),
          }),
          P.jsxs(En.div, {
            initial: { opacity: 0, y: 20 },
            animate: { opacity: 1, y: 0 },
            transition: { delay: 0.2 },
            children: [
              P.jsxs("div", {
                className:
                  "flex flex-col md:flex-row md:items-end justify-between gap-6 mb-8",
                children: [
                  P.jsxs("div", {
                    children: [
                      P.jsx("h1", {
                        className:
                          "text-5xl font-black uppercase tracking-tighter mb-2 bg-clip-text text-transparent bg-gradient-to-r from-white to-slate-500",
                        children: "Inventory Generator",
                      }),
                      P.jsx("p", {
                        className:
                          "text-slate-500 font-mono text-xs uppercase tracking-[0.2em]",
                        children: "Module ID: AST-INV-GEN-07",
                      }),
                    ],
                  }),
                  P.jsxs("button", {
                    onClick: i,
                    className:
                      "group flex items-center gap-2 px-8 py-4 bg-slate-600/20 hover:bg-slate-600/40 text-slate-400 border border-slate-500/50 rounded-xl font-bold uppercase tracking-wider text-sm transition-all shadow-[0_0_20px_rgba(100,116,139,0.2)] hover:shadow-[0_0_40px_rgba(100,116,139,0.4)] backdrop-blur-md",
                    children: [
                      "Launch Tool",
                      P.jsx(Yc, {
                        className:
                          "w-4 h-4 group-hover:translate-x-1 group-hover:-translate-y-1 transition-transform",
                      }),
                    ],
                  }),
                ],
              }),
              P.jsxs("div", {
                className: "max-w-4xl mx-auto space-y-6",
                children: [
                  P.jsxs(En.div, {
                    initial: { opacity: 0, scale: 0.95 },
                    animate: { opacity: 1, scale: 1 },
                    transition: { delay: 0.4 },
                    className:
                      "p-8 rounded-2xl border border-white/10 bg-black/40 backdrop-blur-xl shadow-2xl",
                    children: [
                      P.jsxs("h3", {
                        className:
                          "text-lg font-bold mb-6 flex items-center gap-2 text-slate-400",
                        children: [
                          P.jsx(gz, { className: "w-5 h-5" }),
                          "Operational Overview",
                        ],
                      }),
                      P.jsxs("div", {
                        className:
                          "space-y-6 text-zinc-300 text-sm leading-relaxed",
                        children: [
                          P.jsx("p", {
                            children:
                              "Upload the Excel file in the prescribed template format. The system will process the data and generate the Inventory file in the required standard format, ready for submission or further use.",
                          }),
                          P.jsx("p", {
                            children:
                              "This tool streamlines asset tracking and inventory management by converting raw field data into structured, submission-ready reports. It ensures consistency across all asset categories and maintains a clear audit trail for project documentation.",
                          }),
                        ],
                      }),
                      P.jsxs("div", {
                        className: "mt-10 space-y-4",
                        children: [
                          P.jsx("p", {
                            className:
                              "text-[10px] font-mono text-slate-500/60 uppercase tracking-widest",
                            children: "Input Template",
                          }),
                          P.jsx("div", {
                            className: "max-w-md",
                            children: P.jsxs("a", {
                              href: "./Automation-Supporting-Team/Inventory-Export-Automation-main/assets/Inventory.xlsx",
                              download: "inventory_input_template.xlsx",
                              className:
                                "flex items-center justify-between p-4 rounded-xl bg-white/5 hover:bg-white/10 border border-white/5 transition-all group",
                              children: [
                                P.jsxs("div", {
                                  className: "flex items-center gap-4",
                                  children: [
                                    P.jsx("div", {
                                      className:
                                        "p-3 rounded-lg bg-slate-500/20 text-slate-400 group-hover:scale-110 transition-transform",
                                      children: P.jsx(rf, {
                                        className: "w-5 h-5",
                                      }),
                                    }),
                                    P.jsxs("div", {
                                      className: "text-left",
                                      children: [
                                        P.jsx("p", {
                                          className:
                                            "text-sm font-bold text-white",
                                          children: "Inventory Input Template",
                                        }),
                                        P.jsx("p", {
                                          className:
                                            "text-[10px] text-zinc-500 font-mono uppercase",
                                          children:
                                            "Excel  28 KB  Required Format",
                                        }),
                                      ],
                                    }),
                                  ],
                                }),
                                P.jsx(i0, {
                                  className:
                                    "w-5 h-5 text-slate-500 group-hover:text-white transition-colors",
                                }),
                              ],
                            }),
                          }),
                        ],
                      }),
                      P.jsxs("div", {
                        className:
                          "mt-10 grid grid-cols-1 md:grid-cols-2 gap-4",
                        children: [
                          P.jsxs("div", {
                            className:
                              "p-4 rounded-xl bg-slate-950/20 border border-slate-500/20 flex items-start gap-3",
                            children: [
                              P.jsx(cL, {
                                className:
                                  "w-5 h-5 text-slate-500 shrink-0 mt-0.5",
                              }),
                              P.jsxs("div", {
                                children: [
                                  P.jsx("p", {
                                    className:
                                      "text-xs font-bold text-white uppercase tracking-wider mb-1",
                                    children: "Asset Tracking",
                                  }),
                                  P.jsx("p", {
                                    className: "text-[11px] text-zinc-500",
                                    children:
                                      "Comprehensive logging of all network assets with unique identifiers.",
                                  }),
                                ],
                              }),
                            ],
                          }),
                          P.jsxs("div", {
                            className:
                              "p-4 rounded-xl bg-slate-950/20 border border-slate-500/20 flex items-start gap-3",
                            children: [
                              P.jsx(xz, {
                                className:
                                  "w-5 h-5 text-slate-500 shrink-0 mt-0.5",
                              }),
                              P.jsxs("div", {
                                children: [
                                  P.jsx("p", {
                                    className:
                                      "text-xs font-bold text-white uppercase tracking-wider mb-1",
                                    children: "Data Consolidation",
                                  }),
                                  P.jsx("p", {
                                    className: "text-[11px] text-zinc-500",
                                    children:
                                      "Merges multiple data sources into a single, unified inventory record.",
                                  }),
                                ],
                              }),
                            ],
                          }),
                        ],
                      }),
                    ],
                  }),
                  P.jsxs(En.div, {
                    initial: { opacity: 0, y: 20 },
                    animate: { opacity: 1, y: 0 },
                    transition: { delay: 0.6 },
                    className:
                      "p-8 rounded-2xl border border-white/10 bg-black/40 backdrop-blur-xl",
                    children: [
                      P.jsx("h3", {
                        className:
                          "text-sm font-bold uppercase tracking-[0.3em] text-slate-500/60 mb-6",
                        children: "System Specs",
                      }),
                      P.jsx("div", {
                        className: "grid grid-cols-1 md:grid-cols-3 gap-4",
                        children: [
                          "Asset ID Validation",
                          "Batch Processing",
                          "Audit-Ready Output",
                        ].map((e, t) =>
                          P.jsxs(
                            "div",
                            {
                              className:
                                "flex items-center gap-3 text-xs text-zinc-400 font-mono",
                              children: [
                                P.jsx("div", {
                                  className:
                                    "w-1.5 h-1.5 rounded-full bg-slate-500 shadow-[0_0_8px_#64748b]",
                                }),
                                e,
                              ],
                            },
                            t,
                          ),
                        ),
                      }),
                    ],
                  }),
                ],
              }),
            ],
          }),
        ],
      }),
      P.jsx("div", {
        className:
          "fixed inset-0 pointer-events-none bg-[linear-gradient(rgba(18,16,16,0)_50%,rgba(0,0,0,0.1)_50%),linear-gradient(90deg,rgba(255,0,0,0.03),rgba(0,255,0,0.01),rgba(0,0,255,0.03))] bg-[length:100%_2px,3px_100%] z-50 opacity-10",
      }),
    ],
  });
}
function RX() {
  const i = ie.useRef(null);
  return (
    Pr((e) => {
      i.current && (i.current.rotation.y = e.clock.elapsedTime * 0.1);
    }),
    P.jsx("group", {
      ref: i,
      children: Array.from({ length: 10 }).map((e, t) =>
        P.jsx(
          Jl,
          {
            speed: 2,
            rotationIntensity: 1,
            floatIntensity: 1,
            position: [
              (Math.random() - 0.5) * 12,
              (Math.random() - 0.5) * 10,
              (Math.random() - 0.5) * 5,
            ],
            children: P.jsxs("group", {
              children: [
                P.jsxs("mesh", {
                  children: [
                    P.jsx("planeGeometry", { args: [0.6, 0.8] }),
                    P.jsx("meshStandardMaterial", {
                      color: "#3b82f6",
                      transparent: !0,
                      opacity: 0.6,
                      side: Na,
                    }),
                  ],
                }),
                P.jsxs("mesh", {
                  position: [0.2, -0.2, 0.1],
                  children: [
                    P.jsx("boxGeometry", { args: [0.2, 0.1, 0.05] }),
                    P.jsx("meshStandardMaterial", {
                      color: "#06b6d4",
                      emissive: "#06b6d4",
                      emissiveIntensity: 0.5,
                    }),
                  ],
                }),
                P.jsx(Wp, {
                  position: [0, 0.5, 0],
                  fontSize: 0.08,
                  color: "#60a5fa",
                  font: "https://fonts.gstatic.com/s/jetbrainsmono/v13/t6nu27PSq1_7hvBTjD1v96u6_8L2.woff",
                  children: "EXTRACTING_DATA...",
                }),
              ],
            }),
          },
          t,
        ),
      ),
    })
  );
}
function DX() {
  const i = ie.useRef(null);
  return (
    Pr((e) => {
      i.current &&
        (i.current.position.x = Math.sin(e.clock.elapsedTime * 1.5) * 6);
    }),
    P.jsxs("mesh", {
      ref: i,
      children: [
        P.jsx("boxGeometry", { args: [0.02, 15, 0.02] }),
        P.jsx("meshBasicMaterial", {
          color: "#06b6d4",
          transparent: !0,
          opacity: 0.8,
        }),
      ],
    })
  );
}
function LX() {
  return P.jsxs("div", {
    className: "fixed inset-0 -z-10 bg-[#020617]",
    children: [
      P.jsxs(eu, {
        camera: { position: [0, 0, 8], fov: 60 },
        children: [
          P.jsx("color", { attach: "background", args: ["#020617"] }),
          P.jsx("ambientLight", { intensity: 0.2 }),
          P.jsx("pointLight", {
            position: [10, 10, 10],
            intensity: 1,
            color: "#3b82f6",
          }),
          P.jsx("pointLight", {
            position: [-10, -10, 10],
            intensity: 0.5,
            color: "#06b6d4",
          }),
          P.jsxs(ie.Suspense, {
            fallback: null,
            children: [
              P.jsx(tu, {
                radius: 100,
                depth: 50,
                count: 2e3,
                factor: 4,
                saturation: 0,
                fade: !0,
                speed: 0.5,
              }),
              P.jsx(RX, {}),
              P.jsx(DX, {}),
              P.jsx("gridHelper", {
                args: [30, 30, 1981066, 132631],
                position: [0, -4, 0],
              }),
            ],
          }),
        ],
      }),
      P.jsx("div", {
        className:
          "absolute inset-0 bg-gradient-to-b from-transparent via-[#020617]/50 to-[#020617]",
      }),
    ],
  });
}
function NX() {
  const i = () => {
    (mf("ODF PDF to Excel"),
      window.open(
        "./Automation-Supporting-Team/OBD_PDF_File_Reader-main/index.html",
        "_blank",
        "noopener,noreferrer",
      ));
  };
  return P.jsxs("div", {
    className:
      "relative min-h-screen flex flex-col text-white p-8 font-sans overflow-hidden",
    children: [
      P.jsx(LX, {}),
      P.jsxs("div", {
        className: "relative z-10 max-w-7xl mx-auto w-full",
        children: [
          P.jsx(En.div, {
            initial: { opacity: 0, x: -20 },
            animate: { opacity: 1, x: 0 },
            className: "mb-12",
            children: P.jsxs(Jo, {
              to: "/",
              className:
                "inline-flex items-center gap-2 text-blue-400 hover:text-blue-300 transition-colors font-mono text-xs uppercase tracking-widest",
              children: [
                P.jsx(ff, { className: "w-4 h-4" }),
                "Back to Command Center",
              ],
            }),
          }),
          P.jsxs(En.div, {
            initial: { opacity: 0, y: 20 },
            animate: { opacity: 1, y: 0 },
            transition: { delay: 0.2 },
            children: [
              P.jsxs("div", {
                className:
                  "flex flex-col md:flex-row md:items-end justify-between gap-6 mb-8",
                children: [
                  P.jsxs("div", {
                    children: [
                      P.jsx("h1", {
                        className:
                          "text-5xl font-black uppercase tracking-tighter mb-2 bg-clip-text text-transparent bg-gradient-to-r from-white to-blue-500",
                        children: "ODF PDF to Excel",
                      }),
                      P.jsx("p", {
                        className:
                          "text-blue-500 font-mono text-xs uppercase tracking-[0.2em]",
                        children: "Module ID: AST-ODF-PDF-08",
                      }),
                    ],
                  }),
                  P.jsxs("button", {
                    onClick: i,
                    className:
                      "group flex items-center gap-2 px-8 py-4 bg-blue-600/20 hover:bg-blue-600/40 text-blue-400 border border-blue-500/50 rounded-xl font-bold uppercase tracking-wider text-sm transition-all shadow-[0_0_20px_rgba(59,130,246,0.2)] hover:shadow-[0_0_40px_rgba(59,130,246,0.4)] backdrop-blur-md",
                    children: [
                      "Launch Tool",
                      P.jsx(Yc, {
                        className:
                          "w-4 h-4 group-hover:translate-x-1 group-hover:-translate-y-1 transition-transform",
                      }),
                    ],
                  }),
                ],
              }),
              P.jsxs("div", {
                className: "max-w-4xl mx-auto space-y-6",
                children: [
                  P.jsxs(En.div, {
                    initial: { opacity: 0, scale: 0.95 },
                    animate: { opacity: 1, scale: 1 },
                    transition: { delay: 0.4 },
                    className:
                      "p-8 rounded-2xl border border-white/10 bg-black/40 backdrop-blur-xl shadow-2xl",
                    children: [
                      P.jsxs("h3", {
                        className:
                          "text-lg font-bold mb-6 flex items-center gap-2 text-blue-400",
                        children: [
                          P.jsx(Cz, { className: "w-5 h-5" }),
                          "Operational Overview",
                        ],
                      }),
                      P.jsxs("div", {
                        className:
                          "space-y-6 text-zinc-300 text-sm leading-relaxed",
                        children: [
                          P.jsx("p", {
                            children:
                              "Attach the ODF PDF file to extract and download the ODF details in Excel format.",
                          }),
                          P.jsxs("div", {
                            className:
                              "p-4 rounded-xl bg-blue-950/20 border border-blue-500/30 flex items-start gap-4",
                            children: [
                              P.jsx(dz, {
                                className:
                                  "w-6 h-6 text-blue-500 shrink-0 mt-1",
                              }),
                              P.jsxs("div", {
                                children: [
                                  P.jsx("p", {
                                    className:
                                      "text-sm font-bold text-blue-400 uppercase tracking-wider mb-1",
                                    children: "Disclaimer",
                                  }),
                                  P.jsx("p", {
                                    className:
                                      "text-zinc-400 text-xs leading-relaxed",
                                    children:
                                      "This tool is intended to save time by automating data extraction. However, all generated details must be thoroughly cross-checked after the Excel file is created, as the accuracy of ODF latitude and longitude is critical for KML activities and network planning.",
                                  }),
                                ],
                              }),
                            ],
                          }),
                          P.jsx("p", {
                            children:
                              "This module utilizes advanced OCR and pattern recognition to identify ODF tables within PDF documents, mapping them directly to structured spreadsheet columns for immediate use in engineering workflows.",
                          }),
                        ],
                      }),
                      P.jsxs("div", {
                        className:
                          "mt-10 grid grid-cols-1 md:grid-cols-2 gap-4",
                        children: [
                          P.jsxs("div", {
                            className:
                              "p-4 rounded-xl bg-blue-950/20 border border-blue-500/20 flex items-start gap-3",
                            children: [
                              P.jsx(vM, {
                                className:
                                  "w-5 h-5 text-blue-500 shrink-0 mt-0.5",
                              }),
                              P.jsxs("div", {
                                children: [
                                  P.jsx("p", {
                                    className:
                                      "text-xs font-bold text-white uppercase tracking-wider mb-1",
                                    children: "Automated Extraction",
                                  }),
                                  P.jsx("p", {
                                    className: "text-[11px] text-zinc-500",
                                    children:
                                      "High-speed processing of multi-page ODF documents with complex table structures.",
                                  }),
                                ],
                              }),
                            ],
                          }),
                          P.jsxs("div", {
                            className:
                              "p-4 rounded-xl bg-blue-950/20 border border-blue-500/20 flex items-start gap-3",
                            children: [
                              P.jsx(rf, {
                                className:
                                  "w-5 h-5 text-blue-500 shrink-0 mt-0.5",
                              }),
                              P.jsxs("div", {
                                children: [
                                  P.jsx("p", {
                                    className:
                                      "text-xs font-bold text-white uppercase tracking-wider mb-1",
                                    children: "Structured Output",
                                  }),
                                  P.jsx("p", {
                                    className: "text-[11px] text-zinc-500",
                                    children:
                                      "Clean Excel formatting optimized for KML integration and network planning tools.",
                                  }),
                                ],
                              }),
                            ],
                          }),
                        ],
                      }),
                    ],
                  }),
                  P.jsxs(En.div, {
                    initial: { opacity: 0, y: 20 },
                    animate: { opacity: 1, y: 0 },
                    transition: { delay: 0.6 },
                    className:
                      "p-8 rounded-2xl border border-white/10 bg-black/40 backdrop-blur-xl",
                    children: [
                      P.jsx("h3", {
                        className:
                          "text-sm font-bold uppercase tracking-[0.3em] text-blue-500/60 mb-6",
                        children: "Extraction Specs",
                      }),
                      P.jsx("div", {
                        className: "grid grid-cols-1 md:grid-cols-3 gap-4",
                        children: [
                          "PDF OCR Engine",
                          "Coordinate Mapping",
                          "Batch Conversion",
                        ].map((e, t) =>
                          P.jsxs(
                            "div",
                            {
                              className:
                                "flex items-center gap-3 text-xs text-zinc-400 font-mono",
                              children: [
                                P.jsx("div", {
                                  className:
                                    "w-1.5 h-1.5 rounded-full bg-blue-500 shadow-[0_0_8px_#3b82f6]",
                                }),
                                e,
                              ],
                            },
                            t,
                          ),
                        ),
                      }),
                    ],
                  }),
                ],
              }),
            ],
          }),
        ],
      }),
      P.jsx("div", {
        className:
          "fixed inset-0 pointer-events-none bg-[linear-gradient(rgba(18,16,16,0)_50%,rgba(0,0,0,0.1)_50%),linear-gradient(90deg,rgba(0,0,255,0.03),rgba(0,255,0,0.01),rgba(255,0,0,0.03))] bg-[length:100%_2px,3px_100%] z-50 opacity-10",
      }),
    ],
  });
}
const UX = [
  "chander@conexgen.com",
  "sandeep@conexgen.com",
  "darpan@conexgen.com",
  "ravi@gmail.com",
];
function PX({ onLogin: i }) {
  const [e, t] = ie.useState(""),
    [n, r] = ie.useState(""),
    [s, o] = ie.useState(!1),
    u = async (h) => {
      (h.preventDefault(), r(""), o(!0));
      const d = e.trim().toLowerCase();
      (UX.includes(d)
        ? (await G1(
            ` User Login: **${d}** has successfully logged into the Automation Supporting Team portal.`,
          ),
          i(d))
        : (await G1(
            ` **Unauthorized Login Attempt**: Someone tried to login with email: \`${e}\``,
          ),
          r("Unauthorized Mail ID. Please use your official email.")),
        o(!1));
    };
  return P.jsxs("div", {
    className:
      "relative min-h-screen flex items-center justify-center overflow-hidden text-white font-sans",
    children: [
      P.jsx(GU, {}),
      P.jsx(En.div, {
        initial: { opacity: 0, scale: 0.9 },
        animate: { opacity: 1, scale: 1 },
        className: "relative z-10 w-full max-w-md px-6",
        children: P.jsxs("div", {
          className:
            "p-8 rounded-3xl border border-white/10 bg-black/60 backdrop-blur-2xl shadow-2xl",
          children: [
            P.jsxs("div", {
              className: "text-center mb-8",
              children: [
                P.jsx("div", {
                  className:
                    "inline-flex p-4 rounded-2xl bg-cyan-500/20 text-cyan-400 mb-4",
                  children: P.jsx(Lz, { className: "w-8 h-8" }),
                }),
                P.jsx("h1", {
                  className:
                    "text-3xl font-black tracking-tighter uppercase mb-2",
                  children: "Access Portal",
                }),
                P.jsx("p", {
                  className: "text-zinc-400 text-sm",
                  children: "Enter your Official Mail ID to continue",
                }),
              ],
            }),
            P.jsxs("form", {
              onSubmit: u,
              className: "space-y-6",
              children: [
                P.jsxs("div", {
                  children: [
                    P.jsx("label", {
                      className:
                        "block text-[10px] font-mono uppercase tracking-[0.2em] text-cyan-500/60 mb-2 ml-1",
                      children: "Official Mail ID",
                    }),
                    P.jsx("input", {
                      type: "email",
                      required: !0,
                      value: e,
                      onChange: (h) => t(h.target.value),
                      placeholder: "name@email.com",
                      className:
                        "w-full px-5 py-4 rounded-xl bg-white/5 border border-white/10 focus:border-cyan-500/50 focus:ring-2 focus:ring-cyan-500/20 transition-all outline-none text-white placeholder:text-zinc-600",
                    }),
                  ],
                }),
                n &&
                  P.jsxs(En.div, {
                    initial: { opacity: 0, y: -10 },
                    animate: { opacity: 1, y: 0 },
                    className:
                      "flex items-center gap-3 p-4 rounded-xl bg-rose-500/10 border border-rose-500/20 text-rose-400 text-xs",
                    children: [P.jsx(yM, { className: "w-4 h-4 shrink-0" }), n],
                  }),
                P.jsx("button", {
                  type: "submit",
                  disabled: s,
                  className:
                    "w-full py-4 bg-cyan-600 hover:bg-cyan-500 disabled:opacity-50 disabled:cursor-not-allowed text-white font-bold uppercase tracking-widest rounded-xl transition-all shadow-[0_0_20px_rgba(6,182,212,0.3)] hover:shadow-[0_0_30px_rgba(6,182,212,0.5)]",
                  children: s ? "Verifying..." : "Initialize Session",
                }),
              ],
            }),
            P.jsx("div", {
              className: "mt-8 pt-8 border-t border-white/5 text-center",
              children: P.jsx("p", {
                className:
                  "text-[10px] font-mono uppercase tracking-widest text-zinc-500",
                children: "Secure Authentication Protocol v4.0",
              }),
            }),
          ],
        }),
      }),
      P.jsx("div", {
        className:
          "fixed inset-0 pointer-events-none bg-[linear-gradient(rgba(18,16,16,0)_50%,rgba(0,0,0,0.25)_50%),linear-gradient(90deg,rgba(255,0,0,0.06),rgba(0,255,0,0.02),rgba(0,0,255,0.06))] bg-[length:100%_2px,3px_100%] z-50 opacity-20",
      }),
    ],
  });
}
function IX() {
  const [i, e] = ie.useState(() => localStorage.getItem("ast_user")),
    t = (n) => {
      e(n); 
  	  localStorage.setItem("ast_user", n);
      if (!n) { // If logging out (setting user to null/empty)
      	window.location.href = "https://princeyadav78.github.io/Automation-Supporting-Team/";
      }
    };
  return i
    ? P.jsx($I, {
        children: P.jsxs(RI, {
          children: [
            P.jsx(jo, { path: "/", element: P.jsx(iX, { user: i }) }),
            P.jsx(jo, { path: "/kml-data-filler", element: P.jsx(oX, {}) }),
            P.jsx(jo, { path: "/kml-cable-snapper", element: P.jsx(uX, {}) }),
            P.jsx(jo, {
              path: "/kml-cable-length-filler",
              element: P.jsx(pX, {}),
            }),
            P.jsx(jo, { path: "/kml-p2p-data", element: P.jsx(vX, {}) }),
            P.jsx(jo, { path: "/kml-verifier", element: P.jsx(bX, {}) }),
            P.jsx(jo, { path: "/nesa-generator", element: P.jsx(TX, {}) }),
            P.jsx(jo, { path: "/inventory-generator", element: P.jsx(CX, {}) }),
            P.jsx(jo, { path: "/odf-pdf-to-excel", element: P.jsx(NX, {}) }),
            P.jsx(jo, {
              path: "*",
              element: P.jsx(AI, { to: "/", replace: !0 }),
            }),
          ],
        }),
      })
    : P.jsx(PX, { onLogin: t });
}
LP.createRoot(document.getElementById("root")).render(
  P.jsx(ie.StrictMode, { children: P.jsx(IX, {}) }),
);
